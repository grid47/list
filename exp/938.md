### Problem Statement

The problem at hand is to find the sum of values of all nodes within a Binary Search Tree (BST) that lie within a given range `[low, high]`. Given a BST, you are asked to return the sum of the node values that are within this specified range.

A Binary Search Tree (BST) is a tree data structure where for each node:
- The value of the left subtree node is less than the node’s value.
- The value of the right subtree node is greater than the node’s value.

You are provided with the root of the tree and the range `[low, high]`. The task is to compute the sum of all node values in the tree that lie within this range.

### Approach

To solve this problem, we can take advantage of the properties of a Binary Search Tree. Specifically, we can avoid traversing parts of the tree that are outside the range `[low, high]` to make the algorithm more efficient.

1. **Traversal Strategy**: Since the problem involves summing nodes within a certain range, an in-order traversal is suitable. In-order traversal ensures that the nodes of the tree are visited in ascending order of their values, which matches the nature of the Binary Search Tree.

2. **Pruning the Search Space**: 
    - If the current node’s value is less than `low`, then all values in the left subtree are also less than `low`. Therefore, we can skip the entire left subtree and only recurse into the right subtree.
    - Similarly, if the current node’s value is greater than `high`, all values in the right subtree are also greater than `high`, and we can skip the right subtree and only recurse into the left subtree.
    - If the current node's value lies within the range `[low, high]`, we should add this value to the sum and continue searching both the left and right subtrees.

3. **Base Case**: The base case for recursion is when the current node is null, in which case we return 0 as there is nothing to sum.

This approach ensures that we only traverse the relevant parts of the tree, making it more efficient than a simple brute-force traversal.

### Code Breakdown (Step by Step)

1. **TreeNode Definition**:
   The problem assumes the following structure for the tree node:
   ```cpp
   struct TreeNode {
       int val;
       TreeNode *left;
       TreeNode *right;
       TreeNode() : val(0), left(nullptr), right(nullptr) {}
       TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
       TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   };
   ```
   This is a standard definition for a binary tree node. Each node contains an integer value (`val`), and pointers to its left and right children.

2. **Recursive Function - `rangeSumBST`**:
   ```cpp
   int rangeSumBST(TreeNode* root, int low, int high) {
       if(!root) return 0;
       int sum = 0;
       sum += rangeSumBST(root->left, low, high);
       if(root->val >= low && root->val <= high)
           sum += root->val;
       sum += rangeSumBST(root->right, low, high);
       return sum;
   }
   ```
   - **Base Case**: `if(!root) return 0;`
     - If the current node is `null`, we return 0, as there are no nodes to sum in this part of the tree.
   
   - **Recursive Traversal**:
     - We first call `rangeSumBST(root->left, low, high)` to process the left subtree. The sum of the left subtree nodes will be added to `sum`.
     - We then check if the current node’s value is within the specified range `[low, high]`. If it is, we add `root->val` to `sum`.
     - We finally call `rangeSumBST(root->right, low, high)` to process the right subtree and add its result to `sum`.

   - **Return Value**: After recursively summing the values in the left subtree, adding the value of the current node (if it is within the range), and summing the right subtree, we return the total sum for this subtree.

3. **Efficiency**:
   - The function performs an in-order traversal of the tree, but with pruning: we only visit parts of the tree that might contain values within the given range. This pruning helps to skip unnecessary nodes, making the traversal more efficient than a full in-order traversal.

4. **Final Sum**: After the recursion finishes, the function returns the sum of all values in the range `[low, high]` in the tree.

### Complexity

1. **Time Complexity**:
   - In the worst case, the algorithm needs to visit every node in the tree. However, due to the pruning technique, we can avoid traversing subtrees that are outside the range. Therefore, in the worst case, the time complexity is proportional to the number of nodes in the tree, `O(N)`, where `N` is the number of nodes in the tree.
   - In the best case, when the entire tree or large parts of it can be skipped due to pruning, the time complexity can be much less than `O(N)`.

2. **Space Complexity**:
   - The space complexity is determined by the depth of the recursion stack. In the worst case, the depth of the recursion stack is equal to the height of the tree, which is `O(H)`, where `H` is the height of the tree.
   - For a balanced tree, the height is `O(log N)`, but in the worst case (for an unbalanced tree), the height can be `O(N)`.
   - Therefore, the space complexity is `O(H)`.

### Conclusion

This solution efficiently computes the sum of values within a given range in a Binary Search Tree using a recursive approach with pruning. By leveraging the properties of a BST, we avoid unnecessary traversal of subtrees that are outside the specified range, making the algorithm both efficient and elegant. The time complexity is `O(N)` in the worst case, where `N` is the number of nodes in the tree, and the space complexity is `O(H)`, where `H` is the height of the tree. This approach ensures that the solution is optimal for large trees and scales well with the size of the input.
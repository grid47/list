### Problem Statement

The goal of the problem is to determine the maximum score obtainable by splitting a binary string `s` into two non-empty substrings. The score is defined as the sum of the number of `0`s in the left substring and the number of `1`s in the right substring. The task is to implement a function that computes this maximum score efficiently.

### Approach

To solve this problem, we can take advantage of a linear traversal of the string. The idea is to keep track of the number of `0`s in the left substring and the number of `1`s in the right substring as we iterate through the string. Here’s a step-by-step breakdown of the approach:

1. **Count Initial `1`s**: First, traverse the string to count the total number of `1`s present in the string, which will initially belong to the right substring.

2. **Iterate and Update Counts**: Iterate through the string from the beginning to the second last character (since both substrings must be non-empty). For each character:
   - If it's a `0`, increment the count of `0`s in the left substring.
   - If it's a `1`, decrement the count of `1`s in the right substring.
   
3. **Calculate and Track Maximum Score**: After updating counts, calculate the score as the sum of `0`s in the left substring and `1`s in the right substring. Continuously update the maximum score encountered during the iteration.

4. **Return Result**: At the end of the iteration, return the maximum score calculated.

### Code Breakdown (Step by Step)

Let’s analyze the implementation step-by-step to understand how it works:

1. **Class Declaration**:
   ```cpp
   class Solution {
   public:
   ```

   - This defines the `Solution` class where our function to compute the maximum score will reside.

2. **Function Declaration**:
   ```cpp
   int maxScore(string s) {
   ```

   - The method `maxScore` accepts a string `s` and returns an integer representing the maximum score.

3. **Variable Initialization**:
   ```cpp
   int rightOnes = 0, leftZeroes = 0;
   for(char c: s)
       if(c=='1') rightOnes++;
   ```

   - We initialize `rightOnes` to count the total number of `1`s in the string. We loop through the string and increment `rightOnes` whenever we encounter a `1`.

4. **Score Calculation**:
   ```cpp
   int score = 0;
   for(int i=0; i<s.length()-1; i++){
   ```

   - We initialize `score` to zero. The second loop iterates through the string up to the second last character to ensure both substrings are non-empty.

5. **Updating Counts and Calculating Score**:
   ```cpp
   if(s[i]=='0') leftZeroes++;
   else rightOnes--;
   score = max(score, leftZeroes + rightOnes);
   ```

   - Inside the loop:
     - If the current character is `0`, we increment `leftZeroes` to count the `0`s in the left substring.
     - If the character is `1`, we decrement `rightOnes` to update the count of `1`s in the right substring.
     - We then calculate the current score as the sum of `leftZeroes` and `rightOnes` and update `score` if this value is greater than the previously recorded maximum.

6. **Return Statement**:
   ```cpp
   return score;
   }
   ```

   - Finally, we return the computed maximum score.

### Complexity

- **Time Complexity**: The time complexity of the algorithm is \(O(n)\), where \(n\) is the length of the string `s`. This is because we perform a constant-time operation for each character in the string during two passes: one for counting `1`s and another for computing the score.

- **Space Complexity**: The space complexity is \(O(1)\) since we only use a fixed amount of space for the variables `rightOnes`, `leftZeroes`, and `score`, regardless of the size of the input string.

### Conclusion

The `maxScore` function efficiently calculates the maximum score obtainable by splitting the binary string into two non-empty substrings. By maintaining a count of `0`s on the left and `1`s on the right during a single linear traversal, we minimize both time and space complexity.

#### Key Takeaways:

- **Efficiency in Problem Solving**: This approach showcases how a linear traversal can optimize the solution to problems involving counting and scoring, providing results in optimal time.
- **Use of Simple Variables**: The solution effectively uses a few simple variables to maintain state, which is a hallmark of efficient coding.
- **Binary String Handling**: The problem emphasizes the importance of understanding the properties of binary strings and leveraging these properties in algorithm design.

Overall, the provided solution offers a clear and efficient way to solve the problem of maximizing the score based on specified conditions in a binary string, demonstrating sound programming principles and effective algorithmic strategy.
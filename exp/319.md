### Problem Statement

The problem asks us to determine how many bulbs are on after `n` rounds of flipping bulbs. Initially, all bulbs are off. In each round, a certain set of bulbs are flipped. Specifically, for each round `i` (where `i` starts from 1), every `i`-th bulb is flipped. After completing all the rounds, we need to find how many bulbs are left in the "on" state.

### Approach

The key observation in solving this problem is recognizing the pattern of bulb flipping based on the number of divisors of the bulb's index. Here's how we can approach it:

1. **Initial Setup**: Initially, all bulbs are off.
2. **Flipping Rule**: In round `i`, we flip every `i`-th bulb. This means that in round 1, every bulb is flipped (since every number is divisible by 1), in round 2, every second bulb is flipped, and so on.
3. **Bulb Flipping Pattern**: A bulb is flipped each time its index is divisible by the round number. This means that bulb `k` will be flipped for every divisor of `k`. For example, bulb 6 will be flipped in rounds 1, 2, 3, and 6 (because 1, 2, 3, and 6 are divisors of 6).
4. **Final State of Bulb**: A bulb will be in the "on" state if it has been flipped an odd number of times, and in the "off" state if it has been flipped an even number of times. The only way a bulb is flipped an odd number of times is if the bulb's index is a perfect square. This is because perfect squares have an odd number of divisors. For example, 9 has divisors 1, 3, and 9, which is an odd count.
5. **Result**: The number of bulbs that remain on corresponds to the number of perfect squares less than or equal to `n`. This is equivalent to the integer part of the square root of `n`.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    int bulbSwitch(int n) {
        return sqrt(n);
    }
};
```

1. **Function Signature**:
    - The function `bulbSwitch` takes an integer `n` as input, representing the number of bulbs.
    - It returns an integer, which is the number of bulbs that remain "on" after `n` rounds.

2. **Use of `sqrt`**:
    - The core idea behind the solution is that the number of bulbs that remain "on" is the number of perfect squares less than or equal to `n`.
    - The function `sqrt(n)` computes the square root of `n` and returns the largest integer that is less than or equal to `sqrt(n)`. This integer represents the number of perfect squares less than or equal to `n`.

3. **Why Perfect Squares**:
    - As mentioned earlier, only bulbs at perfect square indices will remain "on". This is because perfect squares are the only numbers with an odd number of divisors.
    - For example:
      - `1` is flipped once (perfect square).
      - `4` is flipped three times (perfect square).
      - `9` is flipped five times (perfect square).
      - So, for any number `n`, the number of bulbs that are "on" corresponds to the count of perfect squares up to `n`, which is simply `floor(sqrt(n))`.

4. **Efficiency**:
    - The function computes the square root of `n`, which is a constant-time operation (`O(1)` complexity).
    - This provides an optimal solution for the problem, as it avoids simulating all the rounds of bulb flipping, reducing the time complexity to `O(1)`.

### Complexity

#### Time Complexity:
- **O(1)**: The solution involves only the computation of the square root of `n`, which is a constant-time operation. No loops or complex operations are involved.

#### Space Complexity:
- **O(1)**: The solution uses only a constant amount of space to store the input `n` and the result, which is an integer.

### Conclusion

This solution is highly efficient and leverages the mathematical property of perfect squares to solve the problem in constant time and space. The key insight is recognizing that the bulbs that remain "on" are those at indices that are perfect squares. By calculating the square root of `n`, we can quickly determine how many bulbs will remain "on".

**Key Takeaways**:
1. **Mathematical Insight**: Only perfect squares will remain "on", and the number of perfect squares less than or equal to `n` is the integer part of `sqrt(n)`.
2. **Optimal Solution**: The solution runs in constant time and uses constant space, making it optimal for large values of `n`.
3. **Efficiency**: This approach avoids the need for simulating each round, making it both time and space efficient.

By understanding the problem in terms of divisors and perfect squares, we can solve the problem in an elegant and efficient manner, providing a quick and scalable solution.
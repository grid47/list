### ðŸŒŸ Maximum Profit from at Most `k` Transactions

The problem asks you to find the maximum profit you can achieve by performing at most `k` transactions (buying and selling once per transaction) on an array of stock prices. The goal is to maximize profit while respecting the transaction limit.

#### Example:
- Given prices = `[2, 4, 1]` and `k = 2`, the maximum profit would be `2` by buying at 2 and selling at 4.
- Given prices = `[3, 2, 6, 5, 0, 3]` and `k = 2`, the maximum profit would be `7` by buying at 2, selling at 6, and buying at 0 and selling at 3.

### ðŸ’¡ Approach

This problem can be efficiently solved using **dynamic programming (DP)** with **memoization**. The idea is to recursively explore all possible scenarios and store intermediate results to avoid redundant calculations.

#### Key Concepts:
1. **State Representation**: The state is defined by:
   - The current day (`idx`).
   - Whether we are in the "buy" or "sell" phase (`buy`).
   - The number of transactions weâ€™ve performed so far (`cnt`).

2. **Memoization**: We use memoization to store the results of subproblems to avoid recalculating them multiple times.

3. **Recursive Transition**: At each step, we have two options:
   - Skip the current day.
   - Either buy or sell the stock, depending on the current phase.

### ðŸ›  Code Breakdown

#### Step 1: Memoization Setup

```cpp
int memo[2][1001][100];
```
- `memo[buy][idx][cnt]` stores the maximum profit at a given day (`idx`), whether we're buying (`buy == 1`) or selling (`buy == 0`), and the number of transactions performed so far (`cnt`).

#### Step 2: Recursive `dp` Function

```cpp
int dp(int k, vector<int>& prices, int buy, int idx, int cnt) {
```
- The recursive `dp` function explores two possible choices for each state:
  - **Skip the current day**: Just move to the next day (`idx + 1`).
  - **Buy or Sell**: If we are in the buying phase, buy the stock and move to the selling phase; if we are in the selling phase, sell the stock and move back to the buying phase, incrementing the transaction count (`cnt + 1`).

#### Step 3: Base Case

```cpp
if(cnt == k || idx == prices.size()) {
    return 0;
}
```
- If we've reached the maximum number of allowed transactions (`cnt == k`) or have iterated through all the days (`idx == prices.size()`), no further profit can be made, so we return 0.

#### Step 4: Memoization Check

```cpp
if(memo[buy][idx][cnt] != -1) return memo[buy][idx][cnt];
```
- Before calculating the result for a state, we check if it's already been computed (cached) in `memo`. If it has, we return the stored value.

#### Step 5: Recursive Transitions

```cpp
int res = dp(k, prices, buy, idx + 1, cnt);
```
- This represents the case where we skip the current day and move to the next day (`idx + 1`).

```cpp
if(buy) {
    res = max(res, -prices[idx] + dp(k, prices, false, idx + 1, cnt));
} else {
    res = max(res, prices[idx] + dp(k, prices, true, idx + 1, cnt + 1));            
}
```
- If we are in the "buy" phase, we try to buy the stock on the current day (`-prices[idx]`), and the next phase will be "sell".
- If we are in the "sell" phase, we try to sell the stock on the current day (`prices[idx]`), and the next phase will be "buy" with an incremented transaction count (`cnt + 1`).

#### Step 6: Return Memoized Result

```cpp
return memo[buy][idx][cnt] = res;
```
- After calculating the maximum profit for the current state, we store the result in `memo` and return it.

#### Step 7: Main Function

```cpp
int maxProfit(int k, vector<int>& prices) {
    memset(memo, -1, sizeof(memo));
    return dp(k, prices, true, 0, 0);
}
```
- The `maxProfit` function initializes the memoization table to `-1` (indicating uncomputed states).
- It then starts the recursive exploration from the first day (`idx = 0`) with the "buy" phase (`buy = true`) and no transactions (`cnt = 0`).

### ðŸ“Š Complexity Analysis

#### Time Complexity:
- **O(k * n)**: The time complexity is proportional to the number of unique states, where `n` is the number of days and `k` is the maximum number of transactions. The DP approach uses memoization to compute each state only once.

#### Space Complexity:
- **O(k * n)**: The space complexity is determined by the memoization table, which stores results for each combination of transaction count (`cnt`), day index (`idx`), and whether we're in the "buy" or "sell" phase.

### âœ… Conclusion

This solution efficiently calculates the maximum profit with at most `k` transactions using dynamic programming and memoization. It avoids the inefficiencies of brute force by breaking the problem into subproblems and reusing computed results.

#### Key Highlights:
- **Efficient Time Complexity**: **O(k * n)** is optimal for this type of problem.
- **Memoization**: Helps avoid redundant calculations, improving performance.
- **Dynamic Programming**: The DP approach ensures that all possible states are considered while keeping track of transactions and profits.

This approach is a powerful solution for maximizing profit with at most `k` stock transactions.
### Problem Statement

The problem requires removing the **n-th node from the end of a singly linked list**. The task is to implement a function that takes the head of a singly linked list and an integer `n`, and removes the `n-th` node from the list, returning the updated list. The input list is guaranteed to have at least one node, and we assume `n` is always valid.

#### Input:
- A singly linked list with at least one node.
- An integer `n`, which specifies the position of the node to remove, counted from the end of the list.

#### Output:
- A singly linked list with the `n-th` node from the end removed.

The challenge is to solve this problem with an efficient approach, ideally in linear time complexity.

### Approach

This problem can be approached using two main methods:

1. **Two-pass approach (Length-first)**:
   - **First pass**: Traverse the linked list to compute its length (`sz`).
   - **Second pass**: Traverse again, but this time stop at the node just before the one that needs to be removed (i.e., the `sz - n - 1` node) and adjust the `next` pointer to skip the target node.

2. **One-pass approach (Two pointers)**:
   - We can maintain two pointers, `first` and `second`, such that the distance between them is always `n` nodes.
   - Move the `first` pointer `n` steps ahead, and then move both pointers forward simultaneously until the `first` pointer reaches the end. The `second` pointer will then point to the node just before the one to be removed.
   
For the sake of clarity and simplicity, we will walk through the **two-pass approach** in the provided code, which is more intuitive and easier to implement with a slight increase in time complexity.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
```
- The function `removeNthFromEnd` takes the head of the linked list (`ListNode* head`) and an integer `n`, which indicates the position of the node to remove (counted from the end of the list).
  
```cpp
        ListNode* node = head;
        int sz = 0;
```
- `node` is a pointer that will traverse the list, and `sz` is a variable to store the length of the list.

```cpp
        while(node) {
            node = node->next;
            sz++;
        }
```
- The first `while` loop iterates through the entire list, incrementing `sz` each time to compute the length of the linked list. After the loop, `sz` will hold the total number of nodes in the list.

```cpp
        node = head;
        int tgt = sz - n;
```
- Now, we reset `node` to point back to the head of the list. `tgt` is the index of the node just before the one we need to remove. This is calculated as `sz - n`.

```cpp
        if(sz == n) return head->next;
```
- If `n` is equal to `sz`, this means the node to remove is the head of the list itself. In this case, we simply return `head->next`, which effectively removes the head node by pointing to the next node.

```cpp
        for(int i = 0; i < tgt-1; i++)
            node = node->next;
```
- This loop moves the `node` pointer to the node just before the node we need to remove (i.e., `tgt - 1` steps ahead).

```cpp
        if(node->next)
        node->next = node->next->next;
```
- After reaching the node before the target, we remove the target node by changing the `next` pointer of `node` to skip over the `n-th` node from the end. Specifically, we set `node->next` to `node->next->next`, which effectively removes the node by linking to the next node after the one we want to delete.

```cpp
        return head;
    }
};
```
- Finally, the updated head is returned. This may be the same as the original head if the target node was not the head itself, or it may be a new head if the target node was the first one in the list.

### Complexity

#### Time Complexity:
- **First pass**: The first loop traverses the entire list to calculate the size, which takes `O(N)` time, where `N` is the number of nodes in the list.
- **Second pass**: The second loop iterates `tgt-1` times to reach the node just before the one to be removed. In the worst case, this is also `O(N)`.

Thus, the overall **time complexity** is `O(N)`, where `N` is the length of the linked list.

#### Space Complexity:
- The space complexity of the solution is **O(1)** because the algorithm only uses a constant amount of extra space for the `sz` variable and the `node` pointer. We do not use any additional data structures that grow with the size of the input.

### Conclusion

This solution efficiently removes the `n-th` node from the end of a singly linked list in `O(N)` time and `O(1)` space. By first calculating the length of the list, and then finding the node to remove by traversing again, the algorithm ensures correctness and simplicity. While an alternative one-pass approach using two pointers could also be implemented, the two-pass approach is more intuitive and easier to understand. 

Key takeaways:
- The first pass calculates the length of the list.
- The second pass traverses the list again to find the node just before the one to be deleted.
- The list is updated by adjusting the `next` pointer to remove the target node.
  
This solution is effective for typical use cases and handles edge cases like removing the head node without additional complexity.
### Problem Statement

Given a binary string `s`, the task is to split it into the minimum number of beautiful substrings. A beautiful substring is defined as a substring that, when converted to a decimal number, is divisible by `15625`. The goal is to determine the minimum number of beautiful substrings into which the string `s` can be split, or return `-1` if it's not possible to split `s` into beautiful substrings.

### Approach

The core idea of this solution is to use dynamic programming to minimize the number of beautiful substrings we can obtain from the string `s`. We'll take advantage of the fact that the only values divisible by `15625` that can be represented as binary strings are specific powers of 5. Therefore, our approach focuses on iterating over the string and trying to find all valid binary substrings that are divisible by `15625`, updating the result through dynamic programming.

Here are the steps involved:

1. **Initialization**:
   - We need a dynamic programming array `dp` where `dp[i]` will store the minimum number of beautiful substrings needed to split the substring `s[0..i-1]`. 
   - We initialize the `dp` array with a large value (`n + 1`), except for `dp[0]`, which is 0 because no substrings are needed before the start of the string.

2. **Check Divisibility for All Substrings**:
   - For every substring starting from index `i`, we try to form a number from the binary digits of the string. For each binary substring, we convert it to a decimal number and check if it is divisible by `15625`.
   - If the number is divisible by `15625`, we update the `dp` value for the end of that substring to reflect that we've found a new beautiful substring.

3. **Final Answer**:
   - After processing the entire string, if `dp[n]` is still `n + 1`, it means it's impossible to split the string into beautiful substrings, so we return `-1`. Otherwise, we return the value of `dp[n]`, which represents the minimum number of beautiful substrings.

### Code Breakdown (Step by Step)

Let's walk through the code line by line:

1. **Dynamic Programming Array Setup**:
   ```cpp
   int n = s.length();
   vector<int> dp(n + 1, n + 1);
   dp[0] = 0;
   ```
   - The variable `n` holds the length of the string `s`.
   - We initialize the `dp` array with size `n + 1`. The value of `dp[i]` represents the minimum number of beautiful substrings needed to split the substring `s[0..i-1]`. Initially, all values are set to `n + 1` (a large value), except for `dp[0]`, which is set to 0 because no substrings are required before the start of the string.

2. **Iterate Through the String**:
   ```cpp
   for (int i = 0; i < n; i++) {
       if (s[i] == '0') continue;
       for (int j = i, cur = 0; j < n; j++) {
           cur = cur * 2 + s[j] - '0';
           if (15625 % cur == 0)
               dp[j + 1] = min(dp[j + 1], dp[i] + 1);
       }
   }
   ```
   - The outer loop iterates through each character in the string. If the current character is `'0'`, it skips to the next iteration because no valid substring can start with `0`.
   - The inner loop tries to form a binary number starting from index `i`. The variable `cur` keeps track of the current number as we append each bit.
   - We convert the binary substring formed by `s[i..j]` into a decimal number by continuously updating `cur = cur * 2 + s[j] - '0'`.
   - If the current number `cur` is divisible by `15625`, we update the `dp[j + 1]` to the minimum value between the current `dp[j + 1]` and `dp[i] + 1`. This means we've found a valid substring from `i` to `j`, and we can consider it as one beautiful substring, increasing the count.

3. **Return Result**:
   ```cpp
   return dp[n] > n ? -1 : dp[n];
   ```
   - After iterating through all substrings, if `dp[n]` is still greater than `n`, it means it's impossible to split the string into beautiful substrings, so we return `-1`.
   - Otherwise, we return `dp[n]`, which represents the minimum number of beautiful substrings.

### Complexity Analysis

#### Time Complexity:
1. **Outer Loop**:
   - The outer loop runs from `i = 0` to `i = n-1`, so it iterates `n` times.

2. **Inner Loop**:
   - For each position `i`, the inner loop iterates from `j = i` to `j = n-1`. In the worst case, the inner loop runs \(n\) times for each value of `i`. Therefore, the total number of iterations in both loops is approximately \(O(n^2)\).

3. **Divisibility Check**:
   - For each valid substring, we check if `cur % 15625 == 0`, which takes constant time \(O(1)\) because checking divisibility is a simple operation.

Hence, the total time complexity is \(O(n^2)\), where \(n\) is the length of the string `s`.

#### Space Complexity:
- We are using an array `dp` of size \(n + 1\) to store the minimum number of beautiful substrings. Hence, the space complexity is \(O(n)\), where \(n\) is the length of the string `s`.

### Conclusion

This solution utilizes dynamic programming to find the minimum number of beautiful substrings in a binary string. The algorithm processes the string by iterating over all possible substrings and checking if they are divisible by `15625`. The time complexity of \(O(n^2)\) makes the solution efficient for moderate-sized strings. The solution is well-optimized, with space complexity of \(O(n)\) for the `dp` array, and it provides the correct result by keeping track of the minimum number of beautiful substrings needed. 

This approach ensures that all edge cases, such as strings containing only `0`s or strings where no beautiful substring exists, are handled correctly.
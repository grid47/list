### Problem Statement

The problem requires us to parse a chemical formula and return a string that represents the atoms and their respective counts in the formula. The formula may contain elements, integers, and parentheses. Our goal is to count the frequency of each element and return them in lexicographical order. Additionally, the formula can contain nested parentheses that imply multiplicative factors for the enclosed atoms.

### Approach

We need to break down and process the formula by:
1. **Parsing atoms**: Recognizing elements from the formula which are represented by one or two lowercase letters.
2. **Counting the frequency of atoms**: Managing the count of atoms, handling nested structures (i.e., parentheses) and their multiplicative factors.
3. **Managing recursion and multiplicative factors**: Handling nested formulas by recursively breaking down sub-formulas inside parentheses, multiplying their counts appropriately.
4. **Output**: Generating a lexicographically sorted string representation of the atoms and their frequencies.

The algorithm utilizes recursion to handle nested parentheses and applies a multiplicative factor for each group of atoms inside parentheses. We also use maps to store the counts of atoms and their respective frequencies. 

### Code Breakdown (Step by Step)

#### 1. **`merge` function**
The `merge` function is used to combine atom counts from two maps. It takes two maps `to` and `from` and a multiplier `mul`. For every atom in `from`, it multiplies its count by `mul` and adds it to `to`.

```cpp
void merge(map<string, int> &to, map<string, int> &from, int mul) {
    for(auto [key, val]: from) {
        to[key] += val * mul;
    }
}
```

- The `merge` function ensures that we can combine atom counts correctly, especially when we deal with nested formulas.

#### 2. **`atom` function**
The `atom` function extracts an atom (element) from the formula. An atom is a sequence of lowercase letters, typically starting with a lowercase letter. This function will return the atom as a string and update the index `i` to the next position.

```cpp
string atom(string &eqn, int &i) {
    int i1 = i++;
    while(i < n && islower(eqn[i])) i++;
    return eqn.substr(i1, i - i1);
}
```

- This function recognizes the start of an atom, finds all the lowercase letters that follow, and returns them as an atom.

#### 3. **`num` function**
The `num` function retrieves the number following an atom or a parenthesis. If no number is found, it defaults to `1`.

```cpp
int num(string &eqn, int &i) {
    int i1 = i;
    while(i < n && isdigit(eqn[i])) i++;
    return i1 == i ? 1 : stoi(eqn.substr(i1, i - i1));
}
```

- The `num` function checks if a number follows an atom or parentheses. If it exists, it converts it to an integer; otherwise, it defaults to `1`.

#### 4. **`unit` function**
The `unit` function parses a single unit (either an atom or a sub-formula in parentheses). If the unit is enclosed in parentheses, it recursively calls the `formula` function to process the contents of the parentheses and applies the multiplicative factor.

```cpp
map<string, int> unit(string &eqn, int &i) {
    map<string, int> cnt;
    if(eqn[i] == '(') {
        map<string, int> cur = formula(eqn, ++i);
        int frq = num(eqn, ++i);
        merge(cnt, cur, frq);
    } else {
        string str = atom(eqn, i);
        int frq = num(eqn, i);
        cnt[str] = frq;
    }
    return cnt;
}
```

- The `unit` function handles the two cases:
  1. When encountering parentheses, it recursively calls `formula` and applies the multiplier to the result.
  2. Otherwise, it processes a single atom and its multiplier.

#### 5. **`formula` function**
The `formula` function processes the entire formula. It iterates through the formula, calling `unit` to process individual atoms or sub-formulas, and combines the counts using the `merge` function.

```cpp
map<string, int> formula(string &eqn, int &i) {
    map<string, int> cnt;
    while(i < n && eqn[i] != ')') {
        map<string, int> res = unit(eqn, i);
        int mul = num(eqn, i);
        merge(cnt, res, mul);
    }
    return cnt;
}
```

- The `formula` function handles parsing a larger formula, calling `unit` for individual units (atoms or sub-formulas) and applying multiplicative factors to each.

#### 6. **`countOfAtoms` function**
The main function, `countOfAtoms`, serves as the entry point for solving the problem. It initializes the parsing and then formats the result by iterating over the final atom counts.

```cpp
string countOfAtoms(string eqn) {
    n = eqn.size();
    string ans = "";
    int i = 0;
    map<string, int> mp = formula(eqn, i);
    for(auto [key, val]: mp) {
        ans += (key + ((val == 1)? "" : to_string(val)));
    }
    return ans;
}
```

- The function initializes the formula parsing by calling `formula(eqn, i)` to get the atom counts.
- It then constructs the final string, appending each atom followed by its count (unless the count is `1`).
- The result is returned as a formatted string.

### Complexity Analysis

#### Time Complexity: **O(n)**

- The primary work in the algorithm is parsing the formula, which involves iterating through the string character by character. Each character is processed a constant number of times (depending on whether it belongs to an atom, a number, or a parenthesis).
- The overall time complexity is linear with respect to the size of the formula, **O(n)**, where `n` is the length of the input string.

#### Space Complexity: **O(n)**

- The space complexity is dominated by the storage of the atom counts in the map. In the worst case, each atom could be unique, leading to a space complexity of **O(n)**.
- Additionally, the recursion stack for processing nested parentheses adds a small overhead, but this is negligible compared to the space used for the result.

### Conclusion

This solution efficiently parses a chemical formula and counts the frequency of each atom, even when nested parentheses are involved. By utilizing recursion, maps, and multiplicative factors, the algorithm ensures that the atoms are counted accurately and returned in lexicographical order. The time complexity of **O(n)** and space complexity of **O(n)** make this approach efficient for processing large formulas. 

The key steps involve:
- Parsing the string to identify atoms, numbers, and parentheses.
- Handling nested parentheses by recursively calling the `formula` function.
- Merging atom counts correctly and applying multiplicative factors as necessary.

This solution is highly efficient and robust for counting atoms in complex chemical formulas, and it handles both simple and nested cases gracefully.
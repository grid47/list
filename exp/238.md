### Problem Statement

The problem at hand is to compute the product of all elements in a given array **except the current element** at each index for all indices in the array. Specifically, for each index `i`, we want to compute the product of all elements of the array except for the element at index `i`. This must be achieved without using division and in **O(n)** time complexity, where `n` is the size of the array.

Given an array `nums`, you are tasked with constructing an array `output` where each `output[i]` is the product of all the numbers in the original array except `nums[i]`.

Example:
```cpp
Input:  [1,2,3,4]
Output: [24,12,8,6]
```
Explanation:
- `output[0] = 2 * 3 * 4 = 24`
- `output[1] = 1 * 3 * 4 = 12`
- `output[2] = 1 * 2 * 4 = 8`
- `output[3] = 1 * 2 * 3 = 6`

### Approach

In order to solve this problem efficiently (in **O(n)** time complexity), we can leverage the concept of prefix and suffix products. Hereâ€™s how the approach works:

1. **Prefix Products**:
    - The **prefix product** of an index `i` is the product of all the elements before index `i` in the array.
    - For example, for an index `i = 3`, the prefix product would be the product of all elements before index 3, i.e., `nums[0] * nums[1] * nums[2]`.
    - We can store the prefix products in an array `pre`, where `pre[i]` represents the product of all elements before `i`.

2. **Suffix Products**:
    - The **suffix product** of an index `i` is the product of all elements after index `i` in the array.
    - For example, for an index `i = 3`, the suffix product would be the product of all elements after index 3, i.e., `nums[4] * nums[5]`.
    - We can store the suffix products in an array `suf`, where `suf[i]` represents the product of all elements after `i`.

3. **Final Product**:
    - The product of all elements except for `nums[i]` can then be computed by multiplying the corresponding values from the prefix and suffix product arrays:
    ```cpp
    output[i] = pre[i - 1] * suf[i + 1]
    ```
    - For the first element, we consider the suffix product, and for the last element, we consider the prefix product.

This method ensures that each element is processed only once, leading to an **O(n)** time complexity solution, with **O(n)** extra space for storing the prefix and suffix products.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
```
- We define a class `Solution` and a public method `productExceptSelf`, which takes a reference to a vector `nums` as its input. This vector contains the elements of the array.

```cpp
        int n = nums.size();
```
- The first step inside the function is to determine the size of the `nums` array and store it in the variable `n`.

```cpp
        vector<int> pre(n, 1), suf(n, 1);
```
- We declare two vectors, `pre` and `suf`, both of size `n`. These vectors will hold the prefix and suffix products, respectively.
    - Both vectors are initialized with the value `1` because we need to start multiplying from `1` (i.e., the identity element for multiplication).

```cpp
        pre[0] = nums[0];
        suf[n - 1] = nums[n - 1];
```
- We initialize the first element of the prefix product array `pre[0]` with the value of `nums[0]` (the first element of the array). This is because for the first element, the prefix product is just the first element itself.
- Similarly, we initialize the last element of the suffix product array `suf[n - 1]` with the value of `nums[n - 1]` (the last element of the array).

```cpp
        for(int i = 1; i < n; i++)
            pre[i] = pre[i - 1] * nums[i];
```
- We loop through the array starting from the second element (`i = 1`) and calculate the prefix product for each element. The prefix product at each index `i` is the product of the element `nums[i]` and the prefix product of the previous element `pre[i - 1]`.

```cpp
        for(int i = n - 2; i >= 0; i--)
            suf[i] = suf[i + 1] * nums[i];
```
- We loop backward from the second-to-last element (`i = n - 2`) and calculate the suffix product for each element. The suffix product at each index `i` is the product of the element `nums[i]` and the suffix product of the next element `suf[i + 1]`.

```cpp
        vector<int> ans(n, 1);
        for(int i = 0; i < n; i++)
            ans[i] = (i > 0? pre[i - 1]: 1) * (i < n - 1? suf[i + 1]: 1);
```
- We now compute the final product for each index `i`. The value at `ans[i]` is the product of the prefix product at index `i - 1` (i.e., `pre[i - 1]`) and the suffix product at index `i + 1` (i.e., `suf[i + 1]`).
    - For the first index (`i = 0`), the prefix product is `1` because there are no elements before index `0`. 
    - Similarly, for the last index (`i = n - 1`), the suffix product is `1` because there are no elements after index `n - 1`.

```cpp
        return ans;
    }
};
```
- Finally, we return the array `ans`, which contains the result of the product of all elements except the current element for each index in the array.

### Complexity

#### Time Complexity:
- **O(n)**: The solution performs three separate loops over the array `nums` to calculate the prefix products, suffix products, and the final result. Each loop iterates through the array once, so the time complexity is linear in the size of the array, i.e., `O(n)`.

#### Space Complexity:
- **O(n)**: We use three additional arrays (`pre`, `suf`, and `ans`) to store the prefix products, suffix products, and the final result. Each of these arrays is of size `n`, so the space complexity is also linear, i.e., `O(n)`.

### Conclusion

This approach efficiently solves the problem of calculating the product of all elements except the current element in an array in linear time, using the prefix and suffix product arrays to avoid using division. The solution is both time-efficient (O(n)) and space-efficient (O(n)), making it an optimal solution for this problem.

#### Key Points:
1. **Efficient Calculation**: By using the prefix and suffix products, we avoid the need for nested loops or division.
2. **Space Complexity**: Although we use extra space for the prefix and suffix products, the space complexity is still linear, which is optimal for this problem.
3. **Edge Cases**: The algorithm handles all edge cases efficiently, including cases with arrays of length 1 or 2.

This approach is commonly used in problems where you need to compute the product of all elements except one, without using division or requiring multiple nested loops.
### Problem Statement

The problem asks us to partition an array `nums` into two contiguous subarrays such that every element in the left partition is less than or equal to every element in the right partition. The left partition should be as small as possible in size, meaning we want to find the smallest possible length of the left subarray. Our task is to return the length of this left partition.

### Approach

To achieve this partition, we need to find the smallest index where we can divide `nums` so that all elements in the left subarray are less than or equal to all elements in the right subarray. The approach is based on tracking the maximum value in the left partition and updating it as we iterate through the array.

1. **Initialize Values**:
   - `max_i` keeps track of the maximum element in the left partition (initially set to `nums[0]`).
   - `cur` represents the current maximum we encounter while iterating.
   - `ans` is the answer representing the length of the left partition (initialized to 1 because the left partition must contain at least one element).

2. **Iterate through the Array**:
   - If `nums[i]` is less than `max_i`, it indicates that `nums[i]` needs to be part of the left partition to satisfy the partition condition. Therefore, we update `max_i` to `cur` (the maximum element we've seen so far) and set `ans` to `i + 1`, effectively expanding the left partition.
   - If `nums[i]` is greater than `cur`, we update `cur` to `nums[i]` to track the largest value seen while iterating.

3. **Return the Result**:
   - After the loop, `ans` will contain the length of the left partition that satisfies the required condition.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    int partitionDisjoint(vector<int>& nums) {
        int n = nums.size();
        int max_i, cur, ans = 1;
        max_i = cur = nums[0];
        
        for(int i = 1; i < n; i++) {
            if(nums[i] < max_i) {
                max_i = cur;
                ans = i + 1;
            } else if (nums[i] > cur)
                cur = nums[i];
        }
        return ans;
    }
};
```

1. **Initialization**:
   - `max_i` and `cur` are both set to `nums[0]`, representing the maximum value seen so far.
   - `ans` is set to `1` to initially assume the smallest possible left partition.

2. **Loop through the Array**:
   - For each `nums[i]`:
     - If `nums[i] < max_i`, we extend the left partition and set `max_i` to `cur` to include the maximum element seen in the left partition.
     - If `nums[i] > cur`, we update `cur` to this value to track the highest element encountered so far.

3. **Return Statement**:
   - We return `ans`, which represents the minimum length of the left partition.

### Complexity

- **Time Complexity**: `O(n)` where `n` is the length of `nums`. This is because we only make a single pass through the array.
- **Space Complexity**: `O(1)` as we use a constant amount of extra space.

### Conclusion

The solution effectively finds the smallest possible left partition length by tracking the maximum elements in the left and right parts of the array with a single pass. This approach is efficient and ensures we meet the requirements of the problem while optimizing space usage. By keeping track of the maximum values, the solution guarantees that the left partition contains only elements less than or equal to those in the right partition, achieving the desired partition structure with minimal computational overhead.
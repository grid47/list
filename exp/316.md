### Problem Statement

The problem asks us to remove duplicate letters from a given string `s` such that:
1. Every letter appears only once in the result string.
2. The result string must be the smallest in lexicographical order.

This means that for any two duplicate letters, the earlier occurrence should be removed if a lexicographically smaller option can still be placed in the result string while ensuring the sequence is valid.

### Approach

To solve this problem efficiently, we can take advantage of a **greedy algorithm** combined with a **stack**. Here's a breakdown of the approach:

1. **Character Frequency Count**: We need to know how many times each character appears in the string so that we can ensure that we don’t discard a character which we might need later.
   
2. **Lexicographical Order**: While traversing the string, we will try to build the result string in lexicographical order. This requires removing characters from the stack if we encounter a smaller character that can still be placed later. 

3. **Stack for Result Construction**: A stack will help us maintain the result string while respecting the lexicographical order, and ensuring each character appears only once.

4. **Two Helper Arrays**:
   - `frq[26]`: Tracks the frequency of each character in the string.
   - `lidx[26]`: Tracks the last index at which each character appears in the string.

5. **Visited Set**: A boolean array `seen[26]` to track if a character is already present in the stack (result).

### Code Breakdown (Step by Step)

#### Step 1: Frequency and Last Index Calculation

```cpp
vector<int> frq(26, 0), lidx(26, 0);

for (int i = 0; i < s.size(); i++) {
    char x = s[i];
    frq[x - 'a']++;
    lidx[x - 'a'] = i;
}
```

- **`frq` Array**: This array stores how many times each character (from 'a' to 'z') appears in the string. We increment the frequency count of the character each time it appears.
  
- **`lidx` Array**: This array keeps track of the last index where each character is located. This helps us decide whether it’s safe to remove a character from the stack while maintaining the possibility of encountering it later.

#### Step 2: Initialize Seen Array and Stack

```cpp
vector<bool> seen(26, false);
stack<char> st;
```

- **`seen` Array**: A boolean array to track whether a character is already present in the stack. If a character is already in the result, we skip adding it again.
  
- **`st` Stack**: The stack will store characters of the final result in a way that respects the lexicographical order and ensures no duplicates.

#### Step 3: Process Each Character in the String

```cpp
for(int i = 0; i < s.size(); i++) {
    int cur = s[i] - 'a';            
    if(seen[cur]) continue;

    while(st.size() > 0 && st.top() > s[i] && i < lidx[st.top() - 'a']) {
        seen[st.top() - 'a'] = false;
        st.pop();
    }

    st.push(s[i]);
    seen[cur] = true;
}
```

- **Loop Through the String**: We iterate through each character of the string.
  
- **Skip Seen Characters**: If a character has already been added to the stack (i.e., it’s part of the result string), we skip processing it by continuing to the next character.
  
- **Removing Larger Characters**: For each character, we check if it’s smaller than the character currently on top of the stack (`st.top()`) and if the top character appears later in the string (`i < lidx[st.top() - 'a']`). If both conditions are true, we can safely remove the top character from the stack because:
  - The current character is lexicographically smaller.
  - The character we remove will appear again later in the string.
  
- **Push Current Character to Stack**: After the above checks, we push the current character into the stack and mark it as "seen".

#### Step 4: Build the Final Result String

```cpp
string ans = "";
while(st.size() > 0) {
    ans += st.top();
    st.pop();
}
reverse(ans.begin(), ans.end());
return ans;
```

- **Construct the Result**: Once all characters have been processed, the stack contains the result but in reverse order.
  
- **Reverse the Stack**: We reverse the stack content to get the final result in the correct order.

- **Return the Result**: The final string is returned.

### Example Walkthrough

Consider the input `s = "bcabc"`. The steps would be:

1. **Initial Frequency Count**:
   - `frq = [0, 1, 2, 1, 0, ..., 0]` (b appears twice, c appears once, a appears once).

2. **Processing `s = "bcabc"`**:
   - Process 'b': Not seen, push 'b' to the stack.
   - Process 'c': Not seen, push 'c' to the stack.
   - Process 'a': Not seen, remove 'c' from the stack (because it will appear again), then push 'a' to the stack.
   - Process 'b': 'b' is already in the stack, skip.
   - Process 'c': 'c' is now safely pushed to the stack.
   
   The stack at the end will contain `["a", "b", "c"]`.

3. **Final String**: The stack content is `["a", "b", "c"]`, so after reversing it, the final result is `"abc"`.

### Complexity

#### Time Complexity:
The time complexity of the solution is **O(n)**, where `n` is the length of the input string `s`. This is because:
- We only traverse the string once to compute the frequency and last index of each character.
- We process each character once when pushing and popping from the stack.

#### Space Complexity:
The space complexity is **O(n)** because:
- We use extra space for the `frq`, `lidx`, and `seen` arrays of size 26 (constant space).
- The stack stores the characters of the result, which in the worst case can store all `n` characters of the input string.

### Conclusion

This approach ensures that we remove duplicate letters while maintaining the smallest lexicographical order in an efficient manner. By leveraging a stack and keeping track of character frequencies and last occurrences, we can solve this problem in linear time. The greedy strategy of removing characters that can appear later allows us to build the correct result string while respecting both the uniqueness and order of characters. 

**Key Takeaways**:
1. **Greedy Approach**: We optimize the lexicographical order by always considering removing larger characters when possible.
2. **Stack Usage**: The stack efficiently helps in constructing the final result while adhering to the order constraints.
3. **Optimal Time Complexity**: The algorithm runs in **O(n)** time, making it suitable for large input sizes.
### Problem Statement

In this problem, we are given a list of integers `nums`, and we need to determine if there exists a valid split point in the list where the elements before the split and after the split are "coprime." Two numbers are considered coprime if their greatest common divisor (GCD) is 1. A valid split is one where every element on the left side has no common prime factor with any element on the right side.

The objective is to find the smallest index `i` such that:
- The left side of the array (`nums[0]` to `nums[i]`) and the right side (`nums[i+1]` to `nums[n-1]`) have no common prime factors.

If such a split exists, we should return the smallest index `i`, otherwise, return `-1`.

### Approach

The approach involves using **prime factorization** to check if there exists a valid split where the left and right sides of the array have no prime factors in common. We need to track the prime factors of each number in the array and maintain a mechanism to check if there is an overlap in the prime factors between the two sides of the array.

#### Steps:
1. **Prime Factorization**:
   - For each element in the array, find its prime factors. We can use a method to efficiently compute the prime factors of a number by checking divisibility for each prime number up to 1000.
   
2. **Tracking Prime Factors**:
   - Use a map (`mp`) to store the most recent index where a prime factor has been encountered.
   - We use a difference array (`line`) to track where prime factors start and end for each element.

3. **Partial Sum to Find Split Point**:
   - By accumulating the prime factors using the difference array and computing the partial sum, we determine where prime factors no longer overlap between the two sides of the array.
   - If we find a point where the prime factors of the left side and right side are disjoint, that is a valid split, and we return the index of that split.

4. **Return Result**:
   - If a valid split is found, return the smallest index `i`. If no such split exists, return `-1`.

### Code Breakdown (Step by Step)

#### 1. **Prime Factorization Function**:
```cpp
vector<int> primes(int n) {
    vector<int> res;
    for(int i = 2; i < 1000 && n > 1; i += 1 + (i % 2)) {
        if(n % i == 0) {
            res.push_back(i);
            while((n% i) == 0) n /= i;
        }
    }
    if(n > 1) res.push_back(n);
    return res;
}
```
- This function takes an integer `n` and returns a list of its prime factors.
- It iterates through all integers starting from `2` to `1000` and checks if `n` is divisible by each number. If so, it adds that number to the result and divides `n` by the factor until it is no longer divisible.
- The prime factors of the number are stored in the `res` vector and returned.

#### 2. **Main Function - `findValidSplit`**:
```cpp
int findValidSplit(vector<int>& nums) {
    map<int, int> mp;
    vector<long long> line(10001, 0);
```
- `mp` is a map used to store the last index where each prime factor appeared in the array.
- `line` is a difference array used to track the ranges where a prime factor is present.

```cpp
    int n = nums.size();
    for(int i = 0; i < n; i++)
        for(int f: primes(nums[i])) {
            if(!mp.count(f)) {
                mp[f] = i;
            }
            line[mp[f]]++;
            line[i]--;
        }
```
- We iterate through the array `nums` and compute the prime factors of each number using the `primes()` function.
- For each prime factor `f` of the current number `nums[i]`, we check if it has been encountered before. If not, we store the index `i` in the map `mp`.
- We update the `line` array to mark where the prime factors start and end using a difference array. Specifically, when a prime factor `f` is first encountered, we increment `line[mp[f]]`, and when the prime factor `f` is no longer relevant, we decrement `line[i]`.

```cpp
    partial_sum(line.begin(), line.end(), line.begin());
```
- After processing all elements, we compute the **partial sum** of the `line` array. This gives us the cumulative number of prime factors that are active at each index.

```cpp
    int res = find(line.begin(), line.end(), 0) - line.begin();
    return res < (nums.size() - 1)? res : -1;
}
```
- We search for the first occurrence of `0` in the `line` array, which represents a valid split where the left side and right side have no common prime factors.
- If a valid split is found, we return the index of the split. Otherwise, we return `-1`.

### Complexity Analysis

- **Time Complexity**:
  - For each element in `nums`, we calculate its prime factors. The maximum number of prime factors a number can have is logarithmic with respect to the number itself, and for numbers up to 1000, this is relatively small.
  - The total time complexity for factorization is \(O(n \log \log n)\), where `n` is the size of the array and each factorization is done in logarithmic time with respect to the number.
  - Updating the `line` array and computing the partial sum is \(O(n)\).
  - The total time complexity is \(O(n \log \log n)\).

- **Space Complexity**:
  - We use `map` to store the prime factor indices, which takes \(O(k)\), where `k` is the number of unique prime factors encountered.
  - The `line` array takes \(O(n)\) space.
  - Thus, the space complexity is \(O(n + k)\), where `k` is the number of unique prime factors.

### Conclusion

This solution efficiently solves the problem of finding a valid split point in an array based on prime factors. By utilizing prime factorization, a difference array, and partial sums, the algorithm can quickly determine whether there exists a split where the left and right sides have no common prime factors. The time complexity of \(O(n \log \log n)\) ensures that this approach works efficiently even for larger arrays, making it a scalable and effective solution.
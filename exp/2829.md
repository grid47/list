### Problem Statement

Given two integers `n` and `k`, the task is to compute the sum of `n` distinct integers such that no two integers in the sum are complementary to `k`. The complementary pair of any integer `i` is defined as the number `k - i`. The integers in the sum must all be distinct, and the goal is to find the minimum sum of these `n` distinct integers.

### Approach

To solve this problem, we need to carefully select distinct integers while making sure that no two integers sum up to `k`. The main strategy is as follows:

1. **Selection Process**: Start with the smallest integers, and at each step, check whether the number and its complement (i.e., `k - i`) have been used previously.
2. **Avoid Complementary Pairs**: If both `i` and `k - i` are not used, add `i` to the sum, mark it as used, and continue.
3. **Fill Remaining Slots**: Once we've added all the possible numbers that satisfy the complementary condition, continue adding the next available numbers to complete the sum of `n` integers.

The solution ensures that the sum is minimized by selecting the smallest possible integers first.

### Code Breakdown (Step by Step)

#### 1. Function Definition

```cpp
int minimumSum(int n, int k) {
```
- The function `minimumSum` takes two parameters:
  - `n`: The number of distinct integers we need to select.
  - `k`: The number used to define complementary pairs.

#### 2. Initialization

```cpp
    int sum = 0;
    vector<int> vis(51, 0);
    int i = 1;
```
- `sum`: A variable to store the total sum of the selected integers.
- `vis`: A vector that keeps track of whether a number has been used. It has a size of 51 because the problem constraints are based on numbers between 1 and 50, inclusive.
- `i`: This variable starts from 1 and is used to iterate through the integers.

#### 3. First While Loop (Select Distinct Integers and Avoid Complements)

```cpp
    while(n > 0 && i <= k) {
        if(!vis[i] && !vis[k - i]) {
            n--;                
            sum += i;
            vis[i] = true;
        }
        i++;
    }
```
- The loop runs as long as `n > 0` (i.e., we still need to select numbers) and `i <= k` (we are iterating through the possible numbers starting from 1).
- Inside the loop:
  - The `if` condition checks if neither `i` nor `k - i` have been used (i.e., both are not marked as `true` in `vis`).
  - If both `i` and `k - i` are unused, it selects `i`, adds it to the sum, marks it as used in `vis[i]`, and decreases `n` by 1 (because we have selected one number).
- `i++` moves to the next integer to consider.

#### 4. Second While Loop (Select Remaining Integers)

```cpp
    while(n--) {
        sum += i++;
    }
```
- After the first loop, if there are still remaining integers (`n > 0`), this loop continues from the next available integer `i` and adds them to the sum.
- The loop continues until all `n` integers have been selected.

#### 5. Return the Result

```cpp
    return sum;
}
```
- Finally, the function returns the computed sum.

### Complexity

1. **Time Complexity**:
   - The first while loop runs at most `k` times, as it iterates through integers from 1 to `k`.
   - The second while loop runs for the remaining `n` integers after the first loop.
   - Therefore, the time complexity is **O(k + n)**. In the worst case, `k` and `n` can be up to 50, so the algorithm runs efficiently for the given input limits.

2. **Space Complexity**:
   - The space complexity is **O(1)**, as we only use a small constant amount of extra space: the `vis` vector of fixed size (51), and the integer variables `sum` and `i`.

### Conclusion

The solution efficiently calculates the minimum sum of `n` distinct integers such that no two integers are complementary to `k`. The approach ensures that the smallest possible integers are selected first to minimize the sum, while avoiding the complementary pairs.

The time complexity of **O(k + n)** ensures that the solution can handle the given input constraints effectively. The space complexity of **O(1)** makes the solution optimal in terms of memory usage. Thus, this approach provides an optimal and efficient solution for the problem.
### Problem Statement
You are given two strings, `s1` and `s2`, both of the same length, which contain only lowercase letters. Your goal is to find the minimum number of adjacent swaps required to make `s1` equal to `s2`.

### Approach
1. **Breadth-First Search (BFS)**:
   - Use a queue to explore all possible strings generated by swapping adjacent characters in `s1`.
   - Keep track of the current level of swaps (or transformations) using a variable `level`.

2. **Tracking Seen States**:
   - Utilize an unordered set to keep track of the strings that have already been visited to avoid re-processing and to ensure efficiency.

3. **Generate Neighbors**:
   - For each string in the queue, generate its neighbors by swapping adjacent characters. This is done in the `next` function, which:
     - Identifies the first mismatch between `s1` and `s2`.
     - Swaps the mismatched character in `s1` with any subsequent character in `s1` that matches the target character in `s2`.
     - Returns a set of all possible valid strings resulting from these swaps.

4. **Termination Condition**:
   - If during the BFS, the string generated matches `s2`, return the current level count, indicating the number of swaps needed.
   - If the queue is exhausted without finding `s2`, return the level count (indicating no valid transformation found).

### Complexity
- **Time Complexity**: O(N!), where N is the length of the strings. This is due to the factorial growth of permutations possible with adjacent swaps.
- **Space Complexity**: O(N) for storing the visited states and the BFS queue.

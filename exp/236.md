### Problem Statement

In this problem, we are tasked with finding the **Lowest Common Ancestor (LCA)** of two nodes in a **Binary Tree**. The lowest common ancestor of two nodes is the deepest node that is an ancestor of both nodes. Given the structure of a binary tree, we need to identify and return the lowest common ancestor of two nodes, `p` and `q`. 

The binary tree nodes are represented by a `TreeNode` structure that has three members:
- `val` — the value of the node.
- `left` — pointer to the left child node.
- `right` — pointer to the right child node.

### Problem Description

Given a binary tree with nodes `p` and `q`, we need to find the **Lowest Common Ancestor**. The key observation here is that the lowest common ancestor is the first node in the tree where the paths to `p` and `q` split. The problem is a classic tree traversal problem where the goal is to identify a node that is common in both the paths from the root to `p` and from the root to `q`.

### Approach

This problem can be solved using **recursion** in a **post-order** traversal manner. The recursive approach works as follows:
1. **Base Case**: If the current node is either `NULL`, `p`, or `q`, return the current node. This is because if the node is `NULL`, we cannot find an ancestor. If the node matches either `p` or `q`, we return it since we have found one of the nodes.
   
2. **Recursive Case**:
    - Recursively search for `p` and `q` in the left subtree and the right subtree.
    - If we find `p` or `q` in both the left and right subtrees, the current node is their **Lowest Common Ancestor**.
    - If we find either `p` or `q` in one subtree, we return the node from that subtree.
    - If neither `p` nor `q` is found in a subtree, we return `NULL`.

3. **Decision Making**:
    - If both left and right recursive calls return non-`NULL` nodes, it means one node was found in the left subtree and the other in the right subtree. Therefore, the current node is the **Lowest Common Ancestor**.
    - If only one of the recursive calls returns a non-`NULL` node, then that node must be the **Lowest Common Ancestor**.

The approach is a **depth-first search (DFS)** where we explore the left and right subtrees recursively to find the lowest common ancestor.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
```
- This defines the `Solution` class with a public member function `lowestCommonAncestor`, which takes three parameters: the `root` of the tree and the two nodes `p` and `q`.

```cpp
        if(!root || root == p || root == q) return root;
```
- **Base case**: If `root` is `NULL` (i.e., we've reached the end of a path) or if the current node is either `p` or `q`, we return the `root`. This means we've either hit a leaf node or found one of the nodes we are looking for.

```cpp
        TreeNode* left = lowestCommonAncestor(root->left, p, q);
        TreeNode* right = lowestCommonAncestor(root->right, p, q);
```
- Recursively search the left and right subtrees for the nodes `p` and `q`. 
- `left` holds the result of the search in the left subtree, and `right` holds the result of the search in the right subtree.

```cpp
        return !left ? right : !right ? left : root;
```
- **Decision making**:
  - If `left` is `NULL`, it means `p` and `q` are not found in the left subtree, so return the result from the right subtree (`right`).
  - If `right` is `NULL`, it means `p` and `q` are not found in the right subtree, so return the result from the left subtree (`left`).
  - If both `left` and `right` are non-`NULL`, it means we have found `p` in the left subtree and `q` in the right subtree (or vice versa), so the current `root` is the **Lowest Common Ancestor**.

### Complexity

#### Time Complexity:
- The time complexity of this approach is **O(n)**, where `n` is the number of nodes in the binary tree. In the worst case, we may have to visit every node in the tree to find the Lowest Common Ancestor. This occurs when the tree is unbalanced or when the nodes `p` and `q` are located deep in the tree.
- In the case of a balanced tree, the algorithm still explores each node once, so the time complexity remains **O(n)** in the general case.

#### Space Complexity:
- The space complexity of the algorithm is **O(h)**, where `h` is the height of the binary tree. This is because the recursive function calls are stored on the call stack. In the worst case (unbalanced tree), the height of the tree can be equal to the number of nodes `n`, and thus the space complexity would be **O(n)**. In the best case (balanced tree), the space complexity would be **O(log n)**.

### Conclusion

This solution efficiently finds the **Lowest Common Ancestor (LCA)** of two nodes in a **Binary Tree** using a recursive depth-first search approach. The algorithm leverages the properties of a binary tree to efficiently determine where the paths from the root to the nodes `p` and `q` diverge.

#### Key Points:
- **Base Case**: If we reach `NULL`, or if the current node is `p` or `q`, we return that node.
- **Recursive Search**: We recursively search the left and right subtrees to find `p` and `q`.
- **Decision Logic**: If both subtrees contain one of the nodes, the current node is the LCA.
- **Efficient Traversal**: The algorithm only traverses each node once, making it efficient in finding the LCA.

#### Benefits:
- The algorithm is simple and intuitive, using recursion to explore the tree.
- It works well for both balanced and unbalanced binary trees.
- The space complexity is manageable, and the time complexity is linear with respect to the number of nodes in the tree, making it suitable for large trees.

This approach is highly efficient and commonly used in interviews and competitive programming to solve the problem of finding the **Lowest Common Ancestor** in a binary tree.
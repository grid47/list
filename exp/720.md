### Problem Statement

The problem asks us to find the **longest word** from a list of words that can be built by adding one character at a time to the previous word. Specifically, we want to find the longest word such that every prefix of it is also present in the list of words. A prefix is defined as the initial part of the word, which must also be a valid word in the list.

### Approach

To solve this problem efficiently, we can use a **greedy approach** combined with a **hash set** to track the valid words we've encountered. Here’s a step-by-step breakdown of how we can approach the problem:

1. **Sorting the Words**: By sorting the list of words lexicographically, we ensure that we process smaller words first. This is crucial because smaller words are potential prefixes for larger words. This step allows us to easily check if a prefix of a word is already in the set.

2. **Using a Hash Set**: We use an **unordered set (hash set)** to store the valid words that we have encountered so far. This allows us to check if a prefix exists in constant time.

3. **Checking Each Word**: For each word in the list, we check if the word can be built by adding one character at a time. This is done by checking if the word’s prefix (i.e., the substring formed by removing the last character) is already in the set of valid words. If it is, we add the current word to the set and consider it as a potential result.

4. **Choosing the Longest Word**: As we process the words, we keep track of the longest word that meets the criteria. If a new word is longer than the current result, we update the result.

### Code Breakdown (Step by Step)

Let’s now look at the code to understand the solution in more detail:

1. **Sorting the Words**:
   ```cpp
   sort(words.begin(), words.end());
   ```
   - The list of words is sorted lexicographically. This ensures that for any given word, all of its prefixes are processed before the word itself. Sorting helps in optimizing the search for prefixes in the set.

2. **Initializing the Hash Set**:
   ```cpp
   unordered_set<string> mp;
   ```
   - The unordered set `mp` is used to store all the valid words we encounter while processing the list. This set helps in checking if a prefix exists in constant time.

3. **Initializing the Result String**:
   ```cpp
   string res = "";
   ```
   - The variable `res` holds the current longest word that satisfies the condition. We initialize it as an empty string and update it as we process the list of words.

4. **Iterating Over Each Word**:
   ```cpp
   for (string w: words) {
   ```
   - We loop through each word in the sorted list of words.

5. **Checking If the Word is Valid**:
   ```cpp
   if (w.size() == 1 || mp.count(w.substr(0, w.size() - 1))) {
   ```
   - For each word, we check if it can be formed by adding one character at a time to a valid prefix. If the word has only one character, it’s automatically valid. Otherwise, we check if the prefix of the word (i.e., the word minus its last character) exists in the set `mp`.

6. **Updating the Result**:
   ```cpp
   res = w.size() > res.size() ? w : res;
   ```
   - If the current word is valid (i.e., its prefix exists in the set), we compare its length with the current result `res`. If the current word is longer than the current result, we update `res` to the current word.

7. **Adding the Word to the Set**:
   ```cpp
   mp.insert(w);
   ```
   - After processing the current word, we add it to the set `mp` so that it can be used as a prefix for subsequent words.

8. **Returning the Result**:
   ```cpp
   return res;
   ```
   - After processing all the words, we return the longest valid word found.

### Complexity Analysis

- **Time Complexity**:
  - **Sorting the words**: Sorting the list of words takes **O(n log n)**, where `n` is the number of words.
  - **Checking and inserting into the set**: For each word, we perform a constant time check and insert operation in the unordered set. The check involves substring operations, which take **O(m)** time where `m` is the length of the word. Hence, the overall time complexity is **O(n log n + n * m)**, where `n` is the number of words and `m` is the average length of the words.
  
- **Space Complexity**:
  - We use an unordered set to store the words, which takes **O(n * m)** space in the worst case, where `n` is the number of words and `m` is the average length of the words.

### Conclusion

This solution leverages a combination of sorting and hash set lookups to efficiently find the longest word that can be built from the list of words by adding one character at a time. The sorting step ensures that we process words in order, making it easy to check if each word's prefix exists. The unordered set allows for fast lookups and insertions to track valid words. This approach has a time complexity of **O(n log n + n * m)** and a space complexity of **O(n * m)**, making it efficient for large input sizes.

By using these techniques, we can solve the problem in an optimal manner. The greedy approach ensures that we always choose the longest valid word while processing each word in the sorted list. This solution is efficient and works well within the given problem constraints.
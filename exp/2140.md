### Problem Statement

The problem at hand is to maximize the total points obtained from a series of questions. Each question gives a certain number of points if answered, but there is a penalty: answering a question also prohibits the answering of subsequent questions for a specified number of indices. Specifically, each question has a point value and a "skip" value, which denotes how many subsequent questions must be skipped if that question is answered. The goal is to find the maximum number of points that can be obtained by strategically choosing which questions to answer.

### Approach

The solution utilizes a dynamic programming approach to explore the different options available at each question while maximizing the total points. The key steps involved are:

1. **State Representation**: We represent the state of our solution using an index `idx`, which tracks the current question being considered.

2. **Recursion with Memoization**: The function `dp(idx)` recursively determines the maximum points obtainable from the current index onward. To avoid recalculating results for previously computed states, we employ memoization.

3. **Decision Making**: At each index, there are two choices:
   - **Skip the Current Question**: Simply carry forward the result of the next index.
   - **Answer the Current Question**: Add the points of the current question and recursively compute the maximum points obtainable from the index after skipping the required questions.

4. **Base Case**: The recursion ends when we exceed the number of questions, at which point the function returns 0, indicating no more points can be earned.

### Code Breakdown (Step by Step)

1. **Class Definition**:
   ```cpp
   class Solution {
   public:
   ```
   - This defines the `Solution` class, encapsulating the methods to solve the problem.

2. **Data Members**:
   ```cpp
   vector<vector<int>> qns;
   vector<long long> mem;
   ```
   - `qns`: A 2D vector that holds the questions, where each entry contains the points and the skip count.
   - `mem`: A vector for memoization that stores the maximum points that can be obtained starting from each index.

3. **Dynamic Programming Function**:
   ```cpp
   long long dp(int idx) {
   ```
   - The `dp` function takes an integer index `idx` as a parameter, which indicates the current question being processed.

4. **Base Case**:
   ```cpp
   if(idx >= qns.size()) return 0;
   ```
   - If the current index exceeds the number of questions, return 0 since no points can be gained.

5. **Memoization Check**:
   ```cpp
   if(mem[idx] != -1) return mem[idx];
   ```
   - Before calculating the points for the current index, check if the result has already been computed. If it has, return the cached result.

6. **Skip the Current Question**:
   ```cpp
   long long ans = dp(idx + 1);
   ```
   - Calculate the points if the current question is skipped by recursively calling `dp` for the next index.

7. **Answer the Current Question**:
   ```cpp
   ans = max(ans, (long long) qns[idx][0] + dp(idx + 1 + qns[idx][1]));
   ```
   - Calculate the potential points if the current question is answered. The points obtained from the current question are added to the result of `dp` from the next index, skipping the required number of questions as specified by `qns[idx][1]`.

8. **Store and Return Result**:
   ```cpp
   return mem[idx] = ans;
   ```
   - Store the computed result in the `mem` vector for the current index before returning it.

9. **Main Function**:
   ```cpp
   long long mostPoints(vector<vector<int>>& questions) {
       qns = questions;
       mem.resize(qns.size(), -1);
       return dp(0);
   }
   ```
   - The `mostPoints` function initializes the questions and prepares the `mem` vector for memoization. It then calls the `dp` function starting from index 0 to compute the maximum points obtainable.

10. **End of Class**:
    ```cpp
    };
    ```
    - This closing brace signifies the end of the `Solution` class.

### Complexity Analysis

- **Time Complexity**: \(O(n)\), where \(n\) is the number of questions.
  - Each question is processed once, and the recursive calls do not revisit the same state due to memoization.

- **Space Complexity**: \(O(n)\)
  - The space complexity arises from the memoization vector `mem` and the input vector `qns`.

### Conclusion

The `mostPoints` function effectively calculates the maximum points that can be earned by answering a strategic selection of questions, considering the constraints imposed by the "skip" values. This solution is a classic example of dynamic programming, demonstrating how to optimize decision-making through recursion and memoization.

This approach can be generalized to other problems where decisions at one state affect the outcomes of future states, highlighting the power of dynamic programming in solving complex optimization problems.

By mastering the concepts illustrated in this solution, programmers can enhance their skills in tackling similar algorithmic challenges, which are common in competitive programming and technical interviews. The combination of recursion, dynamic programming, and memoization forms a foundational toolkit for solving a wide range of problems efficiently.
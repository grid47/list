### Problem Statement

The problem at hand requires us to remove the minimum number of intervals such that no intervals overlap. Given a collection of intervals where each interval is represented by a pair of integers [start, end], our goal is to find the minimum number of intervals to remove to ensure that no two intervals overlap. The intervals are provided as a 2D array, where each subarray contains the start and end time of an interval.

### Approach

To solve this problem efficiently, we can utilize a greedy algorithm approach. The idea is to always prioritize the intervals that end the earliest. By removing the intervals that overlap with others, we ensure that the remaining intervals are as non-overlapping as possible.

#### Key Observations:
1. **Sorting by End Time**: By sorting the intervals based on their end times, we are effectively selecting intervals that leave as much space as possible for subsequent intervals. This helps us minimize the number of removals.
2. **Greedy Strategy**: Once sorted, we can iterate through the intervals and check if the current interval overlaps with the previously selected interval. If there is an overlap, we increment the count of intervals to remove. If there’s no overlap, we update the previous interval to the current one.

#### Steps:
1. **Sort the intervals**: Sort the intervals by their end time.
2. **Iterate through the sorted intervals**: Start from the second interval and compare it with the first one.
3. **Check for overlap**: If the start time of the current interval is less than the end time of the previous interval, there’s an overlap. Increment the removal counter.
4. **Update the `prv` index**: If the current interval ends earlier than the previous interval, update the `prv` index to point to the current interval.

### Code Breakdown (Step by Step)

#### Step 1: Sorting the Intervals

```cpp
sort(ivl.begin(), ivl.end());
```

- We begin by sorting the intervals in increasing order of their end times. This helps in choosing the interval that finishes the earliest, ensuring that we leave room for as many intervals as possible.
- The sorting step is crucial to the greedy strategy, allowing us to compare each interval with the one that finishes before it.

#### Step 2: Initializing Variables

```cpp
int ans = 0;
int n = ivl.size();
int prv = 0;
```

- `ans` keeps track of the number of intervals we need to remove.
- `n` is the total number of intervals.
- `prv` is the index of the previously selected interval. We initialize it to 0, assuming that we start with the first interval in the sorted list.

#### Step 3: Iterating Over the Intervals

```cpp
for(int cur = 1; cur < n; cur++) {
```

- We begin iterating from the second interval (`cur = 1`), as the first interval is always considered as selected initially.

#### Step 4: Checking for Overlap

```cpp
if(ivl[cur][0] < ivl[prv][1]) {
    ans++;
    if(ivl[cur][1] <= ivl[prv][1])
        prv = cur;
}
else {
    prv = cur;
}
```

- If the start time of the current interval (`ivl[cur][0]`) is less than the end time of the previous interval (`ivl[prv][1]`), it means the intervals overlap. In this case:
  - We increment the `ans` variable, indicating that one interval needs to be removed to avoid the overlap.
  - If the current interval ends earlier than or at the same time as the previous interval, we update the `prv` index to the current interval (`cur`). This ensures that the previous interval is replaced by the one that ends earlier, allowing more room for future intervals.
- If there is no overlap (i.e., the start time of the current interval is greater than or equal to the end time of the previous interval), we update the `prv` index to point to the current interval.

#### Step 5: Return the Result

```cpp
return ans;
```

- After processing all intervals, we return the `ans` variable, which contains the minimum number of intervals to remove to make the rest non-overlapping.

### Complexity

#### Time Complexity:

- **Sorting**: The time complexity of sorting the intervals is `O(n log n)`, where `n` is the number of intervals.
- **Iterating Through Intervals**: The iteration through the intervals takes `O(n)`.
- Therefore, the overall time complexity of the solution is dominated by the sorting step, which is `O(n log n)`.

#### Space Complexity:

- The algorithm uses `O(1)` extra space, as we only store a few variables (`ans`, `n`, `prv`), and the input intervals are modified in-place.
- Therefore, the space complexity is `O(1)`.

### Conclusion

This problem is a classic example of a greedy algorithm. By sorting the intervals based on their end times, we ensure that we are selecting the maximum number of non-overlapping intervals. This approach is optimal, with a time complexity of `O(n log n)` due to the sorting step, and a space complexity of `O(1)` because we use only a constant amount of extra space. The solution is efficient and suitable for large inputs, making it a great fit for interval scheduling problems.
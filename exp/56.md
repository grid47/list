### Problem Statement

The problem at hand involves merging overlapping intervals from a collection of intervals. Each interval is represented as a pair of integers `[start, end]`, where `start` is the beginning of the interval, and `end` is the end. The task is to merge all overlapping or contiguous intervals and return a list of non-overlapping intervals.

For example, given the intervals:

```
[[1, 3], [2, 4], [5, 7], [6, 8]]
```

The intervals `[1, 3]` and `[2, 4]` overlap, so they should be merged into `[1, 4]`. Similarly, the intervals `[5, 7]` and `[6, 8]` should be merged into `[5, 8]`. The final result would be:

```
[[1, 4], [5, 8]]
```

### Approach

To solve this problem, we can take the following approach:

1. **Sort the intervals** by their start times. Sorting helps us group the overlapping intervals together and makes it easier to merge them.
2. **Iterate through the sorted intervals** and compare each interval with the last added merged interval:
   - If the current interval overlaps or is contiguous with the last merged interval, merge them by updating the end of the last interval.
   - If there is no overlap, push the current interval as a new merged interval into the result list.
3. Finally, return the list of merged intervals.

This greedy approach ensures that we merge overlapping intervals optimally.

### Code Breakdown (Step by Step)

#### Step 1: Sorting the Intervals

```cpp
sort(iv.begin(), iv.end());
```

- **Sorting:** First, we sort the input list of intervals `iv` by their starting points (`iv[i][0]`). Sorting is crucial because it helps us easily compare consecutive intervals to determine if they overlap or not. The sorting operation ensures that we process intervals in increasing order of their start times, which simplifies the merging logic.

#### Step 2: Initialization

```cpp
vector<vector<int>> ans;
vector<int> tmp = iv[0];
```

- **ans:** This vector will hold the final merged intervals.
- **tmp:** This temporary vector is initialized to the first interval `iv[0]`. It represents the current interval that we are working with to merge with subsequent intervals.

#### Step 3: Iterating Over the Intervals

```cpp
for(int i = 0; i < iv.size(); i++) {
    if(iv[i][0] <= tmp[1]) {
        tmp[1] = max(tmp[1], iv[i][1]);
    } else {
        ans.push_back(tmp);
        tmp = iv[i];
    }
}
```

- **Loop through the intervals:** We iterate over the sorted intervals.
- **If the current interval overlaps:** If the start time of the current interval (`iv[i][0]`) is less than or equal to the end time of the last merged interval (`tmp[1]`), it means the intervals overlap or are contiguous. In this case, we merge them by updating the end time of `tmp` to be the maximum of the two intervals' end times (`tmp[1] = max(tmp[1], iv[i][1])`).
- **If there is no overlap:** If the current interval does not overlap with the last merged interval, we push the current merged interval (`tmp`) into the result list `ans` and start a new merge with the current interval `iv[i]` by updating `tmp` to be `iv[i]`.

#### Step 4: Final Merge

```cpp
ans.push_back(tmp);
```

- After the loop ends, we need to push the last interval `tmp` into the result list `ans` since it would not have been added yet. This ensures that the final interval is properly included.

#### Step 5: Return the Result

```cpp
return ans;
```

- Finally, we return the list of merged intervals, which is stored in `ans`.

### Complexity

#### Time Complexity:

- **O(n log n):** The primary time-consuming operation is sorting the input intervals, which takes `O(n log n)` time, where `n` is the number of intervals. After sorting, we simply iterate over the intervals once to merge them, which takes `O(n)` time. Therefore, the overall time complexity is dominated by the sorting step, resulting in a time complexity of `O(n log n)`.

#### Space Complexity:

- **O(n):** The space complexity is `O(n)` because we store the merged intervals in the result list `ans`. In the worst case, if no intervals overlap, the result will contain `n` intervals, requiring `O(n)` space.

### Conclusion

This solution efficiently solves the problem of merging overlapping intervals using a greedy approach. By sorting the intervals and iterating through them once, we can merge overlapping or contiguous intervals in an optimal manner. The time complexity of `O(n log n)` makes this approach well-suited for handling large input sizes, and the space complexity of `O(n)` ensures that it uses memory efficiently.

The algorithm works by:
1. Sorting the intervals to facilitate easy merging.
2. Iterating through the sorted intervals to merge them as needed.
3. Storing the result in a list and returning it.

This approach ensures that we can handle all possible edge cases, such as intervals that do not overlap, intervals that are already merged, or intervals that overlap in complex ways. With its simplicity and efficiency, this solution is ideal for practical use in scenarios where interval merging is required.
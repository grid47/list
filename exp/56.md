### ğŸš€ **Merge Intervals**

The problem asks you to merge overlapping intervals from a collection of intervals. Each interval is represented as a pair of integers `[start, end]`, where `start` is the beginning of the interval, and `end` is the end. The task is to merge all overlapping or contiguous intervals and return a list of non-overlapping intervals.

For example, given the intervals:

```
[[1, 3], [2, 4], [5, 7], [6, 8]]
```

The intervals `[1, 3]` and `[2, 4]` overlap, so they should be merged into `[1, 4]`. Similarly, the intervals `[5, 7]` and `[6, 8]` should be merged into `[5, 8]`. The final result would be:

```
[[1, 4], [5, 8]]
```

### ğŸ§‘â€ğŸ’» **Approach**

To solve this problem efficiently, we use a **greedy approach**. The core steps are:

1. **Sort the intervals** by their start times. Sorting helps us group overlapping intervals together, making it easier to merge them.
2. **Iterate through the sorted intervals** and compare each interval with the last added merged interval:
   - If the current interval overlaps or is contiguous with the last merged interval, merge them by updating the end of the last interval.
   - If there is no overlap, add the current interval as a new merged interval into the result list.
3. Finally, return the list of merged intervals.

This approach ensures that we merge overlapping intervals in an optimal manner.

### ğŸ“ **Code Breakdown**

#### Step 1: Sorting the Intervals

```cpp
sort(iv.begin(), iv.end());
```

- **Sorting:** We start by sorting the input list of intervals `iv` based on their starting points (`iv[i][0]`). This helps us easily compare consecutive intervals to check if they overlap. Sorting ensures that we process intervals in increasing order of their start times, which simplifies the merging logic.

#### Step 2: Initialization

```cpp
vector<vector<int>> ans;
vector<int> tmp = iv[0];
```

- **ans:** This vector will store the final merged intervals.
- **tmp:** This temporary vector is initialized to the first interval `iv[0]` and represents the current interval being merged with subsequent intervals.

#### Step 3: Iterating Over the Intervals

```cpp
for(int i = 0; i < iv.size(); i++) {
    if(iv[i][0] <= tmp[1]) {
        tmp[1] = max(tmp[1], iv[i][1]);
    } else {
        ans.push_back(tmp);
        tmp = iv[i];
    }
}
```

- **Loop through intervals:** We iterate through the sorted intervals.
- **If the current interval overlaps:** If the start of the current interval (`iv[i][0]`) is less than or equal to the end of the last merged interval (`tmp[1]`), it means the intervals overlap or are contiguous. In this case, we merge them by updating the end time of `tmp` to the maximum of the two intervals' end times (`tmp[1] = max(tmp[1], iv[i][1])`).
- **If there is no overlap:** If the current interval does not overlap with the last merged interval, we push the current merged interval (`tmp`) into the result list `ans` and start a new merge with the current interval `iv[i]`.

#### Step 4: Final Merge

```cpp
ans.push_back(tmp);
```

- After the loop ends, we push the last interval `tmp` into the result list `ans` since it has not been added yet. This ensures that the final merged interval is included.

#### Step 5: Return the Result

```cpp
return ans;
```

- Finally, we return the list of merged intervals stored in `ans`.

### ğŸ“Š **Complexity Analysis**

#### Time Complexity:

- **O(n log n):** The most time-consuming operation is sorting the intervals, which takes `O(n log n)` time, where `n` is the number of intervals. After sorting, we iterate over the intervals once to merge them, which takes `O(n)` time. Therefore, the overall time complexity is dominated by the sorting step, resulting in **O(n log n)**.

#### Space Complexity:

- **O(n):** The space complexity is `O(n)` because we store the merged intervals in the result list `ans`. In the worst case, if no intervals overlap, the result will contain `n` intervals, requiring `O(n)` space.

### ğŸŒŸ **Conclusion**

This solution efficiently merges overlapping intervals using a **greedy approach**. By sorting the intervals and iterating through them once, we can merge overlapping or contiguous intervals in an optimal manner. The time complexity of **O(n log n)** makes this approach suitable for handling large input sizes, and the space complexity of **O(n)** ensures efficient memory usage.

The algorithm works by:
1. Sorting the intervals to make merging easier.
2. Iterating through the sorted intervals to merge them as necessary.
3. Returning the final merged intervals.

This approach guarantees that we can handle all edge cases, such as intervals that donâ€™t overlap, intervals that are already merged, or more complex overlapping scenarios. With its simplicity and efficiency, this solution is ideal for practical applications requiring interval merging.

---
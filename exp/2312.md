### Problem Statement

The problem involves selling a piece of wood of dimensions `m` x `n`, where the piece can be divided into smaller rectangular pieces. Each smaller piece of wood has a price associated with it, and our task is to maximize the total revenue by cutting the original piece into smaller pieces. The goal is to find the maximum revenue obtainable by cutting the wood into smaller pieces or selling it as is, given the prices for various dimensions.

The input consists of:
1. Two integers `m` and `n`, representing the dimensions of the wood.
2. A 2D array `prices` where each element contains three integers: the first integer is the length of the piece, the second is the width, and the third is the price for that piece.

We need to return the maximum revenue that can be obtained by cutting the wood and selling the pieces.

### Approach

To solve this problem efficiently, we can use **dynamic programming (DP)** to break down the problem into smaller subproblems. We can calculate the maximum revenue for any piece of wood of dimensions `m` x `n` by considering:
1. The revenue obtained by selling the piece without any cuts.
2. The revenue obtained by making a cut along the length (i.e., divide `m` into two parts) or along the width (i.e., divide `n` into two parts), and then recursively calculating the revenue for the resulting pieces.

The key idea is to memoize the results for subproblems to avoid redundant calculations. We use a `dp` array to store the maximum revenue for each dimension of the wood.

### Code Breakdown (Step by Step)

#### Step 1: Initialization

```cpp
vector<int> v, h;
vector<vector<int>> p;
vector<vector<long long>> mem, mp;
```

- **`v` and `h`**: These vectors are meant to store the possible lengths and widths of the pieces from the input prices. However, in the final implementation, they are not used, as the `prices` array is directly used to populate the `mp` matrix.
- **`p`**: This stores the input price information, where each element contains a length, width, and price.
- **`mem`**: This 2D vector is used to store the maximum revenue for each subproblem. It is initialized with `-1`, indicating that a value has not been calculated for that subproblem yet.
- **`mp`**: This 2D vector is used to store the price for each specific dimension of the wood.

#### Step 2: Filling the Price Matrix

```cpp
for(int i = 0; i < p.size(); i++) {
    mp[p[i][0]][p[i][1]] = p[i][2];
}
```

- Here, the `mp` matrix is populated with the prices from the input `prices` array. The `mp[i][j]` will hold the price for a piece of wood of size `i` x `j`.

#### Step 3: Dynamic Programming Recursive Function

```cpp
long long dp(int m, int n) {
    if(m <= 0 || n <= 0) return 0;

    if(mem[m][n] != -1) return mem[m][n];

    long long ans = mp[m][n];

    for(int i = 1; i <= m / 2; i++) {
        ans = max(ans, dp(m - i, n) + dp(i, n));
    }
    for(int i = 1; i <= n / 2; i++) {
        ans = max(ans, dp(m, n - i) + dp(m, i));
    }

    return mem[m][n] = ans;
}
```

- The `dp` function computes the maximum revenue for a piece of wood of size `m` x `n` by considering all possible cuts along both dimensions (length and width).
- If `m` or `n` is `0`, the value is `0` because no revenue can be obtained from a piece with zero dimensions.
- If the value for `mem[m][n]` has already been computed (i.e., it is not `-1`), it is returned directly to avoid redundant calculations.
- The `ans` variable starts with the price of the whole piece, `mp[m][n]`, and is then updated by considering cuts along the length and width.
- The function recursively calculates the maximum revenue for the remaining pieces after the cuts, and the result is stored in `mem[m][n]`.

#### Step 4: Function to Calculate Maximum Revenue

```cpp
long long sellingWood(int m, int n, vector<vector<int>>& prices) {
    p = prices;
    mem.resize(m + 1, vector<long long>(n + 1, -1));
    mp.resize(m + 1, vector<long long>(n + 1, 0));

    for(int i = 0; i < p.size(); i++) {
        mp[p[i][0]][p[i][1]] = p[i][2];
    }

    return dp(m, n);
}
```

- The `sellingWood` function sets up the `prices` array and initializes the `mem` and `mp` matrices.
- The `dp(m, n)` function is called to compute the maximum revenue for the piece of wood of size `m` x `n`.
- The final result is returned.

### Complexity

#### Time Complexity:

The time complexity of this solution is driven by the recursive nature of the `dp` function, which is memoized to avoid recomputing the same values multiple times.

- The DP function computes values for each pair of dimensions `(m, n)` up to the size `m` x `n`, resulting in a time complexity of `O(m * n)`.
- Each call to the `dp` function involves checking at most `m / 2` and `n / 2` possible cuts, so the work done for each state is proportional to `m` and `n`.
- Thus, the overall time complexity is `O(m * n)`.

#### Space Complexity:

- The space complexity is dominated by the space used to store the `mem` and `mp` matrices, both of which are of size `(m+1) x (n+1)`.
- Therefore, the space complexity is `O(m * n)`.

### Conclusion

The given solution efficiently solves the problem of maximizing the revenue from cutting and selling a piece of wood. By leveraging dynamic programming, we avoid redundant calculations by memoizing the results of subproblems. The solution handles the problem in `O(m * n)` time complexity, making it scalable even for larger inputs. This approach ensures that we consider all possible ways to cut the wood while keeping track of the maximum possible revenue, resulting in an optimal solution. The space complexity of `O(m * n)` is manageable given the constraints, and the implementation is clean and effective.
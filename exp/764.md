### Problem Statement

The problem asks us to find the order of the largest "plus sign" in an `n x n` grid, given a set of "mines" that block certain positions in the grid. A plus sign consists of a central cell with arms extending in four cardinal directions (up, down, left, right) such that all cells in the arms are connected, and the length of each arm is equal. The goal is to determine the order of the largest plus sign that can be formed in the grid, where the order is defined as the length of the arms of the plus sign.

A plus sign can only extend in the four directions as long as there are no mines in its path. The grid is filled with `1`s except where mines are located, in which case those cells are marked as `0`.

#### Example:

For `n = 5` and mines located at `[[4, 2], [3, 2], [2, 2]]`, the grid looks like:

```
1 1 1 1 1
1 1 1 1 1
1 1 0 1 1
1 1 0 1 1
1 0 0 0 1
```

We need to determine the order of the largest plus sign that can be formed. The largest plus sign in this case has order 1, as the largest arm length is 1 (from the center of the plus).

### Approach

To solve this problem, we can use dynamic programming (DP) to compute the possible arm lengths for each cell in the grid in four directions: up, down, left, and right. The key idea is that for each cell, we calculate how far we can extend in each direction without hitting a mine. The minimum value from the four directions at each cell gives the arm length, and thus, the size of the plus sign that can be formed at that cell.

#### Steps:

1. **Initialization**: Start by creating a `grid` where each cell is initialized to `n`, representing the maximum possible arm length for that cell if there are no mines. Cells that contain mines are immediately set to 0.

2. **Filling the grid**: Iterate through the grid and compute the arm lengths for each cell. This involves:
   - For each row, compute the left and right arm lengths for each cell.
   - For each column, compute the up and down arm lengths for each cell.

3. **Finding the maximum order**: After calculating the arm lengths, iterate through the grid and find the minimum arm length for each cell. The largest of these values will give the order of the largest plus sign.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the grid

```cpp
vector<vector<int>> grid(n, vector<int>(n, n));
for (auto &m: mines)
    grid[m[0]][m[1]] = 0;
```

- We start by creating a grid of size `n x n` and initializing each cell to `n` because, in the worst case (no mines), a plus sign can have an arm length of `n-1`. We then mark the positions of the mines as `0` in the grid.

#### Step 2: Compute arm lengths in all four directions

```cpp
for (int i = 0; i < n; i++)
    for (int j = 0, k = n - 1, l = 0, r = 0, u = 0, d = 0; j < n; j++, k--) {
        grid[i][j] = min(grid[i][j], l = (grid[i][j] == 0? 0: l + 1));
        grid[i][k] = min(grid[i][k], r = (grid[i][k] == 0? 0: r + 1));
        grid[j][i] = min(grid[j][i], u = (grid[j][i] == 0? 0: u + 1));
        grid[k][i] = min(grid[k][i], d = (grid[k][i] == 0? 0: d + 1));
    }
```

- The nested loop iterates over each row and column of the grid.
  - For each row, it calculates the arm lengths extending to the left (`l`) and right (`r`).
  - For each column, it calculates the arm lengths extending upwards (`u`) and downwards (`d`).
  
- For each direction, if the current cell is a mine (`grid[i][j] == 0`), we reset the corresponding arm length to `0`. Otherwise, we increment the arm length.

- The `min()` function ensures that for each cell, the arm length in any direction is limited by the shortest arm among the four directions.

#### Step 3: Compute the largest plus sign

```cpp
int res = 0;
for (int i = 0; i < n; i++)
    for (int j = 0; j < n; j++)
        res = max(grid[i][j], res);
```

- After computing the arm lengths for all cells, we simply iterate over the grid to find the maximum value. This value represents the largest arm length, which corresponds to the largest plus sign that can be formed.

#### Step 4: Return the result

```cpp
return res;
```

- Finally, we return the result, which is the order of the largest plus sign.

### Complexity

#### Time Complexity:

- The time complexity of this solution is **O(n^2)**, where `n` is the size of the grid. This is because:
  - We iterate through the grid multiple times: once to set the initial mine locations, and then twice to compute the arm lengths in all four directions for each cell.
  - Each iteration involves constant time operations, and thus, the time complexity is quadratic in terms of the grid size.

#### Space Complexity:

- The space complexity is **O(n^2)** because we are using a 2D grid to store the arm lengths for each cell. Additionally, we store the positions of the mines, which is also a 2D array.

### Conclusion

This solution efficiently computes the order of the largest plus sign that can be formed in a grid, even with the presence of mines. By using dynamic programming to compute the arm lengths in all four directions for each cell, we ensure that we calculate the correct plus sign order in an optimized manner.

- **Time Complexity**: **O(n^2)**, where `n` is the size of the grid.
- **Space Complexity**: **O(n^2)**, as we store the grid and mine locations in 2D arrays.

The approach ensures that we can handle large grids efficiently while also accounting for the positions of mines that block the formation of plus signs.
### Problem Statement

The problem asks us to convert an integer into its Roman numeral representation. Roman numerals are written by combining the following symbols:

| Symbol | Value |
|--------|-------|
| I      | 1     |
| V      | 5     |
| X      | 10    |
| L      | 50    |
| C      | 100   |
| D      | 500   |
| M      | 1000  |

For example, given the integer `3`, the Roman numeral would be "III". For the integer `58`, it would be "LVIII". The task is to implement a function `intToRoman(int num)` that converts an integer `num` into its corresponding Roman numeral.

### Approach

To solve this problem efficiently, we need to break the integer down using the largest possible Roman numeral values first, working our way down to the smallest. The main idea behind this approach is to repeatedly subtract the largest possible Roman numeral value from the number until the number becomes zero. This method leverages **greedy** principles, as we always choose the largest Roman numeral value that is less than or equal to the remaining number.

#### Key Observations:
1. **Roman numeral symbols**: There are specific combinations like "IV" (4), "IX" (9), "XL" (40), "XC" (90), "CD" (400), and "CM" (900) that are used to avoid four consecutive characters of the same type (e.g., 4 would be represented as "IV", not "IIII").
   
2. **Greedy approach**: The integer is reduced in steps by repeatedly subtracting the largest possible Roman numeral value. Once we subtract a value, we add its corresponding Roman numeral string to the result. This process is repeated until the entire number is converted.

3. **Order of symbols**: The symbols should be used in a descending order starting from the largest value (1000, 900, etc.). This ensures that we represent the number optimally.

### Code Breakdown (Step by Step)

Let's go through the code and understand each part of it.

#### Step 1: Initialize the Numerals and Symbols

```cpp
vector<int> nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };
vector<string> chrs = { "M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I" };
```

- `nums` holds the integer values corresponding to each Roman numeral (from largest to smallest).
- `chrs` holds the corresponding Roman numeral symbols for the integers in `nums`.
  
Both vectors are in descending order to facilitate the conversion process from the largest value to the smallest.

#### Step 2: Initialize the Result String and Index

```cpp
int idx = 0;
string res = "";
```

- `idx` is used to iterate over the `nums` and `chrs` vectors.
- `res` will hold the final Roman numeral representation of the given integer.

#### Step 3: Conversion Loop

```cpp
while(num > 0)
{
    while(num >= nums[idx])
    {
        num -= nums[idx];
        res += chrs[idx];
    }
    idx++;
}
```

- The outer `while` loop ensures that the process continues until `num` becomes zero.
- Inside the loop, the inner `while` loop checks if the current value (`nums[idx]`) is less than or equal to `num`. If it is, we subtract `nums[idx]` from `num` and append the corresponding Roman numeral (`chrs[idx]`) to `res`.
- The `idx++` step increments the index to move to the next lower Roman numeral value, ensuring that we consider smaller values once the current one has been fully used.

This process ensures that the number is gradually reduced while adding the correct Roman numeral symbols to the result string.

#### Step 4: Return the Result

```cpp
return res;
```

- Once `num` is reduced to zero, the result string `res` contains the correct Roman numeral representation, and we return it.

### Complexity

#### Time Complexity:
- The time complexity is **O(1)** because the maximum number of iterations in the outer loop is limited to the number of Roman numeral symbols, which is constant (13 elements). Thus, the algorithm performs a constant number of iterations for any input, making it very efficient.

#### Space Complexity:
- The space complexity is **O(1)**, as we only use a fixed amount of extra space regardless of the input size. The space required for the `nums` and `chrs` arrays is constant and does not scale with the size of the input.

### Conclusion

This approach provides an efficient way to convert an integer into a Roman numeral by following a greedy strategy. By starting with the largest Roman numeral and working our way down, we can ensure that the conversion is done optimally and in constant time.

#### Advantages:
- **Optimal Efficiency**: With a constant time complexity of O(1), this solution is extremely fast for any valid input.
- **Simple and Intuitive**: The algorithm uses a greedy approach, which is easy to understand and implement.
  
#### Limitations:
- The approach assumes the input number is within the range of valid Roman numerals (i.e., between 1 and 3999).

#### Summary:
- This solution uses a greedy algorithm that iteratively subtracts the largest Roman numeral value from the integer and appends the corresponding Roman numeral symbol. By processing the number in this way, we can convert any valid integer to its Roman numeral representation in an optimal and efficient manner. The use of two arrays (`nums` and `chrs`) ensures that the Roman numeral symbols are applied correctly in a descending order, and the algorithm is very efficient with constant time and space complexity.
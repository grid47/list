### Problem Statement

The problem is to determine the minimum number of operations required to make an array k-increasing. An array is k-increasing if for every k-th index subsequence (i.e., starting from index `i` and taking every k-th element), the subsequence is non-decreasing. The allowed operation is to remove an element from the array. Your task is to return the minimum number of elements that must be removed to achieve this condition.

### Approach

To solve this problem, we can utilize the concept of finding the Longest Increasing Subsequence (LIS) in the context of subsequences formed by every k-th element. The idea is to iterate over each possible starting index from `0` to `k-1` and for each index, create a subsequence using every k-th element. By calculating the length of the LIS for each of these subsequences, we can derive how many elements need to be removed to make each subsequence non-decreasing. The total number of elements removed will be the difference between the total number of elements and the total length of the LIS across all k-subsequences.

### Code Breakdown (Step by Step)

1. **Initialization**:
   ```cpp
   int n = arr.size(), longest = 0;
   ```
   - `n` is initialized to store the size of the input array `arr`.
   - `longest` is initialized to keep track of the total length of the longest non-decreasing subsequences we find.

2. **Iterate Over k Subsequences**:
   ```cpp
   for(int i = 0; i < k; i++) {
   ```
   - A loop runs from `0` to `k-1`, where each iteration processes a different k-th subsequence.

3. **Finding the Longest Increasing Subsequence (LIS)**:
   ```cpp
   vector<int> lis;
   for(int j = i; j < n; j += k) {
   ```
   - An empty vector `lis` is declared to store the elements of the current subsequence.
   - A nested loop starts with `j` initialized to `i` and increments by `k` in each iteration to grab every k-th element.

4. **Building the LIS**:
   ```cpp
   if(lis.empty() || lis.back() <= arr[j])
       lis.push_back(arr[j]);
   ```
   - If the `lis` vector is empty or if the last element in `lis` is less than or equal to the current element `arr[j]`, the current element is appended to `lis`. This indicates that we can extend our increasing sequence.

5. **Updating the LIS Using Binary Search**:
   ```cpp
   else *upper_bound(lis.begin(), lis.end(), arr[j]) = arr[j];
   ```
   - If the current element does not extend the sequence, the code uses `upper_bound` to find the first element in `lis` that is greater than `arr[j]` and replaces it with `arr[j]`. This effectively maintains the smallest possible elements in `lis`, which helps in future extensions of the subsequence.

6. **Accumulate the Length of the LIS**:
   ```cpp
   longest += lis.size();
   ```
   - After processing all elements for the current k-th subsequence, the size of `lis` is added to `longest`, indicating the total length of the longest non-decreasing subsequences found so far.

7. **Return the Result**:
   ```cpp
   return n - longest;
   ```
   - Finally, the function returns the difference between the total number of elements in `arr` and `longest`, which represents the minimum number of removals required to make the array k-increasing.

### Complexity Analysis

- **Time Complexity**: \(O(n \log n)\)
  - The outer loop runs `k` times, and the inner loop processes each element in `arr`. The use of `upper_bound` (which takes \(O(\log n)\) time) within the inner loop contributes to the overall complexity.

- **Space Complexity**: \(O(n)\)
  - The space complexity is primarily due to the `lis` vector used for each k-th subsequence. The maximum size of `lis` can be \(O(n)\) in the worst case.

### Conclusion

The provided solution efficiently calculates the minimum number of removals required to transform an array into a k-increasing sequence using the concept of Longest Increasing Subsequences. By segmenting the array into k-th subsequences and utilizing binary search for updates, the solution achieves optimal time complexity while maintaining clarity and conciseness. This approach ensures that all edge cases are handled effectively, making it a robust solution for the given problem.
### Problem Statement:
The problem asks us to calculate a new grid where each element at position `(i, j)` is the result of a mathematical operation involving the sum of ones and zeros in the corresponding row and column of the original grid. Specifically, for each element, the value should be the result of the formula:

\[ \text{result}(i, j) = 2 \times (\text{number of ones in row } i) + 2 \times (\text{number of ones in column } j) - m - n \]

Where:
- `m` is the number of rows in the grid.
- `n` is the number of columns in the grid.
- The grid consists of ones and zeros.

The task is to compute this new grid for a given input `grid`.

### Approach:
The problem can be solved in an efficient manner by breaking the task into two steps:
1. **Precompute row and column sums**:
   - The first step is to calculate the number of ones in each row and each column. This can be done using two arrays: one to store the sum of ones for each row and another for each column.
   - This will help in reducing the redundant computations for each element of the new grid.

2. **Construct the result grid**:
   - For each element in the grid, the result can be computed by using the precomputed row and column sums. This way, we avoid counting the ones in the row and column repeatedly for every element of the grid.

### Code Breakdown (Step by Step):
Let’s break down the code and explain each part in detail:

```cpp
class Solution {
public:
    vector<vector<int>> onesMinusZeros(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size();
        vector<int> row(m), col(n);
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++) {
                row[i] += grid[i][j];
                col[j] += grid[i][j];
            }
```

1. **Initialization**:
   - The function `onesMinusZeros` takes the input `grid`, which is a 2D vector of integers representing a grid of zeros and ones.
   - `m` stores the number of rows in the grid (`grid.size()`), and `n` stores the number of columns in the grid (`grid[0].size()`).
   - Two vectors, `row` and `col`, are initialized to store the count of ones in each row and column, respectively. These vectors are of size `m` and `n`, initialized with zeros.

2. **Precomputing Row and Column Sums**:
   - The two nested loops iterate over each element of the grid. For each element `grid[i][j]`, the value is added to the corresponding row and column count:
     - `row[i] += grid[i][j]` increments the count of ones in the `i`-th row.
     - `col[j] += grid[i][j]` increments the count of ones in the `j`-th column.
   - This step ensures that after the loops, `row[i]` contains the total number of ones in row `i`, and `col[j]` contains the total number of ones in column `j`.

```cpp
        vector<vector<int>> g(m, vector<int>(n, 0));
        for(int i = 0; i < m; i++)
            for(int j = 0; j < n; j++) {
                g[i][j] = 2 * row[i] + 2 * col[j] - m - n;
            }
        return g;
    }
};
```

3. **Constructing the Result Grid**:
   - A new grid `g` is created to store the result. This grid has the same dimensions as the input grid (`m` rows and `n` columns). Initially, all elements of `g` are set to 0.
   - The nested loops again iterate through each element `g[i][j]` of the result grid.
   - For each element, the formula `g[i][j] = 2 * row[i] + 2 * col[j] - m - n` is applied:
     - `2 * row[i]` is twice the number of ones in the `i`-th row.
     - `2 * col[j]` is twice the number of ones in the `j`-th column.
     - Subtracting `m` and `n` adjusts the value as per the problem's requirements.

4. **Return the Result**:
   - After filling in the entire result grid `g`, it is returned as the final output.

### Complexity:
Let’s analyze the time and space complexity of the solution:

- **Time Complexity**:
   - The first loop that computes the row and column sums takes \(O(m \times n)\), where `m` is the number of rows and `n` is the number of columns. This is because we are iterating over every element in the grid once to compute the row and column sums.
   - The second loop that constructs the result grid also takes \(O(m \times n)\) as we are iterating over every element of the grid once to apply the formula.
   - Therefore, the overall time complexity is \(O(m \times n)\).

- **Space Complexity**:
   - The space complexity is \(O(m + n)\) due to the two auxiliary vectors `row` and `col` that store the counts of ones in each row and column, respectively.
   - The result grid `g` takes \(O(m \times n)\) space, which dominates the overall space complexity.
   - Hence, the overall space complexity is \(O(m \times n)\).

### Conclusion:
The solution efficiently computes the new grid by first precomputing the number of ones in each row and column. This reduces redundant calculations and allows us to compute the result in a second pass through the grid. The time complexity of \(O(m \times n)\) and space complexity of \(O(m \times n)\) ensure that the solution scales well with large grids. This approach is optimal for problems of this nature where we need to compute values based on row and column aggregates, and it avoids recalculating these sums multiple times, ensuring efficient performance.
### 🚀 Problem Statement

You're asked to design a data structure that supports two main operations:

1. **addNum(num)** - Adds a number to the data structure.
2. **findMedian()** - Returns the median of all numbers added so far:
   - If there’s an odd number of elements, the median is the middle element.
   - If there’s an even number of elements, the median is the average of the two middle elements.

For example:
- **Input:** `addNum(1), addNum(2), findMedian() → 1.5`
- **Input:** `addNum(3), findMedian() → 2`

Ready to dive in? Let's go!

---

### 🧠 Approach: The Two-Heap Trick

To solve this efficiently, we use a **two-heap approach**. We’ll maintain two heaps (or priority queues) to handle two groups of numbers:
- A **max-heap** for the smaller half of the numbers.
- A **min-heap** for the larger half of the numbers.

The strategy is simple:
1. The **max-heap** stores the smaller half, using negative values to simulate a max-heap in a min-heap structure.
2. The **min-heap** stores the larger half.

With this setup:
- If the number of elements is odd, the median is the top of the max-heap.
- If the number of elements is even, the median is the average of the tops of both heaps.

---

### 🔨 Step-by-Step Code Breakdown

#### Step 1: Setting Up Our Heaps
```cpp
priority_queue<long> sm;
priority_queue<long, vector<long>, greater<long>> lg;
```
- `sm` is a max-heap that will store the smaller half of the numbers.
- `lg` is a min-heap that will store the larger half.

#### Step 2: Adding a Number with `addNum(num)`
```cpp
void addNum(int num) {
    sm.push((long) num);
    lg.push((long) sm.top());
    sm.pop();
    if(sm.size() < lg.size()) {
        sm.push(lg.top());
        lg.pop();
    }
}
```
1. First, add the number to `sm` (our max-heap).
2. Then move the top of `sm` (the largest of the smaller half) to `lg` (our min-heap).
3. If the size of `lg` exceeds `sm`, balance it by moving the top of `lg` back to `sm`.

This setup keeps our heaps balanced and ensures that the size difference between them never exceeds 1.

#### Step 3: Retrieving the Median with `findMedian`
```cpp
double findMedian() {       
    return lg.size() < sm.size() ? sm.top() : (double)(lg.top() + sm.top()) / 2;
}
```
- If `sm` has more elements, the median is `sm.top()`.
- If both heaps have the same number of elements, the median is the average of `sm.top()` and `lg.top()`.

---

### 📈 Complexity Analysis

#### Time Complexity:
- **addNum(num):** Each insertion involves a heap operation, which is **O(log n)**.
  
- **findMedian():** Retrieving the median is **O(1)** since it only requires looking at the tops of the heaps.

#### Space Complexity:
- The space complexity is **O(n)**, where `n` is the number of elements added to the data structure.

---

### 🏁 Conclusion

This solution offers an efficient way to dynamically calculate the median by splitting the data into two heaps:
- **Max-heap** for the smaller half.
- **Min-heap** for the larger half.

With this approach:
- **Efficient insertions:** Adding a number takes **O(log n)** time.
- **Quick median retrieval:** Finding the median takes only **O(1)** time.
- **Optimal memory usage:** We use **O(n)** space, which is perfect for handling large data streams.

This two-heap approach is not just efficient but also elegant, giving you quick access to the median without sorting or reordering the entire dataset. Keep going—you're building some seriously cool data structure skills! 🌟
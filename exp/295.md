### ðŸš€ Problem Statement

You're asked to design a data structure that supports two main operations:

1. **addNum(num)** - Adds a number to the data structure.
2. **findMedian()** - Returns the median of all numbers added so far:
   - If thereâ€™s an odd number of elements, the median is the middle element.
   - If thereâ€™s an even number of elements, the median is the average of the two middle elements.

For example:
- **Input:** `addNum(1), addNum(2), findMedian() â†’ 1.5`
- **Input:** `addNum(3), findMedian() â†’ 2`

Ready to dive in? Let's go!

---

### ðŸ§  Approach: The Two-Heap Trick

To solve this efficiently, we use a **two-heap approach**. Weâ€™ll maintain two heaps (or priority queues) to handle two groups of numbers:
- A **max-heap** for the smaller half of the numbers.
- A **min-heap** for the larger half of the numbers.

The strategy is simple:
1. The **max-heap** stores the smaller half, using negative values to simulate a max-heap in a min-heap structure.
2. The **min-heap** stores the larger half.

With this setup:
- If the number of elements is odd, the median is the top of the max-heap.
- If the number of elements is even, the median is the average of the tops of both heaps.

---

### ðŸ”¨ Step-by-Step Code Breakdown

#### Step 1: Setting Up Our Heaps
```cpp
priority_queue<long> sm;
priority_queue<long, vector<long>, greater<long>> lg;
```
- `sm` is a max-heap that will store the smaller half of the numbers.
- `lg` is a min-heap that will store the larger half.

#### Step 2: Adding a Number with `addNum(num)`
```cpp
void addNum(int num) {
    sm.push((long) num);
    lg.push((long) sm.top());
    sm.pop();
    if(sm.size() < lg.size()) {
        sm.push(lg.top());
        lg.pop();
    }
}
```
1. First, add the number to `sm` (our max-heap).
2. Then move the top of `sm` (the largest of the smaller half) to `lg` (our min-heap).
3. If the size of `lg` exceeds `sm`, balance it by moving the top of `lg` back to `sm`.

This setup keeps our heaps balanced and ensures that the size difference between them never exceeds 1.

#### Step 3: Retrieving the Median with `findMedian`
```cpp
double findMedian() {       
    return lg.size() < sm.size() ? sm.top() : (double)(lg.top() + sm.top()) / 2;
}
```
- If `sm` has more elements, the median is `sm.top()`.
- If both heaps have the same number of elements, the median is the average of `sm.top()` and `lg.top()`.

---

### ðŸ“ˆ Complexity Analysis

#### Time Complexity:
- **addNum(num):** Each insertion involves a heap operation, which is **O(log n)**.
  
- **findMedian():** Retrieving the median is **O(1)** since it only requires looking at the tops of the heaps.

#### Space Complexity:
- The space complexity is **O(n)**, where `n` is the number of elements added to the data structure.

---

### ðŸ Conclusion

This solution offers an efficient way to dynamically calculate the median by splitting the data into two heaps:
- **Max-heap** for the smaller half.
- **Min-heap** for the larger half.

With this approach:
- **Efficient insertions:** Adding a number takes **O(log n)** time.
- **Quick median retrieval:** Finding the median takes only **O(1)** time.
- **Optimal memory usage:** We use **O(n)** space, which is perfect for handling large data streams.

This two-heap approach is not just efficient but also elegant, giving you quick access to the median without sorting or reordering the entire dataset. Keep goingâ€”you're building some seriously cool data structure skills! ðŸŒŸ
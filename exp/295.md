### Problem Statement

The problem asks you to design a data structure that supports the following two operations:

1. **addNum(num)** - Adds a number `num` to the data structure.
2. **findMedian()** - Returns the median of all the numbers added so far. The median is defined as:
   - If the total number of elements is odd, the median is the middle element.
   - If the total number of elements is even, the median is the average of the two middle elements.

### Approach

To solve this problem efficiently, we can use a **two-heap approach**. This approach leverages two heaps (priority queues) to maintain two groups of numbers:
- A **max-heap** to store the smaller half of the numbers.
- A **min-heap** to store the larger half of the numbers.

By maintaining this split, the median can be found in constant time, and inserting a new number can be done efficiently.

The basic idea is:
1. The **max-heap** (`sm`) stores the smaller half of the numbers (we use a max-heap by storing negative values to simulate max behavior in a min-heap).
2. The **min-heap** (`lg`) stores the larger half of the numbers.

After every insertion:
- The smaller half of the numbers is stored in the max-heap (`sm`).
- The larger half is stored in the min-heap (`lg`).
- The heaps are kept balanced such that the size difference between the two heaps is at most 1.

By balancing the heaps:
- If the number of elements is odd, the median is the top of the max-heap (`sm`).
- If the number of elements is even, the median is the average of the top elements of both heaps.

This allows us to calculate the median in constant time, while insertion is handled in logarithmic time.

### Code Breakdown (Step by Step)

#### Step 1: Class Initialization
```cpp
priority_queue<long> sm;
priority_queue<long, vector<long>, greater<long>> lg;
```
- `sm` is a max-heap, which will store the smaller half of the numbers.
- `lg` is a min-heap, which will store the larger half of the numbers.

#### Step 2: Constructor
```cpp
MedianFinder() {
    
}
```
- The constructor initializes the two heaps (`sm` and `lg`), which will be used to manage the data and allow efficient median retrieval.

#### Step 3: Adding a Number (`addNum`)
```cpp
void addNum(int num) {
    sm.push((long) num);
    lg.push((long) sm.top());
    sm.pop();
    if(sm.size() < lg.size()) {
        sm.push(lg.top());
        lg.pop();
    }
}
```
- The number `num` is first added to the max-heap (`sm`).
- The top of the max-heap (the largest of the smaller half) is then moved to the min-heap (`lg`).
- If the size of the min-heap exceeds the size of the max-heap, the top of the min-heap (the smallest of the larger half) is moved back to the max-heap to restore balance.
- The size of the two heaps is kept balanced, ensuring that:
  - The max-heap has either the same number of elements as the min-heap or one more element than the min-heap.

#### Step 4: Finding the Median (`findMedian`)
```cpp
double findMedian() {       
    return lg.size() < sm.size()? sm.top(): (double)(lg.top() + sm.top()) / 2;
}
```
- If the number of elements in the max-heap is greater than the number of elements in the min-heap (i.e., the total number of elements is odd), the median is the top element of the max-heap (`sm.top()`).
- If the sizes of both heaps are equal (i.e., the total number of elements is even), the median is the average of the tops of both heaps (`(lg.top() + sm.top()) / 2`).

### Complexity

#### Time Complexity:
- **addNum(num):** 
  - Inserting an element into a heap takes **O(log n)** time, where `n` is the number of elements currently in the data structure.
  - Therefore, the time complexity for adding a number is **O(log n)**.
  
- **findMedian():** 
  - Retrieving the top element of a heap is an **O(1)** operation.
  - Therefore, the time complexity for finding the median is **O(1)**.

#### Space Complexity:
- The space complexity is **O(n)**, where `n` is the number of elements in the data structure, because we are storing the elements in two heaps.

### Conclusion

This solution provides an efficient way to compute the median of a dynamic stream of numbers using the **two-heap approach**. By splitting the data into two heaps:
1. The **max-heap** stores the smaller half of the numbers.
2. The **min-heap** stores the larger half of the numbers.

The median can be computed in constant time once the heaps are properly balanced.

**Key Advantages:**
- **Efficient insertions:** Each insertion takes **O(log n)** time due to the heap operations.
- **Fast median retrieval:** The median can be obtained in **O(1)** time by simply looking at the tops of the heaps.
- **Balanced memory usage:** The space complexity is **O(n)**, where `n` is the number of elements added to the data structure, which is optimal for this problem.

This approach ensures that the solution is scalable and efficient, making it well-suited for real-time applications or large datasets where the median needs to be dynamically computed as new numbers are added.
### Problem Statement

The problem is to count the number of **islands** in a given 2D grid. The grid consists of '1's (land) and '0's (water). An island is formed by connecting adjacent lands (horizontally or vertically). You are asked to return the number of distinct islands in the grid.

**Problem Input:**
- A 2D grid represented by a vector of vectors of characters:
  ```cpp
  vector<vector<char>> grid;
  ```
  where each element is either '1' (land) or '0' (water).

**Problem Output:**
- An integer that represents the number of islands in the grid.

For example:
- **Input:**
  ```cpp
  grid = [
      ['1', '1', '1', '1', '0'],
      ['1', '1', '0', '1', '0'],
      ['1', '1', '0', '0', '0'],
      ['0', '0', '0', '0', '0']
  ]
  ```
- **Output:** `1`  
  Explanation: The grid contains one island.

### Approach

To solve the problem, we can use a **Depth-First Search (DFS)** approach. DFS is a natural fit because it allows us to explore an island from any '1' cell, marking all connected '1's as visited as we traverse. By performing DFS for every unvisited '1', we effectively count each distinct island.

#### Steps:
1. **Iterate through the grid:** We start by iterating over each cell in the grid. If we encounter a '1', it means we have found a new island.
  
2. **DFS Traversal:** Once we find a '1', we initiate a DFS search starting from that cell. During the DFS, we explore all connected land cells (i.e., all '1's connected horizontally or vertically). As we explore, we mark each visited land cell as '0' to avoid revisiting it.

3. **Count Islands:** Each time we start a DFS search, it corresponds to discovering a new island. We increment the island count.

4. **Return the result:** After iterating through the entire grid, the island count will reflect the number of distinct islands in the grid.

### Code Breakdown (Step by Step)

#### Step 1: Initialize and Traverse the Grid
```cpp
int numIslands(vector<vector<char>>& grid) {
    int cnt = 0;
    int m = grid.size(), n = grid[0].size();
```
- `cnt` is used to keep track of the number of islands.
- `m` and `n` store the number of rows and columns in the grid, respectively.

#### Step 2: Iterate Over Each Cell in the Grid
```cpp
    for(int i = 0; i < m; i++)
        for(int j = 0; j < n; j++)
            if(grid[i][j] == '1') {
                cnt++;
                dfs(grid, i, j);
            }
```
- We use two nested loops to iterate through each cell in the grid.
- If a cell contains '1', we increment the island count (`cnt`) and initiate a DFS search from that cell to mark all connected land as visited.

#### Step 3: DFS Function
```cpp
    void dfs(vector<vector<char>> &grid, int i, int j) {
        if(i < 0 || j < 0 || i == grid.size() || j == grid[0].size() || grid[i][j] == '0')
            return ;
        grid[i][j] = '0';
        dfs(grid, i + 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i - 1, j);
        dfs(grid, i, j - 1);
    }
```
- The DFS function is designed to explore the land cells that are connected to the starting point.
- **Base Case:** If the current cell is out of bounds or contains water ('0'), we return.
- **Mark as Visited:** Once we visit a land cell, we mark it as water ('0') to prevent revisiting it.
- **Recursion:** We then recursively explore the neighboring cells (down, right, up, and left).

#### Step 4: Return the Number of Islands
```cpp
    return cnt;
}
```
- After the grid has been fully processed, we return the number of islands found (`cnt`).

### Complexity

#### Time Complexity:
- **O(m * n):** In the worst case, the algorithm visits each cell in the grid once. Each DFS call processes a single land cell and marks it as visited. Since we visit every cell exactly once, the time complexity is O(m * n), where `m` is the number of rows and `n` is the number of columns in the grid.

#### Space Complexity:
- **O(m * n):** The space complexity is mainly determined by the recursion stack in DFS. In the worst case, we may need to recurse through all the cells in the grid. Therefore, the space complexity is O(m * n). This could be improved to O(min(m, n)) if we use an iterative DFS or BFS approach instead of recursion.

### Conclusion

This solution effectively counts the number of distinct islands in a 2D grid using a DFS approach. Here's a summary of the approach and its efficiency:

1. **DFS Traversal:** The DFS explores all connected '1's (land) starting from any unvisited '1', marking them as visited by changing them to '0'. This ensures we count each island only once.
2. **Efficiency:** The solution runs in O(m * n) time and uses O(m * n) space due to the recursion stack.
3. **Space Optimization:** The recursive DFS could be optimized to an iterative approach, but the current recursive solution is simple and efficient for most practical cases.

Overall, this solution provides a clear and optimal method for counting islands in a grid, making it well-suited for handling large grids effectively.
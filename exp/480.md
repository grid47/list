### Problem Statement

The task is to find the median of each sliding window of size `k` as it moves from left to right across a given integer array `nums`. A sliding window of size `k` means we consider only `k` consecutive elements in `nums` at each position, and for each window, we calculate the median. The median for an odd-sized window is the middle element, while for an even-sized window, it’s the average of the two middle elements. The goal is to efficiently calculate these medians as the window slides one element to the right in each step, until it reaches the end of `nums`.

### Approach

To solve this problem, we utilize a data structure that allows us to efficiently maintain a sorted window and access the middle elements required to compute the median. Here, a `multiset` is chosen for its ability to store duplicate values and provide log-time insertion and deletion, which is crucial for managing the dynamic nature of the sliding window.

The approach consists of several key steps:

1. **Initialize the Multiset and Median Iterator**:
   - First, we populate the multiset `win` with the first `k` elements of `nums`, representing the initial window.
   - We then set an iterator, `mid`, to the middle of this sorted window (`k/2` elements from the start) to facilitate median calculation.

2. **Slide the Window and Calculate Medians**:
   - For each step as the window slides right, we calculate the median based on whether `k` is even or odd.
   - For odd `k`, the median is the value at the `mid` iterator, while for even `k`, it’s the average of the two central elements (the element pointed to by `mid` and the previous one).

3. **Update the Multiset**:
   - After calculating the median for the current window, we slide the window by adding the next element in `nums` and removing the leftmost element of the previous window.
   - We adjust the `mid` iterator after each insertion and deletion:
     - If the inserted element is less than the current median, `mid` is adjusted to ensure it still points to the middle of the window.
     - If the removed element is less than or equal to the current median, `mid` is adjusted to maintain the correct position.

4. **Return the Result**:
   - We continue sliding the window across `nums` and computing medians until the window reaches the end of the array.
   - Finally, we return the list of medians for each window.

### Code Breakdown (Step by Step)

Here’s a breakdown of the code and how each part contributes to solving the problem:

1. **Initialize the Sliding Window**:
   ```cpp
   multiset<int> win(nums.begin(), nums.begin() + k);
   auto mid = next(win.begin(), k/2);
   vector<double> ans;
   ```
   This initializes the `multiset` with the first `k` elements and sets an iterator `mid` to the middle of the window (`k/2` from the start). The `ans` vector will store the medians for each window.

2. **Loop to Slide the Window**:
   ```cpp
   for(int i = k; ; i++) {
       double med = ((double)*mid + (double)*prev(mid, 1 - k%2)) / 2;
       ans.push_back(med);
   ```
   The loop starts from the `k`-th element, representing the next position after the initial window. For each window:
   - The median is calculated based on the value at `mid`. If `k` is even, we also take `prev(mid, 1 - k % 2)` to get the other central element.
   - This median is added to the `ans` vector.

3. **Break Condition**:
   ```cpp
   if(i == nums.size()) return ans;
   ```
   We exit the loop and return `ans` when the sliding window has reached the end of the array.

4. **Insert New Element and Adjust `mid`**:
   ```cpp
   win.insert(nums[i]);
   if(nums[i] < *mid)
       mid--;
   ```
   After calculating the median, we insert the next element in `nums` into the `multiset`. If the new element is less than the current median, `mid` is decremented to keep it pointing to the middle.

5. **Remove the Old Element and Adjust `mid`**:
   ```cpp
   if(nums[i - k] <= *mid)
       mid++;
   win.erase(win.lower_bound(nums[i - k]));
   ```
   The leftmost element of the previous window is removed. If this removed element was less than or equal to the current median, `mid` is incremented to retain its position at the middle of the updated window.

6. **Return the Answer**:
   ```cpp
   return ans;
   ```
   Once all medians have been calculated, `ans` is returned as the result.

### Complexity

#### Time Complexity:
The time complexity of this solution is **O(n log k)**, where `n` is the length of `nums` and `k` is the size of the window. Each insertion and deletion in the `multiset` takes O(log k) time, and since we perform these operations `n - k + 1` times, the complexity is `O(n log k)`.

#### Space Complexity:
The space complexity is **O(k)**, as we store only `k` elements in the `multiset` at any time, plus a few additional variables for storing iterators and results.

### Conclusion

This solution provides an efficient and elegant way to find the median of each sliding window in a large array. By leveraging a balanced data structure (`multiset`) with an iterator to the middle element, we can dynamically maintain the sorted window and compute medians in logarithmic time. This approach is particularly suitable for scenarios where the window size `k` is significantly smaller than the length of `nums`, providing a well-balanced solution to the sliding window median problem.
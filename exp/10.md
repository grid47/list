### Problem Statement

The problem at hand is to implement a regular expression matching function that matches a string `s` against a pattern `p`. The pattern `p` may contain:
1. **`.`**: which matches any single character.
2. **`*`**: which matches zero or more of the preceding element.

You need to determine if the string `s` matches the pattern `p` using these rules.

For example:
- `isMatch("aa", "a*")` → `true` (because `a*` can match the string "aa").
- `isMatch("mississippi", "mis*is*p*.")` → `false`.

### Approach

To solve this problem, we can utilize **Dynamic Programming (DP)**. The basic idea is to recursively explore each character of the string `s` and the pattern `p`. We'll use memoization to avoid recomputation and improve efficiency.

Here's a breakdown of the approach:

1. **Recursive Matching**:
   - We start from the beginning of both `s` and `p` and recursively check for matches.
   - If the current pattern character is `*`, it could either match zero occurrences of the preceding character or one or more occurrences, which means we need to handle both cases.
   - If the pattern character is `.`, it can match any single character of `s`.

2. **Memoization**:
   - To avoid recalculating the same subproblem multiple times, we'll store the result of each recursive call in a 2D memoization table `memo[i][j]`. Here, `i` represents the current index of `s` and `j` represents the current index of `p`.
   - If a subproblem has already been computed, we simply return the stored result.

### Code Breakdown (Step by Step)

#### 1. `isMatch` Function

```cpp
bool isMatch(string s, string p) {
    this->s = s;
    this->p = p;
    
    memo.resize(s.size() + 1, vector<int>(p.size() + 1, -1));
    return dp(0, 0);
}
```

- This is the main function that sets up the initial values for the string `s` and pattern `p`. It also initializes the memoization table `memo` with dimensions `(s.size() + 1) x (p.size() + 1)` to store intermediate results.
- The `dp(0, 0)` call starts the recursive matching process from the beginning of both the string and the pattern.

#### 2. `dp` Function

```cpp
bool dp(int i, int j) {
    if(i == s.size() && j == p.size()) return true;
    if(j == p.size()) return false;
```

- The base cases:
  - If both `i` and `j` have reached the end of `s` and `p` respectively, it means we've successfully matched the entire string to the pattern, so return `true`.
  - If we've reached the end of the pattern (`j == p.size()`) but the string `s` has not been fully traversed, return `false`.

```cpp
    if(memo[i][j] != -1) return memo[i][j];
```

- If the result for this specific subproblem (`i`, `j`) has already been computed, return the stored result to avoid recomputation.

#### 3. Matching Logic for `*` and `.`
```cpp
    int ans = 0;
    if(j + 1 < p.size() && p[j + 1] == '*') {
        if(i < s.size() && (s[i] == p[j] || p[j] == '.'))
            ans |= dp(i+1, j);
        ans |= dp(i, j + 2);
    } else {
        if(i < s.size() && (s[i] == p[j] || p[j] == '.'))
            ans |= dp(i+1, j + 1);
    }
```

- **If the next character in the pattern is `*`**: The `*` can either:
  1. Match **zero occurrences** of the preceding character, so we recursively check the match starting from `i` and `j + 2` (skipping the `*` and its preceding character).
  2. Match **one or more occurrences** of the preceding character, so we check if `s[i]` matches `p[j]` (or `p[j]` is a `.`) and then continue matching from `i + 1` and `j`.

- **If the next character in the pattern is not `*`**: We simply check if `s[i]` matches `p[j]`, or if `p[j]` is a `.` (which can match any character), and then proceed recursively with `i + 1` and `j + 1`.

#### 4. Storing the Result

```cpp
    return memo[i][j] = ans;
}
```

- After exploring all possible matching conditions for the current pair `(i, j)`, store the result (`ans`) in the memoization table to avoid redundant calculations.

### Complexity

#### Time Complexity:

- **O(m * n)**: The time complexity is proportional to the product of the lengths of `s` and `p` because we explore each pair of indices `(i, j)` exactly once, where `m` is the length of `s` and `n` is the length of `p`.

#### Space Complexity:

- **O(m * n)**: The space complexity is dominated by the size of the memoization table, which has dimensions `(m + 1) x (n + 1)`.

### Conclusion

The solution employs a dynamic programming approach with memoization to efficiently solve the problem of regular expression matching. By breaking down the problem into smaller subproblems and storing the results of these subproblems, we avoid redundant calculations and improve the algorithm's efficiency.

- **Handling of Special Characters**: The `*` and `.` characters are handled carefully, ensuring that they match appropriately, either by matching multiple occurrences (`*`) or by matching any single character (`.`).
- **Efficiency**: The use of memoization ensures that the time complexity remains manageable even for larger strings and patterns, with an overall complexity of O(m * n), where `m` and `n` are the lengths of the string and the pattern, respectively.

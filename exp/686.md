### Problem Statement:
The problem at hand is to determine how many times a string `a` must be repeated to make it contain string `b` as a substring. If it is not possible for `b` to appear in the repeated version of `a`, the function should return `-1`. This type of problem is common when dealing with string matching and repeated patterns.

Given two strings `a` and `b`, the objective is to find the minimum number of times string `a` needs to be repeated such that string `b` becomes a substring of the repeated string.

### Approach:
To solve the problem, we must check if the string `b` can be formed by repeating string `a`. The basic idea is to simulate the repeating process of string `a` and check if `b` can be matched within the repeated string.

We will take a brute force approach where we:
1. Iterate over each possible starting position of `b` within the repeated `a`.
2. For each possible position, compare the characters of `a` with `b` while considering the wrapping effect due to repetition.
3. Return the number of repetitions of `a` required for `b` to become a substring.

### Key Observations:
- The idea is to iterate through the string `a` in a circular manner (as it repeats).
- We try to align string `b` starting from each index in `a` and check if the entire string `b` can be formed by wrapping around and repeating `a`.
- If at any point string `b` is completely matched, we calculate how many repetitions of `a` are required and return that number.
- If no valid alignment is found, we return `-1`.

### Code Breakdown (Step by Step):

#### Step 1: Iterate over Each Character of `a`
```cpp
for(int i = 0, j = 0; i < a.size(); i++) {
```
- We use two indices: `i` to iterate over each character in `a` and `j` to compare the corresponding characters of `a` and `b`. The outer loop tries starting at each index in `a` as a potential starting point for `b`.

#### Step 2: Compare Characters of `a` and `b` in Circular Fashion
```cpp
for(j = 0; j < b.size() && a[(i + j) % a.size()] == b[j]; j++);
```
- This inner loop compares characters of `a` and `b` character by character. Since `a` repeats, we use the modulo operation `(i + j) % a.size()` to simulate the circular nature of string `a`.
- If `a[(i + j) % a.size()] == b[j]` holds true, we continue comparing the next characters.
- The loop continues until all characters of `b` are matched, or the characters in `a` and `b` do not match.

#### Step 3: Check if Entire `b` is Matched
```cpp
if(j == b.size())
    return (j + i - 1)/ a.size() + 1;
```
- If the inner loop completes successfully (i.e., `j == b.size()`), it means we have matched all characters of `b` with the corresponding characters in the repeated string `a`.
- The formula `(j + i - 1)/ a.size() + 1` calculates how many repetitions of `a` are needed to cover the substring `b`. Here, `i` is the starting index in `a`, and `j` is the total number of characters matched.

#### Step 4: Return -1 if No Match is Found
```cpp
return -1;
```
- If no valid starting index in `a` leads to a match of `b`, we return `-1`, indicating that `b` cannot be formed by repeating `a`.

### Complexity:

#### Time Complexity:
- **O(n * m)**, where `n` is the length of string `a` and `m` is the length of string `b`. In the worst case, we need to check each possible starting point in `a` and compare up to `m` characters of `b` at each step.
- The time complexity arises from the nested loops where the outer loop runs `n` times and the inner loop runs at most `m` times.

#### Space Complexity:
- **O(1)**. The algorithm uses a constant amount of extra space since we only use a few integer variables (`i` and `j`) for indexing and comparison. No additional space is required for storing the strings or intermediate results.

### Conclusion:
This solution efficiently solves the problem of finding how many times a string `a` must be repeated to contain string `b` as a substring. It uses a brute force approach with a circular comparison of characters to simulate the repeated nature of string `a`. The time complexity is linear with respect to the product of the lengths of `a` and `b`, making it feasible for moderately sized strings.

The use of modulo operations ensures that the comparison respects the repetition of string `a` without explicitly constructing the repeated string, which is both memory-efficient and easy to understand. The solution works for edge cases such as when `b` is already a substring of `a` or when `b` cannot be formed even with multiple repetitions of `a`.
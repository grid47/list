### Problem Statement

In this problem, we are tasked with sorting an array of integers that contains only the values 0, 1, and 2. This is often referred to as the **Dutch National Flag problem**, where we need to rearrange the array so that all the 0s come first, followed by all the 1s, and then all the 2s, all in a single pass through the array. The challenge is to do this sorting without using extra space (i.e., sorting in-place) and with a time complexity of O(n).

### Approach

To solve this problem efficiently, we can use a three-pointer technique, which is ideal for problems where we need to partition an array into three categories. The idea is to maintain three pointers that will help us separate the array into three sections: one for 0s, one for 1s, and one for 2s.

We use the following pointers:
1. `i` (beginning of the array) – This pointer will track where the next `0` should be placed.
2. `j` (end of the array) – This pointer will track where the next `2` should be placed.
3. `k` (current element) – This pointer will iterate through the array, examining each element one by one.

The basic idea is to use these pointers to swap elements into their correct positions as we encounter them. The key observation is that as we move through the array:
- If we encounter a `0`, we swap it to the beginning of the array (`i` pointer).
- If we encounter a `2`, we swap it to the end of the array (`j` pointer).
- If we encounter a `1`, it is already in the correct position, so we move on.

The algorithm works efficiently by ensuring that each element is visited only once, and no additional space is used. The array is sorted in one pass through the list.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Pointers
```cpp
int n = nums.size();
int i = 0, j = n - 1;
```
- We first get the size of the array, `n`, and initialize two pointers, `i` and `j`. The pointer `i` is set to 0 (the beginning of the array), and `j` is set to `n - 1` (the end of the array).
- The pointer `k` is implicitly handled by the for loop, which will iterate over the array.

#### Step 2: Iterating through the Array
```cpp
for(int k = 0; k < n; k++) {
```
- We use a for loop to iterate over the entire array. The index `k` will be used to inspect each element one by one.

#### Step 3: Handling the Case for `2`
```cpp
while(nums[k] == 2 && k < j) {
    swap(nums[k], nums[j--]);
}
```
- When we encounter a `2`, we swap it with the element at the `j` pointer, which points to the last unprocessed element. After the swap, we decrement the `j` pointer to move it towards the left, ensuring the elements are partitioned correctly.
- This process repeats until we no longer encounter a `2` or the `k` pointer crosses `j`.

#### Step 4: Handling the Case for `0`
```cpp
while(nums[k] == 0 && k > i) {
    swap(nums[k], nums[i++]);
}
```
- When we encounter a `0`, we swap it with the element at the `i` pointer, which points to the first unprocessed element. After the swap, we increment the `i` pointer to move it towards the right, ensuring that all 0s are moved to the beginning of the array.
- This process repeats until we no longer encounter a `0` or the `k` pointer crosses `i`.

#### Step 5: Loop Continuation and Finalization
- The loop continues for all the elements in the array, effectively sorting the array in-place by swapping `0`s and `2`s into their correct positions while leaving `1`s in their place.

### Complexity

#### Time Complexity:
- **O(n)**: The algorithm iterates through the array once using the `k` pointer. Each element is processed once, either being swapped to the front or the back, and there are no nested loops. Thus, the time complexity is linear in terms of the number of elements in the array, which is O(n), where `n` is the size of the input array.

#### Space Complexity:
- **O(1)**: The algorithm only uses a constant amount of extra space for the pointers (`i`, `j`, and `k`). No additional arrays or data structures are used. Therefore, the space complexity is O(1), meaning it sorts the array in place.

### Conclusion

This solution leverages the three-pointer technique to solve the **Dutch National Flag problem** efficiently. By using the pointers `i`, `j`, and `k`, we are able to sort the array in-place with a time complexity of **O(n)** and a space complexity of **O(1)**. The approach is optimal, as it avoids the need for extra space and ensures that the entire array is processed in a single pass.

This solution is ideal for problems where we need to sort an array with only a few distinct values (in this case, 0, 1, and 2). The use of a single loop and constant space makes the algorithm not only time-efficient but also space-efficient, making it highly suitable for large datasets or situations with limited memory resources.
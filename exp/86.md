### Problem Statement

Given a singly linked list and an integer `x`, the task is to partition the list such that all nodes with values less than `x` appear before nodes with values greater than or equal to `x`. The relative order of the nodes in each partition should remain the same as in the original list. The goal is to return the head of the new list after performing the partitioning.

### Approach

To solve this problem efficiently, we can use a two-pointer approach by maintaining two separate linked lists:
1. One list will contain all nodes with values less than `x`.
2. The other list will contain all nodes with values greater than or equal to `x`.

At the end of the partitioning process, we will merge the two lists into one. This approach ensures that the order of nodes in both partitions is maintained as required.

### Code Breakdown (Step by Step)

#### Step 1: Define the ListNode Structure

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};
```

- The `ListNode` structure represents a node in the singly linked list.
- It has two fields:
  - `val`: stores the value of the node.
  - `next`: a pointer to the next node in the list.
- There are three constructors:
  - The default constructor initializes `val` to 0 and `next` to `nullptr`.
  - The second constructor initializes `val` to the given value and sets `next` to `nullptr`.
  - The third constructor initializes both `val` and `next` with the given arguments.

#### Step 2: Create New Lists to Partition the Original List

```cpp
ListNode* p1 = new ListNode(0);
ListNode* p2 = new ListNode(0);
ListNode* ans = p1, *r = p2;
```

- Two new dummy nodes `p1` and `p2` are created. These dummy nodes are used to build two separate lists:
  - `p1`: Will store nodes with values less than `x`.
  - `p2`: Will store nodes with values greater than or equal to `x`.
- `ans` is a pointer to `p1` (to return the result later).
- `r` is a pointer to `p2`, which will be used to connect the second partition list to the first.

#### Step 3: Traverse the Input List and Partition the Nodes

```cpp
while(head) {
    if(head->val < x) {
        p1->next = new ListNode(head->val);
        p1 = p1->next;
    } else {
        p2->next = new ListNode(head->val);
        p2 = p2->next;
    }
    head = head->next;
}
```

- We iterate through the input list, starting from the `head`.
- For each node:
  - If the node's value is less than `x`, it is added to the list represented by `p1` (nodes with values less than `x`).
  - If the node's value is greater than or equal to `x`, it is added to the list represented by `p2` (nodes with values greater than or equal to `x`).
- After adding the node, the corresponding pointer (`p1` or `p2`) is moved to the next node in that list.

#### Step 4: Merge the Two Lists

```cpp
p1->next = r->next;
```

- After traversing all the nodes in the input list, the `p1` list (containing nodes less than `x`) is connected to the `p2` list (containing nodes greater than or equal to `x`).
- This is done by linking `p1->next` to `r->next`, which points to the head of the `p2` list.

#### Step 5: Return the New Head of the Partitioned List

```cpp
return ans->next;
```

- The merged list is stored starting from `ans->next`, because `ans` is a dummy node. We return `ans->next` as the head of the partitioned list, which now satisfies the required condition where nodes with values less than `x` appear before nodes with values greater than or equal to `x`.

### Complexity

#### Time Complexity:
- **O(n)**, where `n` is the number of nodes in the linked list.
  - We traverse the entire list once to partition it into two separate lists.
  - Then, we merge the two lists by modifying the `next` pointers, which is a constant-time operation.
  - Thus, the total time complexity is linear with respect to the number of nodes.

#### Space Complexity:
- **O(n)**, where `n` is the number of nodes in the linked list.
  - We create two new lists (one for nodes less than `x` and one for nodes greater than or equal to `x`).
  - Each new node requires additional space, so the space complexity is proportional to the number of nodes in the input list.

### Conclusion

The provided solution efficiently solves the problem of partitioning a singly linked list around a given value `x`. By maintaining two separate linked lists for nodes with values less than `x` and greater than or equal to `x`, we are able to achieve the required partitioning while maintaining the relative order of nodes in each partition. This approach runs in linear time (`O(n)`) and uses linear space (`O(n)`), making it an optimal solution for this problem.

Key takeaways:
- The algorithm efficiently partitions the linked list into two parts.
- The order of nodes is maintained within each partition.
- A dummy node is used to simplify the process of building the new partitioned list.
- The solution works in linear time and space, which is optimal for this type of problem.
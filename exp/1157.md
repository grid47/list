
### Problem Statement
The `MajorityChecker` class is created to support efficient majority element queries in a fixed integer array. A majority element in this context is defined as an element that appears at least a certain number of times (given by a threshold) within a specified subrange. The primary goal of the class is to quickly determine if there exists such a majority element within any arbitrary subrange `[left, right]` of the array and return it. If no element meets the threshold, the function should return -1.

The `MajorityChecker` class is initialized as follows:
```cpp
MajorityChecker(vector<int>& arr);
```
and has a method to query the majority element:
```cpp
int query(int left, int right, int threshold);
```
where `left` and `right` define the bounds of the subarray, and `threshold` is the minimum number of times an element must appear to be considered the majority.

### Approach
The approach used here combines hash mapping, binary search, and randomization. Here's a breakdown of the methods and logic:

1. **Hash Mapping with Indices Tracking**:
   - The constructor stores the array elements in `arr` and initializes a hash map, `mp`, which stores indices of each element in the array. This way, for any element, we can access the indices where it appears, allowing for efficient range counting using binary search.

2. **Binary Search for Frequency Count**:
   - The function `frq` calculates the frequency of a specified number within a range `[l, r]`. It uses `lower_bound` and `upper_bound` to locate the indices within the given range and quickly count the occurrences of the number.

3. **Randomized Selection for Majority Candidate**:
   - To find the majority element, the code samples random indices within `[left, right]` up to 20 times, ensuring that if a majority element exists, itâ€™s likely to be picked and checked within these samples. By picking random indices and verifying the threshold using the `frq` function, this approach avoids the inefficiency of a brute-force search.
   
4. **Returning Majority Element**:
   - If an element in the sample meets the required threshold, it is returned as the majority element. If no sampled element meets the threshold, -1 is returned, indicating the absence of a majority.

### Code Breakdown (Step by Step)
The code is divided into methods and setup as follows:

```cpp
class MajorityChecker {
public:
    vector<int> arr;
    unordered_map<int, vector<int>> mp;
    MajorityChecker(vector<int>& arr) {
        this->arr = arr;
        for(int i = 0; i < arr.size(); i++)
            mp[arr[i]].push_back(i);
    }
```
- **Lines 3-9**: The constructor `MajorityChecker` initializes the `arr` vector with the given array and builds a hash map `mp`. Each unique element in `arr` is mapped to a vector containing all of its indices, making it easy to locate occurrences within specific subranges.

```cpp
    int frq(int num, int l, int r) {
        if(!mp.count(num)) return 0;
        auto it = lower_bound(mp[num].begin(), mp[num].end(), l);
        if(it == mp[num].end()) return 0;
        auto it2 = upper_bound(mp[num].begin(), mp[num].end(), r);
        return it2 - it;
    }
```
- **Lines 10-15**: The `frq` function takes a number `num` and calculates how many times it appears between indices `l` and `r`. It first checks if the number exists in `mp`; if not, it returns 0. Using `lower_bound` and `upper_bound`, it locates the range of indices that fall within `[l, r]` and returns the count.

```cpp
    int idx(int l, int r) {
        return rand() % (r - l + 1) + l;
    }
```
- **Lines 16-18**: The helper function `idx` generates a random index within `[l, r]`, enabling the main query function to randomly sample elements in the range.

```cpp
    int query(int left, int right, int thq) {

        for(int i = 0; i < 20; i++) {
            int num = arr[idx(left, right)];
            if(frq(num, left, right) >= thq)
                return num;
        }

        return -1;
    }
};
```
- **Lines 19-27**: The `query` function performs the majority element search within the range `[left, right]` with the specified `threshold` `thq`. It attempts up to 20 random samples from the range. For each sampled element, the code checks its frequency using `frq`, and if it meets or exceeds `thq`, the element is returned. If no sampled element meets the threshold, the function returns -1.

### Complexity
- **Time Complexity**:
  - Constructor `MajorityChecker`: \(O(N)\), where \(N\) is the length of `arr`. Each element and its index are stored in `mp`.
  - `frq` function: \(O(\log N)\) for each frequency check due to binary search on the pre-sorted list of indices.
  - `query` function: The time complexity depends on the number of samples (20), with each frequency check taking \(O(\log N)\). This makes the average complexity of `query` approximately \(O(20 \cdot \log N) = O(\log N)\).

- **Space Complexity**:
  - The hash map `mp` stores up to \(N\) indices, resulting in \(O(N)\) space usage. Other auxiliary space includes only a few integer variables, making it efficient in terms of space.

### Conclusion
The `MajorityChecker` class provides a robust solution for majority element queries in a subarray. Utilizing a hash map for indexing, binary search for fast frequency calculation, and random sampling for optimized majority detection, this approach is both time-efficient and memory-efficient. The randomized sampling, while theoretically probabilistic, ensures that any majority element is highly likely to be found within 20 samples, keeping query times low.

The combination of efficient data structures (hash map and binary search) and the probabilistic method makes this approach suitable for real-time, large-scale applications where fast majority queries are essential.
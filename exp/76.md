### üè∑Ô∏è **Minimum Window Substring**

Given two strings `s` and `t`, the task is to find the **minimum window** in string `s` which contains **all the characters of string `t`**. The string `t` can have duplicate characters, and the window should include all occurrences of characters in `t`. The goal is to return the minimum length substring of `s` that contains all the characters from `t`.

If no such window exists, we return an empty string.

#### Example:
- **Input:** s = "ADOBECODEBANC", t = "ABC"
- **Output:** "BANC"

---

### üß† **Approach**

To solve this problem efficiently, we can use the **sliding window** technique combined with **character frequency counting**. Here's a step-by-step breakdown:

1. **Character Frequency Map for `t`:** Build a frequency map for the characters in string `t`, which helps us track how many occurrences of each character are needed.

2. **Sliding Window:** Use two pointers, `i` (left) and `j` (right), to represent the current window in string `s`. The right pointer expands the window, and once we have a valid window, the left pointer contracts it.

3. **Valid Window Check:** Maintain a count of how many characters from `t` are present in the current window. When the window contains all characters from `t`, try to shrink the window from the left to find the minimum size.

4. **Tracking the Minimum Window:** As we iterate through string `s`, keep track of the smallest valid window that contains all characters from `t`.

5. **Edge Case:** If no valid window is found, return an empty string.

---

### üìù **Code Breakdown**

#### Step 1: Initialize the Character Frequency Map
```cpp
map<char, int> mp;
for(char x: t) mp[x]++;
```
- We build a map `mp` to store the frequency of characters in string `t`. This helps to check if all required characters are present in the current window.

#### Step 2: Initialize Variables
```cpp
int cnt = t.size();
int lo, len = s.size() + 1;
int i = 0;
```
- `cnt` tracks how many characters from `t` are still required in the current window.
- `lo` will store the starting index of the minimum valid window.
- `len` holds the length of the smallest valid window found, initialized to a value larger than the maximum possible window length.
- `i` is the left pointer for the sliding window.

#### Step 3: Iterate Through String `s` with the Right Pointer (`j`)
```cpp
for(int j = 0; j < s.size(); j++) {
    if(mp.count(s[j])) {
        mp[s[j]]--;
        if(mp[s[j]] >= 0) cnt--;
    }
}
```
- For each character `s[j]`, if it is in `t` (i.e., `mp.count(s[j])`), decrement its frequency in `mp`. If the frequency is still non-negative, reduce `cnt` to track how many required characters are still missing.

#### Step 4: Shrink the Window When It Is Valid
```cpp
while(cnt == 0 && i <= j) {
    if(len > j - i + 1) {
        lo = i;
        len = j - i + 1;
    }
    if(mp.count(s[i])) {
        mp[s[i]]++;
        if(mp[s[i]] >= 1) cnt++;
    }
    i++;
}
```
- When `cnt` becomes 0, the current window contains all characters from `t`. We then try to shrink the window by moving the left pointer `i`.
- If the current window is smaller than the previous minimum window, update `lo` and `len` accordingly.
- Move the left pointer `i` and update `cnt` and `mp`.

#### Step 5: Return the Result
```cpp
return len == (s.size() + 1)? "" : s.substr(lo, len);
```
- After the loop, if no valid window was found (`len` is still `s.size() + 1`), return an empty string. Otherwise, return the substring of `s` starting at index `lo` with length `len`, representing the minimum window containing all characters from `t`.

---

### üßÆ **Complexity Analysis**

#### Time Complexity:
- **O(n + m):** The algorithm iterates through string `s` once with the right pointer `j`, performing constant-time operations for each character. The left pointer `i` moves at most `n` times, so the overall time complexity is **O(n + m)**, where `n` is the length of string `s` and `m` is the length of string `t`.

#### Space Complexity:
- **O(m):** The space complexity is **O(m)** due to the map used to store the frequency of characters in `t`. Since there are at most `m` distinct characters in `t`, the space used by the map is proportional to the size of `t`.

---

### üéØ **Conclusion**

This solution leverages the **sliding window technique** to efficiently find the minimum window substring. By maintaining a frequency map and adjusting the window size using two pointers (`i` and `j`), we can solve the problem in **O(n + m)** time and **O(m)** space, making it optimal for large inputs.

This approach works well for problems where we need to find substrings or subarrays that meet certain conditions, and it is particularly effective when the string `t` contains duplicate characters.

---

### ‚ú® **Key Takeaways**
- **Sliding window** with two pointers is an efficient way to solve substring-related problems.
- Using a **frequency map** helps track required characters in the current window.
- The algorithm runs in **O(n + m)** time and **O(m)** space, making it ideal for large strings.

---
### Problem Statement

In this problem, we are given two strings `s` and `t`, and the task is to find the **minimum window** in string `s` which contains **all the characters of string `t`**. The string `t` can have duplicate characters, and the window should include all occurrences of characters in `t`. The goal is to return the minimum length substring of `s` that contains all the characters from `t`.

If no such window exists, we return an empty string.

For example:
- **Input:** s = "ADOBECODEBANC", t = "ABC"
- **Output:** "BANC"

### Approach

To solve this problem efficiently, we can use the **sliding window** technique combined with **character frequency counting**. The idea is to expand the window by moving the right pointer and contract the window from the left when a valid window is found, all the while ensuring that the window contains all characters from `t`.

Here's the approach in detail:
1. **Character Frequency Map for `t`:** We first build a frequency map for the characters in string `t`, which tells us how many times each character appears in `t`. This helps in checking if all characters in `t` are present in the current window.
  
2. **Sliding Window:** We use two pointers, `i` (left) and `j` (right), that represent the current window in string `s`. The right pointer expands the window by moving to the right, while the left pointer contracts the window once we have a valid window (i.e., when the window contains all characters of `t`).

3. **Character Count and Valid Window:** We maintain a count of how many characters from `t` are present in the current window. Once we have all the characters from `t` in the current window, we try to minimize the window size by moving the left pointer `i` to the right.

4. **Tracking the Minimum Window:** As we go through the string, we keep track of the smallest valid window that contains all characters from `t`.

5. **Edge Case:** If no valid window is found, we return an empty string.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the Character Frequency Map
```cpp
map<char, int> mp;
for(char x: t) mp[x]++;
```
- First, we initialize a map `mp` to store the frequency of characters in string `t`. This will help us know how many of each character are required for a valid window.

#### Step 2: Initialize Variables
```cpp
int cnt = t.size();
int lo, len = s.size() + 1;
int i = 0;
```
- `cnt` keeps track of how many characters from `t` we still need in the current window. Initially, it is equal to the length of `t` because we need all characters in `t` to form a valid window.
- `lo` will store the starting index of the minimum valid window.
- `len` stores the length of the smallest valid window found so far. Initially, it is set to a value larger than the maximum possible length of the window (`s.size() + 1`).
- `i` is the left pointer of the sliding window.

#### Step 3: Iterate Through String `s` with the Right Pointer (`j`)
```cpp
for(int j = 0; j < s.size(); j++) {
    if(mp.count(s[j])) {
        mp[s[j]]--;
        if(mp[s[j]] >= 0) cnt--;
    }
```
- We iterate through the string `s` with the right pointer `j`.
- For each character `s[j]`, if it's present in `t` (i.e., `mp.count(s[j])` is true), we decrement the frequency of that character in the map `mp`. If the character's frequency is still non-negative (i.e., we have not used more characters than required), we decrement `cnt` because we have one more character from `t` in the window.

#### Step 4: Shrink the Window When It Is Valid
```cpp
while(cnt == 0 && i <= j) {
    if(len > j - i + 1) {
        lo = i;
        len = j - i + 1;
    }
    if(mp.count(s[i])) {
        mp[s[i]]++;
        if(mp[s[i]] >= 1) cnt++;
    }
    i++;                
}
```
- Once `cnt` becomes 0, it means the current window contains all characters of `t` (and possibly more). We then try to minimize the window by moving the left pointer `i` to the right.
- Inside the `while` loop, we check if the current window size is smaller than the previously recorded smallest window. If so, we update `lo` and `len` to reflect the new minimum window.
- After checking the window, we move the left pointer `i` to the right and update the map and `cnt` accordingly.

#### Step 5: Return the Result
```cpp
return len == (s.size() + 1)? "" : s.substr(lo, len);
```
- After the loop ends, if no valid window was found (`len` is still `s.size() + 1`), we return an empty string. Otherwise, we return the substring of `s` starting at index `lo` with length `len`, which represents the minimum window containing all characters from `t`.

### Complexity

#### Time Complexity:
- **O(n + m):** Here, `n` is the length of string `s` and `m` is the length of string `t`. We iterate through the string `s` once with the right pointer `j`, and for each character, we perform constant-time operations (checking the map, updating the count, etc.). The while loop moves the left pointer `i` at most `n` times, so the total time complexity is O(n + m), where `n` is the length of `s` and `m` is the length of `t`.

#### Space Complexity:
- **O(m):** We use a map to store the frequency of characters in `t`. Since there are at most `m` distinct characters in `t`, the space complexity is O(m), where `m` is the length of `t`.

### Conclusion

This solution efficiently solves the minimum window substring problem using the sliding window technique. By maintaining a frequency map for string `t` and using two pointers (`i` and `j`), we can track the valid windows and shrink them when necessary, all in linear time relative to the size of string `s`. The algorithm is optimal in terms of both time and space, with a time complexity of **O(n + m)** and a space complexity of **O(m)**, where `n` is the size of string `s` and `m` is the size of string `t`.
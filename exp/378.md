### Problem Statement

In this problem, we are tasked with finding the **kth smallest element** in a **sorted 2D matrix**. The matrix `mtx` is sorted both row-wise and column-wise, meaning that:
- Each row is sorted in ascending order.
- Each column is sorted in ascending order.

Given a value `k`, we need to return the **kth smallest element** in the entire matrix.

### Approach

This problem can be efficiently solved using a **min-heap** (priority queue), leveraging the fact that each row and column is sorted. By pushing the smallest element from the matrix into the heap, and continuously replacing it with the next smallest element in the matrix, we can track the smallest elements in ascending order.

#### Key Insights:
1. **Min-Heap (Priority Queue)**:
   - The heap will allow us to efficiently retrieve and remove the smallest element.
   - Each entry in the heap will be a tuple consisting of the element value, its row, and column indices.
   
2. **Efficient Traversal**:
   - We start by pushing the first element of each row into the heap. Since each row is sorted, the smallest element in the entire matrix will be at the top of the heap.
   - After extracting the smallest element, we push the next element from the same row into the heap (if it exists). This ensures that the heap always contains the next potential smallest element.

3. **Heap Size**:
   - The heap will always store at most `k` elements. This ensures that the solution works efficiently even for large matrices.

### Code Breakdown (Step by Step)

#### Step 1: Define the Solution Class and Method
```cpp
class Solution {
public:
    int kthSmallest(vector<vector<int>>& mtx, int k) {
        int m = mtx.size(), n = mtx[0].size();
```
- We define a class `Solution` with the method `kthSmallest`, which takes a 2D matrix `mtx` and an integer `k`.
- We determine the number of rows (`m`) and columns (`n`) in the matrix.

#### Step 2: Initialize Min-Heap (Priority Queue)
```cpp
priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;
```
- We create a **min-heap** using a priority queue. This will allow us to efficiently extract the smallest element.
- The elements of the heap are vectors of size 3, where:
  - The first element is the value from the matrix.
  - The second element is the row index.
  - The third element is the column index.
  
#### Step 3: Push First Element from Each Row
```cpp
for(int r = 0; r < min(m, k); r++)
    pq.push({mtx[r][0], r, 0});
```
- We loop through the rows of the matrix, and for each row, we push the first element (`mtx[r][0]`) into the heap, along with the row index `r` and the column index `0` (the first element in each row).
- We only need to push the first `k` rows into the heap because we only care about finding the smallest elements up to the `kth` one.

#### Step 4: Extract Elements from the Heap
```cpp
vector<int> cur;
while(k-- > 1 && !pq.empty()) {
    cur = pq.top();
    pq.pop();
```
- We continue extracting the smallest element from the heap (`pq.top()`) and store it in `cur`. The heap will always store the smallest element at the top.
- After extracting the smallest element, we decrement `k` since we have found one more smallest element.
  
#### Step 5: Push the Next Element in the Row into the Heap
```cpp
if(cur[2] + 1 < n)
    pq.push({mtx[cur[1]][cur[2] + 1], cur[1], cur[2] + 1});
```
- After extracting an element, we check if there is another element in the same row (i.e., if `cur[2] + 1 < n`).
- If there is, we push the next element from the same row into the heap. This ensures that we are always considering the next smallest element from the matrix in the heap.

#### Step 6: Return the kth Smallest Element
```cpp
cur = pq.top();
return cur[0];
```
- Once we have extracted `k-1` smallest elements, the next element at the top of the heap (`pq.top()`) will be the `kth` smallest element in the matrix.
- We return the value of the `kth` smallest element, which is stored in `cur[0]`.

### Complexity

#### Time Complexity:
- **O(k log m)**, where `k` is the number of elements we need to extract and `m` is the number of rows in the matrix.
  - We perform `k` extractions from the heap, and for each extraction, we may need to push a new element from the matrix into the heap. Since there are at most `m` rows, the heap size will be at most `m`.
  - Each heap operation (insertion and extraction) takes **O(log m)** time.
  - Thus, the time complexity is **O(k log m)**.

#### Space Complexity:
- **O(m)**, where `m` is the number of rows in the matrix.
  - The heap stores at most `m` elements at any given time. Therefore, the space complexity is dominated by the size of the heap, which is **O(m)**.

### Conclusion

This solution efficiently finds the `kth` smallest element in a sorted 2D matrix using a **min-heap**. By leveraging the properties of the matrix (sorted rows and columns), we ensure that we only store the necessary elements in the heap at any given time, making the solution both time and space efficient.

Key highlights:
- **Optimal time complexity**: The algorithm runs in **O(k log m)** time, which is efficient for large matrices where `k` is much smaller than the total number of elements.
- **Space efficiency**: The space complexity is **O(m)** due to the size of the heap.
- **Correct handling of sorted matrix**: By iterating through the rows and ensuring that we always push the next element in the row into the heap, the algorithm efficiently tracks the smallest elements in the matrix.

In conclusion, this approach is well-suited for large matrices and ensures that we can find the `kth` smallest element quickly.
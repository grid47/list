### 🚀 Problem Statement

In this problem, we're tasked with finding the **kth smallest element** in a **sorted 2D matrix**. The matrix is sorted both row-wise and column-wise, meaning:
- Each row is sorted in ascending order.
- Each column is also sorted in ascending order.

Given the matrix and a number `k`, we need to return the **kth smallest element** from the entire matrix.

For example, consider the matrix:
```
[[1, 5, 9],
 [10, 11, 13],
 [12, 13, 15]]
```
If `k = 8`, the 8th smallest element is `13`.

---

### 🧠 Approach

To solve this problem efficiently, we’ll use a **min-heap** (priority queue). The key here is to take advantage of the matrix's sorted properties. By pushing the smallest elements into the heap and extracting them one by one, we can track the smallest elements in ascending order.

#### Key Insights:
1. **Min-Heap (Priority Queue)**:
   - The heap allows us to efficiently extract the smallest element.
   - Each heap entry is a tuple: the element value, the row index, and the column index.
   
2. **Efficient Traversal**:
   - We begin by pushing the first element of each row into the heap. Since each row is sorted, the smallest element in the matrix will always be at the top of the heap.
   - After extracting the smallest element, we push the next element from the same row into the heap. This ensures the heap always holds the next smallest element.

3. **Heap Size**:
   - The heap will store at most `k` elements at any time, ensuring that the algorithm remains efficient.

---

### 🔨 Step-by-Step Code Breakdown

#### Step 1: Define the Solution Class and Method
```cpp
class Solution {
public:
    int kthSmallest(vector<vector<int>>& mtx, int k) {
        int m = mtx.size(), n = mtx[0].size();
```
- We define a `Solution` class with a method `kthSmallest` that takes the matrix `mtx` and the integer `k`.
- We first get the number of rows (`m`) and columns (`n`) of the matrix.

#### Step 2: Initialize Min-Heap (Priority Queue)
```cpp
priority_queue<vector<int>, vector<vector<int>>, greater<>> pq;
```
- We initialize a **min-heap** using a priority queue. The heap will store vectors containing:
  - The element value.
  - The row index.
  - The column index.

#### Step 3: Push First Element from Each Row
```cpp
for(int r = 0; r < min(m, k); r++)
    pq.push({mtx[r][0], r, 0});
```
- We push the first element of each row into the heap, along with its row and column indices. This step ensures that the heap will initially hold the smallest elements from each row.

#### Step 4: Extract Elements from the Heap
```cpp
vector<int> cur;
while(k-- > 1 && !pq.empty()) {
    cur = pq.top();
    pq.pop();
```
- We begin extracting the smallest element from the heap (`pq.top()`), storing it in `cur`. Each extraction brings us one step closer to finding the `kth` smallest element.
- After each extraction, we decrement `k`.

#### Step 5: Push the Next Element in the Row into the Heap
```cpp
if(cur[2] + 1 < n)
    pq.push({mtx[cur[1]][cur[2] + 1], cur[1], cur[2] + 1});
```
- After extracting an element, we check if there’s another element in the same row (i.e., `cur[2] + 1 < n`). If so, we push the next element from that row into the heap.

#### Step 6: Return the kth Smallest Element
```cpp
cur = pq.top();
return cur[0];
```
- Once we’ve extracted `k-1` smallest elements, the next element at the top of the heap (`pq.top()`) will be the `kth` smallest element in the matrix.
- We return the value of `cur[0]` as the result.

---

### 📈 Complexity Analysis

#### Time Complexity
- **O(k log m)**, where `k` is the number of elements to extract and `m` is the number of rows in the matrix.
  - We perform `k` extractions from the heap, and for each extraction, we may push a new element into the heap.
  - The heap can hold at most `m` elements at any time, and each heap operation (insertion and extraction) takes **O(log m)** time.
  - Thus, the time complexity is **O(k log m)**.

#### Space Complexity
- **O(m)**, where `m` is the number of rows in the matrix.
  - The heap stores at most `m` elements at any given time, so the space complexity is **O(m)**.

---

### 🏁 Conclusion

This solution efficiently finds the `kth` smallest element in a sorted 2D matrix using a **min-heap**. By pushing and extracting elements from the heap, we ensure that we always have access to the next smallest element in the matrix, and by maintaining a heap of size `m`, we make sure the solution is both time and space efficient.

#### Quick Recap:
- **Time Complexity**: O(k log m)
- **Space Complexity**: O(m)
- **Efficient solution using min-heap**
- **Great for large matrices with sorted rows and columns!**

This approach is perfect for large matrices, ensuring that we can efficiently find the `kth` smallest element without having to search the entire matrix. Keep up the great work, and happy coding! 💻✨
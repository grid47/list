### 🚀 Problem Statement

Given two sorted integer arrays, `nums1` and `nums2`, and an integer `k`, we need to find the `k` smallest pairs `(x, y)` where `x` is from `nums1` and `y` is from `nums2`. The pairs should be returned in ascending order of their sum. 

For example:
- Input: `nums1 = [1,7,11]`, `nums2 = [2,4,6]`, `k = 3`
- Output: `[[1,2],[1,4],[1,6]]`

If there are fewer than `k` pairs, return all the possible pairs.

---

### 🧠 Approach

To solve this problem efficiently, we use a **Min-Heap** (priority queue) to extract the smallest pairs dynamically. Here's how:

1. **Min-Heap**: Since we need to find the smallest elements in a sorted order, the Min-Heap helps us do that efficiently by always giving us the pair with the smallest sum.
   
2. **Iterative Pairing**: We begin by pushing the smallest pair (`nums1[i]` paired with `nums2[0]`) into the heap. As we pop pairs from the heap, we push the next possible pair formed by the current element from `nums1` and the next element in `nums2`. This ensures that pairs with smaller sums are processed first.

3. **Efficient Pair Management**: Since `nums1` and `nums2` are already sorted, pairing the smallest elements first gives us a clear path to finding the smallest sums in ascending order.

4. **Optimization**: To ensure we don't generate more pairs than needed, we keep the heap size limited to `k`, which allows us to efficiently compute the smallest `k` pairs without any unnecessary operations.

---

### 🔨 Step-by-Step Code Breakdown

Here's a detailed breakdown of the code:

#### 1. **Initial Setup**

```cpp
vector<vector<int>> ans;
int n1 = nums1.size(), n2 = nums2.size();
priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
```

- `ans`: This stores the result (the smallest pairs).
- `n1` and `n2`: The sizes of `nums1` and `nums2`.
- `pq`: A Min-Heap (priority queue) to store the pairs in the order of their sum.

#### 2. **Push the First `k` Pairs**

```cpp
for(int i = 0; i < n1 && i < k; i++) {
    pq.push({nums1[i] + nums2[0], nums1[i], nums2[0], 0});
}
```

- We loop through the elements of `nums1` and push pairs of the form `(nums1[i], nums2[0])` into the heap. This ensures that the heap is initialized with the smallest element from `nums1` paired with the smallest element from `nums2`.

Each entry in the heap is a vector of four integers:
1. The sum of the pair (`nums1[i] + nums2[0]`).
2. The current element from `nums1` (`nums1[i]`).
3. The current element from `nums2` (`nums2[0]`).
4. The index in `nums2` that is being paired with `nums1[i]` (initially `0`).

#### 3. **Heap Extraction and Pair Generation**

```cpp
while(!pq.empty() && ans.size() < k) {
    auto it = pq.top();
    pq.pop();
    ans.push_back({it[1], it[2]});
    if(it[3] == n2 - 1) continue;
    it[0] = it[1] + nums2[it[3] + 1];
    it[2] = nums2[it[3] + 1];
    it[3] = it[3] + 1;
    pq.push(it);
}
```

- We pop the smallest pair from the heap and add it to the result `ans`.
- If the index in `nums2` is the last element (`n2 - 1`), we skip pushing further pairs for that element of `nums1`.
- Otherwise, we generate the next pair by moving one step forward in `nums2` and push it back into the heap.

#### 4. **Return the Result**

```cpp
return ans;
```

Finally, we return the `k` smallest pairs stored in `ans`.

---

### 📈 Complexity Analysis

#### Time Complexity

- **Heap Operations**: Each push and pop operation in the heap takes `O(log k)` time, where `k` is the number of pairs we need to extract. The heap size is at most `k` at any time, and we perform these operations at most `k` times.
  
Thus, the overall time complexity is:
- **O(k log k)**, where `k` is the number of pairs we need to return.

#### Space Complexity

- We use a heap of size at most `k` to store pairs, so the space complexity is:
- **O(k)**.

Additionally, we store the result in a vector, which can hold up to `k` pairs, so the overall space complexity remains:
- **O(k)**.

---

### 🏁 Conclusion

The `kSmallestPairs` function efficiently computes the `k` smallest pairs from two sorted arrays using a Min-Heap and iterative pairing. By leveraging the sorted nature of the arrays and a priority queue, the solution efficiently generates the desired pairs with optimal time and space complexity. This approach is particularly well-suited for problems where the arrays are large and the number of pairs to return (`k`) is relatively small.
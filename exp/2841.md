### Problem Statement

We are given an array of integers `nums`, and we need to find the maximum sum of any subarray of size `k` such that the subarray contains at least `size` distinct elements. The goal is to identify the subarray with the highest sum that meets this condition.

### Approach

This problem involves finding the maximum sum of a subarray of fixed size `k`, with the additional constraint that the subarray must contain at least `size` distinct elements. To solve this problem efficiently, we can use the **sliding window technique** in combination with a **hash map** to keep track of the frequency of elements within the window. Here's how we can break down the approach:

1. **Sliding Window**: The idea is to maintain a sliding window of size `k` that moves across the array, updating the sum of the window and the count of distinct elements as we go. The window starts at the first element and expands to the right until it reaches size `k`. If the window exceeds size `k`, we shrink it from the left.

2. **Hash Map for Frequency Count**: A hash map is used to store the frequency of each element in the current window. This helps us quickly track how many distinct elements are present in the window. As the window expands and contracts, we update the hash map by adding or removing elements.

3. **Check for Valid Window**: Once the window reaches size `k`, we check if the number of distinct elements in the window is greater than or equal to `size`. If so, we update the maximum sum encountered.

4. **Efficiency Considerations**: Since the sliding window moves one step at a time, and we only perform constant-time operations for each element (updating the sum and the hash map), the time complexity of this approach is linear, O(n), where `n` is the length of the input array.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables
```cpp
unordered_map<int, int> m; // Hash map to store the frequency of elements in the current window
long long sum = 0; // To store the sum of the current window
long long maxi = 0; // To store the maximum sum encountered
int i = 0, j = 0; // Two pointers to define the sliding window
```
- We use an unordered map `m` to track the frequency of elements in the current window.
- `sum` holds the sum of the elements in the current window.
- `maxi` keeps track of the maximum sum of subarrays that have at least `size` distinct elements.
- `i` and `j` are the pointers that define the boundaries of the sliding window.

#### Step 2: Expand the Window
```cpp
while(j < nums.size()) {
    m[nums[j]]++; // Add the element at position j to the window
    sum += nums[j]; // Add the element to the current sum
```
- We expand the window by moving the `j` pointer to the right. Each time we add a new element to the window, we update the frequency map and the sum of the window.

#### Step 3: Shrink the Window if It Exceeds Size `k`
```cpp
if(j - i + 1 > k) {
    m[nums[i]]--; // Remove the element at position i from the window
    sum -= nums[i]; // Subtract the element from the current sum
    if(m[nums[i]] == 0) {
        m.erase(nums[i]); // If the frequency becomes zero, remove the element from the map
    }
    i++; // Move the left pointer to shrink the window
}
```
- If the window size exceeds `k`, we shrink the window by moving the `i` pointer to the right.
- We update the sum and frequency map by removing the element at index `i` from the window.
- If the frequency of an element becomes zero after removal, we delete it from the map.

#### Step 4: Check for Valid Subarray and Update Maximum Sum
```cpp
if(j - i + 1 == k) {
    if(m.size() >= size) { // Check if the number of distinct elements is at least 'size'
        maxi = max(sum, maxi); // Update the maximum sum if the current window is valid
    }
}
```
- When the window size is exactly `k`, we check if the number of distinct elements in the window is at least `size`. If the condition is satisfied, we update `maxi` with the maximum sum encountered so far.

#### Step 5: Move the Right Pointer
```cpp
j++; // Move the right pointer to expand the window
```
- After processing the current window, we move the right pointer `j` to expand the window further.

#### Step 6: Return the Maximum Sum
```cpp
return maxi; // Return the maximum sum of subarrays with at least 'size' distinct elements
```
- After processing all possible subarrays, we return the maximum sum found that meets the condition of having at least `size` distinct elements.

### Complexity

#### Time Complexity:
- **O(n)**: The algorithm iterates through the array once with the sliding window technique. Each element is processed once when added to the window and potentially once when removed from the window. The operations on the hash map (insertion, deletion, and lookup) are O(1) on average. Therefore, the overall time complexity is O(n), where `n` is the length of the input array.

#### Space Complexity:
- **O(n)**: The space complexity is O(n) due to the use of the hash map, which may store up to `n` distinct elements in the worst case. The space used for the sum and `maxi` variables is constant, O(1).

### Conclusion

This solution efficiently solves the problem of finding the maximum sum of a subarray of size `k` with at least `size` distinct elements using the sliding window technique and a hash map. By maintaining a sliding window of fixed size `k` and dynamically adjusting the frequency of elements within the window, we ensure that the algorithm runs in linear time, making it well-suited for large input arrays. This approach ensures that the problem is solved optimally both in terms of time and space complexity.
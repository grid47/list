### Problem Statement

The problem requires trimming a binary search tree (BST) such that all node values are within a specified range. Specifically, given the root of a BST and two integers `low` and `high`, you need to return the root of the tree after removing all nodes that don't satisfy the condition: `low <= node->val <= high`.

A binary search tree is a tree data structure where each node follows the condition that:
1. The left subtree of a node contains only nodes with values less than the node’s value.
2. The right subtree of a node contains only nodes with values greater than the node’s value.

### Approach

The core idea behind this solution is to traverse the tree recursively and prune nodes whose values are outside the range `[low, high]`. The pruning process involves adjusting pointers for subtrees that are either too small or too large.

#### Key Steps:
1. **Base Case**: If the current node is `NULL`, simply return `NULL`. This occurs when the node is outside the tree or when we reach the end of a branch.
2. **Pruning the Left and Right Subtrees**: 
   - If the current node's value is less than `low`, this means the left subtree (and any of its descendants) cannot be part of the valid tree. Therefore, we skip the left subtree and recurse on the right subtree.
   - If the current node's value is greater than `high`, this means the right subtree (and any of its descendants) cannot be part of the valid tree. Therefore, we skip the right subtree and recurse on the left subtree.
3. **Valid Node**: If the node’s value is within the range, we recursively trim both the left and right subtrees of the node, ensuring all values in the subtrees are also within the specified range.
4. **Returning the Node**: Once a node has been validated (its value is within the specified range and its subtrees have been pruned), return the node.

This approach ensures that all nodes outside the range are removed and that the tree structure remains a valid binary search tree.

### Code Breakdown (Step by Step)

The implementation of this solution in C++ uses a recursive approach to trim the BST. Below is a detailed breakdown of the code.

#### 1. **Function Definition and Base Case**

```cpp
TreeNode* trimBST(TreeNode* root, int low, int high) {
    if(root == NULL) return NULL;
```
- The function `trimBST` takes three parameters: the root of the BST, and two integers `low` and `high` that define the allowed range for node values.
- The first check is for the base case where the `root` is `NULL`. If this is the case, we simply return `NULL` because there are no nodes to process at this point.

#### 2. **Pruning Nodes Less than `low`**

```cpp
if(root->val < low) {
    return trimBST(root->right, low, high);
}
```
- If the current node’s value is less than `low`, then all nodes in the left subtree of the current node must also be smaller than `low` (because it’s a binary search tree). Hence, the left subtree is entirely invalid, and we recursively trim the right subtree by calling `trimBST(root->right, low, high)`.

#### 3. **Pruning Nodes Greater than `high`**

```cpp
else if(root->val > high) {
    return trimBST(root->left, low, high);
}
```
- If the current node’s value is greater than `high`, then all nodes in the right subtree of the current node must also be greater than `high` (because of the BST property). Therefore, we prune the right subtree and recursively call `trimBST(root->left, low, high)` to trim the left subtree.

#### 4. **Valid Node within Range**

```cpp
root->left = trimBST(root->left, low, high);
root->right = trimBST(root->right, low, high);
```
- If the current node’s value is within the allowed range (`low <= node->val <= high`), we recursively trim both the left and right subtrees.
- The result of the recursive calls for the left and right subtrees is assigned to `root->left` and `root->right`, respectively.

#### 5. **Return the Valid Node**

```cpp
return root;
```
- Once the left and right subtrees have been trimmed, the current node is returned as part of the pruned tree.

### Complexity

#### Time Complexity:
- The time complexity of the solution is **O(n)**, where `n` is the number of nodes in the binary search tree. In the worst case, we visit every node in the tree exactly once.

#### Space Complexity:
- The space complexity is **O(h)**, where `h` is the height of the tree. This is because we are using recursion, and the maximum depth of recursion depends on the height of the tree. In the case of an unbalanced tree, this could be up to `O(n)` in the worst case, but for a balanced tree, the space complexity would be `O(log n)`.

### Conclusion

This approach is a simple yet effective way of trimming a binary search tree based on a specified range. By using recursion, we can traverse the tree and prune it in-place, ensuring that the tree remains a valid binary search tree after the operation. The solution efficiently handles both small and large trees with a time complexity of **O(n)** and space complexity that depends on the tree’s height.

The algorithm's core idea is to ensure that only nodes with values within the given range `[low, high]` are retained, and all other nodes are removed, keeping the tree structure valid. The recursive pruning of the left and right subtrees ensures correctness while maintaining the binary search tree properties. This approach is ideal for scenarios where you need to dynamically trim a tree based on variable conditions.
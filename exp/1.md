### Problem Statement

The **Two Sum** problem is a classic algorithmic challenge that requires you to find two distinct indices in a list of integers where the sum of the integers at those indices equals a given target value. The problem is defined as follows:

- You are given an array of integers, `nums`, and an integer, `target`.
- Your task is to return the indices of two numbers such that their sum is equal to the `target`. You may assume that each input would have exactly one solution and that you may not use the same element twice.

### Approach

The problem can be solved efficiently using a **hashmap** (or dictionary) approach. The key idea is to traverse the array once and use the hashmap to store the difference between the target and the current element. As you continue to iterate, you check whether the current element exists in the hashmap.

1. **Iterate through the list**: For each element in the list, calculate the difference between the target and the current element. This difference will represent the value needed to pair with the current element to sum up to the target.
   
2. **Check if the difference is already in the hashmap**: If the difference (i.e., `target - nums[i]`) is found in the hashmap, it means we have previously encountered an element that, when added to the current element, equals the target. In that case, return the indices of the two elements.
   
3. **If the difference is not found, store the current element in the hashmap**: The key is the difference `target - nums[i]` and the value is the index of the current element. This will allow us to check for potential pairs in the future iterations.

4. **Edge case**: If no solution is found after iterating through the entire array, return `{-1, -1}`, indicating no valid pair exists (though the problem guarantees a solution).

### Code Breakdown (Step by Step)

#### Step 1: Initialize the Map

```cpp
map<int, int> mp;
```

- A `map` is used to store the differences between the target and the elements of the array. The key is the difference (`target - nums[i]`), and the value is the index of the element `nums[i]`. This allows us to quickly check if a potential complement (i.e., a number that when added to the current element equals the target) has been encountered earlier.

#### Step 2: Iterate Through the Array

```cpp
for(int i = 0; i < nums.size(); i++) {
```

- A loop is initiated to go through each element in the `nums` array.

#### Step 3: Check if the Current Element's Complement is in the Map

```cpp
if(mp.count(nums[i])) {
    return { mp[nums[i]], i };
} else {
    mp[target - nums[i]] = i;
}
```

- For each element `nums[i]`, we check if `nums[i]` exists in the map. If it does, this means we have previously encountered a number that, when added to `nums[i]`, equals the target. The index of that number is stored in `mp[nums[i]]`.
- If we find such a complement in the map, we immediately return the pair of indices: `{ mp[nums[i]], i }`, which represents the two indices whose values add up to the target.

- If the current element doesn't exist in the map, we store the difference `target - nums[i]` as the key in the map and its corresponding index `i` as the value. This allows us to potentially find a pair in the future iterations.

#### Step 4: Return the Result

```cpp
return {-1, -1};
```

- If the loop completes without finding any pair of numbers that sum up to the target, we return `{-1, -1}`, which is a safeguard against input that does not have a solution. However, as the problem guarantees that exactly one solution exists, this part is more for completeness.

### Complexity

#### Time Complexity: **O(n)**
- We iterate over the list of numbers once. For each element, we perform constant-time operations (map lookup, insert). Hence, the overall time complexity is linear in the size of the array, which is **O(n)**, where `n` is the number of elements in the `nums` array.

#### Space Complexity: **O(n)**
- We use a hashmap to store up to `n` different elements. In the worst case, all elements need to be stored in the map, so the space complexity is proportional to the size of the input array, which is **O(n)**.

### Conclusion

This solution is an optimal approach for solving the **Two Sum** problem. By using a hashmap, we are able to efficiently track the differences needed to reach the target sum, and we can find the solution in a single pass through the array. The time complexity of **O(n)** and space complexity of **O(n)** make this solution both time-efficient and space-efficient, ideal for larger inputs. The approach guarantees a solution in **O(n)** time because the problem constraints ensure that exactly one solution exists, and the hashmap provides constant-time lookups and insertions. This method is much more efficient than a brute-force approach that would require checking all pairs, which would have a time complexity of **O(n^2)**.
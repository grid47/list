### Problem Statement

The problem requires rotating a given `n x n` matrix (2D square matrix) by 90 degrees in a clockwise direction. The goal is to rotate the matrix in-place, which means modifying the original matrix without using extra space for a new matrix. The elements of the matrix should be rearranged so that the first row becomes the last column, the second row becomes the second-last column, and so on.

For example, consider the following matrix:

```
1 2 3
4 5 6
7 8 9
```

After rotating the matrix by 90 degrees clockwise, the matrix should look like:

```
7 4 1
8 5 2
9 6 3
```

### Approach

To solve this problem efficiently, we can break it down into two key operations:

1. **Transpose the matrix**: The first step in the rotation process is to transpose the matrix. The transpose of a matrix is obtained by swapping the rows and columns. Specifically, we swap the element at position `(i, j)` with the element at position `(j, i)` for all `i` and `j` where `i < j`. This step essentially converts the matrix so that the rows become columns.

2. **Reverse the rows**: After transposing the matrix, the next step is to reverse the rows of the matrix. This operation is simple — we swap the first row with the last row, the second row with the second-last row, and so on. This operation ensures that the elements are positioned correctly after the 90-degree rotation.

By performing these two operations — transposing and then reversing — we can achieve the desired 90-degree clockwise rotation of the matrix in-place.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    void rotate(vector<vector<int>>& mtx) {
        // Step 1: Reverse the rows of the matrix
        int i = 0, j = mtx.size() - 1;
        while(i <= j) {
            swap(mtx[i++], mtx[j--]);
        }
        
        // Step 2: Transpose the matrix
        for(int i = 0; i < mtx.size(); i++) {
            for(int j = i+1; j < mtx.size(); j++) {
                swap(mtx[i][j], mtx[j][i]);
            }
        }
    }
};
```

#### Step 1: Reverse the Rows

The first step in the rotation is to reverse the rows of the matrix. This is achieved using the following code:

```cpp
int i = 0, j = mtx.size() - 1;
while(i <= j) {
    swap(mtx[i++], mtx[j--]);
}
```

- We initialize two pointers: `i` points to the start of the matrix (the first row), and `j` points to the end of the matrix (the last row).
- The `swap(mtx[i++], mtx[j--])` operation swaps the rows at indices `i` and `j` while incrementing `i` and decrementing `j`. This effectively reverses the order of rows in the matrix.
- This process continues until `i` is greater than `j`, ensuring all rows have been swapped.

#### Step 2: Transpose the Matrix

The second step involves transposing the matrix, which involves swapping elements at `(i, j)` and `(j, i)` for all `i < j`. The code for this step is:

```cpp
for(int i = 0; i < mtx.size(); i++) {
    for(int j = i+1; j < mtx.size(); j++) {
        swap(mtx[i][j], mtx[j][i]);
    }
}
```

- We iterate through each element of the matrix using two nested loops. The outer loop runs over each row `i`, and the inner loop runs over the columns `j` starting from `i + 1` (to avoid swapping the same element).
- For each pair of elements at `(i, j)` and `(j, i)`, we swap their values. This transposes the matrix by flipping rows and columns.

After this step, the matrix will have been transposed, meaning the rows will have become columns. For example, the matrix:

```
1 2 3
4 5 6
7 8 9
```

becomes:

```
1 4 7
2 5 8
3 6 9
```

#### Result After Both Steps

At this point, the matrix has been reversed row-wise and transposed. These two operations together result in a 90-degree clockwise rotation. The matrix:

```
1 4 7
2 5 8
3 6 9
```

is now correctly rotated to:

```
7 4 1
8 5 2
9 6 3
```

### Complexity

#### Time Complexity

- **Reversing the Rows**: Reversing the rows involves swapping elements in pairs across the matrix. The number of operations for this is proportional to the number of rows, so it takes `O(n)` time, where `n` is the size of the matrix (since it's an `n x n` matrix, there are `n` rows).
- **Transposing the Matrix**: The transposition step involves visiting each pair of elements `(i, j)` where `i < j` and swapping them. The total number of such pairs is `n * (n - 1) / 2`, which simplifies to `O(n^2)`.

Therefore, the overall **time complexity** is dominated by the transposition step, which is `O(n^2)`.

#### Space Complexity

The algorithm rotates the matrix **in-place**, meaning no additional space is used to store a new matrix. The only extra space used is for the loop variables and the temporary swap during the transposition step.

Thus, the **space complexity** is `O(1)` as we are only using constant extra space.

### Conclusion

This solution efficiently rotates an `n x n` matrix by 90 degrees clockwise using two simple operations: reversing the rows and transposing the matrix. Both operations are performed in-place, ensuring that the space complexity remains constant. The time complexity is `O(n^2)`, which is optimal for this problem given the need to process all elements in the matrix.

- **Time Complexity**: `O(n^2)`, where `n` is the size of the matrix.
- **Space Complexity**: `O(1)`, as the rotation is performed in-place.

This approach is both time-efficient and space-efficient, making it a great choice for rotating matrices in competitive programming and real-world applications that require in-place modifications.
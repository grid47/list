### Problem Statement

The problem at hand is to find the number of distinct subsequences of a string `s` that match a given string `t`. A **subsequence** is formed by deleting some or none of the characters in a string without changing the order of the remaining characters.

For example:
- Given `s = "rabbbit"` and `t = "rabbit"`, there are 3 distinct subsequences of `s` that match `t`:
  - "rabbbit"
  - "rabbbit"
  - "rabbbit"
  
The goal is to compute how many distinct ways the string `t` can be formed by deleting characters in string `s`.

### Approach

This problem can be solved using **dynamic programming** (DP) with memoization. The key idea is to use a recursive approach that explores all potential subsequences of `s` that could match `t`, while avoiding redundant recalculations using memoization to store previously computed results.

To solve the problem, we need to consider two cases at each position of `s` and `t`:
1. If the current characters `s[i]` and `t[j]` match, we can:
   - Either include `s[i]` in the subsequence and move both indices (`i + 1`, `j + 1`).
   - Or skip `s[i]` and only move the index `i` forward (`i + 1`, `j`).
2. If the characters do not match, we can only skip `s[i]` and move forward in `s` (`i + 1`, `j`).

We use a 2D DP table `memo[i][j]` to store the number of distinct subsequences starting from index `i` in `s` and index `j` in `t`. By recursively computing the number of distinct subsequences for each pair of indices and storing the results, we avoid redundant calculations, making the solution efficient.

### Code Breakdown (Step by Step)

#### 1. Data Members

```cpp
int memo[1001][1001];
string s, t;
```

- We declare a 2D array `memo` of size `1001x1001` to store the results of subproblems. The array stores the number of distinct subsequences for specific positions in `s` and `t`.
- `s` and `t` are the input strings.

#### 2. DP Function (`dp`)

```cpp
int dp(int i, int j) {
    if(j == t.size()) return 1;
    if(i == s.size()) return 0;
    if(memo[i][j] != -1) return memo[i][j];
```

- The function `dp(i, j)` computes the number of distinct subsequences of `s[i...]` that match `t[j...]`.
- **Base Case 1**: If `j == t.size()`, we have matched all characters of `t`, so there is one subsequence: the empty string. Thus, we return `1`.
- **Base Case 2**: If `i == s.size()` but `j != t.size()`, it means we have reached the end of `s` but still need to match remaining characters of `t`, so we return `0`.
- **Memoization**: If the result for `dp(i, j)` has already been computed (i.e., `memo[i][j] != -1`), we return the cached result.

#### 3. Recursive Computation

```cpp
    int res = 0;
    if(s[i] == t[j]) {
        res = dp(i + 1, j + 1) + dp(i + 1, j);
    } else {
        res = dp(i + 1, j);
    }
```

- **Case 1**: If `s[i] == t[j]`, we can either:
  - Include `s[i]` in the subsequence and move both indices (`dp(i + 1, j + 1)`).
  - Or skip `s[i]` and only move the index of `s` (`dp(i + 1, j)`).
- **Case 2**: If `s[i] != t[j]`, we must skip `s[i]` and move forward in `s` (`dp(i + 1, j)`).

#### 4. Store and Return the Result

```cpp
    return memo[i][j] = res;
}
```

- After computing the result, we store it in `memo[i][j]` to avoid recomputing it in future calls.

#### 5. Main Function (`numDistinct`)

```cpp
int numDistinct(string s, string t) {
    this->s = s;
    this->t = t;
    memset(memo, -1, sizeof(memo));
    return dp(0, 0);
}
```

- In the `numDistinct` function, we initialize the input strings `s` and `t`.
- We initialize the `memo` table with `-1` using `memset`, indicating that no subproblem has been solved yet.
- We call `dp(0, 0)` to start the computation from the beginning of both strings `s` and `t`.

### Time Complexity

The time complexity of this solution is **O(m * n)**, where `m` is the length of string `s` and `n` is the length of string `t`. This is because we compute the result for each pair of indices `(i, j)` in the `s` and `t` strings, and each subproblem is solved only once due to memoization.

- For each subproblem `(i, j)`, we have two recursive calls at most: one for the case when the characters match and one for when we skip a character in `s`. Each of these recursive calls is computed once, and the results are stored in the `memo` table.

### Space Complexity

The space complexity is **O(m * n)**, where `m` is the length of string `s` and `n` is the length of string `t`. This is because:
- We use a 2D `memo` table of size `m * n` to store the results of the subproblems.
- The recursion stack takes up space proportional to the depth of the recursion, which is at most `m + n`. However, the dominant space complexity comes from the `memo` table.

### Conclusion

This solution efficiently computes the number of distinct subsequences of string `s` that match string `t` using dynamic programming with memoization. By caching the results of subproblems, we avoid redundant calculations, making the solution time-efficient. The time complexity is **O(m * n)**, where `m` is the length of `s` and `n` is the length of `t`. The space complexity is also **O(m * n)** due to the memoization table.

This approach solves the problem optimally and is particularly useful for cases where the strings `s` and `t` are relatively large.
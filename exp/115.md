### üåü **Problem Statement: Count Distinct Subsequences**

The task is to find how many distinct subsequences of a string `s` match a given string `t`. A **subsequence** is formed by deleting some or none of the characters in `s`, without changing the order of the remaining characters.

For example:
- Given `s = "rabbbit"` and `t = "rabbit"`, there are **3 distinct subsequences** of `s` that match `t`:
  - "rabbbit"
  - "rabbbit"
  - "rabbbit"
  
The goal is to compute how many distinct ways string `t` can be formed by deleting characters from string `s`.

---

### üß† **Approach: Dynamic Programming with Memoization**

This problem can be solved using **dynamic programming (DP)** with **memoization** to avoid redundant calculations.

We will define a 2D table `memo[i][j]` that stores the number of distinct subsequences of `s[i...]` that match `t[j...]`. The idea is to recursively calculate the number of subsequences for each pair of indices and store intermediate results in `memo` to speed up the computation.

Here‚Äôs how we break it down:

1. **If characters match:** We have two choices:
   - **Include the current character** from `s` in the subsequence and move both indices forward.
   - **Skip the current character** from `s` and move forward in `s` only.

2. **If characters don't match:** We can only skip the current character in `s` and move forward.

By using memoization, we avoid recomputing the results for overlapping subproblems.

---

### üõ†Ô∏è **Code Walkthrough: Step-by-Step**

#### 1. Data Members

```cpp
int memo[1001][1001];
string s, t;
```

- We declare a 2D array `memo` to store results of subproblems.
- `s` and `t` are the input strings.

#### 2. DP Function (`dp`)

```cpp
int dp(int i, int j) {
    if(j == t.size()) return 1;
    if(i == s.size()) return 0;
    if(memo[i][j] != -1) return memo[i][j];
```

- **Base Case 1**: If we've matched all characters of `t` (i.e., `j == t.size()`), we return 1 because we've successfully formed `t`.
- **Base Case 2**: If we've reached the end of `s` but still have characters left in `t` to match (i.e., `i == s.size()`), we return 0 because no valid subsequence exists.
- **Memoization**: If we've already computed `memo[i][j]`, return the stored result.

#### 3. Recursive Computation

```cpp
    int res = 0;
    if(s[i] == t[j]) {
        res = dp(i + 1, j + 1) + dp(i + 1, j);
    } else {
        res = dp(i + 1, j);
    }
```

- **If characters match (`s[i] == t[j]`)**:
  - Include `s[i]` in the subsequence: `dp(i + 1, j + 1)`
  - Or skip `s[i]`: `dp(i + 1, j)`
  
- **If characters don't match (`s[i] != t[j]`)**:
  - We must skip `s[i]`: `dp(i + 1, j)`

#### 4. Store and Return the Result

```cpp
    return memo[i][j] = res;
}
```

- After computing the result, store it in `memo[i][j]` to reuse it later.

#### 5. Main Function (`numDistinct`)

```cpp
int numDistinct(string s, string t) {
    this->s = s;
    this->t = t;
    memset(memo, -1, sizeof(memo));
    return dp(0, 0);
}
```

- Initialize `s` and `t` and the `memo` table with `-1` using `memset`.
- Start the computation by calling `dp(0, 0)` to begin matching from the start of both strings.

---

### ‚è±Ô∏è **Time Complexity**

The time complexity of this solution is **O(m * n)**, where `m` is the length of `s` and `n` is the length of `t`. This is because we solve a subproblem for each pair of indices `(i, j)` in `s` and `t`, and each subproblem is solved only once, thanks to memoization.

---

### üí° **Space Complexity**

The space complexity is **O(m * n)**:
- The `memo` table requires **O(m * n)** space.
- The recursion stack depth is at most `m + n`, but the space used by the memoization table dominates.

---

### üéâ **Conclusion**

This solution uses dynamic programming with memoization to compute the number of distinct subsequences of `s` that match `t` efficiently. By avoiding redundant calculations through memoization, we ensure that the solution is both **time-efficient** and **space-efficient**.

With a time complexity of **O(m * n)** and a space complexity of **O(m * n)**, this approach handles relatively large strings effectively and avoids recalculating overlapping subproblems. 

This is an optimal solution for the problem of counting distinct subsequences and is great for large input sizes!
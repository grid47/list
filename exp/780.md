### Problem Statement

The problem asks whether it is possible to reach the target point `(tx, ty)` from the starting point `(sx, sy)` by applying the following two operations:

1. Starting at `(sx, sy)`, move to `(sx + sy, sy)`.
2. Or, move to `(sx, sx + sy)`.

Both operations are allowed repeatedly until the target is reached or the conditions are violated.

The goal is to determine if it is possible to reach `(tx, ty)` starting from `(sx, sy)` using the described operations.

### Approach

The problem can be approached using two distinct methods:

1. **Memoized Recursive Approach (First Approach)**: In this method, we use recursion to explore the possible ways of reaching from the start point `(sx, sy)` to the target `(tx, ty)` by applying the operations. To optimize this approach and avoid redundant calculations, we use memoization to store intermediate results.

2. **Greedy Iterative Approach (Second Approach)**: The second approach is an iterative solution that utilizes the mathematical properties of the moves `(sx + sy, sy)` and `(sx, sx + sy)` to directly work from the target `(tx, ty)` towards the start point `(sx, sy)` by reducing the values in a greedy manner. This approach iteratively checks the conditions and reduces `tx` and `ty` until it either matches the target or fails to reach the desired point.

### Code Breakdown (Step by Step)

#### Memoized Recursive Approach

The first method uses recursion with memoization to solve the problem. Here's the breakdown of the code:

```cpp
unordered_map<long, unordered_map<long, bool>> mp;
```

- **Memoization**: An unordered map `mp` is used to store already computed results for pairs of `(sx, sy)` to avoid redundant calculations. The key for `mp` is the starting x-coordinate `sx`, and the value is another map that holds results for corresponding `sy` values.

```cpp
bool pts(int sx, int sy, int tx, int ty) {
    if (sx == tx && sy == ty) return true;  // Base case
    if (sx > tx || sy > ty) return false;   // Bound check

    if (mp.count(sx) && mp[sx].count(sy)) return mp[sx][sy];  // Check memoized values

    bool ans = pts(sx + sy, sy, tx, ty);  // First possible operation
    if (ans) return true;

    ans = pts(sx, sx + sy, tx, ty);  // Second possible operation
    return mp[sx][sy] = ans;  // Memoize and return result
}
```

- **Base Case**: If the starting point `(sx, sy)` matches the target `(tx, ty)`, return `true` as the target is reached.
  
- **Boundary Check**: If `sx > tx` or `sy > ty`, return `false`, as it is impossible to reach the target with negative or oversized values.
  
- **Memoization Check**: If the pair `(sx, sy)` has been computed before, return the stored result.
  
- **Recursive Calls**: The function explores two possible operations recursively:
  1. Move to `(sx + sy, sy)`.
  2. Move to `(sx, sx + sy)`.

- **Return and Memoize**: The result of these recursive calls is memoized for future reference to avoid redundant calculations.

#### Iterative Greedy Approach

The second part of the solution uses a more efficient **greedy iterative approach** to solve the problem:

```cpp
bool reachingPoints(int sx, int sy, int tx, int ty) {
    while (sx < tx && sy < ty) {
        if (tx < ty) {
            ty %= tx;  // Reduce ty to smaller values by modulo operation
        } else {
            tx %= ty;  // Reduce tx similarly
        }
    }

    return (sx == tx && sy <= ty && (ty - sy) % sx == 0) ||
           (sy == ty && sx <= tx && (tx - sx) % sy == 0);
}
```

- **While Loop**: The loop continues until either `sx == tx` or `sy == ty`. The logic inside the loop ensures that `tx` and `ty` are reduced by applying the modulo operation.
  
- **Modulo Operations**: Depending on whether `tx` is greater than `ty` or vice versa, we perform a modulo operation to reduce the larger value. The modulo operation helps break down the problem by simplifying the values.

- **Return Statement**: After breaking out of the loop, the function checks if the target point `(tx, ty)` is reachable:
  - If `sx == tx`, ensure `sy <= ty` and that the difference between `ty` and `sy` is divisible by `sx`.
  - If `sy == ty`, ensure `sx <= tx` and that the difference between `tx` and `sx` is divisible by `sy`.

### Complexity Analysis

#### Time Complexity:
- **Recursive Method**: The recursive approach has a time complexity of **O(n^2)** in the worst case due to the two recursive calls for each possible move and memoization checks.
  
- **Greedy Iterative Method**: The iterative method involves reducing `tx` and `ty` through modulo operations, and the time complexity depends on the number of times we can apply the modulo operation. In the worst case, it is proportional to the logarithm of the values, so the time complexity is **O(log(max(tx, ty)))**.

#### Space Complexity:
- **Recursive Method**: The space complexity is **O(n^2)** due to the use of recursion and memoization storing the results.
  
- **Greedy Iterative Method**: The space complexity is **O(1)** as no extra space is used other than a few integer variables for tracking `sx`, `sy`, `tx`, and `ty`.

### Conclusion

The solution efficiently handles the problem of checking whether it's possible to reach a target point `(tx, ty)` from a starting point `(sx, sy)` by applying two possible moves. The recursive approach with memoization ensures that redundant calculations are avoided, while the greedy iterative approach provides an efficient, space-optimal solution.

Both methods are effective for solving this problem, with the greedy iterative approach offering a more optimal time complexity, especially for large inputs. The recursive method, while slightly less efficient, provides a clear and intuitive solution for smaller inputs or when recursion is preferred.
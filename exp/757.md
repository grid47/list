### Problem Statement

The problem revolves around finding the smallest set of integers such that each set of intervals in the given array intersects with the set of integers at least twice. Each interval in the array is represented by a pair of integers `[a, b]`, where `a` is the starting point and `b` is the endpoint of the interval. You need to return the size of the smallest set of integers that has at least two common points with each interval.

In simpler terms, you need to determine how many elements are required to cover all the intervals with at least two points of intersection in every interval.

### Approach

To solve the problem, the key idea is to use a greedy algorithm that minimizes the number of elements in the intersection set. The greedy approach is as follows:

1. **Sorting the Intervals**: First, sort the intervals based on their endpoints. Sorting ensures that we always consider the intervals with the smallest endpoint first, which helps in efficiently selecting the necessary points for intersection. If two intervals have the same endpoint, we prioritize intervals with a larger starting point to ensure coverage of both intervals.

2. **Greedy Selection of Points**: For each interval, we want to select the smallest possible set of points that intersects with it at least twice. To achieve this, we maintain two variables `fst` and `scd`, which represent the last two points added to the intersection set. By ensuring these two points always intersect with the current interval, we can guarantee that every interval will have at least two points of intersection.

3. **Efficient Coverage**: For each interval, we check if the two points `fst` and `scd` already cover the interval. If not, we add the necessary points to the set. By doing this greedily, we minimize the size of the set while ensuring it covers all intervals.

### Code Breakdown (Step by Step)

#### Step 1: Sorting the Intervals

```cpp
sort(nums.begin(), nums.end(), [&](vector<int> &a, vector<int> &b){
    if(a[1] != b[1]) return a[1] < b[1];
    return a[0] > b[0];
});
```

- The intervals are sorted first by their endpoint (`a[1]` and `b[1]`). This ensures that we consider the intervals that finish earlier, which helps in covering the intervals optimally.
- If two intervals have the same endpoint, we sort them by their starting point in descending order (`a[0] > b[0]`), ensuring that the intervals with larger starting points are considered first. This approach helps to select the minimum number of points for intersection.

#### Step 2: Initialize Variables for Tracking Coverage

```cpp
int ans = 0, fst = -1, scd = -1;
```

- `ans`: This variable keeps track of the total number of points in the intersection set.
- `fst`: This represents the first point in the current intersection set.
- `scd`: This represents the second point in the current intersection set.

Both `fst` and `scd` are initialized to `-1` to represent that no points have been selected yet.

#### Step 3: Iterate Over Each Interval

```cpp
for(auto it: nums) {
    int a = it[0], b = it[1];

    bool is_fst_in = a <= fst;
    bool is_scd_in = a <= scd;

    if(is_fst_in && is_scd_in) continue;
    
    ans += is_fst_in ? 1 : 2;
    
    scd = is_fst_in ? fst : b - 1;
    fst = b;
}
```

- For each interval `it`, we extract the start (`a`) and end (`b`) of the interval.
- **Check if the current interval is already covered**:
  - `is_fst_in`: Checks if the first point of the intersection set (`fst`) is inside the current interval by comparing `a <= fst`.
  - `is_scd_in`: Checks if the second point of the intersection set (`scd`) is inside the current interval by comparing `a <= scd`.
  
  If both points already cover the interval (`is_fst_in && is_scd_in`), we continue to the next interval without making any changes.

- **If the interval is not covered**:
  - We update the total count `ans`:
    - If the first point (`fst`) is already inside the interval (`is_fst_in`), we add only 1 point, otherwise, we add 2 points to the intersection set.
  - We then update the values of `fst` and `scd` to ensure that they cover the interval:
    - `scd = is_fst_in ? fst : b - 1`: If the first point is already inside the interval, we set `scd` to `fst`. Otherwise, we set `scd` to `b - 1`, which is the largest possible point inside the interval.
    - `fst = b`: We set `fst` to `b` as the first point in the intersection set for the current interval.

#### Step 4: Return the Result

```cpp
return ans;
```

- After processing all the intervals, the total number of points in the intersection set is stored in `ans`, which is returned as the result.

### Complexity

- **Time Complexity**:
  - Sorting the intervals takes **O(n log n)**, where `n` is the number of intervals.
  - The loop that iterates over the intervals takes **O(n)**, where `n` is the number of intervals.
  - Thus, the total time complexity of the algorithm is **O(n log n)**, dominated by the sorting step.

- **Space Complexity**:
  - The space complexity is **O(n)** due to the storage of the intervals in the input array `nums` and the need to store the sorted intervals in the sorting step.

### Conclusion

The solution uses a greedy approach to find the smallest set of integers that intersects with all intervals at least twice. By sorting the intervals based on their endpoints and ensuring that the last two points in the intersection set always cover each interval, we can achieve the desired result efficiently. The time complexity of the algorithm is **O(n log n)**, which is optimal for this type of problem involving intervals.
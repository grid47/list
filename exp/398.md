### Problem Statement

The problem asks to implement a solution that efficiently picks a random index from an array `nums` where a specific target value occurs. The challenge is to implement a `pick` method that, given a target value, returns a random index of the target value from the array `nums`. The solution needs to be efficient in terms of both time and space, especially when there are many occurrences of the target value.

### Approach

To solve this problem, we need to consider the following aspects:
1. **Efficient Storage**: We need to efficiently store the indices of all occurrences of each value in the array. This will allow us to quickly access all indices corresponding to a given target.
2. **Efficient Retrieval**: We must be able to pick a random index from the stored list of indices of the target. To achieve this, we can use a random number generator to randomly select an index from the list of stored indices.
3. **Time Complexity**: Both the initialization of the storage and the retrieval of a random index must be efficient. The `pick` method should ideally run in constant time, i.e., `O(1)`, after the initialization.
4. **Space Complexity**: We must manage the space required for storing the indices of all the occurrences efficiently.

### Code Breakdown (Step by Step)

Let’s go through the code line-by-line to understand how the problem is solved.

#### Step 1: Class Definition

```cpp
class Solution {
    unordered_map<int, vector<int>> mp;
```
- The `Solution` class contains an unordered map `mp`. The key is an integer, and the value is a vector of integers that stores the indices where that integer appears in the array.

#### Step 2: Constructor to Initialize the Map

```cpp
public:
    Solution(vector<int>& nums) {
        int n = nums.size();
        for(int i = 0; i < n; i++)
            mp[nums[i]].push_back(i);
    }
```
- The constructor takes a reference to a vector of integers `nums`, which is the input array.
- The loop iterates over the array, and for each element `nums[i]`, it pushes its index `i` into the vector corresponding to `nums[i]` in the `mp` map.
  - For example, if `nums = [1, 2, 3, 1, 2]`, the map `mp` will look like:
    ```cpp
    {
      1: [0, 3],
      2: [1, 4],
      3: [2]
    }
    ```
  - This allows efficient storage of all indices for each number in the array.

#### Step 3: Pick Method to Randomly Select an Index

```cpp
    int pick(int target) { 
        int sz = mp[target].size();
        int res = mp[target][rand() % sz];
        return res;
    }
```
- The `pick` method takes an integer `target` as input and performs the following:
  1. **Find the Size of the Target’s Index List**:
     - `sz = mp[target].size()` retrieves the size of the vector associated with the target value. This vector contains all the indices where the target appears in `nums`.
  2. **Generate a Random Index**:
     - `rand() % sz` generates a random index between `0` and `sz - 1`. The `rand()` function generates a random integer, and using modulo `sz`, we ensure the index stays within the bounds of the vector of indices.
  3. **Return the Random Index**:
     - `mp[target][rand() % sz]` returns the randomly selected index from the vector of indices.
  4. The random index is then returned as the result of the method.

#### Step 4: Example of Usage

```cpp
/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * int param_1 = obj->pick(target);
 */
```
- This section shows how the `Solution` class is used:
  - You instantiate a `Solution` object with a vector `nums` as the constructor argument.
  - You call the `pick` method with a `target` value, and it returns a random index where `target` is found in `nums`.

### Example Walkthrough

Let’s walk through an example to see how this works:

#### Example 1: 
```cpp
vector<int> nums = {1, 2, 3, 1, 2};
Solution* obj = new Solution(nums);
int result = obj->pick(1);
```
1. **Initialization**: 
   - The `Solution` object is initialized with the array `nums = [1, 2, 3, 1, 2]`.
   - The map `mp` will be populated as:
     ```cpp
     {
       1: [0, 3],
       2: [1, 4],
       3: [2]
     }
     ```
   
2. **Picking an Index**: 
   - When `pick(1)` is called, the method finds that the indices where `1` appears are `[0, 3]`.
   - It generates a random index between `0` and `1` (since there are 2 occurrences of `1`).
   - The method randomly selects either index `0` or `3` and returns it.

#### Example 2: 
```cpp
int result = obj->pick(2);
```
1. **Picking an Index for Target 2**: 
   - When `pick(2)` is called, the method finds that the indices where `2` appears are `[1, 4]`.
   - It generates a random index between `0` and `1` (since there are 2 occurrences of `2`).
   - The method randomly selects either index `1` or `4` and returns it.

### Complexity Analysis

#### Time Complexity:
- **Constructor**: 
  - The constructor iterates over the array `nums` once to populate the map. This takes `O(n)`, where `n` is the size of the array.
- **Pick Method**: 
  - In the `pick` method, accessing the list of indices for a target value is `O(1)`, and selecting a random index using `rand() % sz` is also `O(1)`.
  - Therefore, the time complexity of the `pick` method is `O(1)`.

Overall, the time complexity for initializing the `Solution` object is `O(n)`, and each call to `pick` takes `O(1)` time.

#### Space Complexity:
- **Space Complexity**: The space complexity is determined by the size of the map `mp`, which stores a list of indices for each unique element in the input array.
  - In the worst case, the map will store all `n` indices if all elements in `nums` are unique.
  - Therefore, the space complexity is `O(n)`.

### Conclusion

The solution efficiently solves the problem of randomly picking an index of a target value from an array. By using an unordered map to store the indices of each value in the array, the solution allows the `pick` method to run in constant time, ensuring quick retrieval of random indices. The space complexity is linear in the size of the array due to the storage of indices in the map. This approach is both time-efficient and space-efficient, making it suitable for large input sizes.
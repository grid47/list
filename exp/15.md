### Problem Statement

The problem at hand is to find all unique triplets in an array of integers that sum up to zero. This is a well-known problem often referred to as the "3Sum" problem.

Given an array of integers `nums`, the task is to return a list of all unique triplets `[nums[i], nums[j], nums[k]]` such that:

```
nums[i] + nums[j] + nums[k] == 0
```

**Note:**
- The solution set must not contain duplicate triplets.
- The solution should be efficient, avoiding a brute-force approach of checking all triplets.

### Approach

To solve the 3Sum problem efficiently, we can take advantage of sorting and the two-pointer technique. Here's a step-by-step approach:

1. **Sort the Array**: Sorting the array helps us to avoid duplicates and enables the use of the two-pointer technique.
   
2. **Fix One Element**: Start by fixing one element of the triplet (let's call this element `nums[i]`). For each fixed element, we will find the other two elements that sum to the negative of `nums[i]`.

3. **Two Pointers**: Once the element `nums[i]` is fixed, use two pointers (`s` and `e`) to find pairs in the remaining part of the array such that the sum of the three elements equals zero. Initially, set the pointers `s` and `e` to `i + 1` and `nums.size() - 1`, respectively.

4. **Adjust Pointers**: 
   - If the sum of the elements at `s` and `e` is less than the target (`-nums[i]`), move the left pointer (`s`) to the right to increase the sum.
   - If the sum is greater than the target, move the right pointer (`e`) to the left to decrease the sum.
   - If the sum equals the target, we have found a valid triplet. Add it to the result list and adjust the pointers to skip over duplicate values.

5. **Skip Duplicates**: After finding a valid triplet, skip over any duplicate values to ensure that no duplicate triplets are included in the result.

6. **Skip Duplicates for Fixed Element**: If the current element (`nums[i]`) is the same as the previous one, skip it to avoid duplicate triplets.

### Code Breakdown (Step by Step)

```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
    vector<vector<int>> ans;  // Result array to store unique triplets.
    sort(nums.begin(), nums.end());  // Sort the array to enable two-pointer technique.
    
    for(int i = 0; i < nums.size(); i++) {
        int target = -nums[i];  // We need the sum of the other two elements to be -nums[i].
        int s = i + 1;  // Left pointer starts just after the fixed element.
        int e = nums.size() - 1;  // Right pointer starts at the end of the array.
        
        while(s < e) {  // Loop until the left and right pointers meet.
            if(nums[s] + nums[e] < target) {
                s++;  // If the sum is smaller than the target, move the left pointer to the right.
            } else if (nums[s] + nums[e] > target) {
                e--;  // If the sum is larger than the target, move the right pointer to the left.
            } else {
                // A valid triplet is found: [nums[i], nums[s], nums[e]].
                vector<int> res = {nums[i], nums[s], nums[e]};
                ans.push_back(res);  // Add the triplet to the result.
                
                // Skip duplicates for the left pointer.
                while(s < e && nums[s] == res[1]) s++;
                // Skip duplicates for the right pointer.
                while(s < e && res[2] == nums[e]) e--;
            }
        }
        
        // Skip duplicates for the fixed element nums[i].
        while(i + 1 < nums.size() && nums[i] == nums[i + 1]) i++;
    }
    
    return ans;  // Return the list of unique triplets.
}
```

#### Step 1: Sort the Array
```cpp
sort(nums.begin(), nums.end());
```
- Sorting the array ensures that we can use the two-pointer technique efficiently. This allows us to avoid checking duplicate triplets by skipping over repeated elements.

#### Step 2: Iterate through the Array
```cpp
for(int i = 0; i < nums.size(); i++) {
    int target = -nums[i];
    int s = i + 1;
    int e = nums.size() - 1;
```
- We start by fixing the first element `nums[i]` and calculate the target, which is `-nums[i]`.
- We initialize two pointers, `s` and `e`, to represent the left and right pointers, starting from `i + 1` and the last index, respectively.

#### Step 3: Two Pointer Technique
```cpp
while(s < e) {
    if(nums[s] + nums[e] < target) {
        s++;
    } else if (nums[s] + nums[e] > target) {
        e--;
    } else {
        vector<int> res = {nums[i], nums[s], nums[e]};
        ans.push_back(res);
        while(s < e && nums[s] == res[1]) s++;
        while(s < e && res[2] == nums[e]) e--;
    }
}
```
- We compare the sum of `nums[s]` and `nums[e]` with the target:
  - If the sum is less than the target, we move the left pointer (`s`) to the right.
  - If the sum is greater than the target, we move the right pointer (`e`) to the left.
  - If the sum equals the target, we have found a valid triplet and add it to the result list.

#### Step 4: Skip Duplicates
```cpp
while(i + 1 < nums.size() && nums[i] == nums[i + 1]) i++;
```
- After finding a valid triplet, we skip any duplicate elements of `nums[i]` to ensure that no duplicate triplets are added to the result.

### Complexity

#### Time Complexity:
- **O(n^2)**: The algorithm sorts the input array (`O(n log n)`) and then iterates through it once. For each element, it performs a while loop where two pointers are moved (`O(n)`), resulting in an overall time complexity of O(n^2).

#### Space Complexity:
- **O(n)**: The space complexity is O(n) because we store the result in a list, where in the worst case, there can be O(n) triplets.

### Conclusion

The 3Sum problem can be solved efficiently using sorting and the two-pointer technique. This approach ensures that we can find all unique triplets in O(n^2) time, which is a significant improvement over the brute-force solution. By sorting the array first, we can easily avoid duplicate triplets, ensuring that the result only contains unique combinations of elements that sum up to zero.

#### Advantages:
- **Efficient**: The time complexity of O(n^2) is much faster than a brute force approach.
- **Easy to understand**: The solution uses a common two-pointer technique which is intuitive and widely used in algorithm design.

#### Limitations:
- The solution assumes that the input array can have a length of up to a few thousand elements (depending on constraints), and the solution performs well under such conditions.

In summary, this solution provides an optimal approach to solving the 3Sum problem by leveraging sorting and the two-pointer technique to find unique triplets in a sorted array.
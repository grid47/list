
### Problem Statement

The problem at hand is to determine the minimum number of elements to be removed from an array to make it a mountain array. A mountain array is defined as an array where:

1. There exists an index `i` such that `0 < i < nums.length - 1`.
2. The elements before `i` are strictly increasing.
3. The elements after `i` are strictly decreasing.

For instance, the array `[2, 1, 1, 5, 6, 2, 3, 1]` can be transformed into a mountain array by removing some elements. The goal is to find the optimal way to achieve this while removing the fewest elements possible.

### Approach

The solution leverages the concept of Longest Increasing Subsequence (LIS) combined with iterating through potential peak elements in the array. The main steps involved in the approach are:

1. **Initialization**: Define the `lis` function to calculate the length of the longest increasing subsequence. This will help in determining the increasing and decreasing sequences around each potential peak.

2. **Iterate through potential peaks**: For each index `i` in the array (except the first and last), treat `nums[i]` as a peak and calculate how many elements are in the increasing sequence to the left and the decreasing sequence to the right.

3. **Calculate subsequences**: Use the `lis` function to determine the lengths of the increasing and decreasing subsequences, ensuring both are at least 2 to form a valid mountain.

4. **Update maximum**: Keep track of the maximum length of valid mountain sequences found during the iterations.

5. **Compute removals**: Finally, the minimum number of removals required will be the total size of the array minus the maximum valid mountain length.

### Code Breakdown (Step by Step)

The code is structured in a C++ class named `Solution`, containing two primary functions: `lis` and `minimumMountainRemovals`.

1. **Function `lis`**:
   - **Input**: A vector of integers representing a sequence.
   - **Output**: An integer representing the length of the longest increasing subsequence.
   - **Logic**:
     - Use a vector `res` to store the smallest tail for increasing subsequences found.
     - Iterate through each element in the input array. Use binary search (`lower_bound`) to find the position where the current element can replace or extend the sequence in `res`.
     - Update `res` accordingly to maintain its size as the longest increasing subsequence.

2. **Function `minimumMountainRemovals`**:
   - **Input**: A reference to a vector of integers `nums`.
   - **Output**: An integer representing the minimum number of elements to remove.
   - **Logic**:
     - Determine the length of `nums` and initialize a variable `mx` to keep track of the maximum valid mountain length.
     - Iterate through potential peak positions from index `1` to `n-2`.
     - For each peak index `i`:
       - Create a vector `left` to store the increasing subsequence ending at `i` and another vector `right` to store the decreasing subsequence starting from `i`.
       - Fill `left` by including all elements less than `nums[i]` to its left.
       - Fill `right` by including all elements less than `nums[i]` to its right and reverse it for correct order.
       - Use the `lis` function to compute the lengths of both subsequences.
       - If both lengths are greater than or equal to 2, calculate the total valid mountain length and update `mx`.
     - Finally, return the total length of the array minus `mx`, giving the minimum number of removals required.

### Complexity

The time complexity of the algorithm can be broken down as follows:

- The `lis` function operates in `O(n log n)` due to the binary search utilized in the function.
- The outer loop iterates through potential peaks (`O(n)`), while constructing the `left` and `right` vectors also contributes to an additional `O(n)` complexity in the worst-case scenario.
- Therefore, the overall time complexity of the `minimumMountainRemovals` function is approximately `O(n^2 log n)`, which is efficient for a moderate-sized array.

The space complexity is `O(n)` as we store various vectors that can grow up to the size of the input array.

### Conclusion

This C++ solution efficiently determines the minimum number of removals required to transform an array into a mountain array by utilizing the principles of the Longest Increasing Subsequence and careful consideration of potential peak elements. By iterating through the array and calculating the longest valid mountain lengths, the code effectively balances between optimal performance and clarity.

By understanding the nuances of this implementation, one can appreciate the elegant combination of algorithmic techniques that contribute to solving the mountain array problem efficiently. This solution serves as a great example of how dynamic programming concepts can be integrated with practical coding strategies in competitive programming and technical interviews.

### Problem Statement

The problem asks us to **remove comments** from a list of strings that represent lines of source code. The comments can either be:
- **Single-line comments** that begin with `//`.
- **Multi-line comments** that begin with `/*` and end with `*/`.

The task is to return the source code without any comments, preserving the structure of the original code. The result should not include any lines that are completely empty due to comment removal.

### Approach

The solution uses a **state-machine-based approach** to handle both single-line and multi-line comments. Here's the breakdown of the approach:

1. **State Management**: The algorithm keeps track of whether we are inside a multi-line comment (`is_mul` flag) or not. This allows us to differentiate between lines of actual code and comments.
  
2. **Handling Single-line Comments**: When the algorithm encounters a `//`, it skips the rest of the line because it's a single-line comment.

3. **Handling Multi-line Comments**: When the algorithm encounters a `/*`, it toggles the `is_mul` flag to indicate that it’s inside a multi-line comment. It continues to skip characters until it encounters a closing `*/`, at which point the flag is reset.

4. **String Construction**: The code constructs the non-commented portions of the string in the `res` variable. If a line does not contain any code after removing comments, it is skipped; otherwise, the cleaned line is added to the result.

5. **Result Construction**: After processing all lines of code, the result is returned as a vector of strings that contains the code with comments removed.

### Code Breakdown (Step by Step)

#### Initialization
```cpp
vector<string> ans;
bool is_mul = false;
string res = "";
```
- `ans`: A vector that stores the cleaned code lines.
- `is_mul`: A boolean flag that indicates whether the current position in the code is inside a multi-line comment (`/*...*/`).
- `res`: A temporary string that accumulates the non-comment characters for each line.

#### Loop Over Each Line of Code
```cpp
for(int i = 0; i < source.size(); i++) {
    string str = source[i];
    res = is_mul ? res : "";
```
- The algorithm iterates over each line in the `source` code. For each line, it checks if we are currently inside a multi-line comment. If so, `res` retains the characters collected so far; otherwise, it resets `res` to start collecting the next line’s characters.

#### Loop Through Each Character in the Line
```cpp
for(int j = 0; j < str.size(); j++) {
    if(!is_mul) {
        if (j < str.size() - 1 && str[j] == '/' && str[j + 1] == '/') {
            break;
        } else if (j < str.size() - 1 && str[j] == '/' && str[j + 1] == '*') {
            is_mul = true;
            j++;
        } else {
            res += str[j];
        }
    } else {
        if(j < str.size() - 1 && str[j] == '*' && str[j + 1] == '/') {
            is_mul = false;
            j++;
        }
    }
}
```
- **Single-line comments**: If a `//` is encountered, the algorithm breaks out of the loop because the rest of the line is a comment.
- **Multi-line comments**: If a `/*` is encountered, the algorithm toggles the `is_mul` flag to `true` and skips the next character to handle the multi-line comment’s starting point. When `*/` is encountered inside a multi-line comment, the flag is reset to `false` and the algorithm continues parsing the remaining code.

#### Finalizing the Line
```cpp
if(!is_mul && res != "") ans.push_back(res);
```
- If the algorithm has finished processing the line and is not inside a multi-line comment (`is_mul == false`), it checks if `res` contains any non-commented content. If so, the line is added to the `ans` vector.

#### Return the Result
```cpp
return ans;
```
- After processing all the lines, the function returns the `ans` vector, which contains the cleaned source code with all comments removed.

### Complexity Analysis

- **Time Complexity**: The algorithm processes each character of the source code once. The outer loop iterates through all the lines, and the inner loop processes every character in each line. Thus, the time complexity is **O(n)**, where `n` is the total number of characters in the input `source`.

- **Space Complexity**: The space complexity is **O(n)** as well, where `n` is the total number of characters in the input. The space is used to store the cleaned code lines in the `ans` vector and the temporary `res` string used for building each line.

### Conclusion

This solution efficiently removes both single-line and multi-line comments from a list of source code lines. It uses a simple yet effective approach by managing the state of the algorithm using the `is_mul` flag to track whether we are inside a multi-line comment. It processes each line and each character once, ensuring that the solution runs efficiently even for larger codebases. The algorithm is both time and space efficient, with complexities of **O(n)** for both time and space, where `n` is the total number of characters in the input. This makes it scalable for large inputs, while also ensuring correctness by handling nested and unbalanced comments effectively.
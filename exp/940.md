### Problem Statement

Given a string `S` consisting of lowercase English letters, the task is to find the number of distinct non-empty subsequences of `S`. A subsequence is defined as a sequence derived by deleting some (or no) elements from the original string without changing the order of the remaining characters.

The challenge is to calculate the number of distinct subsequences modulo `10^9 + 7`, ensuring that all the subsequences are unique.

### Approach

To solve the problem efficiently, we can use dynamic programming (DP) to keep track of the number of subsequences that end with each character in the string. Here's a step-by-step breakdown of the approach:

1. **Understanding Subsequences**:
   - A subsequence can be formed by including or excluding each character from the original string. For example, if the string is `abc`, the possible subsequences include `a`, `b`, `c`, `ab`, `ac`, `bc`, and `abc`.
   - A dynamic programming approach can be used to keep track of the number of subsequences that end with each character.

2. **Dynamic Programming Array**:
   - We maintain an array `endsWith[26]` where each index corresponds to a character ('a' to 'z') and stores the number of subsequences that end with that character.
   - The size of this array is 26, as there are 26 lowercase English letters.

3. **Recurrence Relation**:
   - For each character `c` in the string `S`, the number of subsequences that end with `c` can be derived from the following logic:
     - Every subsequence that already exists can either:
       1. **Exclude** the current character, in which case we have all the subsequences from previous steps.
       2. **Include** the current character, in which case we add the character to each subsequence formed in previous steps.
   - This gives a total of `2 * endsWith[c]` subsequences, as we either include or exclude each character.
   - However, if the character `c` has appeared before, we need to subtract the subsequences where it was previously counted. This avoids over-counting subsequences where `c` appears more than once.

4. **Final Count**:
   - At the end of the iteration, the sum of all values in `endsWith` gives the number of distinct subsequences. We subtract 1 to account for the empty subsequence (since the problem asks for non-empty subsequences).
   - The result is taken modulo `10^9 + 7` to prevent overflow and to satisfy the problem constraints.

### Code Breakdown (Step by Step)

1. **Initialization**:
   ```cpp
   int endsWith[26] = {}, mod = 1e9 + 7;
   auto lambda = [&](int s, int i) { return (s + i) % mod; };
   ```
   - `endsWith[26]` is an array that keeps track of the number of subsequences that end with each character from 'a' to 'z'.
   - `mod = 1e9 + 7` is used to store the modulo value to prevent overflow.
   - `lambda` is a helper function for performing the modulo operation in the accumulate function.

2. **Loop Over Characters in String**:
   ```cpp
   for (char c : S)
       endsWith[c - 'a'] = accumulate(begin(endsWith), end(endsWith), 1, lambda);
   ```
   - We iterate over each character `c` in the string `S`.
   - `endsWith[c - 'a']` is updated by accumulating all previous values in `endsWith` plus 1. This accounts for the addition of the current character to all existing subsequences, as well as the subsequence formed by just the current character.

3. **Calculate Final Result**:
   ```cpp
   return accumulate(begin(endsWith), end(endsWith), 0, lambda);
   ```
   - After processing all characters in `S`, we compute the final result by accumulating all values in the `endsWith` array.
   - The sum of these values gives the total number of distinct subsequences, and the result is returned modulo `10^9 + 7`.

### Complexity

1. **Time Complexity**:
   - The time complexity of this solution is O(n), where `n` is the length of the input string `S`. This is because we iterate over each character of the string once and perform a constant-time update to the `endsWith` array for each character.
   - The `accumulate` function runs in O(26) time (since there are 26 possible characters), which is a constant and does not affect the overall time complexity.

2. **Space Complexity**:
   - The space complexity is O(1) in terms of auxiliary space since the `endsWith` array has a fixed size of 26, independent of the input size. The space used for the result is constant.

### Conclusion

This solution efficiently computes the number of distinct subsequences in a string using dynamic programming. By keeping track of subsequences that end with each character and updating the count based on the inclusion or exclusion of each character, we can compute the result in linear time. The use of modulo `10^9 + 7` ensures that the result fits within the problem's constraints, preventing overflow. This approach is both time-efficient and space-efficient, making it ideal for solving this problem in competitive programming and real-world applications.


### Problem Statement
The task is to add two binary numbers represented as arrays in negabinary format. In negabinary, digits can be either 0 or 1, and the base is -2. Each element in the input arrays represents a digit, with the least significant digit at the end of the array. The goal is to compute the sum and return the result in the same array format, ensuring that any leading zeros in the result are removed.

### Approach
To solve this problem, we can simulate the addition of two numbers digit by digit, accounting for the unique characteristics of negabinary. We need to handle carryovers carefully since the base is negative. The key steps in the approach are as follows:
1. Initialize pointers for both input arrays and a variable to store the carry.
2. Loop through both arrays from the least significant digit to the most significant digit, adding corresponding digits along with the carry.
3. Determine the resulting digit and the new carry based on the sum.
4. After processing all digits, handle any remaining carry.
5. Clean up the resulting array by removing leading zeros and reversing the result to return it in the correct order.

### Code Breakdown (Step by Step)

1. **Class Definition**:
   The `Solution` class encapsulates the method to perform the negabinary addition.

   ```cpp
   class Solution {
   public:
   ```

2. **Function Signature**:
   The method `addNegabinary` takes two vectors (arrays) of integers as inputs and returns a vector representing the sum.

   ```cpp
   vector<int> addNegabinary(vector<int>& arr1, vector<int>& arr2) {
   ```

3. **Initialization**:
   We initialize the carry variable to 0 and set two pointers, `i` and `j`, to point to the last elements of `arr1` and `arr2`, respectively. An empty vector `res` is created to store the result.

   ```cpp
   int carry = 0, i = arr1.size() - 1, j = arr2.size() - 1;
   vector<int> res;
   ```

4. **Main Loop for Addition**:
   We use a while loop that continues as long as there is a carry or there are remaining digits in either array. Inside the loop:
   - We check if there are still digits left in `arr1` or `arr2` and add them to the carry.
   - We calculate the current result digit using the bitwise AND operation and store it in the `res` vector.
   - We then update the carry for the next iteration by right-shifting and negating the carry value, as this handles the transition due to the negabinary base.

   ```cpp
   while(carry || i >= 0 || j >= 0) {
       if(i >= 0) carry += arr1[i--];
       if(j >= 0) carry += arr2[j--];
       res.push_back(carry & 1);
       carry = -(carry >> 1);
   }
   ```

5. **Removing Leading Zeros**:
   After the main addition loop, we check if the resulting vector has more than one element and if the last element is 0 (indicating a leading zero). We then remove any trailing zeros.

   ```cpp
   while(res.size() > 1 && res.back() == 0)
       res.pop_back();
   ```

6. **Reversing the Result**:
   Since we constructed the result from the least significant to the most significant digit, we need to reverse the `res` vector to get the correct order.

   ```cpp
   reverse(res.begin(), res.end());
   ```

7. **Returning the Result**:
   Finally, the method returns the `res` vector containing the sum in negabinary format.

   ```cpp
   return res;
   }
   ```

### Complexity Analysis
- **Time Complexity**: The overall time complexity is \(O(n + m)\), where \(n\) is the length of `arr1` and \(m\) is the length of `arr2`. This complexity arises because we traverse both arrays entirely during the addition process.
  
- **Space Complexity**: The space complexity is \(O(k)\), where \(k\) is the maximum possible length of the result array. In the worst-case scenario, the result could be as long as the longer input array plus one additional digit (if there's a carry).

### Conclusion
The provided C++ code effectively solves the problem of adding two numbers in negabinary format by simulating the addition process as one would do in standard binary addition but adjusting for the unique properties of a negative base. The approach uses a straightforward iterative method, and the implementation is clean and efficient.

By carefully managing the carry and utilizing bitwise operations, this solution efficiently constructs the sum while handling potential leading zeros in the final output. The algorithm's time and space complexity are optimal for the problem at hand, making this solution suitable for competitive programming and practical applications where negabinary arithmetic is required.

In summary, this method offers a clear and concise way to perform negabinary addition, showcasing the importance of understanding numerical systems and their properties in algorithm design.

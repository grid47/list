### Problem Statement

The problem "Stone Game" is a two-player game where players take turns removing stones from piles. Given an array representing the number of stones in each pile, the goal is to determine whether the first player can always win, assuming both players play optimally.

The players take turns removing stones from either the leftmost or the rightmost pile. The winner is determined by the total number of stones they collect. The task is to determine if the first player (starting first) can always win given the array of piles.

### Example:

- **Input**: `[5, 3, 4, 5]`
- **Output**: `true` (The first player can always win.)

In this example, the optimal play would be for the first player to select the pile with 5 stones on the left, leaving the opponent with piles `[3, 4, 5]`. The first player can then choose the next pile with 5 stones to guarantee a win.

### Approach

To solve this problem, we use a **dynamic programming** approach with **memoization** to avoid redundant computations. We will define a function `dp(i, j)` that computes the maximum difference in score the current player can achieve over the opponent, when considering piles from index `i` to `j` (both inclusive). The optimal strategy for the player is to maximize their score while minimizing the opponent's score.

#### Key Insights:
1. **Two Choices**: At any step, the player can pick either the leftmost pile (`piles[i]`) or the rightmost pile (`piles[j]`).
2. **Recursion**: The recurrence is based on the fact that the current player’s score is the maximum of:
   - Choosing the leftmost pile and then minimizing the opponent’s score from the remaining piles, or
   - Choosing the rightmost pile and then minimizing the opponent’s score from the remaining piles.
3. **Memoization**: We use memoization to store the results of previously computed subproblems (ranges `[i, j]`) to speed up the solution.

#### Plan:
1. Use recursion to compute the optimal score difference.
2. Memoize the results to avoid recomputation.
3. Return `true` if the first player's score difference is greater than or equal to zero (i.e., they can win).

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    vector<int> p;
    int n;
    map<int, map<int,int>> memo;

    // The dp function computes the maximum score difference.
    bool dp(int i, int j) {
        // Base case: when there's only one pile left.
        if (i == j) return p[i];
        
        // Check if the result has been memoized.
        if (memo.count(i) && memo[i].count(j)) return memo[i][j];
        
        // Recursive step: Player chooses between picking the i-th or j-th pile.
        return memo[i][j] = max(p[i] - dp(i + 1, j), p[j] - dp(i, j - 1));
    }
    
    bool stoneGame(vector<int>& piles) {
        this->p = piles;  // Store the piles array.
        n = piles.size();  // Get the size of the piles array.
        return dp(0, n - 1) >= 0;  // Check if the first player can win.
    }
};
```

#### Detailed Breakdown:

1. **Class and Variables**:
   - We define the class `Solution` with a public method `stoneGame` that solves the problem.
   - We declare a vector `p` to store the piles and an integer `n` to store the number of piles.
   - We use a `map<int, map<int, int>>` called `memo` to store the results of subproblems. The first `int` represents the start index of the subproblem, and the second `int` represents the end index of the subproblem.

2. **dp Function**:
   - The `dp(int i, int j)` function computes the maximum score difference (first player’s score minus the opponent’s score) for the subarray of piles from index `i` to index `j`.
   - **Base Case**: When `i == j`, the subarray contains only one pile, and the current player can only take that pile, returning the value of `p[i]`.
   - **Memoization Check**: Before computing the result, we check if the result for the subarray `[i, j]` has already been computed and stored in the `memo` map. If it exists, we return the cached result to avoid recomputation.
   - **Recursive Step**: The recursive step tries both options: 
     - Pick the pile at index `i` and subtract the result of the opponent's move from the range `[i+1, j]`.
     - Pick the pile at index `j` and subtract the result of the opponent's move from the range `[i, j-1]`.
     - The optimal choice is the one that maximizes the current player's score while minimizing the opponent's score.

3. **stoneGame Function**:
   - The `stoneGame` function is the entry point. It initializes the `p` vector with the given piles and calls the `dp` function on the full range of piles `[0, n-1]`.
   - The result of `dp(0, n - 1)` will be greater than or equal to 0 if the first player can win. If the score difference is non-negative, the first player wins, and we return `true`.

### Complexity Analysis

#### Time Complexity:
- The time complexity of the solution is **O(n^2)**, where `n` is the number of piles. This is because for each pair of indices `(i, j)`, we are computing the result once, and there are `O(n^2)` such pairs.
- Memoization ensures that we compute the result for each pair only once, avoiding redundant calculations.

#### Space Complexity:
- The space complexity is **O(n^2)** due to the memoization map, which stores the results of all subproblems `(i, j)`.

### Conclusion

This solution effectively solves the problem using dynamic programming and memoization to avoid redundant calculations. By recursively calculating the optimal score difference for each subarray, we can determine if the first player can always win. The memoization map ensures that each subproblem is computed only once, improving efficiency.

- **Time Complexity**: O(n^2), where `n` is the number of piles.
- **Space Complexity**: O(n^2) for storing the results of subproblems.

This approach guarantees an optimal solution while minimizing the number of redundant computations.
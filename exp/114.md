### Problem Statement

The problem is to **flatten a binary tree** into a linked list in-place. The flattening should be done by modifying the tree such that the left child of each node is set to `nullptr` and the right child points to the next node in a pre-order traversal sequence.

Given the following binary tree:

```
          1
         / \
        2   5
       / \   \
      3   4   6
```

After flattening, the tree should look like:

```
1
 \
  2
   \
    3
     \
      4
       \
        5
         \
          6
```

The tree structure is modified such that the tree is "flattened" into a linked list where every node's left child is `nullptr` and the right child points to the next node in the pre-order traversal.

### Approach

The goal of the problem is to flatten the binary tree into a linked list using **pre-order traversal**. The steps involved are:

1. **Start from the root:** Begin by checking if the root is `NULL`. If the root is `NULL`, the tree is already empty, and no further processing is needed.

2. **Flatten the left subtree:** Recurse on the left child of the current node. Before moving to the left subtree, store the right child because it will be needed after flattening the left child.

3. **Rearrange the nodes:** After flattening the left subtree, make the current node's left child `NULL` (because it should now be a linked list, so no left child should remain). Then, the right child of the current node should point to the flattened left subtree.

4. **Traverse to the end of the right subtree:** Once the left subtree has been flattened, traverse to the end of the newly formed right subtree (which contains the flattened left subtree) and attach the original right subtree to the end of the list.

5. **Recursive Flattening:** Recursively call the flatten function on the right child of the current node. This will continue the flattening process.

### Code Breakdown (Step by Step)

Let's walk through the code to see how the problem is solved step by step:

#### 1. Function Definition:

```cpp
void flatten(TreeNode* root) {
    if( root == NULL) return;
```

- This is the base case of the recursive function. If the root is `NULL`, then there is no tree to flatten, so the function simply returns.

#### 2. Temporarily Save the Right Child:

```cpp
    TreeNode* tmp = root->right;
```

- We temporarily store the right child of the current root node in the `tmp` variable. This is done because we will be modifying the tree's structure, and we need to preserve the original right child for later use.

#### 3. Move the Left Subtree to the Right:

```cpp
    root->right = root->left;
    root->left = nullptr;
```

- Now, we move the left child of the current node to the right child position. This is the critical operation where we begin transforming the tree into a linked list structure.
- After that, we set the left child to `nullptr`, since the binary tree should no longer have left children after flattening.

#### 4. Traverse to the End of the New Right Subtree:

```cpp
    TreeNode* node = root;
    while(node->right) node = node->right;
```

- Now that the left subtree has been moved to the right, we need to find the last node in this newly created right subtree. We do this by iterating through the right child of the current node until we reach the last node (i.e., the node with no right child).
- This step is necessary because we need to attach the original right subtree to the end of the flattened left subtree.

#### 5. Attach the Original Right Subtree:

```cpp
    node->right = tmp;
```

- Once we find the last node in the right subtree, we attach the original right subtree (stored in `tmp`) to the `right` child of this last node. This ensures that the original right child is placed correctly in the flattened tree.

#### 6. Recursively Flatten the Right Subtree:

```cpp
    flatten(root->right);
}
```

- Finally, we recursively call the `flatten` function on the right child of the current node. This will flatten the rest of the tree, starting from the modified right subtree.

### Time Complexity

The time complexity of the solution is **O(n)**, where `n` is the number of nodes in the binary tree. This is because each node is visited exactly once during the recursive traversal, and the operations inside each function call (such as setting pointers and traversing the tree) take constant time.

### Space Complexity

The space complexity is **O(h)**, where `h` is the height of the binary tree. This space is used by the recursion stack. In the worst case (unbalanced tree), the height of the tree could be equal to `n`, resulting in a space complexity of **O(n)**. In the best case (balanced tree), the height of the tree is **O(log n)**, resulting in a space complexity of **O(log n)**.

### Conclusion

This solution efficiently flattens a binary tree into a linked list in place by using pre-order traversal. The algorithm performs the flattening operation in **O(n)** time, where `n` is the number of nodes in the tree. The space complexity is **O(h)**, where `h` is the height of the tree, due to the recursive function calls. This approach ensures that the tree is transformed into the desired linked list structure without requiring any extra data structures, making it space-efficient.

The recursive approach is elegant and easy to understand. By recursively flattening the left subtree and attaching the original right subtree at the end, the tree is gradually transformed into a flattened list. This method handles all edge cases, including trees with no nodes or trees with only one node, without requiring additional checks.

In summary, the problem is solved optimally using a simple recursive strategy that transforms the binary tree into a pre-order linked list. The time complexity and space complexity are both efficient for this type of problem.
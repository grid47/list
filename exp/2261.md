### Problem Statement

In this problem, you are given an array `nums` of integers, an integer `k`, and an integer `p`. The goal is to count how many distinct subarrays of `nums` exist such that the number of elements divisible by `p` in each subarray is **at most k**. A subarray is defined as a contiguous portion of the array.

### Approach

To efficiently solve the problem, we can break the task down into several steps:
1. **Iterate Over All Possible Subarrays**: We need to find all possible subarrays in `nums`. For each subarray, we will keep track of how many elements are divisible by `p`.
2. **Condition on the Number of Divisible Elements**: For each subarray, if the number of divisible elements is greater than `k`, we should discard that subarray.
3. **Hash Subarrays**: To count distinct subarrays, we use a hash-based approach to ensure that we don't count the same subarray multiple times.
4. **Efficiently Track Hashes and Divisibility**: We can use a sliding window approach to move through subarrays and update the count of divisible elements as we progress.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables

```cpp
int res = 0, n = nums.size();
vector<int> cnt(201, 0); 
vector<long long> hash(201, 0);
```

- `res` keeps track of the number of distinct subarrays that meet the condition.
- `n` is the size of the input array `nums`.
- `cnt` is an array of size 201, used to track the number of elements divisible by `p` in the subarray.
- `hash` is an array that holds the hash values for subarrays to ensure distinctness.

#### Step 2: Iterate Over All Possible Subarrays

```cpp
for (int sz = 0; sz < n; sz++) {
    unordered_set<int> s;
    for(int i = 0; i + sz < n; i++) {
```

- The outer loop (`sz`) iterates through all possible subarray sizes from 0 to `n-1`.
- The inner loop (`i`) iterates through all starting positions for a subarray of size `sz`.

#### Step 3: Update Count of Divisible Elements

```cpp
cnt[i] += ((nums[i + sz] % p) == 0);
```

- For each subarray, we increment the count of divisible elements by `p` for the element `nums[i + sz]`. If the element is divisible by `p`, we increment the count for that starting index `i` in the `cnt` array.

#### Step 4: Check if Subarray Meets the Condition

```cpp
if(cnt[i] <= k) {
    hash[i] = (hash[i] * 200 + nums[i + sz]) % 1000000007;
    res += s.insert(hash[i]).second;
}
```

- If the count of elements divisible by `p` is less than or equal to `k`, we calculate the hash for the subarray.
- The hash is calculated by multiplying the current hash by 200 (a chosen constant) and adding the current number (`nums[i + sz]`).
- The result is taken modulo `1000000007` to avoid overflow and ensure that we do not get collisions in the hash values.
- We use an unordered set `s` to ensure that we only count distinct subarrays. The `insert` method returns `true` if the subarray's hash was not previously seen, and `false` otherwise. We add to `res` when a new subarray is encountered.

#### Step 5: Return the Result

```cpp
return res;
```

- After processing all subarrays, the variable `res` contains the number of distinct subarrays that satisfy the condition.

### Complexity

#### Time Complexity:
The time complexity of this solution is **O(n^2)**. The outer loop iterates `n` times, and for each subarray size, the inner loop iterates over all possible starting indices for the subarray. The hashing operation and insertion into the set take **O(1)** time on average. Therefore, the overall time complexity is **O(n^2)**.

#### Space Complexity:
The space complexity is **O(n)**. We use extra space for the `cnt` and `hash` arrays, both of which are of size `n`. Additionally, we use an unordered set to store hash values of subarrays, which in the worst case will store all possible subarrays. Therefore, the space complexity is linear in terms of the number of subarrays.

### Conclusion

This solution uses a hash-based approach to count distinct subarrays where the number of elements divisible by `p` is at most `k`. By iterating through all possible subarrays and using a set to ensure distinctness, the algorithm efficiently computes the desired result. The time complexity of **O(n^2)** is acceptable for moderately sized input arrays, and the space complexity of **O(n)** is also reasonable given the problem constraints. This solution balances clarity and efficiency, making it a good choice for solving this problem.
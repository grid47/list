## Problem Statement
Given a binary tree, place the minimum number of cameras to monitor all nodes. Each camera at a node monitors its parent, itself, and its immediate children.

## Approach
1. **Define States**:
   - Each node can be in one of three states:
     - **0**: The node needs a camera.
     - **1**: The node has a camera.
     - **2**: The node is covered but does not have a camera.
2. **DFS Traversal**:
   - Use a depth-first search to decide the state of each node starting from the leaves up to the root.
   - **Base Case**: If the node is `nullptr`, return `2` (covered without a camera).
3. **Node State Logic**:
   - If either child node needs a camera (state 0), place a camera at the current node, increment the result counter `res`, and return `1` (has a camera).
   - If either child has a camera (state 1), the current node is covered without needing a camera, so return `2`.
   - If both children are covered (state 2), the current node needs a camera, so return `0`.

4. **Final Check**:
   - After the DFS completes, check the root node. If it still needs a camera, increment `res`.

## Code Walk-through
- **`int minCameraCover(TreeNode* root)`**:
  - Calls `dfs(root)` to determine if the root itself needs a camera.
  - Returns the total number of cameras required (`res`), adding one if the root is unmonitored.
  
- **`int dfs(TreeNode* root)`**:
  - Recursively determines the state of each child.
  - Applies the node state rules to decide whether the current node requires or has a camera.

## Complexity
- **Time Complexity**: O(n), where `n` is the number of nodes, since each node is visited once.
- **Space Complexity**: O(h), where `h` is the height of the tree due to recursive stack space.

This approach leverages DFS to minimize the number of cameras by deciding each node's state based on its children's states.

### Problem Statement

The problem requires implementing a function to determine if a given string `s` matches a pattern `p`. The pattern `p` may contain the following special characters:

- `?`: Matches any single character.
- `*`: Matches any sequence of characters (including an empty sequence).

Given these rules, the task is to return `true` if the string `s` matches the pattern `p`, otherwise return `false`.

### Approach

To solve this problem, we will use dynamic programming (DP) to store intermediate results of the subproblems and avoid redundant recalculations. We’ll define a DP table where each entry `dp(i, j)` represents whether the substring `s[0..i-1]` matches the substring `p[0..j-1]`. This table will help break down the matching process into smaller, manageable subproblems, significantly improving efficiency.

The solution can be divided into three main parts:

1. **Base Cases**: Handle simple cases where either the pattern or string has reached its end.
2. **Recursive Matching with Memoization**: For each character in the string and pattern, use a recursive approach to explore possible matches, storing results to prevent recomputation.
3. **Wildcard Handling**: Special logic to handle the `?` and `*` characters in the pattern.

### Code Breakdown (Step by Step)

#### Step 1: Class Definition and Initialization

```cpp
string s, p;
vector<vector<int>> memo;
```

- `s` represents the input string, and `p` represents the pattern string.
- `memo` is a 2D vector that will store the results of subproblems. The dimensions of this vector are `(s.size() + 1)` by `(p.size() + 1)` to handle all possible combinations of string and pattern indices, including the base case where both strings are empty.

#### Step 2: Base Case Checks in the Recursive Function

```cpp
if(i == s.size() && j == p.size()) return true;
if(j == p.size()) return false;
```

- The first base case checks if both the string `s` and the pattern `p` have been fully matched (i.e., both indices `i` and `j` have reached the end of the respective strings). If true, the function returns `true`.
- The second base case checks if the pattern `p` has been exhausted but the string `s` still has characters left. If so, return `false` because the pattern cannot match anymore.

#### Step 3: Memoization Check

```cpp
if(memo[i][j] != -1) return memo[i][j];
```

- This line checks if the result for the current pair of indices `(i, j)` has already been computed. If so, the value is returned from the `memo` table to avoid recomputation and improve efficiency.

#### Step 4: Matching Logic

```cpp
int ans = false;
if(i < s.size() && s[i] == p[j]) {
    ans |= dp(i + 1, j + 1);
} else if(p[j] == '?') {
    if(i == s.size()) return false;
    else ans |= dp(i+1, j+1);
} else if(p[j] == '*') {
    if(i < s.size()) ans |= dp(i+1, j);
    ans |= dp(i, j+1);
}
```

- If the current characters `s[i]` and `p[j]` match, or if the pattern has a `?`, we recursively check the next characters in both the string and the pattern.
- If the current character in the pattern is a `*`, it can match any sequence of characters. We explore two possibilities:
  - Consider `*` as matching an additional character in `s` (i.e., advance `i` but keep `j` the same).
  - Consider `*` as matching an empty sequence (i.e., advance `j` but keep `i` the same).

#### Step 5: Storing the Result in the Memoization Table

```cpp
return memo[i][j] = ans;
```

- After exploring all possible matches, we store the result in the `memo` table for the current pair of indices `(i, j)`. This ensures that the same subproblem is not solved multiple times.

#### Step 6: The `isMatch` Function

```cpp
bool isMatch(string s, string p) {
    this->s = s;
    this->p = p;
    memo.resize(s.size() + 1, vector<int>(p.size() + 1, -1));
    return dp(0, 0);
}
```

- The `isMatch` function is the entry point that initializes the string `s`, pattern `p`, and the `memo` table.
- It then calls the recursive `dp` function starting from index 0 of both the string and the pattern.

### Complexity

#### Time Complexity

The time complexity of this solution depends on the number of subproblems that need to be solved. Since the string `s` has `n` characters and the pattern `p` has `m` characters, the total number of subproblems is `O(n * m)`. Each subproblem involves a constant amount of work, so the overall time complexity is:

- **Time Complexity:** `O(n * m)`

#### Space Complexity

The space complexity is determined by the size of the `memo` table, which has dimensions `(n + 1) x (m + 1)` to store the results of all subproblems. Thus, the space complexity is:

- **Space Complexity:** `O(n * m)`

Additionally, the recursive function uses the call stack, which can go as deep as `n + m` in the worst case. However, since the memoization avoids recomputing values, this doesn’t add significant overhead.

### Conclusion

This solution efficiently handles the string matching problem with the `?` and `*` wildcards by leveraging dynamic programming with memoization. The use of a 2D table allows us to solve overlapping subproblems without redundant calculations, ensuring that the algorithm runs efficiently even for larger inputs. The time complexity is `O(n * m)`, making it suitable for strings and patterns of moderate size, and the space complexity is also `O(n * m)` due to the memoization table. This approach is an optimal solution for pattern matching with wildcards, providing both correctness and efficiency.
### üìú **Pattern Matching with Wildcards (`?` and `*`)**

The problem involves matching a string `s` against a pattern `p` that can include two special wildcard characters:

- `?`: Matches any single character.
- `*`: Matches any sequence of characters (including an empty sequence).

The task is to return `true` if the string `s` matches the pattern `p`, and `false` otherwise. To solve this problem efficiently, we can use dynamic programming (DP) to store intermediate results and avoid redundant computations.

---

### üöÄ **Approach**

We will use a DP approach where we maintain a 2D table `dp` where each entry `dp(i, j)` represents whether the substring `s[0..i-1]` matches the substring `p[0..j-1]`. The key idea is to break down the problem into manageable subproblems and leverage memoization to store the results of these subproblems.

---

### üñ•Ô∏è **Code Breakdown (Step-by-Step)**

#### Step 1: Class Definition and Initialization

```cpp
string s, p;
vector<vector<int>> memo;
```

- `s` is the input string, and `p` is the pattern string.
- `memo` is a 2D vector that will store the results of subproblems. Each element `memo[i][j]` stores whether the substring `s[0..i-1]` matches the substring `p[0..j-1]`.

#### Step 2: Base Case Checks

```cpp
if(i == s.size() && j == p.size()) return true;
if(j == p.size()) return false;
```

- **Base Case 1:** If both the string and the pattern have been fully matched (i.e., `i` and `j` have reached the end of `s` and `p`), return `true`.
- **Base Case 2:** If the pattern is exhausted but the string still has characters left, return `false`.

#### Step 3: Memoization Check

```cpp
if(memo[i][j] != -1) return memo[i][j];
```

- If the result for the current pair of indices `(i, j)` has already been computed, return the value from `memo` to avoid redundant calculations.

#### Step 4: Matching Logic

```cpp
int ans = false;
if(i < s.size() && s[i] == p[j]) {
    ans |= dp(i + 1, j + 1);
} else if(p[j] == '?') {
    if(i == s.size()) return false;
    else ans |= dp(i+1, j+1);
} else if(p[j] == '*') {
    if(i < s.size()) ans |= dp(i+1, j);
    ans |= dp(i, j+1);
}
```

- If the characters `s[i]` and `p[j]` match directly, or if `p[j]` is `?` (which matches any character), we recursively check the next characters in both `s` and `p`.
- If `p[j]` is `*`, it can match any sequence of characters. We explore two possibilities:
  - Consider `*` as matching an additional character in `s` (i.e., advance `i` but keep `j` the same).
  - Consider `*` as matching an empty sequence (i.e., advance `j` but keep `i` the same).

#### Step 5: Store the Result in Memoization Table

```cpp
return memo[i][j] = ans;
```

- After computing the result for the current pair of indices `(i, j)`, store the result in `memo[i][j]` to avoid recomputing the same subproblem in the future.

#### Step 6: The `isMatch` Function

```cpp
bool isMatch(string s, string p) {
    this->s = s;
    this->p = p;
    memo.resize(s.size() + 1, vector<int>(p.size() + 1, -1));
    return dp(0, 0);
}
```

- The `isMatch` function initializes the `s` and `p` strings, sets up the memoization table (`memo`), and calls the recursive `dp` function starting from the beginning of both the string and the pattern.

---

### üßÆ **Time and Space Complexity**

#### Time Complexity:
- The time complexity depends on the number of subproblems that need to be solved. Since `s` has `n` characters and `p` has `m` characters, the total number of subproblems is `O(n * m)`. Each subproblem involves a constant amount of work (checking characters and recursive calls), so the overall time complexity is:
  - **Time Complexity:** `O(n * m)`

#### Space Complexity:
- The space complexity is determined by the size of the `memo` table, which has dimensions `(n + 1) x (m + 1)` to store the results of all subproblems. Thus, the space complexity is:
  - **Space Complexity:** `O(n * m)`

Additionally, the recursive calls use the call stack, which can go as deep as `n + m` in the worst case, but memoization minimizes redundant work, reducing the impact of the recursion depth.

---

### üèÅ **Conclusion**

This solution efficiently handles the pattern matching problem with `?` and `*` wildcards using dynamic programming with memoization. The 2D table stores intermediate results to avoid redundant computations, ensuring that the algorithm runs efficiently even for larger inputs. With a time complexity of `O(n * m)` and space complexity of `O(n * m)`, this approach provides both correctness and efficiency for solving wildcard pattern matching problems.
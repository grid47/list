### Problem Statement
You are given `K` eggs and a building with `N` floors. Your task is to find the minimum number of attempts needed in the worst case to determine the highest floor from which an egg can be dropped without breaking.

### Approach
This problem can be solved using dynamic programming (DP). The main idea is to build a DP table where the entry `dp[m][k]` represents the maximum number of floors that can be checked with `k` eggs and `m` moves.

1. **Initialization**:
   - Create a DP table `dp` with dimensions \((N + 1) \times (K + 1)\), initialized to 0.
   - `m` is initialized to track the number of moves.

2. **DP Table Filling**:
   - Incrementally increase `m` (the number of moves) until `dp[m][K]` (maximum floors with `K` eggs and `m` moves) is at least `N`.
   - For each `k` from 1 to `K`, calculate:
     \[
     dp[m][k] = dp[m-1][k-1] + dp[m-1][k] + 1
     \]
     where:
     - `dp[m-1][k-1]` accounts for the scenario where the egg breaks.
     - `dp[m-1][k]` accounts for the scenario where the egg does not break.
     - The `+1` accounts for the current floor being tested.

3. **Result**:
   - The minimum number of moves `m` needed to guarantee determining the highest safe floor is found when `dp[m][K]` is greater than or equal to `N`.

### Code Walk-through
- The outer while loop continues until the maximum floors reachable with `K` eggs meets or exceeds `N`.
- The inner for loop updates the DP table based on the recurrence relation until the correct number of attempts is found.

### Complexity
- **Time Complexity**: \(O(K \cdot m)\), where `m` is the number of moves needed, which can be at most \(N\).
- **Space Complexity**: \(O(N \cdot K)\) for the DP table.


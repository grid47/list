### Problem Statement

The "Super Egg Drop" problem is a classic dynamic programming problem that asks you to determine the minimum number of moves required to find the highest floor from which an egg can be dropped without breaking, given a certain number of eggs `K` and a building with `N` floors. The key challenge is that if an egg is dropped and it does not break, it can be reused, but if it breaks, it cannot be used again. The goal is to minimize the number of drops required to guarantee finding the critical floor (the highest floor from which an egg can be dropped without breaking) using the fewest possible moves.

### Approach

To solve this problem optimally, we use dynamic programming. The key idea is to maintain a table (`dp`) where `dp[m][k]` represents the maximum number of floors that can be tested with `k` eggs and `m` moves. The approach leverages the following logic:
1. If we drop an egg from a floor:
   - If the egg breaks, the problem reduces to `k-1` eggs and `m-1` moves, and we test the floors below the current floor.
   - If the egg does not break, the problem reduces to `k` eggs and `m-1` moves, and we test the floors above the current floor.
   
2. The goal is to find the smallest `m` such that `dp[m][K]` (maximum floors that can be tested with `K` eggs and `m` moves) is greater than or equal to `N` (the number of floors in the building).

This problem can be thought of as trying to balance the exploration of the floor range while minimizing the number of drops required. The idea is to drop an egg from a floor in such a way that the maximum number of floors we can test in the worst case is maximized, which reduces the number of drops required.

### Code Breakdown (Step by Step)

1. **Initialization**:
   ```cpp
   vector<vector<int>> dp(N + 1, vector<int>(K + 1, 0));
   int m = 0;
   ```
   - We initialize a 2D vector `dp` of size `(N+1) x (K+1)`, where `dp[i][j]` represents the maximum number of floors that can be tested with `j` eggs and `i` moves.
   - Initially, the `dp` table is filled with zeros.
   - We start with `m = 0`, which represents the number of moves.

2. **Filling the DP Table**:
   ```cpp
   while (dp[m][K] < N) {
       m++;
       for (int k = 1; k <= K; ++k)
           dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1;
   }
   ```
   - We increment the number of moves `m` and compute the values for each number of eggs `k` from 1 to `K`.
   - The recursive relation used to fill the DP table is:
     \[
     dp[m][k] = dp[m-1][k-1] + dp[m-1][k] + 1
     \]
     This formula accounts for:
     - The case where the egg breaks (`dp[m-1][k-1]`): The number of floors we can test with one less egg and one less move.
     - The case where the egg does not break (`dp[m-1][k]`): The number of floors we can test with the same number of eggs and one less move.
     - The `+1` accounts for the floor we're testing with the current move.
   - We continue updating the DP table until the maximum number of floors we can test with `K` eggs and `m` moves (`dp[m][K]`) is greater than or equal to `N`.

3. **Returning the Result**:
   ```cpp
   return m;
   ```
   - Once we find the minimum number of moves `m` such that `dp[m][K] >= N`, we return `m`, which represents the minimum number of drops required to find the critical floor in the worst case.

### Complexity

The time complexity of this solution is **O(K * M)**, where:
- `K` is the number of eggs, and
- `M` is the minimum number of moves required such that `dp[m][K] >= N`.

In the worst case, `M` grows logarithmically with respect to `N`, and since we are updating a table of size `K x M`, the time complexity is effectively linear in `K` and logarithmic in `N`.

The space complexity is **O(K * M)**, since we store a 2D table of size `(M+1) x (K+1)`.

### Conclusion

This solution efficiently solves the Super Egg Drop problem by leveraging dynamic programming to calculate the minimum number of drops required to find the critical floor with `K` eggs. The approach involves constructing a DP table that iteratively computes the maximum number of floors that can be tested with a given number of moves and eggs. The solution is optimal, with time complexity of `O(K * M)`, making it feasible for large inputs.

By using the recursive relation for updating the DP table, the solution avoids brute force and provides an efficient way to determine the minimum number of moves. This approach ensures that even for large values of `N` (number of floors), the problem can be solved quickly and accurately.
### Problem Statement

The problem asks to find the index of the **first unique character** in a given string `s`. A character is considered unique if it appears exactly once in the string. If there is no unique character, the function should return `-1`.

For example, for the input string `s = "leetcode"`, the output should be `0` because the first unique character is `'l'`, which is at index `0`.

### Approach

To solve this problem, we will:
1. **Count the frequency of each character** in the string.
2. **Iterate through the string again** to find the first character whose count is `1`.
3. If no such character exists, return `-1`.

#### Key Insights:
1. **Counting characters**: The problem can be efficiently solved by using a data structure that allows quick lookups and insertions, such as a **map** (or hash map).
2. **Two-pass approach**: 
   - In the first pass, count the occurrences of each character in the string.
   - In the second pass, find the first character that has an occurrence of `1`.

This approach ensures that we can solve the problem in **O(n)** time complexity, where `n` is the length of the string, because both passes require linear scans of the string.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    int firstUniqChar(string s) {
        
        map<char, int> mp;
        for(char x: s) mp[x]++;
        
        for(int i = 0; i < s.size(); i++)
            if(mp[s[i]] == 1) return i;
        
        return -1;
    }
};
```

#### 1. **Class Declaration**
```cpp
class Solution {
public:
    int firstUniqChar(string s) {
```
- The function `firstUniqChar` is a member of the `Solution` class, which will be called to solve the problem.
- It takes a single input parameter: a string `s`.

#### 2. **Count Character Occurrences**
```cpp
map<char, int> mp;
for(char x: s) mp[x]++;
```
- We use a `map<char, int>` called `mp` to store the frequency of each character in the string `s`. 
- The `map` is chosen because it allows efficient lookups and insertions with a time complexity of **O(log n)**.
- In the first loop, we iterate over each character `x` in the string `s` and increment its count in the map. If the character appears for the first time, it is added to the map with an initial count of `1`. If it appears again, the count is incremented.

#### 3. **Find the First Unique Character**
```cpp
for(int i = 0; i < s.size(); i++)
    if(mp[s[i]] == 1) return i;
```
- In the second loop, we iterate over the string `s` again, checking each character `s[i]` and looking up its count in the map `mp`.
- If the count of `s[i]` is `1`, it means that the character is unique, and we return the index `i` immediately.
- The first unique character encountered will be returned, ensuring that the result is the **first unique character** in the string.

#### 4. **Handle No Unique Character**
```cpp
return -1;
```
- If no character in the string is unique (i.e., all characters appear more than once), the function returns `-1`, indicating that no unique character exists.

### Complexity

#### Time Complexity:
- **O(n)**, where `n` is the length of the string `s`. 
    - The first loop iterates over the string once to count the occurrences of each character, which takes **O(n)** time.
    - The second loop iterates over the string again to find the first unique character, which also takes **O(n)** time.
    - Thus, the total time complexity is **O(n)**, making this an efficient solution for large strings.

#### Space Complexity:
- **O(n)**, where `n` is the number of unique characters in the string. 
    - The space complexity is dominated by the map `mp`, which stores the frequency of each character in the string. In the worst case, all characters in the string could be unique, requiring space for each of them.
    - Hence, the space complexity is **O(n)**.

### Conclusion

This solution provides an efficient way to find the first unique character in a string by using a **two-pass algorithm** with a **map** to store character frequencies:
1. **First pass**: Count the frequency of each character in the string.
2. **Second pass**: Find the first character with a frequency of `1`.

The approach ensures a linear time complexity of **O(n)**, making it suitable for large input strings. The space complexity is **O(n)** due to the map storing character frequencies, which is necessary to solve the problem efficiently.

This solution is optimal for solving the problem, handling both small and large strings effectively while maintaining clarity and simplicity in the code.
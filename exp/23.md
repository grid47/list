### Problem Statement

The problem is to merge `k` sorted singly linked lists into one sorted linked list. Each list is already sorted in non-decreasing order. The goal is to combine these `k` lists into one list, maintaining the sorted order.

#### Input:
- A list of `k` singly linked lists, where each list is sorted in non-decreasing order.
  
#### Output:
- A single sorted singly linked list that combines all the elements from the `k` input lists.

### Approach

To solve this problem, we can efficiently merge the `k` sorted lists using a **min-heap (priority queue)**. The idea is to keep track of the smallest elements from each list using a priority queue, ensuring that we always append the smallest node from the lists to the merged list. This method is efficient and avoids the need to repeatedly scan the lists.

#### Steps to approach the problem:

1. **Priority Queue (Min-Heap)**: 
   - A min-heap (priority queue) helps in efficiently getting the smallest element from the top of the heap. In this case, it will be used to store the heads of all `k` lists.
   - The priority queue is ordered such that the smallest element is always at the top.

2. **Adding List Heads to Min-Heap**:
   - We will first iterate through all the lists and push their heads (if they exist) into the priority queue.

3. **Merging Lists**:
   - Pop the smallest node from the min-heap and add it to the result list.
   - If the node that was popped has a next node, push that next node into the heap.
   - Repeat the process until all elements from the lists are added to the merged list.

4. **Edge Cases**:
   - If there are no lists or all lists are empty, the result will also be an empty list.
   - If only one list is provided, it will be returned as-is.

### Code Breakdown (Step by Step)

#### 1. Define a Comparison Class for the Priority Queue

```cpp
class cmp {
    public:
    bool operator()(ListNode* a, ListNode* b) {
        return a->val > b->val;
    }
};
```

- The class `cmp` defines how two nodes should be compared in the priority queue.
- We want the smallest element to be at the top of the queue, so we compare the values of two `ListNode` objects (`a` and `b`), and if `a->val > b->val`, the comparison will return `true`, which ensures that the heap is ordered from smallest to largest values.

#### 2. The `mergeKLists` Function

```cpp
ListNode* mergeKLists(vector<ListNode*>& lists) {
    priority_queue<ListNode*, vector<ListNode*>, cmp> pq;
```

- **Priority Queue**: A priority queue `pq` is created that stores pointers to `ListNode` objects, ordered by their values. The `cmp` class ensures that the nodes with smaller values are prioritized.
  
```cpp
    for(auto it: lists) {
        if(it != NULL) 
            pq.push(it);            
    }
```

- **Populating the Queue**: The loop iterates over each linked list in the input vector `lists`. If a list is not `NULL`, its head node is pushed into the priority queue. This step ensures that all the list heads are available for merging.

#### 3. Create a Dummy Head for the Merged List

```cpp
    ListNode* h = new ListNode(0);
    ListNode* tmp = h;
```

- **Dummy Node**: A dummy node `h` is created to simplify the merging process. The `tmp` pointer is used to keep track of the current node in the merged list.
- **Dummy Node Purpose**: The dummy node acts as a placeholder to easily return the head of the merged list at the end. We don't have to handle special cases for the first node.

#### 4. Merging Process Using the Priority Queue

```cpp
    while(!pq.empty()) {
        auto it = pq.top();
        tmp->next = it;
        tmp = tmp->next;
        pq.pop();
        if(it->next)
            pq.push(it->next);
    }
```

- **Merging**:
  - The while loop continues as long as the priority queue is not empty.
  - The smallest node is popped from the queue (`pq.top()`), and it is added to the `tmp` node's `next` pointer, linking it to the merged list.
  - `tmp` is then moved to the newly added node (`tmp = tmp->next`).
  - After processing a node, if it has a `next` node (i.e., the list hasn't ended), the `next` node is pushed into the priority queue.

#### 5. Final Step and Return

```cpp
    tmp->next = NULL;
    return h->next;
}
```

- After all nodes are processed, `tmp->next` is set to `NULL` to terminate the merged list.
- The function returns `h->next`, which points to the actual head of the merged list, skipping the dummy node.

### Complexity

#### Time Complexity:
- **O(N log K)**, where:
  - `N` is the total number of nodes across all `k` linked lists.
  - `K` is the number of linked lists.
  
  **Explanation**:
  - **Priority Queue Operations**: The priority queue operations (insertion and removal) take `O(log K)` time because we maintain a heap of size `K` (the number of lists).
  - We perform these operations for each node in all the lists, so the time complexity is proportional to the number of nodes (`N`) times the time it takes to perform a heap operation (`log K`).
  
#### Space Complexity:
- **O(K)**, where `K` is the number of linked lists.
  - The priority queue stores at most `K` nodes at any point, one for each list. Therefore, the space complexity is dominated by the space used by the priority queue, which holds at most `K` elements.

### Conclusion

This solution efficiently merges `k` sorted linked lists by leveraging a **min-heap (priority queue)**. By pushing the head of each list into the priority queue and continuously extracting the smallest element, we can maintain the sorted order as we build the merged list. 

Key points:
- The use of the min-heap ensures efficient extraction of the smallest element.
- The merging process runs in **O(N log K)** time, making it well-suited for cases with large numbers of lists and nodes.
- The space complexity is **O(K)**, which is optimal for the problem.

This approach is optimal compared to other methods like brute-force merging, where one would repeatedly traverse and compare elements from all lists. The priority queue reduces the need for repeated comparisons, significantly improving efficiency.
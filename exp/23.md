### 🌟 **Merging `k` Sorted Linked Lists** – Step-by-Step Solution

Let's tackle the problem of merging `k` sorted singly linked lists into one sorted list using an efficient approach involving a **min-heap (priority queue)**. By doing so, we can efficiently combine the lists while maintaining the sorted order.

---

#### 📝 **The Problem**

Given `k` sorted singly linked lists, we need to merge them into a single sorted list. Each of the `k` input lists is already sorted in non-decreasing order, and we want the merged list to be sorted as well.

---

#### 🧠 **Approach: Using a Min-Heap**

A **min-heap (priority queue)** helps efficiently extract the smallest element from a group of items. In our case, the group consists of the heads of `k` linked lists. Here’s how we’ll use it:

1. **Priority Queue (Min-Heap)**:
   - The heap will store the heads of all `k` lists, ordered by the values of the nodes.
   - We will always extract the smallest node from the heap and append it to the result list.
   
2. **Merging Process**:
   - Extract the smallest element from the heap, add it to the merged list.
   - If the extracted node has a next node, push that next node into the heap.
   - Repeat this process until all lists are merged.

---

#### 🔑 **Step-by-Step Code Explanation**

1. **Comparison Class for Min-Heap**:

We need a way to compare nodes in the priority queue to ensure that the smallest node is always at the top. We do this by defining a comparison class:

```cpp
class cmp {
    public:
    bool operator()(ListNode* a, ListNode* b) {
        return a->val > b->val;  // Ensure that the smallest value is at the top
    }
};
```

- This class ensures that nodes with smaller values are prioritized in the heap.

---

2. **`mergeKLists` Function:**

The main function to merge the lists is `mergeKLists`. It uses a priority queue to handle the merging:

```cpp
ListNode* mergeKLists(vector<ListNode*>& lists) {
    priority_queue<ListNode*, vector<ListNode*>, cmp> pq;
```

- We initialize a priority queue `pq` which stores `ListNode*` and uses the `cmp` class for comparison.

```cpp
    for(auto it: lists) {
        if(it != NULL) 
            pq.push(it);            
    }
```

- **Populating the Priority Queue**:  
  We iterate through the input lists and push the head of each non-null list into the heap.

---

3. **Creating a Dummy Node:**

To simplify the merging process, we create a dummy node that serves as a placeholder for the result list:

```cpp
    ListNode* h = new ListNode(0);  // Dummy node
    ListNode* tmp = h;  // Pointer to the last node in the merged list
```

- The dummy node `h` helps us easily return the head of the merged list without handling edge cases for the first node.

---

4. **Merging Process:**

We repeatedly extract the smallest element from the heap and append it to the result list:

```cpp
    while(!pq.empty()) {
        auto it = pq.top();  // Get the smallest element
        tmp->next = it;  // Add it to the merged list
        tmp = tmp->next;  // Move the pointer to the last node
        pq.pop();  // Remove the smallest element from the heap
        
        if(it->next)  // If there's a next node, add it to the heap
            pq.push(it->next);
    }
```

- **While Loop**:  
  - Continue as long as there are elements in the heap.
  - Extract the smallest node, add it to the merged list, and move the `tmp` pointer.
  - If the extracted node has a next node, push it into the heap.

---

5. **Return the Merged List:**

After the merging process, we return the actual head of the merged list, skipping the dummy node:

```cpp
    tmp->next = NULL;  // Terminate the merged list
    return h->next;  // Return the merged list (skipping the dummy node)
}
```

---

#### 📊 **Complexity Analysis**

- **Time Complexity**:  
  **O(N log K)**, where:
  - `N` is the total number of nodes in all `k` lists.
  - `K` is the number of linked lists.

  **Explanation**:
  - The heap operations (insertion and removal) take `O(log K)` time.
  - We perform these operations for each node in all the lists, so the time complexity is proportional to `N * log K`.

- **Space Complexity**:  
  **O(K)**, where `K` is the number of lists.

  **Explanation**:
  - The priority queue stores at most `K` nodes (one from each list) at any point in time, so the space complexity is `O(K)`.

---

#### 💡 **Why This Approach is Efficient**

This approach is optimal for merging `k` sorted linked lists:
- **Min-Heap Efficiency**:  
  The priority queue ensures that we always get the smallest element in `O(log K)` time, making it faster than comparing all nodes directly.
  
- **Reduced Time Complexity**:  
  By using the heap, we reduce the need for repeatedly scanning through all nodes in all lists, which would otherwise lead to a slower solution.

---

#### 🚀 **Conclusion**

Merging `k` sorted linked lists is an interesting and challenging problem, but using a **min-heap (priority queue)** gives us a clear and efficient solution. By carefully managing the smallest elements and leveraging the heap structure, we can efficiently merge all the lists into one sorted list in **O(N log K)** time.

- **Key Insights**:
  - Use a priority queue to efficiently get the smallest element.
  - Handle the merging process step by step, ensuring that the lists are combined in sorted order.

With this approach, we're able to handle large input sizes efficiently, making it perfect for merging multiple sorted linked lists in a variety of applications! 💪
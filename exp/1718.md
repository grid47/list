### Problem Statement

The problem requires constructing a sequence of integers from 1 to \( n \) such that each integer \( i \) appears exactly twice in the sequence, and the two instances of \( i \) are separated by exactly \( i \) positions. For example, if \( n = 3 \), a valid sequence could be `[3, 0, 3, 1, 2, 1, 0, 2]`. The goal is to find such a sequence and return it.

### Approach

To solve this problem, we can use a backtracking approach. Hereâ€™s the step-by-step outline of the approach:

1. **Initialization**: Start by creating a result array `ans` of size \( 2n - 1 \) initialized with zeros. This array will hold the final sequence.

2. **Visited Array**: Maintain a visited array `vis` to keep track of which integers from 1 to \( n \) have already been placed in the sequence.

3. **Backtracking Function**: Implement a recursive backtracking function `bt` that attempts to fill the `ans` array. The function should:
   - Check if the current index is at the end of the array, in which case the sequence has been successfully constructed.
   - If the current position is already filled, move to the next index.
   - Otherwise, iterate through the numbers from \( n \) down to 1:
     - If the number has not been used yet, mark it as used and place it in the current index.
     - Check if it can be placed at its required distance; if so, place it at that position and recurse further.
     - If placing the number leads to a solution, return true.
     - If not, backtrack by resetting the position and marking the number as unused.
   
4. **Return the Result**: Once a valid sequence is found, return the constructed sequence.

### Code Breakdown (Step by Step)

Let's break down the provided code in detail to understand how it implements the above approach:

1. **Class Declaration**: The solution is encapsulated in a class named `Solution`.

    ```cpp
    class Solution {
    ```

2. **Member Variable**: A member variable `n` is declared to hold the value of \( n \).

    ```cpp
    public:
    int n;
    ```

3. **Main Method**: The public method `constructDistancedSequence` takes an integer \( n \) and initializes the result array and the visited array.

    ```cpp
    vector<int> constructDistancedSequence(int n) {
        this->n = n;
        vector<int> ans(2 * n - 1, 0);
        vector<int> vis(n + 1, 0);
    ```

4. **Backtracking Call**: The backtracking function `bt` is called to start filling the `ans` array.

    ```cpp
    bt(ans, vis, 0);
    return ans;
    ```

5. **Backtracking Function**: The `bt` function is defined to perform the actual backtracking.

    ```cpp
    bool bt(vector<int> &ans, vector<int> &vis, int idx) {
        if(idx == ans.size()) return true;
        if(ans[idx] != 0) return bt(ans, vis, idx + 1);
    ```

   - The function first checks if the current index `idx` has reached the end of the array, in which case it returns true.
   - If the current index is already filled (not zero), it recursively calls itself for the next index.

6. **Iteration through Possible Values**: If the current index is empty, the function iterates through the integers from \( n \) down to 1.

    ```cpp
    for(int i = n; i >= 1; i--) {
        if(vis[i]) continue;
    ```

   - For each integer \( i \), it checks if it has already been used by looking up the `vis` array. If it has, it continues to the next integer.

7. **Marking as Used**: If \( i \) is unused, it marks it as used, and sets it at the current index `idx`.

    ```cpp
    vis[i] = 1;
    ans[idx] = i;
    ```

8. **Checking Distance Condition**: If \( i \) is greater than 1, it checks whether it can also be placed at the required distance \( idx + i \).

    ```cpp
    if(i == 1) {
        if(bt(ans, vis, idx + 1)) return true;
    } else if (idx + i < ans.size() && ans[idx + i] == 0) {
        ans[idx + i] = i;
        if(bt(ans, vis, idx + 1)) return true;
        ans[idx + i] = 0;                    
    }
    ```

   - If the distance condition is satisfied, it places \( i \) at the required position and recursively calls itself to fill the next index.
   - If the recursion returns true, it indicates a valid sequence has been found.
   - If not, it backtracks by resetting the position and marking the number as unused.

9. **Resetting State for Backtracking**: After trying both placements (current and required), the function resets the state to allow further exploration of other possible configurations.

    ```cpp
    ans[idx] = 0;
    vis[i] = 0;
    ```

10. **Return False if No Valid Configuration Found**: If all possibilities have been tried and none lead to a solution, the function returns false.

    ```cpp
    return false;
    ```

### Complexity

- **Time Complexity**: The time complexity is \( O(n!) \) in the worst case, since the algorithm explores all possible placements of numbers. However, in practice, it is much more efficient due to pruning with backtracking.
  
- **Space Complexity**: The space complexity is \( O(n) \) because of the storage used for the result array `ans` and the visited array `vis`.

### Conclusion

In conclusion, this code efficiently constructs a sequence of integers from 1 to \( n \) such that each integer appears twice at a specific distance. The use of backtracking allows the algorithm to explore various configurations of placements systematically, ensuring all valid arrangements are considered while minimizing unnecessary computations. This approach provides an optimal solution to the problem of constructing a distanced sequence while clearly demonstrating the utility of backtracking in combinatorial problems. The clarity and structure of the code make it a solid example of algorithm design in competitive programming.
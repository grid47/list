### Problem Statement

The problem asks us to find the smallest range that includes at least one number from each of the given `k` lists. Each list is an array of integers, and the goal is to determine a range `[x, y]` such that for every list `nums[i]`, there exists at least one element in the range `[x, y]`. The challenge lies in selecting the smallest possible range while ensuring that the range contains at least one element from each list.

### Approach

The approach for solving this problem involves the following steps:

1. **Flatten the Input Lists:** 
   The first step is to flatten the list of lists into a single list of pairs where each pair consists of a number and the index of the list it came from. This makes it easier to track which list the elements belong to.

2. **Sorting the Elements:**
   Next, we sort the flattened list based on the values of the elements. This allows us to efficiently find potential ranges as we slide through the sorted list.

3. **Sliding Window to Find the Smallest Range:**
   The key idea is to use a sliding window approach over the sorted list. The window represents a potential range, and we expand and contract the window by adjusting the start and end points. The goal is to find the smallest range that contains at least one element from each list.

4. **Tracking List Coverage:**
   We maintain a count of how many lists are represented within the current window. When all `k` lists are represented, we check if the current window forms a smaller range than any previously found range.

5. **Optimization Using a Hash Map:**
   To efficiently keep track of the count of elements from each list in the current window, we use a hash map where the key is the index of the list, and the value is the count of elements from that list within the current window.

### Code Breakdown (Step by Step)

1. **Flattening the Input Lists:**
   ```cpp
   vector<pair<int, int>> arr;
   for(int i = 0; i < nums.size(); i++) {
       for(int j = 0; j < nums[i].size(); j++) {
           arr.push_back({nums[i][j], i});
       }
   }
   ```
   - We first initialize an empty vector `arr` to store pairs of values and their corresponding list index.
   - We iterate over all the lists in the `nums` array. For each element in each list, we create a pair where the first element is the value of the element, and the second element is the index of the list it came from. This pair is then added to the `arr` vector.

2. **Sorting the Array:**
   ```cpp
   sort(arr.begin(), arr.end());
   ```
   - We sort the `arr` vector based on the first element of each pair (i.e., the values from the original lists). This sorting is crucial because it allows us to efficiently slide through the values and find the smallest possible range.

3. **Sliding Window Initialization:**
   ```cpp
   unordered_map<int, int> mp;
   int cnt = 0;
   int j = 0;
   int n = arr.size();
   vector<int> ans = {-100000, 100000};
   ```
   - We initialize an unordered map `mp` to keep track of how many times each list is represented in the current window. The key is the list index, and the value is the count of elements from that list in the window.
   - We also initialize `cnt` to count how many lists are currently represented in the window.
   - `j` is the start of the sliding window.
   - `ans` holds the smallest range found so far, initialized to an arbitrarily large range (from -100000 to 100000).

4. **Sliding Window Expansion and Contraction:**
   ```cpp
   for(int i = 0; i < n; i++) {
       mp[arr[i].second]++;
       if(mp[arr[i].second] == 1) cnt++;
       if(cnt == k) {
           while(mp[arr[j].second] > 1) {
               mp[arr[j].second]--;
               j++;
           }                
           if(arr[i].first - arr[j].first < ans[1] - ans[0]) {
               ans = {arr[j].first, arr[i].first};
           }
       }
   }
   ```
   - We iterate through the sorted list with the variable `i` representing the end of the sliding window.
   - For each element in `arr`, we update the map `mp` to reflect that we have included another element from a list. If this is the first element from that list in the current window, we increment `cnt`.
   - Once `cnt == k`, meaning all `k` lists are represented in the window, we start shrinking the window from the left by incrementing `j` as long as the current element at `arr[j]` appears more than once in the window (i.e., its count in `mp` is greater than 1).
   - We then check if the current window (from `arr[j].first` to `arr[i].first`) forms a smaller range than any previously found range. If it does, we update `ans` to hold the new range.

5. **Returning the Smallest Range:**
   ```cpp
   return ans;
   ```
   - Finally, we return the smallest range stored in `ans`, which contains at least one element from each of the `k` lists.

### Complexity

#### Time Complexity:
- **Flattening the Lists:** Flattening all the lists into the `arr` vector takes **O(n)** time, where `n` is the total number of elements across all lists.
- **Sorting the Array:** Sorting the `arr` vector takes **O(n log n)** time.
- **Sliding Window:** The sliding window logic involves iterating over the array once, so it takes **O(n)** time.

Therefore, the total time complexity is **O(n log n)** due to the sorting step.

#### Space Complexity:
- We use an unordered map `mp` to track the count of elements from each list. The size of this map is proportional to the number of distinct lists, which is **O(k)**.
- Additionally, we store the flattened list in the `arr` vector, which takes **O(n)** space.

Therefore, the space complexity is **O(n + k)**, where `n` is the total number of elements across all lists and `k` is the number of lists.

### Conclusion

The solution employs a sliding window technique to efficiently find the smallest range that includes at least one element from each list. By sorting the elements and maintaining a map to track how many lists are represented in the current window, the algorithm ensures that we can find the optimal range in **O(n log n)** time. This approach is efficient and scalable, making it suitable for handling larger datasets. The use of the sliding window ensures that the solution is both time and space-efficient, making it a robust method for solving this problem.
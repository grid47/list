### Problem Statement

The problem is to generate all possible **unique permutations** of a given list of integers, `nums`. The input list can contain duplicates, so it is important to ensure that each permutation is distinct. You are required to return a list of all the unique permutations of the array.

### Approach

To solve this problem, we can use **backtracking** with a **map** to avoid duplicates. Backtracking is a technique used to explore all possible combinations of elements, and in this case, we will use it to generate all permutations. The key idea is to keep track of the elements we have already used in the current permutation and avoid revisiting them.

Here is the plan:
1. **Backtracking**: Generate all possible permutations of the list by exploring each element and recursively adding them to the current permutation until the permutation reaches the required length (the length of the original list).
2. **Avoiding Duplicates**: Use a `map` (or any other set-like structure) to keep track of which elements have been used in the current permutation. If an element is already used, we skip it to avoid duplicate permutations.
3. **Base Case**: When the current permutation reaches the size of the input list, we add it to the result list.
4. **Recursive Case**: For each element in the list, if it has not been used in the current permutation, we include it, recurse to build the next part of the permutation, and backtrack once we are done with that element.

### Code Breakdown (Step by Step)

#### Step 1: `permute` Function

```cpp
vector<vector<int>> permute(vector<int>& nums) {
    map<int, bool> mp;
    vector<vector<int>> ans;
    vector<int> tmp;
    bt(ans, tmp, nums, 0, mp);
    return ans;
}
```

- **Input**: The function `permute` takes a vector of integers `nums` as input.
- **Variables**:
  - `mp`: A `map` is used to track whether an element has been added to the current permutation or not.
  - `ans`: A vector of vectors that will hold all the unique permutations.
  - `tmp`: A temporary vector used to build each permutation as we recurse.
  - The function then calls the helper function `bt` to start the backtracking process.
- **Return**: After the backtracking process is completed, the `ans` vector contains all the unique permutations and is returned.

#### Step 2: `bt` (Backtracking) Function

```cpp
void bt(vector<vector<int>> &ans, vector<int> &tmp, vector<int> &nums, int idx, map<int, bool> &mp) {
    if(idx == nums.size()) {
        ans.push_back(tmp);
        return;
    }
    
    for(int i = 0; i < nums.size(); i++) {
        if(mp.count(nums[i])) continue;
        mp[nums[i]] = true;
        tmp.push_back(nums[i]);
        bt(ans, tmp, nums, idx + 1, mp);
        tmp.pop_back();
        mp.erase(nums[i]);
    }
}
```

- **Base Case**: When the current index `idx` reaches the size of `nums`, the temporary permutation `tmp` is complete. We add `tmp` to the result vector `ans` and return.
  
  ```cpp
  if(idx == nums.size()) {
      ans.push_back(tmp);
      return;
  }
  ```

- **Loop through `nums`**: For each element in `nums`, we check if it has already been used in the current permutation by checking the map `mp`. If it has been used, we skip it.
  
  ```cpp
  for(int i = 0; i < nums.size(); i++) {
      if(mp.count(nums[i])) continue;
  }
  ```

- **Adding Elements to the Current Permutation**: If the current element has not been used, we mark it as used (`mp[nums[i]] = true`), add it to the temporary permutation `tmp`, and recurse to generate the next element of the permutation.
  
  ```cpp
  mp[nums[i]] = true;
  tmp.push_back(nums[i]);
  bt(ans, tmp, nums, idx + 1, mp);
  ```

- **Backtracking**: After the recursion call, we remove the last element from `tmp` (this is the backtracking step) and mark the element as unused in the map (`mp.erase(nums[i])`).
  
  ```cpp
  tmp.pop_back();
  mp.erase(nums[i]);
  ```

#### Step 3: Recursion Termination

The recursion terminates when we have explored all elements, and the base case is reached. The result vector `ans` will contain all the unique permutations.

### Complexity

#### Time Complexity

The time complexity of generating all permutations of `n` elements is `O(n!)` because there are `n!` possible permutations of the elements. For each permutation, we spend `O(n)` time to process it (i.e., to construct the permutation using the backtracking approach).

- **Time Complexity**: `O(n * n!)`, where `n` is the length of the input array `nums`.

#### Space Complexity

The space complexity of this solution is determined by:
1. The space used to store all permutations: Since there are `n!` permutations, and each permutation takes `O(n)` space, the total space used by the result list is `O(n * n!)`.
2. The space used by the recursion stack: The maximum depth of the recursion tree is `n`, and each call uses `O(n)` space for the temporary permutation `tmp` and the map `mp`. Thus, the total space used by the recursion is `O(n)`.

- **Space Complexity**: `O(n * n!)` for the result, plus `O(n)` for the recursion stack.

### Conclusion

This solution efficiently generates all unique permutations of a list of integers using **backtracking**. By maintaining a map to track which elements have been used in the current permutation, we ensure that duplicate permutations are avoided. The approach is both **time-efficient** and **space-efficient** for generating permutations, given the inherent complexity of the problem. 

The backtracking method ensures that all possible permutations are explored while keeping track of previously used elements to avoid generating duplicates. The solution has a time complexity of `O(n * n!)`, which is the best possible for generating permutations, and a space complexity of `O(n * n!)` to store the results. This makes it suitable for handling relatively small to moderate-size input arrays.
### Problem Statement

The problem requires us to find the largest local value in a 3x3 subgrid for each position in a given 2D grid `g`. For each cell `(i, j)` in the grid (excluding the borders), we need to consider the 3x3 subgrid centered at that cell, and return the maximum value within that subgrid.

The grid is an `n x n` matrix, and we need to compute the maximum of all 3x3 subgrids (excluding borders) and store these values in a new matrix. The size of the resulting matrix will be `(n-2) x (n-2)` since the borders are excluded from the local subgrids.

### Approach

This problem can be efficiently solved by iterating through each possible center of the 3x3 subgrid, and finding the maximum value within that subgrid. The approach can be broken down into the following steps:

1. **Iterate through all possible centers**: The center of the 3x3 subgrid should be a position `(i, j)` where `1 <= i <= n-2` and `1 <= j <= n-2`. This ensures that the 3x3 subgrid has complete coverage without going out of bounds.

2. **Check the 3x3 subgrid for each center**: For each valid position `(i, j)`, we examine all the elements of the 3x3 subgrid, which spans from `g[i-1][j-1]` to `g[i+1][j+1]`, and find the maximum element within this subgrid.

3. **Store the result**: For each center `(i, j)`, store the maximum value found in the corresponding position of the result matrix `res`.

4. **Return the result matrix**: Once the iteration is complete, the matrix `res` will contain the largest local values for each 3x3 subgrid.

### Code Breakdown (Step by Step)

1. **Class Definition**:
    ```cpp
    class Solution {
    public:
        vector<vector<int>> largestLocal(vector<vector<int>>& g) {
    ```
    The `Solution` class contains the method `largestLocal`, which takes a 2D matrix `g` as input and returns the resulting 2D matrix with the largest values of each 3x3 subgrid.

2. **Initialize the Result Matrix**:
    ```cpp
        int n = g.size();  // Get the size of the input grid
        vector<vector<int>> res(n - 2, vector<int>(n - 2));  // Initialize the result matrix
    ```
    First, we retrieve the size `n` of the input matrix `g`. Then, we initialize the result matrix `res`, which will store the largest values from each 3x3 subgrid. The size of `res` is `(n-2) x (n-2)` because we exclude the borders of the grid.

3. **Nested Loops to Traverse the Grid**:
    ```cpp
        for (int i = 0; i < n - 2; ++i) {
            for (int j = 0; j < n - 2; ++j) {
    ```
    The outer two loops iterate through each possible top-left corner of a 3x3 subgrid. We loop through the rows and columns of the grid, ensuring that the current position `(i, j)` can be the top-left corner of a valid 3x3 subgrid.

4. **Find Maximum in the 3x3 Subgrid**:
    ```cpp
                for (int ii = i; ii < i + 3; ++ii) {
                    for (int jj = j; jj < j + 3; ++jj) {
                        res[i][j] = max(res[i][j], g[ii][jj]);  // Update the result with the maximum value
                    }
                }
    ```
    The innermost loops iterate through each element of the 3x3 subgrid centered at `(i, j)`. The range of `ii` is from `i` to `i+2`, and the range of `jj` is from `j` to `j+2`, ensuring we cover all 9 elements in the 3x3 grid. During each iteration, we update the `res[i][j]` with the maximum value found so far in this subgrid.

5. **Return the Result Matrix**:
    ```cpp
            }
        }
        return res;  // Return the result matrix containing the largest values
    }
    ```
    After all the 3x3 subgrids have been processed, the result matrix `res` is returned, which contains the maximum values from each of the local 3x3 grids.

### Complexity

1. **Time Complexity**:
    - The algorithm uses four nested loops:
        - The outer two loops iterate over the rows and columns of the grid, with each loop running `O(n-2)` times (i.e., `O(n)` where `n` is the grid size).
        - The two inner loops iterate over the 3x3 subgrid, running `O(9)` times.
    
    Therefore, the time complexity of the solution is **O(n^2)**, where `n` is the size of the grid. The two outer loops contribute `O(n^2)` operations, and the inner loops contribute a constant factor of 9 for each 3x3 subgrid.

2. **Space Complexity**:
    - The space complexity is determined by the space used for the result matrix `res`, which has dimensions `(n-2) x (n-2)`. Hence, the space complexity is **O(n^2)** for storing the result matrix.

### Conclusion

This solution effectively solves the problem of finding the largest value in each 3x3 subgrid by iterating through the grid and checking each subgrid in constant time. The use of nested loops allows us to check all possible subgrids and calculate the maximum value efficiently. The overall time complexity of **O(n^2)** makes this solution suitable for reasonably sized grids. The space complexity is also **O(n^2)** due to the result matrix.

In summary, this approach provides an efficient and straightforward solution to finding the largest values in local 3x3 grids for a given input matrix. It works optimally for grids of various sizes and ensures that we can process large matrices in a reasonable amount of time.
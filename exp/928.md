### Problem Statement

The goal is to minimize the spread of malware in a network represented as a graph. Given an `n x n` adjacency matrix `grid`, where `grid[i][j] = 1` means nodes `i` and `j` are connected and `0` otherwise, and an array `mw` of initially infected nodes, the objective is to remove exactly one infected node such that the total number of nodes eventually infected is minimized. If multiple nodes yield the same result, the smallest index node is preferred.

### Approach

This solution leverages **Union-Find (UF)** to group uninfected nodes into disjoint sets, then evaluates how removing each infected node impacts the overall spread. By organizing the uninfected nodes into groups, we can determine if an infected node is the only source of infection for a particular group, enabling us to target the most impactful infected node.

#### Steps:

1. **Initialize Union-Find for Uninfected Nodes**:
   - We create a Union-Find instance (`UF`) with methods `find`, `join`, and `size` to manage the connected components of uninfected nodes.
   - `find` uses path compression to efficiently retrieve the root of a node, while `join` connects two nodes and ranks their components by size.

2. **Separate Infected and Uninfected Nodes**:
   - We use sets to categorize nodes as infected (`bad`) or uninfected (`good`), based on the initial infection list `mw`.

3. **Group Uninfected Nodes**:
   - For each pair of uninfected nodes, if they are connected in the `grid`, we unify them using the Union-Find `join` method, establishing groups of connected uninfected nodes.

4. **Map Infected Nodes to Uninfected Groups**:
   - We iterate through infected nodes and identify the uninfected groups they can infect by finding the root of each connected uninfected node in the Union-Find structure.
   - A dictionary `mwg` maps each infected node to the set of uninfected groups it could potentially infect.

5. **Calculate Group Impact**:
   - For each uninfected group, we keep a count (`deg`) of how many infected nodes can infect that group. If only one infected node can infect a particular group, that infected node has a significant impact if removed.
   
6. **Determine Optimal Node to Remove**:
   - We evaluate each infected node, summing the sizes of the uninfected groups it alone can infect. The infected node whose removal yields the maximum decrease in future infections is selected. If there's a tie, we choose the smallest indexed node.

### Code Breakdown (Step by Step)

1. **Union-Find Class Setup**:
   ```cpp
   class UF {
   public:
       vector<int> par, rnk;
       UF(int n) {
           par.resize(n, 0);
           for(int i = 0; i < n; i++) par[i] = i;
           rnk.resize(n, 1);
       }
       bool join(int x, int y) {
           int p = find(x);
           int q = find(y);
           if(p == q) return false;
           if(rnk[p] < rnk[q]) {
               par[p] = q;
               rnk[q] += rnk[p];
           } else {
               par[q] = p;
               rnk[p] += rnk[q];
           }
           return true;
       }
       int find(int x) {
           if(par[x] == x) return x;
           return par[x] = find(par[x]);
       }
       int size(int x) {
           return rnk[find(x)];
       }
   };
   ```
   - `par` stores the parent of each node, and `rnk` tracks the size of each group.

2. **Solution Class**:
   ```cpp
   class Solution {
   public:
       int minMalwareSpread(vector<vector<int>>& grid, vector<int>& mw) {
           int n = grid.size();
           UF* uf = new UF(n);
   ```
   - Initialize Union-Find with the size of `grid`.

3. **Categorize Nodes**:
   ```cpp
           set<int> bad(mw.begin(), mw.end()), good;
           for(int i = 0; i < n; i++)
               if(!bad.count(i)) good.insert(i);
   ```
   - `bad` contains infected nodes; `good` contains uninfected nodes.

4. **Connect Uninfected Nodes**:
   ```cpp
           for(int i : good)
               for(int j : good)
                   if(i != j && grid[i][j]) uf->join(i, j);
   ```
   - Connect uninfected nodes if they are connected in the adjacency matrix.

5. **Map Infected Nodes to Uninfected Groups**:
   ```cpp
           map<int, set<int>> mwg;
           map<int, int> deg;
           for(int m: bad) {
               for(int n: good)
                   if(grid[m][n]) mwg[m].insert(uf->find(n));
               for(int it: mwg[m]) deg[it]++;
           }
   ```
   - `mwg` maps infected nodes to uninfected groups they can reach.
   - `deg` counts how many infected nodes can reach each uninfected group.

6. **Find Optimal Node**:
   ```cpp
           int node = mw[0], res = -1;
           for(auto mlw: mwg) {
               int cnt = 0;
               for(int g: mlw.second)
                   if(deg[g] == 1) cnt += uf->size(g);
               if(cnt > res || (cnt == res && mlw.first < node)) {
                   node = mlw.first;
                   res = cnt;
               }
           }
           return node;
       }
   };
   ```
   - Sum the sizes of uninfected groups that only one infected node can infect.
   - Select the node whose removal reduces future infections the most.

### Complexity

1. **Time Complexity**: **O(n^2)** because we analyze each pair of nodes in the adjacency matrix. Union-Find operations are approximately O(1) due to path compression.

2. **Space Complexity**: **O(n)** for storing parent and rank vectors, maps, and sets.

### Conclusion

This solution efficiently determines the infected node whose removal will minimize malware spread using a Union-Find structure. By analyzing the relationships between infected nodes and uninfected groups, it optimally targets the most impactful infected node. This approach ensures both efficiency and accuracy, even with larger networks.
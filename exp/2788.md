### Problem Statement

The problem at hand is to split a list of words by a specified separator character. Each word in the list is a string, and the goal is to split each word into substrings wherever the separator appears. The solution should return a new list of strings, where each string is a segment of a word split by the separator.

### Approach

We are tasked with splitting each word in the input list based on a separator character `sep`. For each word, we traverse through each character, checking if it matches the separator. If it does, we push the substring formed so far to the result list. If we reach the end of a word, the last substring (which does not end with a separator) is added to the result. This way, we ensure that every segment of the word separated by the given separator is correctly placed in the result list.

Here is the step-by-step breakdown of how the algorithm works:

1. **Input Iteration:** Iterate through each word in the input list `words`.
2. **Character Iteration:** For each word, iterate through its characters one by one.
3. **Separator Detection:** If a separator is encountered, the current accumulated substring is added to the result list.
4. **Segment Completion:** After encountering a separator or reaching the end of the word, finalize the current substring and push it to the result list.
5. **Return Result:** After processing all words, return the list of all the segments (substrings) formed by splitting each word by the separator.

### Code Breakdown (Step by Step)

```cpp
vector<string> splitWordsBySeparator(vector<string>& words, char sep) {
    vector<string> ans; // Vector to store the final answer (substrings)
```
- The function `splitWordsBySeparator` takes in a list of words (`vector<string> words`) and a separator character (`char sep`).
- A vector `ans` is initialized to store the substrings after splitting each word by the separator.

```cpp
    for(int i = 0; i < words.size(); i++) {
        string cur = "";  // Initialize an empty string to hold the current substring
```
- We start by iterating over each word in the list `words`. For each word, we initialize an empty string `cur`, which will be used to build each substring between separators.

```cpp
        for(int j = 0; j < words[i].size(); j++) {
```
- Inside the loop for each word, we start iterating through each character of the word.

```cpp
            if(words[i][j] == sep) {
                if(cur != "")  // If separator is found and cur is not empty
                    ans.push_back(cur); // Add current substring to the answer list
                cur = "";  // Reset the current substring to start a new one
            }
```
- If the current character is equal to the separator (`words[i][j] == sep`), we check if the current substring `cur` is non-empty.
- If it is non-empty, we add it to the result list `ans`.
- After adding the substring, we reset `cur` to an empty string to start collecting the next segment.

```cpp
            } else if(j == words[i].size() - 1) {
                cur += words[i][j];  // Add the last character to the current substring
                ans.push_back(cur);   // Add the last substring to the answer list
                cur = "";  // Reset the current substring
            }
```
- If the current character is not the separator, we check if it's the last character in the word (`j == words[i].size() - 1`).
- If it is the last character, we add it to `cur` and then push the final `cur` substring to the result list `ans`.
- Afterward, `cur` is reset to an empty string.

```cpp
            else
                cur += words[i][j]; // If not separator and not last character, keep building current substring
        }
```
- If the character is not a separator and it's not the last character, we continue adding the current character to `cur` to build the current substring.

```cpp
    }
    return ans;  // Return the final list of substrings
}
```
- After processing all the words in the input list `words`, we return the result list `ans`, which contains all the substrings split by the separator.

### Complexity

#### Time Complexity:
- The time complexity is **O(n * m)**, where:
  - `n` is the number of words in the input list `words`.
  - `m` is the average length of the words in `words`.
  
  This is because we are iterating through each character of every word in the input list once, checking each character and performing operations like adding substrings to the result list.

#### Space Complexity:
- The space complexity is **O(k)**, where `k` is the total number of substrings formed after splitting all the words.
  - We store all the resulting substrings in the `ans` vector, which requires space proportional to the number of substrings.
  - Additionally, we store the `cur` string at each step, but it is used to build substrings incrementally, so the space overhead is mainly from the final result list `ans`.

### Conclusion

This solution efficiently splits each word in the input list by a specified separator character and returns the substrings. The algorithm works by iterating through each word and checking each character. It dynamically builds substrings and adds them to the result whenever a separator is encountered or at the end of the word. The time complexity of **O(n * m)** ensures that this approach works efficiently for relatively large inputs, while the space complexity is dominated by the number of substrings formed. 

This solution is simple and direct, making it suitable for handling cases where splitting words by a separator is required, and it ensures that all edge cases (such as empty words or multiple consecutive separators) are handled appropriately.
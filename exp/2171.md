### Problem Statement
You are given an array `beans`, where each element represents the number of beans in a respective pile. The goal is to determine the minimum number of beans you need to remove such that the number of beans in all piles is equal. However, the removal should ensure that the remaining piles all have the same number of beans, and the number of beans removed should be minimized.

You need to return the minimum number of beans to remove to achieve this.

### Approach
The problem can be broken down into the following steps:
1. **Compute the Total Sum of Beans**:
   - First, calculate the total number of beans in all piles. This helps in determining how many beans would be removed from each pile.
   
2. **Sort the Array**:
   - To simplify the process of calculating the beans to remove, sort the array. This allows you to efficiently compute the number of beans left after removing piles.

3. **Iterate through Sorted Array**:
   - After sorting the array, the number of beans left in each pile (after removal) will be based on the size of the piles that remain. For each pile, compute the number of beans you would remove and keep track of the minimum result.

4. **Calculation of Beans to Remove**:
   - For each index in the sorted array, compute how many beans would be removed if all piles except for the current pile (and those smaller than it) were kept. This is done by subtracting the number of beans in the current pile from the total sum and adjusting it according to the number of piles that remain.

5. **Return the Result**:
   - The result will be the minimum number of beans that can be removed to make the piles equal in size.

### Code Breakdown (Step by Step)
1. **Compute the Total Sum of Beans**:
   ```cpp
   long long sum = accumulate(begin(beans), end(beans), 0L);
   ```
   - `accumulate` is a standard function from `<numeric>` that computes the sum of all elements in the `beans` array. The `0L` ensures that the sum is computed as a `long long` type to prevent overflow.

2. **Sort the Array**:
   ```cpp
   sort(beans.begin(), beans.end());
   ```
   - Sorting the array simplifies the logic of figuring out how to minimize the beans to be removed. Sorting ensures that we can easily calculate how many beans remain in the piles that are left behind.

3. **Iterate and Calculate the Minimum Removal**:
   ```cpp
   long long res = LLONG_MAX;
   for (int i = 0; i < n; i++)
       res = min(res, sum - (long long) (n - i) * beans[i]);
   ```
   - The variable `res` is initialized to `LLONG_MAX` (the largest possible value for a `long long`), which will store the minimum number of beans to be removed.
   - The loop iterates through each pile, and for each iteration, the number of beans removed is computed as the total sum minus the number of beans left in the remaining piles (`(n - i) * beans[i]`).

4. **Return the Result**:
   ```cpp
   return res;
   ```
   - After iterating through all possible scenarios, the smallest value in `res` will be returned, representing the minimum number of beans that need to be removed to make the remaining piles equal.

### Example Walkthrough
Let's walk through an example with the array `beans = [4, 3, 2, 5]`:
- **Step 1: Calculate the Total Sum of Beans**:
  - Sum = `4 + 3 + 2 + 5 = 14`.

- **Step 2: Sort the Array**:
  - Sorted array = `[2, 3, 4, 5]`.

- **Step 3: Iterate and Compute the Minimum Removal**:
  - For each index `i` in the sorted array, calculate how many beans would remain if the piles from index `i` to the end are kept, and then determine how many beans need to be removed.

  - **Iteration 1 (i = 0)**: Remove piles smaller than or equal to `beans[0] = 2`. 
    - Remaining beans: `(4 - 0) * 2 = 8`.
    - Beans to remove: `14 - 8 = 6`.
    
  - **Iteration 2 (i = 1)**: Remove piles smaller than or equal to `beans[1] = 3`.
    - Remaining beans: `(4 - 1) * 3 = 9`.
    - Beans to remove: `14 - 9 = 5`.
  
  - **Iteration 3 (i = 2)**: Remove piles smaller than or equal to `beans[2] = 4`.
    - Remaining beans: `(4 - 2) * 4 = 8`.
    - Beans to remove: `14 - 8 = 6`.
  
  - **Iteration 4 (i = 3)**: Remove piles smaller than or equal to `beans[3] = 5`.
    - Remaining beans: `(4 - 3) * 5 = 5`.
    - Beans to remove: `14 - 5 = 9`.

  - The minimum beans to remove is `5` (from iteration 2).

- **Step 4: Return the Result**:
  - The result is `5`, meaning 5 beans should be removed to make the remaining piles equal.

### Complexity
- **Time Complexity**:
  - O(n log n) due to the sorting step, where `n` is the number of piles. The iteration through the sorted array takes O(n), and the sorting dominates the overall complexity.

- **Space Complexity**:
  - O(1) as the algorithm only uses a few additional variables for the calculations and does not require extra space proportional to the input size.

### Conclusion
The algorithm efficiently solves the problem by utilizing a combination of sorting and selection strategies to minimize the number of beans removed. The time complexity of O(n log n) ensures that the solution works well even for larger arrays. By breaking the problem into logical steps—sorting, calculating sums, and iterating for the minimum—this approach provides a clear, effective solution for the problem at hand.
### Problem Statement

The "Longest Consecutive Sequence" problem asks us to find the length of the longest consecutive elements sequence in an unsorted array of integers. The consecutive sequence must contain elements that are continuous, i.e., each element is exactly one more than its predecessor. We need to determine the length of the longest sequence that can be formed.

**Example:**
- **Input:** 
  - `nums = [100, 4, 200, 1, 3, 2]`
- **Output:** 
  - `4`
  - Explanation: The longest consecutive sequence is `[1, 2, 3, 4]`, so the answer is 4.

### Approach

The approach to solving this problem efficiently revolves around identifying consecutive sequences in the array while ensuring optimal time complexity. A straightforward solution might involve sorting the array and scanning for consecutive numbers, but this could take `O(n log n)` time due to the sorting step.

A more optimal approach uses a **set** (hash set) to store unique numbers and efficiently check whether consecutive elements exist, without requiring sorting. This approach takes **O(n)** time complexity on average since each operation involving a set (insertion, lookup) is O(1) on average.

#### Steps:
1. **Inserting Elements into a Set**:
   - First, we insert all elements from the array into a `set`. A set automatically handles duplicates, so only unique numbers are stored.
2. **Finding the Longest Consecutive Sequence**:
   - For each number in the array, we check if it's the start of a sequence. The idea is to check if `num - 1` exists in the set. If it does, the current number is not the start of a sequence.
   - If `num - 1` does not exist, itâ€™s the start of a sequence. We then incrementally check for the next consecutive numbers (`num + 1`, `num + 2`, etc.) in the set.
   - Count the length of the sequence and update the result if the sequence is longer than the current maximum.

This approach ensures we only traverse the set once and avoids redundant work. By using a set, we efficiently check for the presence of consecutive numbers in constant time on average.

### Code Breakdown (Step by Step)

#### 1. **Function Definition**
```cpp
int longestConsecutive(vector<int>& nums)
```
This function takes a vector of integers `nums` as input and returns an integer representing the length of the longest consecutive sequence in the array.

#### 2. **Inserting Elements into a Set**
```cpp
set<int> s;
for (int x : nums)
    s.insert(x);
```
- A set `s` is declared. This set will store all unique integers from the `nums` vector.
- We loop through the input array `nums`, and for each element `x`, we insert it into the set `s`. If any element is duplicated in the array, only one copy will be stored in the set, as a set does not allow duplicates.

#### 3. **Edge Case: Empty Set**
```cpp
if (s.empty()) return 0;
```
- Before proceeding, we check if the set is empty. If the set is empty, this means there are no elements in the array, and thus no consecutive sequence can exist. In this case, we return `0`.

#### 4. **Finding the Longest Consecutive Sequence**
```cpp
int mx = 1;
for (int i = 0; i < nums.size(); i++) {
    int y = nums[i];
    int c = 1;
    if (!s.count(y + 1))
        while (s.count(y - 1)) {
            c++;
            y = y - 1;
            mx = max(mx, c);
        }
}
```
- We initialize `mx = 1` to keep track of the maximum length of the consecutive sequence found so far.
- We iterate over each number `y` in the array `nums`. For each number, we attempt to determine if it is the start of a consecutive sequence.
- If `y + 1` is not in the set (i.e., `y` is not part of an ongoing sequence), then `y` is a potential start of a new sequence.
- We then check if `y - 1` exists in the set. If it does, it means the current sequence extends backward. We continue to decrease `y` and count the number of consecutive elements until no more consecutive elements are found.
- The counter `c` keeps track of the length of the consecutive sequence.
- If the current sequence length `c` is greater than the current maximum `mx`, we update `mx` with the new maximum value.

#### 5. **Returning the Result**
```cpp
return mx;
```
- After iterating through all the numbers and determining the longest sequence, we return `mx`, which holds the length of the longest consecutive sequence.

### Example Walkthrough

**Example 1:**
- **Input:** 
  - `nums = [100, 4, 200, 1, 3, 2]`
- **Step-by-Step Execution:**
  - Insert all elements into the set: `{1, 2, 3, 4, 100, 200}`.
  - Start iterating over the array:
    - For `100`: No smaller consecutive number exists (`100 - 1` is not in the set), so the sequence length is `1`.
    - For `4`: We find `3, 2, 1` in the set, forming the sequence `[1, 2, 3, 4]`. Sequence length is `4`.
    - For other numbers: No longer sequence found, so we return the longest sequence length of `4`.

**Output:**
  - `4`

### Time Complexity

- **Time Complexity:** `O(n)`
  - Inserting all elements into the set takes O(n) time, where `n` is the number of elements in the input array.
  - Each lookup and insertion in the set takes O(1) on average. Hence, the overall time complexity is O(n).
  - In the worst case, we iterate over each number in the array once, checking for consecutive elements. This does not result in redundant work due to the efficient use of the set.
  
- **Space Complexity:** `O(n)`
  - The space complexity is O(n) because we store the unique elements from the array in a set.

### Conclusion

This approach solves the "Longest Consecutive Sequence" problem efficiently using a set. By leveraging the properties of the set, we can quickly check for consecutive numbers and avoid redundant work. The algorithm runs in linear time, making it suitable for large input sizes. The overall space complexity is also linear, as we store the unique elements in the set. This solution offers a clean, optimal way to tackle the problem of finding the longest consecutive sequence in an unsorted array.
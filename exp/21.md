### Problem Statement

The problem asks us to merge two sorted singly linked lists into a single sorted linked list. Both lists are already sorted in non-decreasing order, and our task is to combine them in such a way that the result is also sorted in non-decreasing order.

#### Input:
- Two sorted singly linked lists `l1` and `l2`.

#### Output:
- A sorted singly linked list containing all the elements of `l1` and `l2`.

### Approach

To merge the two sorted linked lists, we can use a **recursive approach**. The key idea is to compare the first node of both lists and link the smaller node to the merged list, then move to the next node in that list. By repeating this process, we can build the merged list incrementally.

1. **Base cases**:
   - If one of the lists is `NULL`, return the other list as it is because the merge is complete.
   - If both lists are non-empty, we compare their current values and select the smaller node to be the next in the merged list.
   
2. **Recursive step**:
   - If the current node of `l1` is smaller, we recursively merge the next node of `l1` with `l2` and set `l1->next` to the result of that merge.
   - If the current node of `l2` is smaller, we do the same, but set `l2->next` to the result of merging `l1` and the next node of `l2`.

This method ensures that we are building the merged list by always choosing the smaller node at each step, maintaining the order.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
```
- We begin by defining the `mergeTwoLists` function, which takes two pointers to `ListNode` objects (`l1` and `l2`) as input. These pointers represent the heads of the two linked lists to be merged.

```cpp
        if(l1 == NULL) return l2;
        if(l2 == NULL) return l1;
```
- **Base Case**: If one of the lists is `NULL`, we simply return the other list. This is because if a list is `NULL`, there are no elements to merge, and the other list is already sorted.
  
```cpp
        if(l1->val < l2->val) {
            l1->next = mergeTwoLists(l1->next, l2);
            return l1;
        }
```
- **Recursive Case**: If both lists are non-empty, we compare the values of the first nodes of `l1` and `l2`. 
  - If the value of the current node in `l1` is smaller than the value of the current node in `l2`, we set `l1->next` to the result of merging the rest of `l1` (i.e., `l1->next`) with `l2`.
  - We then return `l1` as the head of the merged list.
  
```cpp
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
};
```
- **Recursive Case (continued)**: If the value of the current node in `l2` is smaller or equal, we perform a similar operation: we set `l2->next` to the result of merging `l1` with the rest of `l2` (i.e., `l2->next`).
- We then return `l2` as the head of the merged list.

### Complexity

#### Time Complexity:
- **O(n + m)**, where `n` and `m` are the lengths of the linked lists `l1` and `l2`, respectively.
  - In the worst case, we will visit every node from both lists exactly once, and each comparison takes constant time, `O(1)`.

#### Space Complexity:
- **O(n + m)**, where `n` and `m` are the lengths of the linked lists `l1` and `l2`.
  - This recursive approach uses the call stack to handle the recursion. In the worst case, the maximum depth of the recursion will be the sum of the lengths of both linked lists, which is `O(n + m)`.

### Conclusion

The solution leverages a **recursive approach** to merge two sorted linked lists. It works efficiently by breaking down the problem into smaller subproblems. The key points to note are:

- The **base case** is when one of the lists is empty, in which case we simply return the other list.
- The **recursive step** compares the current nodes of both lists and merges the lists incrementally, always maintaining order.
  
This approach ensures that we maintain the sorted order of the merged list while using a minimal amount of space (recursive call stack).

Key Benefits:
- **Elegant and simple** solution that naturally follows the principles of divide-and-conquer.
- **Efficient**: It processes each element in both lists exactly once.

This recursive solution is both intuitive and optimal for merging two sorted linked lists. It is commonly used in many problems involving linked lists and recursion.
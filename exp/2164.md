### Problem Statement
Given an integer array `nums`, the task is to reorder the array so that:
- Elements at even indices are sorted in non-decreasing (ascending) order.
- Elements at odd indices are sorted in non-increasing (descending) order.

The output should be the modified array `nums` after sorting the elements at even and odd indices separately.

### Approach
The approach involves a custom sorting technique:
1. Use selection sort to sort elements at even indices in non-decreasing order.
2. Use selection sort again to sort elements at odd indices in non-increasing order.
3. Maintain the original relative order for both even and odd indexed elements, ensuring stability within their groups.

### Code Breakdown (Step by Step)
1. **Sorting Even Indices in Ascending Order:**
   ```cpp
   for(int i = 0; i < nums.size(); i += 2) {
       minIndex = i;
       for(int j = i + 2; j < nums.size(); j += 2) {
           if(nums[j] < nums[minIndex])
               minIndex = j;
       }
       swap(nums[i], nums[minIndex]);
   }
   ```
   - This loop iterates through `nums` starting from index `0` (even) and increments by `2` to visit every even-indexed element.
   - For each even-indexed element, find the smallest value among the remaining even-indexed elements (`j` starts from `i + 2` and increments by `2`).
   - Swap the current element at `i` with the minimum value found at `minIndex`.

2. **Sorting Odd Indices in Descending Order:**
   ```cpp
   for(int i = 1; i < nums.size(); i += 2) {
       minIndex = i;
       for(int j = i + 2; j < nums.size(); j += 2) {
           if(nums[j] > nums[minIndex])
               minIndex = j;
       }
       swap(nums[i], nums[minIndex]);
   }
   ```
   - This loop iterates through `nums` starting from index `1` (odd) and increments by `2` to visit every odd-indexed element.
   - For each odd-indexed element, find the largest value among the remaining odd-indexed elements (`j` starts from `i + 2`).
   - Swap the current element at `i` with the maximum value found at `minIndex`.

3. **Return the Modified Array:**
   ```cpp
   return nums;
   ```
   - After sorting both even and odd indices as described, the array `nums` is returned.

### Example Walkthrough
Suppose `nums = [4, 1, 2, 3, 7, 5, 8]`:
- **Even-indexed elements** are `[4, 2, 7, 8]`.
- **Odd-indexed elements** are `[1, 3, 5]`.

**Sorting Even Indices in Ascending Order:**
- The sorted even indices: `[2, 4, 7, 8]`.

**Sorting Odd Indices in Descending Order:**
- The sorted odd indices: `[5, 3, 1]`.

**Reconstruct the Array:**
- Final `nums` becomes `[2, 5, 4, 3, 7, 1, 8]`.

### Complexity
- **Time Complexity**:
  - O(n^2), due to the use of selection sort for both even and odd index sorting.
  - Each loop runs in O(n) time, and the nested structure of selection sort results in O(n^2) in the worst case.

- **Space Complexity**:
  - O(1), as sorting is done in place with no extra space used apart from a few auxiliary variables.

### Conclusion
This solution ensures that the even and odd indices of the array `nums` are sorted as per the given conditions. While the use of selection sort results in a higher time complexity of O(n^2), the approach is simple, easy to implement, and demonstrates how in-place sorting can be managed without additional data structures. For larger arrays or performance-sensitive applications, more optimized sorting algorithms such as a custom merge sort or partitioning method could be considered.
### Problem Statement

The problem requires us to implement a stack data structure using only queues. Specifically, we need to design a class `MyStack` that mimics the behavior of a stack using an internal queue for storage. The stack should support the following operations:
1. **push(x)**: Pushes element `x` onto the stack.
2. **pop()**: Removes and returns the top element of the stack.
3. **top()**: Returns the top element of the stack without removing it.
4. **empty()**: Returns `true` if the stack is empty, otherwise `false`.

A stack follows the **Last In, First Out (LIFO)** principle, which means that the last element added to the stack is the first one to be removed.

The challenge is to implement this stack using only a queue. This requires careful handling of the queue operations to simulate the stack behavior.

### Approach

We can use a single queue to simulate the stack’s LIFO behavior. A queue is a **First In, First Out (FIFO)** structure, which is opposite to the stack’s behavior. However, we can manipulate the queue by shifting elements to simulate the desired stack behavior.

To achieve this, the key idea is:
- **Push operation**: When pushing an element to the stack, we add it to the queue, but to maintain the LIFO order, we need to move all the existing elements behind it. This can be done by rotating the queue after each `push` operation. By pushing an element and then rotating the queue, the newly pushed element moves to the front of the queue, simulating the top of the stack.
  
- **Pop operation**: The element at the front of the queue will always represent the top element of the stack, so we can simply dequeue it to simulate the pop behavior.

- **Top operation**: The element at the front of the queue is the current top of the stack, so we return it without modifying the queue.

- **Empty operation**: Simply check if the queue is empty.

By using this approach, we can simulate stack operations while using only queue operations. The trick lies in the rotation of the queue elements during the `push` operation to ensure that the most recently added element stays at the front of the queue, mimicking the stack's LIFO behavior.

### Code Breakdown (Step by Step)

```cpp
class MyStack {
public:
    queue<int> que;  // Step 1: Declare a queue to store the elements

    // Constructor: Initializes the stack (queue in this case)
    MyStack() {}

    // Step 2: Push operation
    void push(int x) {
        que.push(x);  // Add the element to the queue
        // Rotate the queue to make the new element at the front
        for (int i = 0; i < que.size() - 1; ++i) {
            que.push(que.front());  // Move the front element to the back of the queue
            que.pop();  // Remove the front element after moving it to the back
        }
    }

    // Step 3: Pop operation
    int pop() {
        int x = que.front();  // Get the front element (top of the stack)
        que.pop();  // Remove the front element
        return x;  // Return the popped element
    }

    // Step 4: Top operation
    int top() {
        return que.front();  // Return the front element (top of the stack)
    }

    // Step 5: Empty operation
    bool empty() {
        return que.empty();  // Check if the queue (stack) is empty
    }
};
```

#### Step 1: Declare the Queue
```cpp
queue<int> que;
```
- A single queue `que` is declared to store the stack elements. The queue is the only container used, which is a requirement of the problem. The `queue` is used to simulate the stack's behavior.

#### Step 2: Implement the `push` Operation
```cpp
void push(int x) {
    que.push(x);  // Add the element to the queue
    // Rotate the queue to make the new element at the front
    for (int i = 0; i < que.size() - 1; ++i) {
        que.push(que.front());  // Move the front element to the back of the queue
        que.pop();  // Remove the front element after moving it to the back
    }
}
```
- The `push` operation adds the element `x` to the queue, but since a queue follows the FIFO principle, we need to rotate the queue elements to simulate the LIFO behavior.
- After adding the element `x`, we move the existing elements to the back of the queue one by one. The `for` loop iterates through all elements except the newly added one (`que.size() - 1` iterations). This ensures that the most recently added element ends up at the front of the queue, simulating the "top" of the stack.

#### Step 3: Implement the `pop` Operation
```cpp
int pop() {
    int x = que.front();  // Get the front element (top of the stack)
    que.pop();  // Remove the front element
    return x;  // Return the popped element
}
```
- The `pop` operation simply removes and returns the element at the front of the queue, which corresponds to the "top" of the stack in the LIFO order.

#### Step 4: Implement the `top` Operation
```cpp
int top() {
    return que.front();  // Return the front element (top of the stack)
}
```
- The `top` operation returns the element at the front of the queue without removing it, which simulates checking the top of the stack.

#### Step 5: Implement the `empty` Operation
```cpp
bool empty() {
    return que.empty();  // Check if the queue (stack) is empty
}
```
- The `empty` operation checks if the queue is empty. If the queue is empty, it means the stack is empty, so we return `true`; otherwise, we return `false`.

### Complexity

#### Time Complexity:
- **Push operation**: The `push` operation involves adding an element to the queue, which is an `O(1)` operation. However, after adding the element, we need to rotate the queue to simulate the stack's LIFO behavior. This rotation requires `O(n)` time, where `n` is the number of elements in the queue. Therefore, the time complexity of the `push` operation is **O(n)**.
  
- **Pop operation**: The `pop` operation simply removes an element from the front of the queue, which takes **O(1)** time.
  
- **Top operation**: The `top` operation retrieves the element from the front of the queue, which is an **O(1)** operation.
  
- **Empty operation**: The `empty` operation checks if the queue is empty, which is an **O(1)** operation.

Therefore, the overall time complexities are:
- `push`: **O(n)**
- `pop`: **O(1)**
- `top`: **O(1)**
- `empty`: **O(1)**

#### Space Complexity:
- The space complexity is determined by the space needed to store the queue. Since we store all the elements in the queue, the space complexity is **O(n)**, where `n` is the number of elements in the stack.

### Conclusion

This solution successfully implements a stack using only a queue by leveraging the properties of the queue and rotating its elements during the `push` operation to simulate the stack’s LIFO behavior. While the `push` operation is `O(n)` due to the rotation, both the `pop`, `top`, and `empty` operations are efficient, with a time complexity of **O(1)**.

- **Time Complexity**: The `push` operation has a time complexity of **O(n)**, while `pop`, `top`, and `empty` operations run in **O(1)**.
- **Space Complexity**: The space complexity is **O(n)** due to the storage of elements in the queue.

Overall, this solution demonstrates how to use a queue to simulate the behavior of a stack and is efficient for the required operations, making it a useful and interesting approach for implementing stack-like behaviors with limited resources.
### üöÄ Problem Statement

In this problem, we're tasked with implementing a **stack** data structure using only **queues**! üßë‚Äçüíª The stack should support the following operations:

1. **push(x)**: Push element `x` onto the stack.
2. **pop()**: Removes and returns the top element of the stack.
3. **top()**: Returns the top element of the stack without removing it.
4. **empty()**: Returns `true` if the stack is empty, otherwise `false`.

A **stack** works on the **Last In, First Out (LIFO)** principle, where the last element added is the first one to be removed. However, queues follow the **First In, First Out (FIFO)** principle. So how do we simulate a stack using a queue? Let's dive in! üîç

---

### üß† Approach

To simulate stack behavior with queues, we need to manipulate the queue operations smartly. Here‚Äôs how we can do it:

- **Push operation**: When adding an element to the stack, we enqueue it. However, to ensure the most recent element is always at the front (top of the stack), we rotate the queue after every push. This will make the newly added element the front of the queue, simulating the "top" of the stack.
  
- **Pop operation**: Since the front element of the queue is always the top of the stack (due to the rotation), we can simply dequeue it.

- **Top operation**: Just like with pop, the front element of the queue is the current top of the stack, so we can return it without removing it from the queue.

- **Empty operation**: This is straightforward! We check if the queue is empty, which directly corresponds to the stack being empty.

By rotating the queue during each push, we can mimic the LIFO behavior of a stack using only FIFO operations. Cool, right? üòé

---

### üî® Step-by-Step Code Breakdown

Let‚Äôs break this down with some code! üõ†Ô∏è

```cpp
class MyStack {
public:
    queue<int> que;  // Step 1: Declare a queue to store the elements

    // Constructor: Initializes the stack (queue in this case)
    MyStack() {}

    // Step 2: Push operation
    void push(int x) {
        que.push(x);  // Add the element to the queue
        // Rotate the queue to make the new element at the front
        for (int i = 0; i < que.size() - 1; ++i) {
            que.push(que.front());  // Move the front element to the back of the queue
            que.pop();  // Remove the front element after moving it to the back
        }
    }

    // Step 3: Pop operation
    int pop() {
        int x = que.front();  // Get the front element (top of the stack)
        que.pop();  // Remove the front element
        return x;  // Return the popped element
    }

    // Step 4: Top operation
    int top() {
        return que.front();  // Return the front element (top of the stack)
    }

    // Step 5: Empty operation
    bool empty() {
        return que.empty();  // Check if the queue (stack) is empty
    }
};
```

#### Step 1: Declare the Queue
```cpp
queue<int> que;
```
- Here, we declare a queue called `que` to hold the stack's elements. It‚Äôs the only container we‚Äôll use to simulate the stack's behavior. üé©‚ú®

#### Step 2: Implement the `push` Operation
```cpp
void push(int x) {
    que.push(x);  // Add the element to the queue
    // Rotate the queue to make the new element at the front
    for (int i = 0; i < que.size() - 1; ++i) {
        que.push(que.front());  // Move the front element to the back of the queue
        que.pop();  // Remove the front element after moving it to the back
    }
}
```
- In the `push` operation, we first add the element `x` to the queue. Then, we rotate the queue to make the newly added element the "top" of the stack (at the front of the queue). üöÄ

#### Step 3: Implement the `pop` Operation
```cpp
int pop() {
    int x = que.front();  // Get the front element (top of the stack)
    que.pop();  // Remove the front element
    return x;  // Return the popped element
}
```
- The `pop` operation simply dequeues the element at the front of the queue, which corresponds to the "top" of the stack.

#### Step 4: Implement the `top` Operation
```cpp
int top() {
    return que.front();  // Return the front element (top of the stack)
}
```
- The `top` operation returns the front element of the queue without removing it, which is equivalent to checking the top of the stack.

#### Step 5: Implement the `empty` Operation
```cpp
bool empty() {
    return que.empty();  // Check if the queue (stack) is empty
}
```
- The `empty` operation checks if the queue is empty. If it is, the stack is empty too!

---

### üìà Complexity Analysis

Let's analyze the time and space complexities of the operations. üìä

#### Time Complexity:
- **Push operation**: The `push` operation involves adding an element to the queue (`O(1)`), and then rotating the queue by moving all elements to the back (`O(n)` where `n` is the number of elements in the queue). Therefore, the overall time complexity of `push` is **O(n)**.
  
- **Pop operation**: The `pop` operation simply removes an element from the front of the queue, which is an **O(1)** operation.
  
- **Top operation**: The `top` operation just returns the front element, which is an **O(1)** operation.
  
- **Empty operation**: The `empty` operation checks if the queue is empty, which is an **O(1)** operation.

#### Space Complexity:
- We only use one queue to store the elements. So, the space complexity is **O(n)**, where `n` is the number of elements in the stack.

---

### üèÅ Conclusion

Congratulations! üéâ You‚Äôve successfully implemented a stack using only a queue. This approach leverages the unique behavior of the queue and simulates stack operations through smart rotations. While the `push` operation takes linear time due to the rotations, the `pop`, `top`, and `empty` operations are all constant time, making this a very efficient solution in practice.

- **Time Complexity**:
  - `push`: **O(n)**
  - `pop`: **O(1)**
  - `top`: **O(1)**
  - `empty`: **O(1)**
  
- **Space Complexity**: **O(n)** due to the storage of elements in the queue.

This solution is a great way to think outside the box and use queues for stack-like behavior. Happy coding! üíªüéØ
### Problem Statement

The task is to determine the minimum number of operations required to make all elements of a given integer array `nums` equal to zero. Each operation allows you to subtract a fixed positive integer (greater than zero) from all non-zero elements in the array. The aim is to count the number of distinct values that must be subtracted to reduce every element in the array to zero.

### Approach

1. **Sorting**: First, sort `nums` to bring identical values together and simplify the identification of unique elements. Sorting helps in counting distinct values efficiently by iterating once through the sorted list.
  
2. **Counting Unique Reductions**:
   - Initialize a `mx` variable to track the maximum value of elements processed so far.
   - Iterate through `nums`, and whenever you encounter a number greater than `mx`, it represents a new distinct value that needs to be subtracted from all elements.
   - Increment the result count (`res`) for each new unique number encountered and update `mx` to this value.

3. **Returning the Result**: After counting all unique reductions, `res` will represent the minimum number of operations required.

### Code Breakdown (Step by Step)

#### Step 1: Sort the Array

```cpp
sort(nums.begin(), nums.end());
```
- Sorting helps arrange the array in increasing order, which simplifies counting unique values needed for reduction.

#### Step 2: Initialize Variables for Counting Unique Operations

```cpp
int mx = 0, res = 0;
```
- `mx`: Tracks the highest unique value seen so far, to help detect new unique values.
- `res`: Stores the number of unique reduction operations needed.

#### Step 3: Iterate Through the Array

```cpp
for(int i = 0; i < nums.size(); i++) {
    if(mx < nums[i]) {
        mx = nums[i];
        res++;
    }
}
```
- For each element, if `nums[i]` is greater than `mx`, it is a new unique value for reduction.
- Update `mx` and increment `res` to reflect this unique value.

#### Step 4: Return the Result

```cpp
return res;
```
- Return `res`, which now holds the minimum number of unique reductions required.

### Complexity

- **Time Complexity**: **O(n log n)**, primarily due to the sorting step. The subsequent single loop through the array runs in **O(n)**.
- **Space Complexity**: **O(1)**, as the solution uses only a few extra variables.

### Conclusion

This solution efficiently calculates the minimum operations needed by counting distinct values after sorting the array. By leveraging sorting and tracking the maximum encountered value, it ensures that each unique reduction is counted only once. This approach is optimal for this problem, making it suitable for large datasets. The algorithm achieves high performance through minimal space usage and avoids redundancy by using sorted order and conditionals to count only distinct values for reduction.
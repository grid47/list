### Problem Statement
Given the head of a singly linked list, return the middle node of the linked list. If there are two middle nodes, return the second middle node.

### Approach
To find the middle node of a linked list, we can use the **two-pointer technique**:

1. **Initialize Two Pointers**:
   - Start with two pointers, `slow` and `fast`, both pointing to the head of the linked list.

2. **Traverse the List**:
   - Move the `slow` pointer one step at a time (`slow = slow->next`).
   - Move the `fast` pointer two steps at a time (`fast = fast->next->next`).
   - Continue this process until the `fast` pointer reaches the end of the list (i.e., `fast` is `nullptr` or `fast->next` is `nullptr`).

3. **Return the Middle Node**:
   - When the loop ends, the `slow` pointer will be pointing to the middle node of the list.
   - If the list has an even number of nodes, the `slow` pointer will point to the second middle node, which is the desired result.

### Code Walk-through
- The function initializes two pointers, `slow` and `fast`, both set to the head.
- A while loop iterates as long as `fast` and `fast->next` are not null.
- After exiting the loop, the `slow` pointer is returned, which represents the middle node of the linked list.

### Complexity
- **Time Complexity**: \( O(n) \), where \( n \) is the number of nodes in the linked list. Each pointer traverses the list once.
- **Space Complexity**: \( O(1) \), as no extra space is used other than the pointers.


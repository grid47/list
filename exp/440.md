### Problem Statement

The problem asks to find the `k`-th smallest number in the lexicographical order of numbers from `1` to `n`. Lexicographical order is akin to dictionary order, and the task is to determine which number appears at the `k`-th position in this order.

For example, given `n = 13` and `k = 5`, the lexicographical order of numbers from 1 to 13 would be:
`1, 10, 11, 12, 13`, so the 5th number is `13`.

### Approach

To solve this problem efficiently, we can take advantage of lexicographical properties and avoid generating all numbers up to `n`. Instead, we can "walk" through the lexicographical order using a tree-like structure and count how many numbers lie between two given numbers. This approach is faster than directly sorting all numbers.

#### Key Observations:
1. **Lexicographical Order as a Tree**:
   - Numbers can be thought of as nodes in a tree where the root is `1`, and each number branches out to form its next possible children (e.g., `1` branches out to `10`, `11`, `12`, etc., as the first digits of the numbers increase).
   - This tree-like structure allows us to navigate efficiently through the lexicographical order without generating every number.

2. **Counting Numbers in a Range**:
   - Given two numbers `a` and `b`, the number of numbers in the lexicographical range `[a, b)` can be calculated by repeatedly multiplying `a` and `b` by 10 until `a` exceeds `n`. This helps us to count how many numbers start with the prefix `a` without directly constructing them.

3. **Optimal Strategy**:
   - Start at `1`, and for each iteration, calculate how many numbers start with the current prefix (e.g., starting with `1`, how many numbers are lexicographically smaller than `10`?).
   - Depending on how many numbers are in the current range, either move to the next number by increasing the prefix (e.g., from `1` to `2`) or move deeper into the tree by multiplying the current prefix by `10`.

### Code Breakdown (Step by Step)

#### Step 1: Lambda Function to Count Numbers in a Range
The function `getGap` is a helper function that computes how many numbers lie in the lexicographical range `[a, b)`:
```cpp
auto getGap = [&n](long a, long b) {
    long gap = 0;
    while (a <= n) {
        gap += min(n + 1, b) - a;  // Count numbers in the range [a, b)
        a *= 10;  // Move to the next range (e.g., from 1 to 10, 11, ...)
        b *= 10;  // Same for b
    }
    return gap;
};
```
- The function uses a loop to multiply `a` and `b` by 10 at each step, effectively moving through lexicographically increasing ranges.
- The condition `a <= n` ensures we stop when `a` exceeds `n`.

#### Step 2: Main Loop to Find the k-th Number
```cpp
long currNum = 1;  // Start with the number 1
for (int i = 1; i < k;) {
    long gap = getGap(currNum, currNum + 1);
    cout << currNum << " " << gap << "\n";  // For debugging purposes
    if (i + gap <= k) {
        i += gap;  // Skip over all numbers in the current range
        ++currNum;  // Move to the next number in the sequence (1 -> 2 -> 3, etc.)
    } else {
        ++i;
        currNum *= 10;  // Move deeper into the tree, e.g., from 1 to 10
    }
}
```
- The variable `currNum` is initially set to `1`.
- The loop iterates while `i` (the position of the current number) is less than `k`. In each iteration:
  - The `getGap` function calculates how many numbers are in the range `[currNum, currNum + 1)`, which gives us the size of the current "branch" in the tree.
  - If the current range contains enough numbers to skip past `k`, we move to the next prefix by incrementing `currNum`. Otherwise, we move deeper into the tree by multiplying `currNum` by `10`.

#### Step 3: Return the Result
Once the loop completes, `currNum` will hold the `k`-th smallest number in lexicographical order, which is returned.

### Complexity

#### Time Complexity:
- **Time for `getGap` function**: The function `getGap` takes `O(log n)` time because at each step it multiplies `a` and `b` by `10`, and the number of steps required to reach `n` is logarithmic in the size of `n`.
- **Time for the main loop**: The loop iterates `k` times. In each iteration, the `getGap` function is called once, and this takes `O(log n)` time. Therefore, the time complexity of the main loop is `O(k * log n)`.
- **Overall Time Complexity**: Since the maximum possible value for `k` is `n`, the overall time complexity is `O(n * log n)`.

#### Space Complexity:
- The space complexity is constant, `O(1)`, since we are only using a few extra variables to store the current number and perform calculations.

### Conclusion

This solution efficiently computes the `k`-th smallest number in lexicographical order from `1` to `n` without needing to generate all numbers up to `n`. By leveraging the structure of lexicographical order and efficiently counting the number of numbers in ranges, we can solve the problem in logarithmic time per iteration, leading to an overall time complexity of `O(k * log n)`. This makes the algorithm well-suited for large values of `n` and `k`.
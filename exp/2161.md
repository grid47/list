### Problem Statement
Given an array of integers `nums` and an integer `pivot`, the task is to reorder the array so that:
- All elements less than `pivot` come before elements equal to `pivot`.
- All elements greater than `pivot` come after elements equal to `pivot`.
- The relative order of the elements less than and greater than `pivot` should remain the same as in the original array.

Return the rearranged array.

### Approach
To achieve the desired arrangement, a three-pass approach is used:
1. **Count the number of elements less than, equal to, and greater than the `pivot`.**
2. **Allocate and reorder elements into their correct positions based on the counts.**

This method ensures that the array is traversed only a couple of times, maintaining the relative order while partitioning the elements.

### Code Breakdown (Step by Step)
1. **Initialization of Counters:**
   ```cpp
   int low = 0, same = 0, high;
   ```
   - `low`: Counter for the number of elements less than the `pivot`.
   - `same`: Counter for the number of elements equal to the `pivot`.
   - `high`: Will be calculated to represent the starting position of elements greater than `pivot`.

2. **Counting Elements:**
   ```cpp
   for(auto num: nums) {
       if(num < pivot) low++;
       else if(num == pivot) same++;
   }
   high = low + same;
   same = low;
   low = 0;
   ```
   - Iterate through `nums` to count how many elements are less than and equal to `pivot`.
   - `high` is set to `low + same`, which will represent the starting index for elements greater than `pivot`.
   - `same` is reset to `low` to represent the starting index for elements equal to `pivot`.

3. **Reordering Elements:**
   ```cpp
   vector<int> res(nums.size(), 0);
   for(auto num: nums) {
       if(num < pivot) res[low++] = num;
       else if(num == pivot) res[same++] = num;
       else res[high++] = num;
   }
   ```
   - Create a new vector `res` of the same size as `nums`, initialized to zero.
   - Traverse `nums` and place elements in `res` based on their comparison with `pivot`:
     - If `num` is less than `pivot`, it goes at the current `low` index and increments `low`.
     - If `num` is equal to `pivot`, it goes at the current `same` index and increments `same`.
     - If `num` is greater than `pivot`, it goes at the current `high` index and increments `high`.

4. **Return the Result:**
   ```cpp
   return res;
   ```
   - Return the reordered vector `res`.

### Example Walkthrough
Suppose `nums = [9, 12, 5, 10, 14, 3, 10]` and `pivot = 10`:
- **First Pass (Counting)**:
  - `low = 3` (for numbers `9, 5, 3`)
  - `same = 2` (for numbers `10, 10`)
  - `high = low + same = 5`

- **Second Pass (Reordering)**:
  - Place elements less than `pivot` in positions `0, 1, 2`.
  - Place elements equal to `pivot` in positions `3, 4`.
  - Place elements greater than `pivot` in positions `5, 6`.

Resulting array: `[9, 5, 3, 10, 10, 12, 14]`.

### Complexity
- **Time Complexity**:
  - O(n), where `n` is the number of elements in `nums`. This includes O(n) for counting and another O(n) for reordering.
- **Space Complexity**:
  - O(n), for the result vector `res` which holds the reordered elements. No additional space is used apart from basic counters and the output vector.

### Conclusion
This solution efficiently partitions the input array based on a given `pivot`, maintaining the original relative order of elements. The algorithm accomplishes this in O(n) time with O(n) space, making it optimal for moderate-sized arrays. The approach is straightforward and well-suited for scenarios that require stable partitioning around a pivot. This makes it ideal for applications that involve pre-processing data for further analysis or segmentation.
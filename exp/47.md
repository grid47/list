### Problem Statement

The task is to generate all unique permutations of a list of integers. The input array `nums` can contain duplicate values, and the goal is to ensure that the permutations generated are unique, i.e., no duplicate permutations are included in the result.

### Approach

The approach to solving this problem involves generating all possible permutations using **backtracking** with the help of a **hash map** (unordered_map). By tracking the elements we've already used in the current level of recursion, we avoid generating duplicate permutations. This approach leverages the fact that swapping the elements in the list and recursively exploring all possible configurations helps generate permutations. The map prevents processing the same element twice at each recursive level, which ensures uniqueness.

Here is the detailed approach for solving this problem:

1. **Backtracking**: We use a recursive function to generate all possible permutations of the input list.
2. **Handling Duplicates**: We use a hash map (`unordered_map`) to keep track of the elements that have been used in the current recursive call to avoid generating duplicate permutations.
3. **Swapping Elements**: During the recursion, we swap the current element with the elements following it, generating all permutations of the sublist.
4. **Base Case**: Once we have processed all elements in the list, we add the permutation to the results.
5. **Recursive Case**: For each index in the array, if the current element hasn't been used at the current recursion level, we swap it into the current position and recurse on the remaining sublist.

### Code Breakdown (Step by Step)

#### Step 1: `permuteUnique` Function

```cpp
vector<vector<int>> permuteUnique(vector<int>& nums) {
    vector<vector<int>> ans;
    f(nums, ans, 0);
    return ans;
}
```

- **Input**: The function `permuteUnique` takes a vector of integers `nums` as input.
- **Initialization**: An empty result vector `ans` is created to store the unique permutations.
- **Backtracking Call**: The function then calls the recursive function `f(nums, ans, 0)` to start generating permutations starting from the 0th index.
- **Return**: After the recursion is complete, the `ans` vector, which contains all the unique permutations, is returned.

#### Step 2: `f` Function (Backtracking Logic)

```cpp
void f(vector<int>& nums, vector<vector<int>>& ans, int ind) {
    if(ind == nums.size()) {
        ans.push_back(nums);
        return;
    }
    
    unordered_map<int, int> mp;
    for(int i = ind; i < nums.size(); i++) {
        if(mp.find(nums[i]) != mp.end()) {
            continue;
        } else {
            mp[nums[i]]++;
            swap(nums[i], nums[ind]);
            f(nums, ans, ind + 1);
            swap(nums[i], nums[ind]);
        }
    }
}
```

- **Base Case**: When `ind` reaches the size of `nums`, the current permutation (`nums`) is complete, so we add it to the result vector `ans` and return.
  
  ```cpp
  if(ind == nums.size()) {
      ans.push_back(nums);
      return;
  }
  ```

- **Map for Duplicate Checking**: A `unordered_map` (`mp`) is used to track which elements have already been processed at the current index `ind`. The map ensures that we only swap each element once at each recursion level.
  
  ```cpp
  unordered_map<int, int> mp;
  ```

- **Loop through Remaining Elements**: The loop runs from the current index `ind` to the end of the array. For each element at index `i`, we check whether it has been used in the current recursive call by checking if it exists in the map `mp`.

  ```cpp
  for(int i = ind; i < nums.size(); i++) {
      if(mp.find(nums[i]) != mp.end()) {
          continue;
      }
  }
  ```

  If the element has already been used, we skip it to prevent generating duplicate permutations. If it hasn't been used, we proceed with the following steps.

- **Swap the Element**: We swap the element at index `i` with the element at index `ind`, effectively placing the element in the current position for the next recursive call.
  
  ```cpp
  swap(nums[i], nums[ind]);
  ```

- **Recursive Call**: We then make a recursive call to generate permutations of the remaining sublist, incrementing the index `ind` by 1.

  ```cpp
  f(nums, ans, ind + 1);
  ```

- **Backtrack**: After the recursion call, we undo the swap to restore the original order and explore other possibilities.

  ```cpp
  swap(nums[i], nums[ind]);
  ```

#### Step 3: Handling Duplicates

The key part of the solution is the use of the unordered map `mp`, which ensures that the same element is not used more than once at the same recursion level. This eliminates the possibility of generating duplicate permutations. If an element at index `i` has already been used at index `ind` (i.e., it has already been swapped into the `ind` position during the current recursive call), we skip that iteration.

### Complexity

#### Time Complexity

The time complexity for generating all permutations of `n` elements is `O(n!)`. This is because there are `n!` possible permutations of `n` elements, and we need to generate each permutation. However, the presence of duplicates in the input array reduces the number of unique permutations. In the worst case, where all elements are distinct, the time complexity remains `O(n!)`.

- **Time Complexity**: `O(n * n!)`, where `n` is the number of elements in the input array `nums`. This is the time required to generate all the permutations and process each one.

#### Space Complexity

The space complexity is driven by:
1. The space used to store the result: There are `n!` permutations, and each permutation contains `n` elements, so the total space used by the result is `O(n * n!)`.
2. The space used by the recursion stack: The maximum depth of the recursion tree is `n`, and each recursive call uses additional space for the map and the temporary permutation array. This results in a space complexity of `O(n)` for the recursion stack and `O(n)` for the temporary permutation array.

- **Space Complexity**: `O(n * n!)` for storing the result, plus `O(n)` for the recursion stack.

### Conclusion

The solution efficiently generates all unique permutations of a given list of integers using a **backtracking** approach with a **hash map** to eliminate duplicate permutations. The algorithm swaps elements to generate different permutations and uses the map to avoid reprocessing the same element at each recursion level.

- The backtracking approach is a natural fit for this problem, allowing us to explore all possible permutations while ensuring that duplicates are avoided through the map.
- The solution has a **time complexity of O(n * n!)**, which is optimal for generating permutations, and a **space complexity of O(n * n!)** due to the need to store the results.
- This method works well for generating permutations of moderate-sized arrays and ensures that the output contains only unique permutations, even when the input contains duplicates.

This approach is both space and time-efficient, and it provides a clear and straightforward solution for generating unique permutations.
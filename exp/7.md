### Problem Statement

The problem asks us to reverse the digits of a 32-bit signed integer `x`. If the reversed integer overflows or results in an invalid 32-bit signed integer, we are to return `0`. A 32-bit signed integer can hold values in the range of `[-2^31, 2^31 - 1]`, i.e., from `-2147483648` to `2147483647`.

### Example:
Given the integer `x = 123`, the output should be `321`.  
For `x = -123`, the output should be `-321`.  
For `x = 120`, the output should be `21`.  
For `x = 0`, the output should be `0`.  
If the reversed integer overflows, return `0`. For example, reversing `1534236469` would result in an overflow, so the output should be `0`.

### Approach

To solve the problem, we need to reverse the digits of the given integer while ensuring that the resulting reversed integer is within the bounds of a 32-bit signed integer. Specifically:
1. **Reversal Logic**: To reverse the digits of an integer, we can extract the last digit of the integer using the modulus operator (`% 10`) and update the integer by dividing it by 10 (`x /= 10`). We then append the extracted digit to the reversed number by multiplying the reversed number by 10.
  
2. **Overflow Handling**: Since the range of 32-bit integers is fixed, we must check whether the reversed integer exceeds the maximum or minimum values. Specifically:
   - If reversing the number would result in a value greater than `INT_MAX` (i.e., `2147483647`), we return `0`.
   - If the reversed number is less than `INT_MIN` (i.e., `-2147483648`), we also return `0`.

3. **Edge Case**: If the number is `0`, the reversal should be `0`.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables

```cpp
int rev = 0, pop;
```
- `rev` is used to hold the reversed number as we build it. It starts at `0`.
- `pop` is used to hold the last digit of the current number during each iteration of the loop.

#### Step 2: Loop to Reverse the Number

```cpp
while(x != 0)
{
    pop  = x % 10;
    x   /= 10;
```
- We enter a loop that continues as long as `x` is not `0`.
- `pop = x % 10` extracts the last digit of `x`.
- `x /= 10` removes the last digit of `x` by performing an integer division by `10`.

#### Step 3: Check for Overflow Conditions

```cpp
if( (rev > INT_MAX/10 || (rev == INT_MAX/10 && pop > 7)) || 
    (rev < INT_MIN/10 || (rev == INT_MIN/10 && pop < -8)) )
    return 0;
```
- Before updating `rev`, we need to check if multiplying `rev` by `10` and adding `pop` would overflow the 32-bit integer range.
- **Overflow condition for positive numbers**: If `rev` is greater than `INT_MAX / 10`, multiplying `rev` by `10` will overflow. Additionally, if `rev` is equal to `INT_MAX / 10`, adding `pop` (which is the last digit) could cause an overflow if `pop` exceeds `7` (since the maximum positive value for a 32-bit signed integer is `2147483647`).
  
- **Overflow condition for negative numbers**: Similarly, if `rev` is less than `INT_MIN / 10`, multiplying `rev` by `10` will overflow. If `rev` is equal to `INT_MIN / 10`, adding `pop` could cause an underflow if `pop` is less than `-8` (since the minimum negative value for a 32-bit signed integer is `-2147483648`).

If any of these conditions are met, we return `0` to indicate an overflow.

#### Step 4: Update the Reversed Number

```cpp
rev = rev * 10 + pop;
```
- If no overflow condition is triggered, we multiply `rev` by `10` (shifting its digits left by one position) and add `pop` (the extracted digit) to the reversed number.

#### Step 5: Return the Result

```cpp
return rev;
```
- Once the loop completes (i.e., `x` becomes `0`), we return the reversed number `rev`.

### Complexity

#### Time Complexity:
- The time complexity is **O(log(x))**, where `x` is the input number. This is because the loop runs once for each digit in the input number, and the number of digits in an integer is proportional to the logarithm of the number. Specifically, it is roughly the base-10 logarithm of the absolute value of `x`.

#### Space Complexity:
- The space complexity is **O(1)** because we are using a constant amount of space to store variables (`rev` and `pop`).

### Conclusion

The solution efficiently reverses the digits of a 32-bit signed integer while handling potential overflow cases. The algorithm runs in logarithmic time with respect to the number of digits in the input, which is optimal for this problem. By performing overflow checks before updating the reversed number, the solution ensures that the final result remains within the valid range of a 32-bit signed integer. If an overflow occurs during the reversal process, the function returns `0`, as required.
### Problem Statement

The problem requires finding all nodes that are at a distance `k` from a given target node in a binary tree. The binary tree is represented by a root node and has an arbitrary structure with child nodes connected by edges. A target node is provided, and you need to determine all the nodes that are exactly `k` edges away from the target. The nodes can be traversed by moving up or down the tree.

For example:
Given a binary tree and a target node, you are tasked with returning all nodes that are at a distance `k` from the target node.

### Approach

To solve this problem, we need to approach it in a systematic way that considers both the traversal of the tree and the relationship between nodes. We will break down the solution into several key components:

1. **Parent Mapping**: Since the problem allows traversal in both directions (up and down), we need a way to navigate from any node to its parent. We can achieve this by creating a mapping from child nodes to their respective parents.

2. **Depth-First Search (DFS)**: To find all nodes at a distance `k` from the target, we perform a DFS starting from the target node. We will visit nodes at increasing levels of depth while keeping track of the nodes we've already visited.

3. **Set of Visited Nodes**: We must ensure that we do not revisit the same node while traversing the tree. For this purpose, we will use a set to store the nodes we have already visited.

4. **Tracking Distance**: While performing DFS, we maintain the depth and stop when we reach a distance `k` from the target node.

The approach is efficient and leverages both DFS and the parent-child relationship in the tree to solve the problem.

### Code Breakdown (Step by Step)

#### Step 1: Parent Mapping

```cpp
void parents(TreeNode* node) {
    if(!node) return;
    if(node->left) {
        mp[node->left] = node;
        parents(node->left);
    }

    if(node->right) {
        mp[node->right] = node;
        parents(node->right);
    }
}
```

- The `parents` function builds a mapping of each node to its parent. We traverse the tree starting from the root, and for every node that has a left or right child, we add an entry in the map `mp` where the child is the key and the parent is the value.
  
- This function ensures that we can traverse upwards in the tree, allowing us to move from a child node to its parent if needed during our search for nodes at distance `k`.

#### Step 2: Depth-First Search (DFS) Implementation

```cpp
void dfs(TreeNode* node, int k) {
    if(st.count(node)) return;
    st.insert(node);

    if(k == 0) {
        ans.push_back(node->val);
        return;
    }

    if(node->left) dfs(node->left, k - 1);
    if(node->right) dfs(node->right, k - 1);
    if(mp[node]) dfs(mp[node], k - 1);
}
```

- The `dfs` function is a recursive helper function that performs a DFS to find all nodes at distance `k` from the target node.
- We first check if the current node has been visited by checking if it exists in the set `st`. If it has, we return immediately to avoid revisiting nodes.
  
- If the distance `k` reaches 0, it means we have found a node that is exactly `k` steps away from the target. We add this node's value to the result vector `ans`.

- The DFS explores the left and right children of the current node. Additionally, it checks if the parent of the node (using the `mp` map) should be explored. This allows us to traverse both upwards and downwards in the tree.

#### Step 3: Initializing the Process

```cpp
vector<int> distanceK(TreeNode* root, TreeNode* target, int k) {
    if(!root) return {};
    parents(root);

    dfs(target, k);
    return ans;
}
```

- The `distanceK` function is the main function called to find all nodes at distance `k` from the target node.
  
- First, we build the parent-child mapping by calling `parents(root)`. This prepares the `mp` map so that each node is associated with its parent.
  
- Then, we start the DFS search from the target node, looking for nodes that are exactly `k` distance away. The result is stored in the `ans` vector, which is returned at the end.

### Complexity

#### Time Complexity:
- **O(N)** where `N` is the number of nodes in the tree.
  - Building the parent map requires a traversal of the entire tree, which is O(N).
  - The DFS traversal visits each node at most once, which is also O(N).
  
Thus, the total time complexity is **O(N)**, where `N` is the number of nodes in the tree.

#### Space Complexity:
- **O(N)** due to the following reasons:
  - The parent map `mp` stores entries for each node, requiring O(N) space.
  - The set `st` stores the nodes that have been visited during DFS, requiring O(N) space in the worst case.
  - The result vector `ans` can also store up to O(N) elements if all nodes are at a distance `k` from the target.
  
Therefore, the space complexity is **O(N)**.

### Conclusion

This solution efficiently solves the problem of finding all nodes at distance `k` from a target node in a binary tree. By using a parent-child mapping and performing a DFS traversal, we are able to navigate both upwards and downwards in the tree while keeping track of visited nodes to avoid revisits. The time and space complexities are both optimal, making this approach suitable for large trees.
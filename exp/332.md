### üöÄ Problem Statement

The goal is to find the **itinerary** of a journey where the itinerary is a path that uses all available tickets exactly once. Each ticket represents a directed flight between two airports. Given a list of tickets, you need to return the itinerary in the **lexicographically smallest order**, starting from `"JFK"`.

#### Input:
- `tickets`: A list of pairs where each pair represents a flight from one airport to another.
- The starting airport is always `"JFK"`, and you need to construct the entire journey using the available tickets.

#### Output:
- The lexicographically smallest itinerary that uses all tickets exactly once.

---

### üß† Approach

To solve this problem, we will use a **Depth First Search (DFS)** combined with a **priority queue** to ensure that we always visit the lexicographically smallest airport first. Let‚Äôs break it down:

1. **Graph Representation**:
   - Think of airports as **nodes** and flights as **edges**. We‚Äôll use a directed graph where each airport has a list of destinations.
   - We need to visit the lexicographically smallest destination first, so we‚Äôll store the destinations in a **priority queue** for each airport.

2. **DFS Traversal**:
   - Starting at `"JFK"`, we recursively visit each destination, choosing the smallest airport available at each step.
   - Once we visit an airport, we backtrack and keep adding airports to the front of the result list (this will give us the correct order in the end, as the DFS is performed in reverse).

3. **Backtracking**:
   - The DFS will backtrack once all destinations from a given airport are visited. Airports will be added to the itinerary in reverse order, so we later reverse the list to get the correct sequence.

4. **Edge Case**:
   - If no tickets are provided, we simply return an empty list.

---

### üî® Step-by-Step Code Breakdown

Let's walk through the code:

#### Step 1: Initialize the Graph
```cpp
map<string, priority_queue<string, vector<string>, greater<string>>> gph;
```
- Here, we create a map (`gph`) where each airport (key) maps to a priority queue of its destinations. The `greater<string>` ensures the destinations are ordered lexicographically.

#### Step 2: Build the Graph
```cpp
for(auto it: tickets) {
    gph[it[0]].push(it[1]);
}
```
- We loop through the tickets and populate the graph. Each ticket‚Äôs origin airport (`it[0]`) points to a priority queue of its destination airport (`it[1]`).

#### Step 3: Start DFS from `"JFK"`
```cpp
dfs("JFK");
```
- The DFS is initiated at `"JFK"`. This will start the recursive search for the itinerary.

#### Step 4: Depth First Search Function (`dfs`)
```cpp
void dfs(string from) {
    while(gph.count(from) && !gph[from].empty()) {
        string x = gph[from].top();
        gph[from].pop();
        dfs(x);
    }
    res.push_front(from);
}
```
- In the DFS function:
  - We check if there are remaining destinations for the current airport (`gph[from]`).
  - If there are, we take the lexicographically smallest destination (the top element of the priority queue), remove it, and call `dfs()` recursively for that destination.
  - Once all destinations are visited for an airport, we add that airport to the front of the result list (`res.push_front(from)`), building the itinerary in reverse order.

#### Step 5: Final Result
```cpp
vector<string> ans;
for(auto it: res)
    ans.push_back(it);
return ans;
```
- After the DFS traversal is done, we convert the `res` list (which is in reverse order) into a vector and return it as the final itinerary.

---

### üìà Complexity Analysis

#### Time Complexity:
- **O(E log E)**: The graph contains `E` edges (tickets), and each operation on the priority queue (insertions and removals) takes **O(log E)** time. Thus, the total time complexity is **O(E log E)**, where `E` is the number of tickets.

#### Space Complexity:
- **O(E)**: We store the graph, which takes **O(E)** space, and the recursion stack of the DFS can also have a depth of **O(E)**, resulting in an overall space complexity of **O(E)**.

---

### üèÅ Conclusion

This solution efficiently constructs the lexicographically smallest itinerary using a **DFS** combined with a **priority queue**. By ensuring that we always explore the smallest airport first, we can build the correct itinerary step by step, with an optimal time complexity of **O(E log E)**.

#### Key Takeaways:
- **Greedy Strategy**: Using the priority queue ensures that we always pick the lexicographically smallest destination.
- **DFS Traversal**: DFS allows us to explore the entire journey, ensuring we don‚Äôt miss any flights.
- **Time Complexity**: The solution performs efficiently even for larger inputs with **O(E log E)** time complexity.

This approach provides an elegant and efficient way to solve the problem, ensuring the lexicographically smallest journey is found every time. Keep practicing DFS and greedy strategies‚Äîthey are powerful tools for solving path-related problems! ‚ú®
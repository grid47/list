### Problem Statement

The problem is to determine how many ways a given string `s` of digits can be decoded into an alphabet string, where each digit or pair of digits represents a letter from the alphabet ('A' = 1, 'B' = 2, ..., 'Z' = 26). The string `s` can be decoded in several ways, and the task is to find the total number of distinct ways to decode it.

For example:
- The string "12" can be decoded as "AB" (1 -> A, 2 -> B) or "L" (12 -> L), so the output is 2.
- The string "226" can be decoded as "BBF", "BZ", or "VF", so the output is 3.

The input string may also contain leading zeroes or numbers greater than 26, which are invalid decodings. Therefore, the goal is to efficiently count the number of valid decodings.

### Approach

The approach to solving this problem is based on **dynamic programming (DP)**, specifically **memoization**. The idea is to break down the problem into smaller subproblems, where each subproblem calculates the number of ways to decode the substring of `s` starting from a specific position. The results of these subproblems are stored in a memoization array to avoid redundant calculations.

Here is a step-by-step breakdown of the approach:

1. **Base Case**: If the index reaches the end of the string, it means we have successfully decoded all characters, so the number of ways to decode from this point is 1. This is the base case for the recursion.

2. **Invalid Cases**: If the current character is '0', it means there is no valid decoding for this character (since there is no letter corresponding to 0). Therefore, the number of ways to decode from this position is 0.

3. **Memoization**: To avoid recalculating the number of ways for the same index repeatedly, we use a `memo` array to store the results of subproblems. If we have already calculated the number of ways to decode starting from a specific index, we simply return the stored result.

4. **Recursive Case**:
   - We recursively calculate the number of ways to decode starting from the next index (`i + 1`).
   - If the current character and the next character together form a valid two-digit number (between 10 and 26), we also recursively calculate the number of ways to decode starting from the index after the next (`i + 2`).

5. **Return Result**: The result for each subproblem is stored in the memoization array and returned.

### Code Breakdown (Step by Step)

#### Step 1: Memoization Setup

```cpp
vector<int> memo;
```

- We declare a vector `memo` that will store the results of subproblems. Initially, it is empty and will be resized to the size of the input string `s`.

#### Step 2: Main Function to Call the Helper

```cpp
int numDecodings(string s) {
    memo.resize(s.size(), -1);
    return !s.size()? 0: ways(0, s);
}
```

- We resize the `memo` vector to be the same size as the input string `s` and initialize all values to `-1` to indicate that no subproblems have been solved yet.
- The main function calls the helper function `ways(0, s)` to compute the number of decodings starting from the first character of the string.
- If the input string `s` is empty, the function returns 0, as there are no valid decodings for an empty string.

#### Step 3: Helper Function for Recursion

```cpp
int ways(int i, string s) {
    if(i == s.size()) return 1;
    if(s[i] == '0') return 0;
    if(memo[i] > -1) return memo[i];
    
    int res = ways(i + 1, s);
```

- The `ways` function is the core of the recursion. It calculates the number of ways to decode the substring starting from index `i` of the string `s`.
- **Base Case 1**: If `i` reaches the size of `s`, we return 1 because we've successfully decoded the entire string.
- **Base Case 2**: If `s[i] == '0'`, we return 0 because a string starting with '0' cannot be decoded.
- **Memoization Check**: If the value for `memo[i]` is not `-1`, it means we have already computed the result for this index, so we simply return the stored result to avoid redundant calculations.

#### Step 4: Recursive Case for Single-Digit Decoding

```cpp
int res = ways(i + 1, s);
```

- We recursively compute the number of decodings by considering the next character in the string. This corresponds to decoding the current character as a single digit (e.g., '1' -> A, '2' -> B).

#### Step 5: Recursive Case for Two-Digit Decoding

```cpp
if(i < s.size() - 1 && (s[i] == '1' || (s[i] == '2' && s[i+1] < '7')))
    res += ways(i + 2, s);
```

- If the current character and the next character together form a valid two-digit number (i.e., between '10' and '26'), we consider this as a valid decoding and add the result of decoding the substring starting from `i + 2`.

#### Step 6: Store the Result in Memoization

```cpp
return memo[i] = res;
```

- After calculating the number of decodings for the current index `i`, we store the result in the `memo` array to avoid redundant calculations in future recursive calls.

#### Final Return

The main function returns the value of `ways(0, s)`, which gives the total number of decodings starting from the first character of the input string.

### Complexity

#### Time Complexity:
- The time complexity of this algorithm is **O(n)**, where `n` is the length of the input string `s`. This is because we compute the result for each index at most once, using memoization to avoid redundant work.

#### Space Complexity:
- The space complexity is **O(n)** due to the `memo` array and the recursion stack, where `n` is the length of the input string.

### Conclusion

The dynamic programming approach with memoization provides an efficient solution to the problem of counting the number of decodings of a string of digits. By breaking down the problem into smaller subproblems and using memoization to store intermediate results, the algorithm achieves a time complexity of **O(n)**, making it suitable for large input sizes. This approach avoids unnecessary recomputation and ensures that each subproblem is solved only once, leading to significant performance improvements over a naive recursive solution.
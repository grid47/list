### Problem Statement

The problem asks us to find the shortest substring in a given string `s` that contains exactly `k` occurrences of the character '1'. If multiple substrings of the same length are found, the lexicographically smallest one should be returned.

### Approach

To solve this problem efficiently, we need to find substrings of the string `s` that contain exactly `k` occurrences of the character '1'. To achieve this, we can use a sliding window approach with two pointers (`i` and `j`) and a counter (`cnt`) to track the number of '1's in the current window. We aim to expand the window to include the required number of '1's and then contract it to find the smallest possible valid substring. 

1. **Sliding Window**: We will iterate over the string using two pointers, `i` (to expand the window) and `j` (to contract the window). The goal is to adjust the window to contain exactly `k` '1's at each step.
   
2. **Tracking the '1's Count**: As we move the right pointer (`i`), we increment the counter `cnt` whenever we encounter a '1'. When `cnt` reaches `k`, we check if the current window is the shortest possible substring that satisfies the condition. If it is, we update the result.

3. **Optimizing the Result**: If multiple valid substrings of the same length are found, we will compare them lexicographically to ensure that the smallest one is chosen.

### Code Breakdown (Step by Step)

#### 1. Initialization

```cpp
int n = s.size();
string ans = "";
int j = 0, cnt = 0;
```

- `n`: Stores the size of the input string `s`.
- `ans`: A string variable to store the shortest valid substring.
- `j`: Left pointer of the sliding window, initialized to 0.
- `cnt`: Counter to keep track of the number of '1's in the current window.

#### 2. Expanding the Window

```cpp
for(int i = 0; i < n; i++)
{
    if(s[i] == '1') cnt++;
```

- The outer loop (`for(int i = 0; i < n; i++)`) iterates through the string with the right pointer `i`.
- Whenever we encounter a '1' in the string (`if(s[i] == '1')`), we increment the counter `cnt` to keep track of how many '1's are in the current window.

#### 3. Contracting the Window When `cnt == k`

```cpp
    while(j < n && cnt == k)
    {
        string tmp = s.substr(j, i - j + 1);
```

- Once `cnt` reaches `k`, we enter the inner `while` loop, which will contract the window from the left to minimize the substring.
- `s.substr(j, i - j + 1)` extracts the substring starting at index `j` and ending at index `i`. This substring contains exactly `k` '1's.

#### 4. Update the Result

```cpp
        if(ans.size() == 0 || tmp.size() < ans.size()) ans = tmp;
        else if(tmp.size() == ans.size()) ans = min(ans, tmp);
```

- If the `ans` string is empty or the current substring `tmp` is smaller than `ans`, we update `ans` to the current substring.
- If the lengths of `tmp` and `ans` are equal, we choose the lexicographically smaller substring by comparing them using `min()`.

#### 5. Move the Left Pointer `j`

```cpp
        if(s[j] == '1') cnt--;
        j++;
    }
}
```

- To try and find a smaller valid substring, we move the left pointer `j` to the right.
- If the character at position `j` is '1', we decrement the counter `cnt` since we are removing a '1' from the window.
- We then increment `j` to shift the window.

#### 6. Return the Result

```cpp
return ans;
```

- After the loop finishes, the result `ans` holds the shortest valid substring that contains exactly `k` occurrences of '1'. If no valid substring is found, `ans` will remain an empty string.

### Complexity

#### Time Complexity

- **Outer Loop**: The outer loop runs from `0` to `n-1`, where `n` is the size of the string `s`. Therefore, the outer loop has a time complexity of `O(n)`.
  
- **Inner Loop**: The inner loop's condition depends on the counter `cnt`. For every valid window where `cnt == k`, we increment `j` to shrink the window. In the worst case, each index is visited only once by `j` for each index visited by `i`. Thus, the time complexity of the inner loop is also `O(n)` in total.

- **Substring Extraction**: The call to `s.substr(j, i - j + 1)` extracts a substring of length `i - j + 1`. In the worst case, this operation is called `O(n)` times, and each substring extraction takes `O(n)` time.

Thus, the overall time complexity is dominated by the two nested loops, and the substring extraction, leading to an **O(n^2)** time complexity.

#### Space Complexity

- We are using a constant amount of extra space (apart from the input string) to store variables such as `ans`, `tmp`, `cnt`, and `j`. The space complexity for these variables is **O(1)**.
- The space required for storing substrings temporarily in the `tmp` variable can be up to `O(n)` in the worst case.

Therefore, the overall space complexity is **O(n)**.

### Conclusion

The solution efficiently finds the shortest substring containing exactly `k` '1's using a sliding window approach. The use of two pointers (`i` and `j`) and a counter (`cnt`) allows us to expand and contract the window dynamically to find the required substrings. The algorithm guarantees an optimal result by comparing substrings lexicographically when necessary and by minimizing the window size to ensure the shortest valid substring. Although the time complexity is `O(n^2)` due to the substring extraction, this solution is still feasible for moderately sized strings and provides a clear, concise way to tackle the problem.
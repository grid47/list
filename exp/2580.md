### Problem Statement

Given a list of intervals in the form of a 2D vector `range`, the task is to calculate the number of distinct ways to pick non-overlapping intervals. Each interval is represented by two integers: the start and end points. The goal is to find how many distinct sets of non-overlapping intervals can be formed such that no intervals overlap in any chosen set. The answer should be returned modulo \(10^9 + 7\).

### Approach

To solve this problem, we need to count the number of ways to choose non-overlapping intervals. This is a dynamic programming or greedy problem, but the approach here leverages sorting and a greedy strategy:

1. **Sort the Intervals by Start Point**:  
   First, we sort the intervals based on their start point. Sorting allows us to process the intervals in order and compare their end points efficiently.

2. **Initialize Counters**:  
   We initialize a counter `cnt` that starts at 2. This is because, in the beginning, we have two possibilities for the first interval:
   - Select the first interval.
   - Skip the first interval.

   We also initialize a variable `next` to track the end point of the most recent non-overlapping interval. This ensures that we don't select overlapping intervals.

3. **Greedy Interval Selection**:  
   We loop through the sorted intervals:
   - If the current interval starts before or at the same time as the `next` interval, we update `next` to the maximum of `next` and the current interval's end. This means we are extending the current non-overlapping set.
   - If the current interval starts after `next`, it means the intervals are no longer overlapping. We can now form two choices:
     - Include the current interval in the set.
     - Skip the current interval.
     
   For each non-overlapping transition, we multiply the number of ways by 2 (because we now have two choices: to include or exclude the interval). The result is taken modulo \(10^9 + 7\).

4. **Return the Result**:  
   Finally, after processing all intervals, the total number of ways is stored in `cnt`. This is the final result.

### Code Breakdown (Step by Step)

1. **Sort the Intervals**:  
   ```cpp
   sort(range.begin(), range.end());
   ```
   Sorting the intervals by their starting point ensures that we process them in the correct order. This helps in efficiently checking if the intervals overlap and helps to decide whether to include them in the current non-overlapping set.

2. **Initialize Variables**:
   ```cpp
   int mod = (int) 1e9 + 7;
   int next = range[0][1];
   long cnt = 2;
   ```
   - `mod` is the modulus value used to ensure that the result fits within the specified range.
   - `next` holds the end point of the most recent non-overlapping interval. Initially, it is set to the end point of the first interval.
   - `cnt` starts at 2, because there are two possible choices for the first interval: either we include it or we skip it.

3. **Iterate Through Each Interval**:
   ```cpp
   for(int i = 0; i < n; i++) {
       if(range[i][0] <= next) {
           next = max(next, range[i][1]);
           continue;
       }
       cnt = (cnt * 2) % mod;
       next = range[i][1];
   }
   ```
   - We loop through each interval:
     - If the start of the current interval is less than or equal to `next` (the end of the last selected non-overlapping interval), we simply extend the current non-overlapping set by updating `next` to be the maximum of its current value and the end of the current interval. We continue to the next interval without changing the number of ways.
     - If the current interval starts after `next`, it means we can form a new non-overlapping set, so we multiply the number of ways by 2 (because we now have two choices: include or exclude the interval).

4. **Return the Result**:
   ```cpp
   return cnt;
   ```
   The final result is the number of ways to form non-overlapping intervals, modulo \(10^9 + 7\).

### Complexity Analysis

- **Time Complexity**:  
  The time complexity is dominated by the sorting step, which is \(O(n \log n)\), where `n` is the number of intervals. The subsequent loop through the intervals takes \(O(n)\). Hence, the overall time complexity is \(O(n \log n)\).

- **Space Complexity**:  
  The space complexity is \(O(1)\) for the algorithm, as we are only using a few variables to store the count and the end point of the last selected interval. The space for storing the intervals themselves is not considered here as it's part of the input.

### Conclusion

This solution efficiently counts the number of ways to select non-overlapping intervals by leveraging a greedy approach. Sorting the intervals helps ensure that we can easily check if they overlap or not, and the use of a dynamic counting mechanism allows us to account for the two possible choices at each step: include or exclude an interval. This approach is optimal for this problem and runs in \(O(n \log n)\) time, which is suitable for large inputs. The result is returned modulo \(10^9 + 7\), ensuring that we do not run into overflow issues.
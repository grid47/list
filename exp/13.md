### Problem Statement

The problem requires converting a Roman numeral string to an integer. Roman numerals are a combination of characters representing specific values. The task is to write a function `romanToInt` that takes a Roman numeral string as input and returns its corresponding integer value.

For example:
- "III" should return 3.
- "IV" should return 4.
- "IX" should return 9.
- "LVIII" should return 58.
- "MCMXCIV" should return 1994.

### Approach

Roman numerals follow certain conventions:
1. If a smaller numeral appears before a larger one, it is subtracted (e.g., "IV" represents 4, not 6).
2. If a numeral is followed by a numeral of equal or smaller value, it is added (e.g., "VI" represents 6).

Given these rules, the general approach is:
1. Start by converting the last character to its corresponding value.
2. Traverse the string from right to left, and for each character:
   - Compare the current numeral's value to the previous numeral’s value.
   - If the current numeral is smaller than the previous one, subtract its value; otherwise, add its value.
   
By doing this, we correctly handle cases where smaller numerals precede larger ones (like in "IV", "IX", etc.).

### Code Breakdown (Step by Step)

#### Step 1: `romanToInt` Function

```cpp
int romanToInt(string s)
{
    int ln = s.length();  // Get the length of the input string.
    int res = RomToNum(s[ln-1]);  // Convert the last character to its integer value.
    int prv = res, curr = 0;
```

- We initialize the result `res` with the value of the last character of the string.
- `prv` stores the previous numeral’s value, which is initially set to the last character's value.
- `curr` is used to store the current numeral's value as we iterate through the string.

#### Step 2: Iterate Through the String

```cpp
for (int i = ln -2; i >= 0; i--)  // Start iterating from the second last character.
{
    curr = RomToNum(s[i]);  // Convert the current character to its integer value.
    
    (curr < prv) ? (res -= curr) : (res += curr);  // Check if current numeral is smaller than previous one.
    
    prv = curr;  // Update the previous value to the current value.
}
```

- We start the loop from the second last character (`ln - 2`) and move towards the first character of the string.
- The `curr` variable is updated with the value of the current character.
- If the current numeral’s value is smaller than the previous numeral’s value (`curr < prv`), we subtract `curr` from `res`. This handles cases like "IV" or "IX", where the smaller numeral should be subtracted.
- Otherwise, we add `curr` to `res`, which is the case for normal numeral combinations like "VI" or "XII".
- Finally, `prv` is updated to the current value (`curr`), so that it can be used for the next iteration.

#### Step 3: Return the Result

```cpp
return res;  // Return the computed result.
```

- After processing all the characters, `res` contains the final integer value, which is returned.

#### Step 4: `RomToNum` Helper Function

```cpp
int RomToNum(char s)
{
    switch (s)
    {
        case 'I' : return 1;   // Roman numeral I maps to 1.
        case 'V' : return 5;   // Roman numeral V maps to 5.
        case 'X' : return 10;  // Roman numeral X maps to 10.
        case 'L' : return 50;  // Roman numeral L maps to 50.
        case 'C' : return 100; // Roman numeral C maps to 100.
        case 'D' : return 500; // Roman numeral D maps to 500.
        case 'M' : return 1000; // Roman numeral M maps to 1000.
    }
    return 0;  // If the character is not a valid Roman numeral, return 0.
}
```

- This helper function `RomToNum` takes a Roman numeral character and returns its integer value. For example, 'I' returns 1, 'V' returns 5, and so on.
- The function uses a `switch` statement to match the character and return the corresponding integer value.

### Complexity

#### Time Complexity:
- **O(n)**: The time complexity of this solution is O(n), where `n` is the length of the input string `s`. This is because we iterate through the string once from right to left, processing each character in constant time (thanks to the `RomToNum` helper function).

#### Space Complexity:
- **O(1)**: The space complexity is O(1), since we use a constant amount of extra space (only a few integer variables are used). The space required does not depend on the input size.

### Conclusion

This approach efficiently converts a Roman numeral string to an integer by traversing the string from right to left and using a greedy strategy to decide whether to add or subtract the current numeral's value. The solution works in linear time and uses constant space, making it highly efficient for the problem at hand.

#### Advantages:
- **Time efficiency**: The solution processes the string in a single pass, making it highly efficient for converting Roman numerals to integers.
- **Simplicity**: The code is easy to understand and follow, with a clear separation of logic in the main function and the helper function.
  
#### Limitations:
- This solution assumes the input string represents a valid Roman numeral within the acceptable range (1 to 3999).
  
#### Summary:
This solution provides an optimal and easy-to-understand method for converting a Roman numeral string to its integer equivalent. By using a greedy approach and processing the string from right to left, it ensures that the subtraction rule (for numerals like "IV" and "IX") is handled correctly. The algorithm operates in linear time and constant space, making it an efficient solution to this problem.
### Problem Statement

The problem asks to recover a **binary search tree (BST)** that has two of its nodes swapped by mistake. Given a binary tree where exactly two nodes are swapped, the goal is to identify the two nodes and swap them back to restore the tree’s validity as a BST.

### Approach

To solve this problem, we need to identify the two nodes that were swapped in the tree and swap them back. The key property of a BST is that during an **in-order traversal**, the node values should be in strictly increasing order.

#### Steps:
1. Perform an in-order traversal of the tree.
2. While traversing, if we find a node whose value is smaller than its previous node's value, this indicates that a violation of the BST property has occurred.
3. The two nodes involved in the violation will be the first node that violates the property (`fst`) and the second node that violates the property (`scd`).
4. After identifying the swapped nodes, swap their values to restore the tree.

The in-order traversal will help us efficiently identify where the tree structure is incorrect, and by using just three pointers, we can pinpoint the nodes that need to be swapped.

### Code Breakdown (Step by Step)

#### 1. Class Definition and Variable Declaration

```cpp
class Solution {
    TreeNode *prv = NULL, *fst = NULL, *scd = NULL;
```

- **`prv`**: A pointer used to track the previous node during the in-order traversal.
- **`fst`**: A pointer that will store the first node involved in the swap violation.
- **`scd`**: A pointer that will store the second node involved in the swap violation.

#### 2. In-Order Traversal Function

```cpp
    void inorder(TreeNode* node)
    {
        if(!node) return;
        inorder(node->left);
```

- The function `inorder` performs an in-order traversal of the tree starting from the `node` passed as an argument.
- If the `node` is `NULL`, the function returns without doing anything.

```cpp
        if (prv && node->val < prv->val) {
            if (!fst)  fst = prv;
            scd = node;
        }
        prv = node;
        inorder(node->right);
    }
```

- The **in-order traversal** of the left subtree is done first, and then the value of the current node (`node->val`) is compared to the previous node’s value (`prv->val`).
- If the current node’s value is less than the previous node’s value (`node->val < prv->val`), a BST property violation has been detected.
- The first violation occurs when we encounter the first node that is out of order, which is stored in `fst`.
- The second violation node is stored in `scd`.
- The `prv` pointer is updated to point to the current node (`node`) to continue the traversal.
- The traversal then proceeds to the right child of the current node (`node->right`).

#### 3. Recover the Tree

```cpp
public:
    void recoverTree(TreeNode* node) {
        inorder(node);
        swap(fst->val, scd->val);
    }
```

- The `recoverTree` function is the entry point for the solution. It takes the root of the tree as an argument (`node`).
- The function calls the `inorder` function to identify the swapped nodes.
- Once the swapped nodes are identified, their values are swapped back using the `swap(fst->val, scd->val)` statement.

### Complexity

#### Time Complexity:

The time complexity of this solution is **O(n)**, where `n` is the number of nodes in the binary tree. This is because we perform a single in-order traversal of the tree, visiting each node exactly once.

#### Space Complexity:

The space complexity is **O(h)**, where `h` is the height of the tree. This is the space used by the recursion stack during the in-order traversal. In the worst case (unbalanced tree), the height `h` could be equal to `n`, so the space complexity would be **O(n)**. However, for a balanced tree, the space complexity would be **O(log n)**.

### Conclusion

This solution efficiently solves the problem of recovering a BST with two swapped nodes by performing an **in-order traversal** of the tree. The **in-order traversal** ensures that we can identify the two swapped nodes in a linear scan of the tree, making this approach time-efficient with a complexity of **O(n)**. The solution uses constant space, aside from the recursion stack, ensuring that the algorithm is space-efficient, with a worst-case space complexity of **O(h)**. This approach efficiently restores the validity of the binary search tree, ensuring the tree structure is properly recovered.
### Problem Statement

In this problem, we are given an array of integers `nums`, and we are tasked with finding the number of contiguous subarrays that are filled with zeros. A **subarray** is a sequence of consecutive elements in an array, and a **zero-filled subarray** is one in which every element is zero.

The goal is to return the total number of these zero-filled subarrays in the given array.

### Approach

The main idea to solve this problem efficiently is by recognizing that any contiguous block of zeros can contribute multiple zero-filled subarrays. For example, a sequence of 3 consecutive zeros will have 6 zero-filled subarrays: `[0]`, `[0]`, `[0]`, `[0, 0]`, `[0, 0]`, `[0, 0, 0]`.

#### Key Observations:
- **Consecutive Zeros**: If there are `k` consecutive zeros in the array, the number of zero-filled subarrays that can be formed from these zeros is the sum of the first `k` integers. This sum is given by the formula `k * (k + 1) / 2`.
- **Breaking Points**: Any non-zero number in the array serves as a break between potential zero-filled subarrays. When encountering a non-zero number, we reset the count of consecutive zeros.

By maintaining a running count of consecutive zeros, we can calculate the number of zero-filled subarrays dynamically without needing to explicitly enumerate each subarray.

### Code Breakdown (Step by Step)

#### 1. **Initialization**
```cpp
long long res = 0;
```
- We initialize a variable `res` to store the final result â€” the total number of zero-filled subarrays. The result is stored as a `long long` type to avoid overflow, as the number of subarrays can grow quickly.

#### 2. **Loop Through the Array**
```cpp
for (int i = 0, j = 0; i < nums.size(); i++) {
    if (nums[i] != 0) 
        j = i + 1;
    res += i + 1 - j;
}
```
- We loop through each element of the array using a variable `i`, where `i` is the index of the current element.
- We use another variable `j` to track the index of the last non-zero element encountered. This allows us to determine the length of the current sequence of consecutive zeros.
- Whenever we encounter a non-zero element (`nums[i] != 0`), we update `j` to `i + 1`, effectively marking the start of the next potential sequence of zeros.

#### 3. **Counting Zero-filled Subarrays**
```cpp
res += i + 1 - j;
```
- For every position `i`, we calculate how many subarrays end at index `i` and are filled with zeros.
- The formula `i + 1 - j` computes the number of zero-filled subarrays ending at `i`. This works because for a sequence of zeros ending at index `i`, the subarrays range from the previous break point `j` to the current index `i`.
- We add this count to the running total `res`.

#### 4. **Return the Final Result**
```cpp
return res;
```
- After the loop finishes processing all elements, we return the result, which contains the total number of zero-filled subarrays.

### Complexity

#### Time Complexity:
- **O(n)**: The algorithm processes each element of the input array `nums` exactly once. In each iteration, the logic inside the loop runs in constant time. Hence, the time complexity is **O(n)**, where `n` is the length of the array.

#### Space Complexity:
- **O(1)**: The algorithm uses a constant amount of extra space since it only maintains a few variables (`res`, `i`, `j`). It doesn't use any additional data structures that scale with the size of the input, so the space complexity is **O(1)**.

### Conclusion

This solution is efficient and works in linear time with constant space, making it ideal for large input sizes. The key idea is to dynamically track the length of consecutive zero sequences and count the zero-filled subarrays using a simple formula. This avoids the need for nested loops or explicitly constructing the subarrays, resulting in an optimized solution.

By processing the array in a single pass and using a clever counting mechanism, we ensure that the solution is both time-efficient and space-efficient. This method is suitable for real-time applications where fast processing of large arrays is needed.
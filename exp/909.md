### Problem Statement
You are given a square board of size `n x n`, where the cells are numbered from 1 to \( n^2 \) in a snake-like fashion (1 at the bottom-left corner, moving right to the end of the row, then moving up to the next row). Some cells contain snakes or ladders which affect movement on the board. Write a function to determine the minimum number of moves required to reach the last cell (\( n^2 \)) from the first cell (1).

### Class Definition
- **Class**: `Solution`
  - **Method**: `int snakesAndLadders(vector<vector<int>>& board)`
    - Takes a 2D vector `board` representing the Snakes and Ladders game.
    - Returns the minimum number of moves to reach cell \( n^2 \) from cell 1. Returns -1 if it is not possible.

### Approach
1. **Coordinate Calculation**:
   - Use the helper function `getCoordinate` to convert a cell number `s` into its corresponding row and column on the board.
   - The row is calculated based on how many complete rows fit into the cell number, while the column adjusts based on the direction of traversal (left-to-right or right-to-left).

2. **Breadth-First Search (BFS)**:
   - Initialize a queue to explore the board, starting from cell 1 with 0 moves (`{1, 0}`).
   - Maintain a `seen` vector to track visited cells.
   - While the queue is not empty:
     - Dequeue the front element, retrieve the current cell number `s` and the distance in moves.
     - If `s` is equal to \( n^2 \), return the distance as the result.
     - For each possible die roll (1 to 6):
       - Calculate the next cell number `s+i`.
       - Get the corresponding row and column using `getCoordinate`.
       - Check if the next cell has a snake or ladder:
         - If it has, use the final destination cell; otherwise, use `s+i`.
       - If the final cell has not been visited:
         - Mark it as seen and enqueue it with the incremented distance.

3. **Return**:
   - If the loop completes without reaching \( n^2 \), return -1, indicating that the end is unreachable.

### Complexity
- **Time Complexity**: O(n^2), as the maximum number of cells is \( n^2 \) and each cell can be visited once.
- **Space Complexity**: O(n^2), for the `seen` vector and the BFS queue.

### Problem Statement

You are given `n` rooms, and a list `meets` of meeting schedules where each meeting is represented by a pair of integers `[start, end]`, indicating the start and end time of a meeting. Your task is to assign meetings to rooms such that:

1. Each meeting occupies one room.
2. A room can only be used by one meeting at a time.
3. If there are multiple meetings scheduled at the same time, a meeting has to wait for the next available room.

You need to determine which room is the most frequently used, i.e., the room that is booked the most times.

### Approach

This problem is a variant of the "meeting rooms" or "interval scheduling" problem. The goal is to efficiently assign meetings to rooms, accounting for both scheduling conflicts (when two meetings overlap) and room availability. The solution involves simulating the allocation of meetings to rooms using a priority queue.

#### Key Concepts:
1. **Sorting**: First, we sort the meetings based on their start times to ensure that we process meetings in the correct order.
  
2. **Priority Queue for Room Management**: A priority queue (min-heap) is used to keep track of the rooms and their availability. Specifically, we use two priority queues:
   - One to manage available rooms (`free`).
   - One to track rooms with ongoing meetings and when they will become available (`rvd`).

3. **Tracking Room Usage**: We need to keep track of how many times each room is booked. This can be done using a simple array `frq` where each index represents a room and stores the number of times it was used.

4. **Greedy Allocation**: For each meeting:
   - If a room becomes available before or when the meeting starts, we allocate it immediately.
   - If all rooms are occupied, we push the meeting to the room that will be free the soonest.

#### Plan:
1. **Sorting Meetings**: We begin by sorting the meetings by their start time. This helps ensure that we handle the meetings in the correct order, from the earliest to the latest.

2. **Room Allocation**:
   - For each meeting, we check if any rooms are available by looking at the priority queue `rvd`.
   - If a room is available, we assign the meeting to that room and update the room's availability.
   - If no room is available, we delay the meeting by finding the room that will free up the earliest and update its availability accordingly.

3. **Tracking the Most Booked Room**: After processing all meetings, we simply find the room with the highest booking count.

### Code Breakdown (Step by Step)

#### Step 1: Sorting the Meetings

```cpp
sort(meets.begin(), meets.end(), cmp);
```
- We start by sorting the meetings based on their start time using the custom comparator `cmp`. This ensures that meetings are processed in the order they occur.

#### Step 2: Priority Queues Initialization

```cpp
priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> rvd;
priority_queue<int, vector<int>, greater<int>> free;
```
- `rvd`: This priority queue keeps track of rooms that are currently occupied. Each element is a pair, where the first value is the time the room will become available (the meeting's end time), and the second value is the room number.
  
- `free`: This priority queue keeps track of rooms that are free. Rooms are pushed into this queue at the beginning and are available for allocation.

#### Step 3: Room Usage Tracking

```cpp
vector<int> frq(n, 0);
for(int i = 0; i < n; i++)
    free.push(i);
```
- `frq`: This array stores the number of meetings assigned to each room.
- We push all `n` rooms into the `free` queue, marking them as available at the start.

#### Step 4: Room Allocation for Each Meeting

```cpp
for(auto &t : meets) {
    int s = t[0], e = t[1];
    
    while(!rvd.empty() && rvd.top().first <= s) {
        free.push(rvd.top().second);
        rvd.pop();
    }
    
    if(free.size() > 0) {
        int room = free.top();
        free.pop();
        rvd.push({e, room});
        frq[room]++;
    } else {
        long long newHalt = rvd.top().first + (e - s);
        int room = rvd.top().second;
        rvd.pop();
        rvd.push({newHalt, room});
        frq[room]++;
    }
}
```
- We iterate over each meeting in the sorted list.
- For each meeting, we check if any room has become free by checking if the roomâ€™s next available time (tracked in `rvd`) is less than or equal to the current meeting's start time (`s`).
- If a room is available, we assign the meeting to the first available room from the `free` queue.
- If no room is available, we delay the meeting by finding the room that will be free the soonest (the one with the earliest finish time) and allocate the meeting to it.

#### Step 5: Finding the Most Booked Room

```cpp
int mxi = 0;
for(int i = 0; i < n; i++) {
    if(frq[i] > frq[mxi])
        mxi = i;
}
return mxi;
```
- After processing all meetings, we iterate over the `frq` array to find the room with the highest booking count.

### Complexity

#### Time Complexity:
- **Sorting the Meetings**: Sorting the `meets` array takes **O(m log m)**, where `m` is the number of meetings.
- **Processing the Meetings**: Each meeting is processed once. For each meeting, we perform constant time operations for room allocation (involving the priority queues), resulting in **O(m log n)** time complexity for room allocation, where `n` is the number of rooms and `m` is the number of meetings.
- **Finding the Most Booked Room**: Finding the room with the highest booking count takes **O(n)** time.

Therefore, the overall time complexity is **O(m log m + m log n + n)**, where:
- `m` is the number of meetings,
- `n` is the number of rooms.

#### Space Complexity:
- **Priority Queues**: We use two priority queues to manage the rooms and their availability, which takes **O(n)** space.
- **Other Variables**: We use an array `frq` of size `n`, which also takes **O(n)** space.
  
Thus, the space complexity is **O(n)**.

### Conclusion

This solution efficiently allocates meetings to rooms using priority queues to manage both room availability and scheduling conflicts. By processing meetings in sorted order and dynamically managing room availability, the algorithm is both time-efficient and space-efficient. The approach guarantees that we can handle large inputs while minimizing the time spent on unnecessary re-evaluations of room status.

Key Takeaways:
- Priority queues are used to manage room availability dynamically.
- Sorting meetings by start time ensures that we handle them in the correct order.
- The sliding window technique using priority queues allows for efficient room allocation, even when rooms are busy or unavailable.

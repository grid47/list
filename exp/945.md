### Problem Statement

The problem asks to determine the minimum number of increments required to make all elements of a given array `nums` unique. The elements of the array can be increased any number of times to achieve uniqueness, and the goal is to return the smallest possible total number of increments needed. 

### Approach

To solve this problem efficiently, we can follow these steps:

1. **Sorting the Array**: First, we sort the array to arrange the numbers in increasing order. Sorting helps because if the numbers are in order, we can check each element and ensure that no two consecutive elements are the same. If a duplicate is found, we can increment it to a value that is greater than the previous one.

2. **Tracking the Next Available Number**: As we traverse the sorted array, we maintain a variable `need`, which tracks the smallest number that the next element in the array must be greater than. This ensures that each element in the array is unique.

3. **Increments Calculation**: For each element, if it is smaller than `need`, it means that we have to increment it to `need`. The difference between `need` and the current element will contribute to the result. After processing each element, we update `need` to be the maximum of the current element and `need` + 1 to ensure the next element is strictly greater.

4. **Edge Case Considerations**: If the array is already made up of unique elements, no increments will be needed. The result will be zero in that case.

This approach ensures that we minimize the number of increments because we only increment each element when absolutely necessary (i.e., when it's smaller than the required value `need`).

### Code Breakdown (Step by Step)

1. **Sorting the Array**:
   ```cpp
   sort(nums.begin(), nums.end());
   ```
   Sorting the array arranges the elements in ascending order, which allows us to process each element to ensure uniqueness more easily.

2. **Initialization of Variables**:
   ```cpp
   int res = 0, n = nums.size(), need = 0;
   ```
   - `res`: This variable holds the total number of increments needed to make all elements unique.
   - `n`: The size of the input array `nums`.
   - `need`: A variable that tracks the next number that an element should be incremented to, ensuring uniqueness.

3. **Processing Each Element**:
   ```cpp
   for(int i = 0; i < n; i++) {
       res += max(need - nums[i], 0);
       need = max(nums[i], need) + 1;
   }
   ```
   - The loop iterates through each element of the sorted array.
   - For each element `nums[i]`, we check if it is less than `need`. If it is, we increment it to match `need`, and the difference (`need - nums[i]`) is added to `res` as the number of increments required.
   - After processing the element, we update `need` to be the maximum of the current element `nums[i]` and `need` + 1. This ensures that the next element is always greater than the previous one.

4. **Returning the Result**:
   ```cpp
   return res;
   ```
   After processing all elements, `res` holds the total number of increments needed, which is returned as the final result.

### Complexity

1. **Time Complexity**:
   - The time complexity of the solution is dominated by the sorting step. Sorting an array of size `n` takes O(n log n) time.
   - After sorting, we only perform a single traversal of the array to compute the number of increments, which takes O(n) time.
   - Thus, the overall time complexity is O(n log n), which is efficient for this problem.

2. **Space Complexity**:
   - The space complexity is O(1) because we are only using a few extra variables (`res`, `n`, and `need`), and we are modifying the input array `nums` in place.
   - Therefore, the space complexity is constant, O(1).

### Conclusion

This solution efficiently computes the minimum number of increments required to make all elements of an array unique. By sorting the array and keeping track of the next required unique value for each element, we can determine the necessary increments while minimizing the number of operations. The time complexity of O(n log n) due to sorting ensures that the solution is efficient even for larger input sizes. The space complexity of O(1) makes the solution optimal in terms of memory usage, as it only uses a constant amount of additional space. This solution is simple, effective, and well-suited for handling large datasets efficiently.
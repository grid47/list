### Problem Statement

The task is to find the minimum number of moves required to make all elements of a given array equal. In one move, you can choose any index `i` of the array and either increment or decrement all other elements of the array except `nums[i]`. The goal is to determine the minimum number of moves required to make all elements equal, or return `-1` if it is not possible to make them equal.

For example:
- In the array `[1, 2, 3]`, the sum is `6` and the number of elements is `3`. The target value is `6 / 3 = 2`. To make all elements equal to 2, we can move elements as needed to achieve this target.
- In an array where the sum is not divisible by the number of elements, it is impossible to make all elements equal, and the function should return `-1`.

### Approach

To solve this problem, we need to carefully consider the nature of the transformation allowed and the conditions for achieving an equal array. The key steps can be broken down as follows:

1. **Initial Check for Divisibility**: 
   - First, we compute the sum of all elements in the array. If the sum is not divisible by the number of elements (`n`), it is impossible to make all elements equal because each element must eventually be equal to `sum / n`. In this case, we return `-1`.
   - If the sum is divisible by `n`, the target value for each element is `sum / n`.

2. **Prefix and Suffix Sums**:
   - We calculate two arrays, `left` and `right`, where:
     - `left[i]` holds the cumulative sum of all elements from index `0` to `i-1`.
     - `right[i]` holds the cumulative sum of all elements from index `i+1` to `n-1`.
   - These arrays help us calculate how much "extra" or "deficit" each position has relative to the target value.

3. **Computing the Moves**:
   - For each element `i`, calculate the expected amount that should have been added or subtracted from both the left and right sides to make all values equal to the target. Specifically, we calculate how much "excess" or "deficit" is on the left and right sides compared to the expected value (`hit = sum / n`).
   - The total moves required to balance the array is the sum of the left-side excess (`lefts`) and right-side excess (`rights`).

4. **Result**:
   - For each position `i`, calculate the total moves needed and keep track of the maximum required moves (`res`) since we need the minimum number of moves for the entire array to be balanced.

### Code Breakdown (Step by Step)

Now, let’s break down the code:

1. **Initialization and Input Check**:
   ```cpp
   int sum = accumulate(nums.begin(), nums.end(), 0);
   int n = nums.size();
   if(sum % n != 0) return -1;
   if(sum == 0) return 0;
   int res = -1;
   int hit = sum / n;
   ```
   - We first compute the sum of all elements in `nums` using `accumulate`. The function `accumulate` takes the range of elements and the initial sum (set to 0 here).
   - We check if the sum is divisible by `n` (i.e., `sum % n == 0`). If it’s not divisible, it’s impossible to make the elements equal, and we return `-1`.
   - If the sum is 0, this means the array is already balanced, and no moves are needed, so we return `0`.
   - The variable `hit` stores the target value each element should reach, which is `sum / n`.

2. **Prefix and Suffix Sum Arrays**:
   ```cpp
   vector<int> left(n, 0), right(n, 0);
   for(int i = 1; i < n; i++) 
       left[i] = left[i - 1] + nums[i - 1];

   for(int i = n - 2; i >= 0; i--)
       right[i] = right[i + 1] + nums[i + 1];
   ```
   - We initialize two arrays `left` and `right` to store cumulative sums.
   - The `left[i]` array computes the sum of elements from the start to `i-1`.
   - The `right[i]` array computes the sum of elements from `i+1` to the end of the array.
   - These arrays help us quickly calculate the cumulative sums on both sides of an element, which is essential for calculating the amount of excess or deficit at each position.

3. **Calculate the Minimum Moves**:
   ```cpp
   for(int i = 0; i < n; i++) {
       int expLeft = i * hit;
       int expRight = (n - 1 - i) * hit;
       int lefts = 0;
       int rights = 0;
       if(expLeft > left[i]) {
           lefts = expLeft - left[i];
       }
       if(expRight > right[i]) {
           rights = expRight - right[i];
       }
       res = max(res, lefts + rights);
   }
   ```
   - In this loop, we iterate over each element `i` in the array.
   - For each element, we calculate `expLeft` and `expRight`, which represent the expected sums on the left and right sides of the element if everything were balanced.
   - If the actual sum of the left side (`left[i]`) is less than the expected sum (`expLeft`), we calculate the deficit (`lefts`).
   - Similarly, if the actual sum of the right side (`right[i]`) is less than the expected sum (`expRight`), we calculate the deficit (`rights`).
   - We keep track of the maximum value of `lefts + rights`, as this represents the minimum moves required to balance the array for the current element.

4. **Return the Result**:
   ```cpp
   return res;
   ```
   - Finally, we return the maximum number of moves needed.

### Complexity

#### Time Complexity:
- **O(n)**: The time complexity of this solution is linear because:
  - We compute the sum of the array in `O(n)`.
  - We compute the prefix and suffix sum arrays in `O(n)`.
  - We perform another `O(n)` pass to calculate the minimum moves.

Thus, the overall time complexity is **O(n)**.

#### Space Complexity:
- **O(n)**: We use two additional arrays (`left` and `right`), each of size `n`, to store the cumulative sums. Therefore, the space complexity is **O(n)**.

### Conclusion

In conclusion, this solution efficiently calculates the minimum number of moves required to make all elements of the array equal using a greedy approach. The key observation is that if the sum of the array is divisible by the number of elements, it is possible to make all elements equal by balancing the left and right sums around each element. The use of prefix and suffix sums allows us to compute the required moves efficiently. 

The solution has optimal time and space complexity of **O(n)**, making it suitable for large inputs.
### Problem Statement

The problem requires us to find the `k`-th palindrome number with a specified number of digits `sz` for each query in the input list. A palindrome is a number that reads the same backward as forward, and the task is to return the `k`-th palindrome of a given size or return `-1` if the `k`-th palindrome does not exist.

We are given an array `queries`, where each query `q` asks for the `q`-th palindrome with exactly `sz` digits. If the query exceeds the number of possible palindromes of that size, return `-1`.

### Approach

To solve this problem efficiently, we need to generate palindromes for a given size `sz` and identify the `q`-th palindrome for each query. The key observation is that a palindrome number can be constructed by using its first half digits, and the second half is a mirror of the first half.

#### Steps to Solve:
1. **Understanding Palindromes**:
   - For a given size `sz`, the number of possible palindromes depends on whether the size is even or odd.
   - If `sz` is even, a palindrome consists of two equal halves. For example, a 4-digit palindrome looks like `ABBA`, where `AB` is the first half, and the second half mirrors `AB`.
   - If `sz` is odd, the middle digit is independent, and the palindrome looks like `ABA`, where `AB` is the first half, and `A` is mirrored as the last digit.

2. **Constructing Palindromes**:
   - For each query, calculate the possible range of numbers that can form palindromes with the given size `sz`.
   - Find the first half of the palindrome, and then mirror it to form the full palindrome.
   - For odd-sized palindromes, exclude the middle digit from the mirrored portion.

3. **Efficient Query Resolution**:
   - For each query, determine if the requested palindrome index `q` lies within the valid range of palindromes. If not, return `-1`.
   - Construct the palindrome by manipulating the first half digits and mirroring them.

### Code Breakdown (Step by Step)

#### Step 1: Helper Function `reverse`

```cpp
long long reverse(long long n, int skip) {
    long long res = 0;
    for(n = skip ? n / 10 : n; n > 0; n /= 10)
        res = res * 10 + n % 10;
    return res;
}
```

- This helper function reverses the digits of a number `n`.
- If the `skip` flag is set, it removes the last digit of `n` before starting the reversal process. This is useful for palindromes where we only want to mirror the first half.

#### Step 2: Main Function `kthPalindrome`

```cpp
vector<long long> kthPalindrome(vector<int>& queries, int sz) {
    vector<long long> ans;
    long long start = pow(10, (sz + 1) / 2 - 1), 
              end = pow(10, (sz + 1) / 2), 
              mul = pow(10, sz / 2);
    for (auto q : queries)
        if (start + q > end)
            ans.push_back(-1);
        else {
            long long res = (start + q - 1) * mul + reverse(start + q - 1, sz % 2);
            ans.push_back(res);
        }
    
    return ans;
}
```

- **Variables**:
  - `start`: The smallest possible number for the first half of a palindrome. This is calculated as `pow(10, (sz + 1) / 2 - 1)`.
  - `end`: The largest possible number for the first half of a palindrome. This is calculated as `pow(10, (sz + 1) / 2)`.
  - `mul`: This is a multiplier used to combine the first half of the palindrome with its mirrored second half. It is calculated as `pow(10, sz / 2)`.

- **Query Processing**:
  - For each query `q`, the code checks if the `q`-th palindrome is within the range of possible palindromes. If `q` exceeds the number of palindromes of size `sz`, it appends `-1` to the result.
  - Otherwise, it calculates the palindrome by:
    - Using the first half of the palindrome, which is `(start + q - 1)`.
    - Mirroring the first half by calling the `reverse` function (if the palindrome size `sz` is odd, it skips the middle digit during mirroring).
    - Combining the first half and mirrored second half to form the palindrome.
  
- **Return Result**:
  - After processing all queries, the function returns the result vector `ans`, which contains the palindromes or `-1` for invalid queries.

### Complexity Analysis

#### Time Complexity:
- **O(m)**, where `m` is the number of queries in the input `queries` array.
  - For each query, we perform constant-time operations, such as checking if the query is valid and reversing the first half of the palindrome. These operations take constant time relative to the size of the palindrome (`sz`), which is a constant value in this case.

#### Space Complexity:
- **O(m)**, where `m` is the number of queries in the input `queries` array.
  - The space complexity is linear in the number of queries because we store the result for each query in the output vector `ans`.

### Conclusion

This solution efficiently handles the task of finding the `k`-th palindrome for various queries with a given number of digits. By leveraging mathematical properties of palindromes, it calculates the palindrome directly from the first half and mirrors it to form the full palindrome, ensuring that the solution runs in optimal time for each query. 

With a time complexity of **O(m)** and space complexity of **O(m)**, this approach is well-suited for handling large input sizes, making it both time and space-efficient.

Overall, the solution is elegant, simple, and performs the task optimally for all valid inputs.
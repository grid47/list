### Problem Statement

The problem asks you to find the **duplicate number** in an array of integers `nums`, where the array contains `n + 1` integers, and all the integers are between `1` and `n` (inclusive). There is exactly one duplicate number in the array, but it may appear more than once. The challenge is to find the duplicate number **without modifying the array** and using **constant extra space**.

For example:
- Input: `nums = [1, 3, 4, 2, 2]`
- Output: `2`
  
In this example, the number `2` is the duplicate because it appears twice in the array.

### Approach

The problem is a classic case that can be solved using **Floydâ€™s Tortoise and Hare** algorithm, also known as the **Cycle Detection** algorithm. The key idea here is that the array can be interpreted as a linked list where each number in the array points to the next index (i.e., `nums[i]` points to the index `nums[i]`).

Given that there is exactly one duplicate number, we can think of this as a **cycle in the linked list**. By detecting the cycle, we can identify the duplicate number. The **Tortoise and Hare** algorithm efficiently detects this cycle without needing extra space.

### Steps:
1. **Phase 1 (Finding the Cycle)**: 
   - Use two pointers: a **slow pointer** and a **fast pointer**. 
   - Move the slow pointer by one step at a time, and the fast pointer by two steps at a time. 
   - Since there is a duplicate, the fast pointer will eventually meet the slow pointer inside the cycle (if a cycle exists).

2. **Phase 2 (Finding the Duplicate)**:
   - Once the slow pointer and fast pointer meet, reset one pointer to the start of the array.
   - Move both pointers one step at a time. The point where they meet again will be the duplicate number.

This approach uses **O(n)** time complexity and **O(1)** space complexity, making it optimal for large arrays with duplicates.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Slow and Fast Pointers
```cpp
int slow = nums[0], fast = nums[nums[0]];
```
- The **slow pointer** is initialized to the first element of the array, `nums[0]`.
- The **fast pointer** is initialized to `nums[nums[0]]`. This means that the fast pointer starts at the index `nums[0]`, which corresponds to the number at the index `nums[0]`. This is the key to identifying the cycle.

#### Step 2: Detect the Cycle
```cpp
while(slow != fast) {
    slow = nums[slow];
    fast = nums[nums[fast]];
}
```
- The slow pointer moves one step at a time (`slow = nums[slow]`), while the fast pointer moves two steps at a time (`fast = nums[nums[fast]]`).
- This loop continues until the slow pointer and fast pointer meet. Once they meet, a cycle is detected. The meeting point is within the cycle, but it does not yet give us the duplicate number. We now proceed to the next phase.

#### Step 3: Find the Start of the Cycle (Duplicate)
```cpp
fast = 0;
while(slow != fast) {
    slow = nums[slow];
    fast = nums[fast];
}
return fast;
```
- Once a cycle is detected, reset the `fast` pointer to the start of the array (`fast = 0`).
- Now, move both the slow and fast pointers one step at a time. The slow pointer moves by one step (`slow = nums[slow]`), and the fast pointer also moves one step (`fast = nums[fast]`).
- When both pointers meet again, the point where they meet is the duplicate number. This is because the cycle is formed by the duplicate number, and the slow and fast pointers are both now pointing to the starting point of the cycle.

### Complexity

#### Time Complexity:
- The time complexity of this algorithm is **O(n)**, where `n` is the size of the input array `nums`.
- In the first phase, both the slow and fast pointers move through the array. Since the fast pointer moves twice as fast as the slow pointer, they will eventually meet in the cycle.
- In the second phase, both pointers traverse the cycle and reach the starting point of the cycle in linear time.
- As a result, the algorithm runs in **O(n)** time.

#### Space Complexity:
- The space complexity is **O(1)**, because we are only using two pointers (`slow` and `fast`) to detect the cycle. No additional space is required for the solution.
- This satisfies the constraint of using constant extra space.

### Conclusion

This solution efficiently solves the problem of finding the duplicate number in the array using **Floyd's Tortoise and Hare** cycle detection algorithm. The algorithm leverages the fact that the array can be seen as a linked list with cycles due to the duplicate number.

**Key Advantages:**
- **Time efficiency**: The algorithm runs in linear time, i.e., **O(n)**, where `n` is the length of the array.
- **Space efficiency**: The solution uses constant space, i.e., **O(1)**, which ensures minimal memory usage.
- **Optimal for large inputs**: Due to its time and space complexity, the algorithm is highly efficient and works well even with large inputs.

This approach is one of the most optimal and well-known solutions to the problem of detecting duplicate numbers in an array, especially when considering the constraints that disallow modifying the array and require constant extra space.
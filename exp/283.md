### Problem Statement

The problem asks you to **move all zeroes in a given array** `nums` to the end, while maintaining the relative order of the non-zero elements. The goal is to do this with **O(n)** time complexity and **O(1)** extra space.

For example:
- Input: `nums = [0, 1, 0, 3, 12]`
- Output: `nums = [1, 3, 12, 0, 0]`

In this example, all the zeroes have been moved to the end of the array, and the relative order of non-zero elements has been maintained.

### Approach

To solve this problem efficiently, we can use the **two-pointer technique** with a swapping approach. The two-pointer approach allows us to traverse the list and rearrange the elements in place without requiring additional space.

**Key idea:**
1. **Pointer `i`:** This pointer will traverse the entire array.
2. **Pointer `j`:** This pointer will track the position where the next non-zero element should be placed.

As we traverse through the array, every time we encounter a non-zero element, we swap it with the element at the position indicated by `j`, and then increment `j`. After this, the pointer `j` will keep moving forward to track the next position for non-zero elements. Once all the non-zero elements are moved to the beginning of the array, the rest of the positions (from `j` onward) will be filled with zeroes.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the Pointer `j`
```cpp
int j = 0;
```
- The variable `j` is initialized to `0`. This pointer will keep track of the position where the next non-zero element should be placed.

#### Step 2: Traverse the Array with Pointer `i`
```cpp
for(int i = 0; i < nums.size(); i++) {
    if(nums[i] != 0)
        swap(nums[i], nums[j]), j++;
}
```
- The loop runs through all the elements in the array (`nums`).
- When the element at index `i` is non-zero (`nums[i] != 0`), we swap it with the element at index `j`.
  - The swap operation ensures that the non-zero element is placed at the correct position.
  - After the swap, we increment the pointer `j` to point to the next position where the next non-zero element will be placed.
- This loop effectively moves all non-zero elements to the front of the array, while maintaining their relative order.

#### Step 3: Fill the Remaining Positions with Zeroes
```cpp
while(j < nums.size())
    nums[j++] = 0;
```
- After the loop finishes, the pointer `j` points to the first position where a zero should be placed.
- We then enter a `while` loop that fills all positions from index `j` to the end of the array with zeroes.
- The loop continues to set `nums[j] = 0` until `j` reaches the end of the array.

### Complexity

#### Time Complexity:
- The algorithm consists of two loops:
  - The first loop iterates through the entire array once, checking and swapping elements. This takes `O(n)` time.
  - The second loop, which sets the remaining positions to zero, also runs in `O(n)` time in the worst case.
- Since both loops together only traverse the array a constant number of times, the overall time complexity is **O(n)**, where `n` is the size of the input array.

#### Space Complexity:
- The algorithm only uses a constant amount of extra space. The swapping is done in-place, so no additional arrays or data structures are required.
- Therefore, the space complexity is **O(1)**.

### Conclusion

This solution provides an **efficient** way to move all zeroes to the end of the array while maintaining the relative order of the non-zero elements. The two-pointer technique, combined with the swap operation, ensures that we can accomplish this task in **O(n)** time and **O(1)** space, making it optimal for large input sizes.

This approach is ideal for problems where in-place modification of the array is required. By minimizing both the time and space complexity, the solution is well-suited for scenarios where performance is critical.

### Key Points:
- **Optimal time complexity:** `O(n)` â€” the algorithm processes the array in a single pass.
- **In-place modification:** The array is modified without needing additional memory allocation.
- **Space efficiency:** The solution achieves **O(1)** space complexity by avoiding extra space usage.
- **Stable ordering of non-zero elements:** The relative order of non-zero elements is preserved during the process.

This technique, often referred to as the "two-pointer" approach, is widely applicable in problems that involve rearranging or partitioning an array based on a condition, such as moving zeroes, partitioning odd/even elements, or sorting elements in-place.
### Problem Statement

The task at hand is to convert a given integer `num` (in the range [0, 2^31 - 1]) into its corresponding English words. For example:
- **Input**: `123`
- **Output**: `"One Hundred Twenty Three"`

You need to return the number as a string in English words. The conversion should be efficient and able to handle large numbers up to the billion range (1,000,000,000).

### Approach

To solve this problem, we use a recursive approach to break down the number into smaller parts that are easier to convert into English words. The number is divided into segments such as ones, tens, hundreds, thousands, millions, and billions. We handle these parts separately and combine them into a full English representation.

The general idea involves:
1. Using arrays to store the English words for numbers in different ranges (ones, tens, and powers of 1000).
2. Recursively breaking down the number into smaller chunks, each representing a number less than 1000.
3. Combining the smaller chunks with appropriate scales like thousand, million, and billion.

### Code Breakdown (Step by Step)

Let's walk through the code to understand how it works:

```cpp
class Solution {
public:
    string ones[20] = {"", " One", " Two", " Three", " Four", " Five", " Six", " Seven", " Eight", " Nine", " Ten", " Eleven", " Twelve", " Thirteen", " Fourteen", " Fifteen", " Sixteen", " Seventeen", " Eighteen", " Nineteen"};
    string tens[10] = {"", " Ten", " Twenty", " Thirty", " Forty", " Fifty", " Sixty", " Seventy", " Eighty", " Ninety"};
    string thousands[4] = {"", " Thousand", " Million", " Billion"};
```

1. **Data Initialization**:
   - We define three arrays:
     - `ones[20]`: Contains words for numbers 0 to 19.
     - `tens[10]`: Contains words for multiples of 10 (20, 30, ..., 90).
     - `thousands[4]`: Contains words for the scales of thousand (thousand, million, billion).

```cpp
    string helper(int n) {
        if (n < 20) 
            return ones[n];
        if (n < 100) 
            return tens[n / 10] + helper(n % 10);
        if (n < 1000) 
            return helper(n / 100) + " Hundred" + helper(n % 100);
        for (int i = 3; i >= 0; i--) {
            if (n >= pow(1000, i)) {
                return helper(n / pow(1000, i)) + thousands[i] + helper(n % (int)pow(1000, i));
            }
        }
        return "";
    }
```

2. **Helper Function**:
   - The function `helper(int n)` is used to convert the number `n` into words.
   - **Base Case**: If `n < 20`, it directly returns the word from the `ones` array (e.g., "One", "Two", ..., "Nineteen").
   - If `n` is between 20 and 99, it returns the word for tens (from `tens` array) followed by a recursive call to convert the remainder (i.e., the ones place).
   - If `n` is between 100 and 999, it returns the word for the hundreds place (using recursion) followed by the word "Hundred", and then a recursive call for the remainder.
   - For numbers larger than 999, the function recursively divides the number into thousands, millions, and billions using the `thousands` array. The number is divided by a power of 1000, and the corresponding scale is added after converting the smaller segment recursively.

```cpp
    string numberToWords(int num) {
        if (num == 0)  return "Zero";
        return helper(num).substr(1);
    }
};
```

3. **Main Function**: 
   - The function `numberToWords(int num)` is the main entry point. If the number is `0`, it returns "Zero".
   - Otherwise, it calls the `helper()` function to convert the number into English words and uses `substr(1)` to remove the leading space added in the `helper()` function.

### Explanation of Recursive Approach

- **Recursive Decomposition**: The number is recursively divided into smaller parts. For instance, 1234 is broken into 1 (thousand), 2 (hundred), and 34 (tens and ones). Each part is processed individually and then combined.
- **Combining Results**: For every part, the corresponding word is found from `ones[]`, `tens[]`, or `thousands[]`, and the results are concatenated. If the number is larger than a thousand, it recursively reduces the number until it reaches smaller values (less than 1000).
  
### Complexity Analysis

#### Time Complexity:
- The time complexity is **O(log n)**, where `n` is the input number. This is because the number is divided by powers of 1000 at each recursive step. Since we only recurse for logarithmic depth (log base 1000), this approach is highly efficient. 

#### Space Complexity:
- The space complexity is **O(log n)** as well, primarily due to the recursion stack. For each recursive call, we store intermediate results, which means the depth of the recursion tree is proportional to the logarithm of the number.

### Conclusion

This approach efficiently converts any integer between 0 and 2^31 - 1 into its corresponding English words using recursion and pre-defined arrays. The algorithm breaks down the problem into smaller, manageable pieces, handling various number ranges (ones, tens, hundreds, thousands, millions, billions). The use of recursion combined with helper arrays ensures that the solution is both clean and efficient.

#### Advantages:
1. **Efficiency**: The time complexity is logarithmic (O(log n)), which ensures fast execution even for large numbers.
2. **Clarity**: The code structure is simple and easy to understand, leveraging recursion for problem decomposition.
3. **No Hardcoding**: The solution is general enough to work with any number in the specified range, thanks to the use of dynamic helper arrays (`ones[]`, `tens[]`, and `thousands[]`).

#### Potential Use Cases:
1. **Financial Software**: Converting large numbers into words for written checks, invoices, etc.
2. **Document Automation**: Generating reports or documents that require numbers to be expressed in English words.
3. **Localization**: Easily adaptable to different languages by adjusting the `ones[]`, `tens[]`, and `thousands[]` arrays.

This solution provides an optimal balance of efficiency and clarity, making it well-suited for applications where number-to-word conversion is required.
### Problem Statement

The task is to calculate the score of selecting numbers from an array `nums` while adhering to specific constraints. The score starts at 0, and for each valid selection, you add the selected number to the score. Once a number is selected from index `i`, the indices `i-1` and `i+1` become unavailable for future selections. The objective is to maximize the total score by carefully selecting numbers from the array.

### Approach

The problem asks us to select numbers in such a way that the score is maximized, and at the same time, we need to ensure that no adjacent indices are selected. This is akin to a problem where we must greedily select the smallest unselected number from the array and then mark its neighbors as unavailable.

The main idea is to use a **min-heap (priority queue)** to efficiently select the smallest available number from the array and manage the unavailability of adjacent indices. We also use a hash map (`unordered_map`) to track the indices that have been marked as unavailable.

### Step-by-Step Breakdown

#### Step 1: Initialize Priority Queue and Data Structures
```cpp
long long score = 0;
priority_queue<vector<int>, vector<vector<int>>, greater<vector<int>>> pq;
int n = nums.size();
unordered_map<int, int> mp;
```
- **score**: This variable will hold the total score as we progress.
- **pq**: A priority queue is used to select the smallest unselected number at each step. The queue stores pairs of `(value, index)` where `value` is the number from the `nums` array, and `index` is its corresponding index.
- **mp**: An unordered map is used to keep track of the indices that have already been marked as unavailable. Specifically, if `mp[i]` is true, it means the number at index `i` is unavailable due to being marked as selected or due to its neighboring index being selected.

#### Step 2: Populate the Priority Queue
```cpp
for(int i = 0; i < n; i++)
    pq.push({nums[i], i});
```
- Here, we iterate over the `nums` array and push each element along with its index into the priority queue. The priority queue is organized to always pop the smallest value first because we are using `greater<vector<int>>` to compare elements. The smallest number will always be at the top of the queue.

#### Step 3: Greedily Select Numbers
```cpp
while(!pq.empty()) {
    while(!pq.empty() && mp.count(pq.top()[1])) pq.pop();
    if(!pq.empty()) {
        score += pq.top()[0];
        mp[pq.top()[1]] = true;
        mp[pq.top()[1] + 1] = true;
        mp[pq.top()[1] - 1] = true;
        pq.pop();
    }
}
```
- **Pop invalid elements**: The outer `while` loop ensures that we continue to pop from the priority queue until we find a valid element. The inner `while` loop checks if the index of the current element (`pq.top()[1]`) is already marked as unavailable. If it is, we pop the element and move to the next one.
  
- **Select the smallest available element**: Once we find a valid element (i.e., one whose index is not in the `mp` map), we add its value to the total score. We also mark the index of the selected element (`pq.top()[1]`), and its neighbors (`pq.top()[1] + 1` and `pq.top()[1] - 1`) as unavailable by setting `mp[pq.top()[1]]`, `mp[pq.top()[1] + 1]`, and `mp[pq.top()[1] - 1]` to `true`. This ensures that these indices cannot be selected in future iterations.
  
- **Pop the selected element**: After selecting the element and marking its neighbors as unavailable, we pop the element from the priority queue and proceed to the next iteration.

#### Step 4: Return the Final Score
```cpp
return score;
```
- Once all valid elements have been selected, and the priority queue is empty, the final score is returned as the result.

### Example Walkthrough

Let's walk through an example to better understand how the code works.

#### Input:
```cpp
vector<int> nums = {1, 3, 2, 4, 5};
```

1. **Initialization**:
   - The priority queue `pq` is populated with the elements and their indices: `{{1, 0}, {3, 1}, {2, 2}, {4, 3}, {5, 4}}`.
   - The `mp` map starts as empty, and `score = 0`.

2. **First Iteration**:
   - The top of the priority queue is `{1, 0}` (value 1 at index 0).
   - The index 0 is not marked as unavailable, so we add `1` to the score.
   - We then mark index 0, and its neighbors (indices -1 and 1) as unavailable. In this case, we only mark index 1 (since index -1 is out of bounds).
   - The score is now `1`, and `mp = {0: true, 1: true}`.

3. **Second Iteration**:
   - The next valid element is `{2, 2}` (value 2 at index 2).
   - The index 2 is not marked as unavailable, so we add `2` to the score.
   - We mark index 2 and its neighbors (indices 1 and 3) as unavailable. Index 1 is already unavailable, so only index 3 is marked as unavailable.
   - The score is now `3`, and `mp = {0: true, 1: true, 2: true, 3: true}`.

4. **Third Iteration**:
   - The next valid element is `{4, 3}` (value 4 at index 3), but index 3 is already marked as unavailable, so we skip it.

5. **Fourth Iteration**:
   - The next valid element is `{3, 1}` (value 3 at index 1), but index 1 is already marked as unavailable, so we skip it.

6. **Fifth Iteration**:
   - The next valid element is `{5, 4}` (value 5 at index 4).
   - We add `5` to the score.
   - We mark index 4 and its neighbors (indices 3 and 5) as unavailable.
   - The score is now `8`, and `mp = {0: true, 1: true, 2: true, 3: true, 4: true}`.

#### Final Score:
The total score after selecting all valid numbers is `8`.

#### Output:
```cpp
return 8;
```

### Time Complexity

- **Time Complexity**: \(O(n \log n)\)
  - The time complexity is dominated by the sorting of the elements in the priority queue and the operations on the queue itself.
  - The priority queue supports `push` and `pop` operations that take \(O(\log n)\) time. Since we perform these operations for each element in the array, the total time complexity is \(O(n \log n)\).
  
- **Space Complexity**: \(O(n)\)
  - The space complexity is primarily determined by the storage of the priority queue, the map `mp`, and the `nums` array. All these structures store data for each element in the array, resulting in an overall space complexity of \(O(n)\).

### Conclusion

This solution efficiently maximizes the score by greedily selecting the smallest available element from the array and marking its adjacent indices as unavailable. The use of a priority queue ensures that the smallest element is always selected, and the map keeps track of which indices are unavailable for future selections. This approach guarantees an optimal solution in \(O(n \log n)\) time and uses \(O(n)\) space, making it efficient and scalable for large input sizes.
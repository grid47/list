### Problem Statement

In this problem, we are given two arrays `g` and `s`:
- `g[i]` represents the greed factor of the i-th child, which indicates the minimum size of the cookie that the child will be content with.
- `s[i]` represents the size of the i-th cookie.

Our goal is to maximize the number of children who can be content by giving them a cookie from the available cookies. A child is content if the size of the cookie they receive is greater than or equal to their greed factor. Each child can receive at most one cookie, and each cookie can only be assigned to one child.

The challenge is to implement an efficient algorithm that finds the maximum number of content children given the greed factors and the cookie sizes.

### Approach

The approach to solving this problem involves:
1. **Sorting**: Sorting both the greed factors array `g` and the cookies array `s` ensures that we can efficiently match children with cookies, starting from the least greedy child and the smallest cookie that can satisfy them.
2. **Greedy Algorithm**: We use a greedy approach to assign cookies. The basic idea is to match the smallest available cookie that can satisfy the current child, starting with the child with the least greed. If the current cookie can satisfy the current child, we move on to the next child; otherwise, we move on to the next cookie. This ensures we maximize the number of satisfied children.
3. **Two-Pointer Technique**: We use two pointers, one for the greed factor array (`g`) and one for the cookie sizes array (`s`). The pointer for `g` tracks the children, and the pointer for `s` tracks the available cookies. We iterate over both arrays, assigning cookies to children whenever possible.

### Code Breakdown (Step by Step)

#### Step 1: Sort the Greed Factors and Cookie Sizes

```cpp
sort(g.begin(), g.end());
sort(s.begin(), s.end());
```

- The first step in the approach is to sort both arrays: `g` (greed factors of children) and `s` (sizes of cookies). Sorting ensures that we can start assigning cookies from the smallest available size to the least greedy child.
- Sorting is crucial because it allows us to efficiently match the smallest cookie that satisfies the child's greed.

#### Step 2: Initialize Pointers and Start Matching

```cpp
int i = 0, j = 0;
while(i < g.size() && j < s.size()) {
    if(s[j] >= g[i])
        i++; // when the child gets the cookie, forward child by 1
    j++;
}
```

- We initialize two pointers: `i` for the greed factor array (`g`) and `j` for the cookie sizes array (`s`).
- The `while` loop continues as long as there are children left (`i < g.size()`) and there are cookies left (`j < s.size()`).
- Inside the loop:
  - If the current cookie `s[j]` can satisfy the current child `g[i]` (i.e., `s[j] >= g[i]`), we move the pointer `i` to the next child (`i++`), because the current child is content with the current cookie.
  - Regardless of whether the current child is satisfied, we always move the pointer `j` to the next cookie (`j++`), as each cookie can only be used once.

#### Step 3: Return the Result

```cpp
return i;
```

- The variable `i` tracks how many children have been satisfied. Since we increment `i` each time we successfully match a child with a cookie, `i` will hold the number of content children when the loop finishes.
- We return `i` as the final result, which represents the maximum number of content children.

### Complexity

#### Time Complexity:
- **Sorting the Greed Factors and Cookie Sizes**: The time complexity of sorting both `g` and `s` is `O(n log n + m log m)`, where `n` is the number of children and `m` is the number of cookies. This is the most expensive operation in the solution.
- **Iterating Over Both Arrays**: After sorting, the while loop runs in `O(n + m)` time, where `n` is the number of children and `m` is the number of cookies. In the worst case, we will iterate through both arrays once.
- Therefore, the overall time complexity is `O(n log n + m log m)`, which is dominated by the sorting steps.

#### Space Complexity:
- The space complexity of the algorithm is `O(1)` since we only use a few additional integer variables (`i` and `j`) and no extra data structures that depend on the input size. The space complexity remains constant.

### Conclusion

This solution efficiently solves the problem of maximizing the number of content children by employing a greedy algorithm with sorting and a two-pointer approach. The main steps involve sorting the greed factors and cookie sizes and then iterating over both arrays to assign cookies to children. The algorithm runs in `O(n log n + m log m)` time, making it efficient even for larger inputs. The space complexity is constant, ensuring minimal memory usage.

By sorting both the greed factors and cookie sizes, we ensure that we always give the smallest available cookie to a child who can be content, thereby maximizing the number of content children. This approach is optimal and easy to understand, making it an excellent solution to the problem.
### Problem Statement

The problem is to determine the maximum profit that can be made by completing at most two stock transactions. A stock transaction is defined as buying a stock on one day and selling it on another. You can buy and sell the stock at most twice in total. Each transaction consists of a buy followed by a sell, and the goal is to maximize the total profit. 

For example:
- **Input**: `prices = [3,2,6,5,0,3]`
- **Output**: `6`
  - Explanation: Buy on day 2 (price = 2), sell on day 3 (price = 6). Profit = `6 - 2 = 4`. Then, buy on day 5 (price = 0), sell on day 6 (price = 3). Profit = `3 - 0 = 3`. The total profit is `4 + 3 = 6`.

- **Input**: `prices = [1,2,3,4,5]`
- **Output**: `4`
  - Explanation: Buy on day 1 (price = 1), sell on day 5 (price = 5). The total profit is `5 - 1 = 4`. Since the prices are continuously rising, only one transaction is needed to achieve the maximum profit.

### Approach

This problem is an extension of the "Best Time to Buy and Sell Stock" problem, but with the added complexity of making at most two transactions. The key idea is to keep track of four variables that represent different states during the stock transactions:

1. `s1`: The maximum profit that can be achieved after buying the stock for the first time (after the first buy).
2. `s2`: The maximum profit that can be achieved after the first sell.
3. `s3`: The maximum profit that can be achieved after the second buy.
4. `s4`: The maximum profit that can be achieved after the second sell (this will be the final result).

Each of these states is updated iteratively, where:
- `s1` is updated to reflect the best price to buy the stock for the first time.
- `s2` is updated to track the best possible profit after selling the stock for the first time.
- `s3` tracks the maximum profit after buying the stock for the second time.
- `s4` tracks the best possible profit after selling the stock for the second time.

### Code Breakdown (Step by Step)

#### 1. **Function Definition**
```cpp
int maxProfit(vector<int>& prices)
```
The function `maxProfit` takes a reference to a vector of integers, `prices`, where each element represents the price of a stock on a given day. The function returns an integer, which is the maximum profit from at most two transactions.

#### 2. **Edge Case Check**
```cpp
if(prices.empty()) return 0;
```
This line checks if the `prices` vector is empty. If the vector is empty, no transactions can be made, so the function immediately returns `0` as the result.

#### 3. **Initialize State Variables**
```cpp
int s1 = -prices[0], s2 = INT_MIN,
    s3 = INT_MIN, s4 = INT_MIN;
```
- `s1`: Represents the maximum profit after the first buy. We initialize it to `-prices[0]` because the first buy can only happen at the first day's price.
- `s2`: Represents the maximum profit after the first sell. This is initialized to `INT_MIN`, meaning it is initially invalid, as no sell has happened yet.
- `s3`: Represents the maximum profit after the second buy. Initially set to `INT_MIN` since no second buy has occurred.
- `s4`: Represents the maximum profit after the second sell. This is also set to `INT_MIN` initially because no sell has occurred yet.

#### 4. **Iterate Through Prices**
```cpp
int n = prices.size();
for(int i = 1; i < n; i++) {
    s1 = max(s1, -prices[i]);
    s2 = max(s2, s1 + prices[i]);
    s3 = max(s3, s2 - prices[i]);
    s4 = max(s4, s3 + prices[i]);
}
```
The loop iterates through the prices array starting from index 1 (since index 0 is already used to initialize `s1`).
- **Update `s1`**: `s1 = max(s1, -prices[i])` ensures that `s1` reflects the best price at which we can buy the stock for the first time, i.e., the minimum price encountered so far.
- **Update `s2`**: `s2 = max(s2, s1 + prices[i])` ensures that `s2` reflects the best profit we can make by selling the stock after the first buy.
- **Update `s3`**: `s3 = max(s3, s2 - prices[i])` ensures that `s3` represents the best price at which we can buy the stock for the second time, which comes after the first sell.
- **Update `s4`**: `s4 = max(s4, s3 + prices[i])` ensures that `s4` reflects the best profit we can achieve by selling the stock after the second buy.

#### 5. **Return the Maximum Profit**
```cpp
return max(s4, 0);
```
Finally, the function returns the maximum profit achieved after the second sell (`s4`). If no transactions were made (i.e., no profit was possible), the function returns `0`.

### Example Walkthrough

Letâ€™s walk through an example to understand how the algorithm works:

**Input**: `prices = [3,2,6,5,0,3]`

1. **Initialization**:
   - `s1 = -3`, `s2 = INT_MIN`, `s3 = INT_MIN`, `s4 = INT_MIN`.

2. **Iterate Through Prices**:

   - **Price 2**:
     - `s1 = max(-3, -2) = -2`.
     - `s2 = max(INT_MIN, -2 + 2) = 0`.
     - `s3 = max(INT_MIN, 0 - 2) = -2`.
     - `s4 = max(INT_MIN, -2 + 2) = 0`.

   - **Price 6**:
     - `s1 = max(-2, -6) = -2`.
     - `s2 = max(0, -2 + 6) = 4`.
     - `s3 = max(-2, 4 - 6) = -2`.
     - `s4 = max(0, -2 + 6) = 4`.

   - **Price 5**:
     - `s1 = max(-2, -5) = -2`.
     - `s2 = max(4, -2 + 5) = 4`.
     - `s3 = max(-2, 4 - 5) = -1`.
     - `s4 = max(4, -1 + 5) = 4`.

   - **Price 0**:
     - `s1 = max(-2, 0) = 0`.
     - `s2 = max(4, 0 + 0) = 4`.
     - `s3 = max(-1, 4 - 0) = 4`.
     - `s4 = max(4, 4 + 0) = 4`.

   - **Price 3**:
     - `s1 = max(0, -3) = 0`.
     - `s2 = max(4, 0 + 3) = 4`.
     - `s3 = max(4, 4 - 3) = 4`.
     - `s4 = max(4, 4 + 3) = 7`.

3. **Final Output**:
   - The maximum profit is `7`, so the function returns `7`.

### Time Complexity

- **Time Complexity**: `O(n)`
  - The algorithm only iterates through the `prices` array once. For each element in the array, constant time operations are performed. Thus, the time complexity is linear with respect to the size of the input array.

- **Space Complexity**: `O(1)`
  - The algorithm uses a constant amount of space (only a few integer variables to track the state). No additional space is used that grows with the size of the input array, so the space complexity is constant.

### Conclusion

This solution efficiently calculates the maximum profit from at most two stock transactions. By maintaining four state variables that track the progress of the two transactions, the algorithm ensures that it handles the problem in linear time with constant space. The time complexity of `O(n)` makes it suitable for large inputs, while the space complexity of `O(1)` ensures minimal memory usage. This approach leverages dynamic programming and greedy strategies to deliver an optimal solution to the problem.
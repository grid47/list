### 📈 **Maximum Profit from Two Stock Transactions**

#### **Problem Statement**
The task is to determine the **maximum profit** that can be achieved by completing at most two stock transactions. A **stock transaction** is defined as buying a stock on one day and selling it on another day. You are allowed to perform **at most two transactions**—each consisting of a buy followed by a sell—and the goal is to maximize the total profit.

---

**Example 1**:
- **Input**: `prices = [3,2,6,5,0,3]`
- **Output**: `6`
  - **Explanation**:  
    - Buy on day 2 (price = 2), sell on day 3 (price = 6). Profit = `6 - 2 = 4`.
    - Buy on day 5 (price = 0), sell on day 6 (price = 3). Profit = `3 - 0 = 3`.
    - Total profit = `4 + 3 = 6`.

---

**Example 2**:
- **Input**: `prices = [1,2,3,4,5]`
- **Output**: `4`
  - **Explanation**:  
    - Buy on day 1 (price = 1), sell on day 5 (price = 5). Profit = `5 - 1 = 4`.
    - Since the prices are continuously rising, only one transaction is needed to achieve the maximum profit.

---

### 🧩 **Approach**

This problem is an extension of the **"Best Time to Buy and Sell Stock"** problem, with the added complexity of allowing **at most two transactions**. The key idea is to track four variables that represent different states during the stock transactions:

1. **`s1`**: The maximum profit after buying the stock for the first time.
2. **`s2`**: The maximum profit after selling the stock for the first time.
3. **`s3`**: The maximum profit after buying the stock for the second time.
4. **`s4`**: The maximum profit after selling the stock for the second time (this will be our final result).

### **State Transitions**:
- **`s1`**: Tracks the minimum price to buy for the first transaction.
- **`s2`**: Tracks the maximum profit possible after the first sell.
- **`s3`**: Tracks the best price to buy again for the second transaction.
- **`s4`**: Tracks the maximum profit after the second sell.

### 💻 **Code Breakdown (Step-by-Step)**

---

#### 1. **Function Definition**
```cpp
int maxProfit(vector<int>& prices)
```
The function `maxProfit` takes a reference to a vector `prices`, representing stock prices on different days, and returns an integer, which is the maximum profit from at most two transactions.

---

#### 2. **Edge Case Check**
```cpp
if(prices.empty()) return 0;
```
If the `prices` vector is empty, no transactions can be made, and the function immediately returns `0`.

---

#### 3. **Initialize State Variables**
```cpp
int s1 = -prices[0], s2 = INT_MIN, s3 = INT_MIN, s4 = INT_MIN;
```
- **`s1`**: Maximum profit after the first buy (initialized to `-prices[0]`).
- **`s2`**: Maximum profit after the first sell (initialized to `INT_MIN`).
- **`s3`**: Maximum profit after the second buy (initialized to `INT_MIN`).
- **`s4`**: Maximum profit after the second sell (initialized to `INT_MIN`).

---

#### 4. **Iterate Through Prices**
```cpp
int n = prices.size();
for(int i = 1; i < n; i++) {
    s1 = max(s1, -prices[i]);
    s2 = max(s2, s1 + prices[i]);
    s3 = max(s3, s2 - prices[i]);
    s4 = max(s4, s3 + prices[i]);
}
```
- **`s1`**: Update the best price to buy for the first transaction.
- **`s2`**: Update the maximum profit after the first sell.
- **`s3`**: Update the best price to buy again for the second transaction.
- **`s4`**: Update the maximum profit after the second sell.

---

#### 5. **Return Maximum Profit**
```cpp
return max(s4, 0);
```
Finally, the function returns the maximum profit achieved after the second sell. If no transactions were made (no profit), it returns `0`.

---

### 🔍 **Example Walkthrough**

Let’s walk through an example to see how the algorithm works:

**Input**: `prices = [3,2,6,5,0,3]`

1. **Initialization**:
   - `s1 = -3`, `s2 = INT_MIN`, `s3 = INT_MIN`, `s4 = INT_MIN`.

2. **Iterate Through Prices**:

   - **Price 2**:
     - `s1 = max(-3, -2) = -2`
     - `s2 = max(INT_MIN, -2 + 2) = 0`
     - `s3 = max(INT_MIN, 0 - 2) = -2`
     - `s4 = max(INT_MIN, -2 + 2) = 0`

   - **Price 6**:
     - `s1 = max(-2, -6) = -2`
     - `s2 = max(0, -2 + 6) = 4`
     - `s3 = max(-2, 4 - 6) = -2`
     - `s4 = max(0, -2 + 6) = 4`

   - **Price 5**:
     - `s1 = max(-2, -5) = -2`
     - `s2 = max(4, -2 + 5) = 4`
     - `s3 = max(-2, 4 - 5) = -1`
     - `s4 = max(4, -1 + 5) = 4`

   - **Price 0**:
     - `s1 = max(-2, 0) = 0`
     - `s2 = max(4, 0 + 0) = 4`
     - `s3 = max(-1, 4 - 0) = 4`
     - `s4 = max(4, 4 + 0) = 4`

   - **Price 3**:
     - `s1 = max(0, -3) = 0`
     - `s2 = max(4, 0 + 3) = 4`
     - `s3 = max(4, 4 - 3) = 4`
     - `s4 = max(4, 4 + 3) = 7`

3. **Final Output**:
   - The maximum profit is `7`.

---

### 🕒 **Time and Space Complexity**

- **Time Complexity**: `O(n)`  
  The algorithm iterates through the `prices` array once, performing constant time operations for each element.

- **Space Complexity**: `O(1)`  
  The algorithm uses only a constant amount of extra space to store a few variables, independent of the input size.

---

### 💡 **Conclusion**

This solution calculates the maximum profit from at most two stock transactions in **linear time** with **constant space**. By tracking the progress of each transaction with four state variables, the algorithm efficiently solves the problem. With a time complexity of `O(n)`, it works well for large inputs and ensures minimal memory usage with a space complexity of `O(1)`.

Happy coding! 🚀

---
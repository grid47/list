### Problem Statement

The task is to compute the **alternating sum of the digits** of a given number `n`, where the digits are added or subtracted alternately. Specifically, you need to:

- Start from the least significant digit (rightmost digit) and alternate the sign (positive/negative) as you move leftward.
- For example, for the number `4321`, the alternating sum will be computed as:
  - `1 - 2 + 3 - 4 = -2`

Given an integer `n`, you are to compute the alternating digit sum.

### Approach

The approach for this problem involves processing each digit of the number `n` in sequence, starting from the least significant digit, and alternately adding and subtracting the digits. The sign alternates after every digit, and we use a variable to track whether the current digit should be added or subtracted. The process continues until all digits of `n` are processed.

1. **Initialization**: We need two variables:
   - `sum`: This will store the resulting alternating sum.
   - `sgn`: This will be used to track the alternating sign, initially set to `1` (for adding the first digit).
   
2. **Processing Each Digit**:
   - Extract the least significant digit of the number using `n % 10`.
   - Multiply the digit by the current sign (`sgn`), and add this value to the `sum`.
   - Remove the last digit of `n` using integer division (`n /= 10`).
   - Alternate the sign by multiplying `sgn` by `-1`.
   
3. **Final Adjustment**: After the loop, if the sign (`sgn`) is still `-1`, it means the sum of the digits should be negated. This is a result of how the sign alternates with each digit, and we need to adjust the sum at the end.

4. **Return the Result**: Finally, return the computed alternating digit sum.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the sum and sign
```cpp
int sum = 0;
int sgn = 1;
```
- `sum` is initialized to `0`, as we need to accumulate the alternating sum of the digits.
- `sgn` is initialized to `1` since we start with adding the rightmost digit (positive sign).

#### Step 2: Extract digits and compute alternating sum
```cpp
while(n) {
    sum += sgn * (n % 10);
    n /= 10;
    sgn *= -1;
}
```
- The loop runs while `n` is not `0`, meaning there are still digits left to process.
- `n % 10` extracts the least significant digit of `n`.
- We multiply this digit by the current sign (`sgn`) and add it to `sum`.
- Then, we update `n` by removing the least significant digit using integer division (`n /= 10`).
- After processing each digit, we alternate the sign for the next digit by multiplying `sgn` by `-1`.

#### Step 3: Final adjustment of the sum
```cpp
return sgn == -1 ? sum : -sum;
```
- After all digits have been processed, the sign (`sgn`) will either be `1` or `-1`.
  - If `sgn` is `-1`, it means the sum was calculated correctly, and we return it as-is.
  - If `sgn` is `1`, the sum needs to be negated to correct the final result.

### Complexity Analysis

#### Time Complexity:
The time complexity of this algorithm is determined by how many digits the number `n` has. Specifically:
- We process each digit once, and the number of digits in `n` is proportional to `log10(n)`.
- Therefore, the time complexity is `O(log n)`, where `n` is the input number.

#### Space Complexity:
The space complexity of the algorithm is constant, `O(1)`, because we are using only a few variables (`sum` and `sgn`) to store the intermediate results, and no additional data structures are used that depend on the size of `n`.

### Conclusion

The function successfully computes the alternating digit sum by processing the digits of `n` from right to left, alternating the sign of the sum as it goes. This approach is efficient with a time complexity of `O(log n)` and a space complexity of `O(1)`, making it both time-efficient and space-efficient for large values of `n`. The solution leverages simple arithmetic and control flow to achieve the desired result in an optimal manner.
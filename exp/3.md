### Problem Statement

The problem you're tasked with is a variation of the **Longest Substring Without Repeating Characters** problem, which is a common question in algorithmic challenges. The problem requires finding the length of the longest substring in a given string `s` that does not contain any repeating characters.

**Input:**
- A string `s` consisting of characters.

**Output:**
- The length of the longest substring in `s` that contains no repeated characters.

### Approach

To solve this problem, we can use a **sliding window** approach combined with a **hashmap** to efficiently track the characters we've encountered and ensure no characters are repeated in the current substring. The sliding window allows us to check substrings in a linear pass, ensuring optimal time complexity.

#### Key Steps:
1. **Sliding Window**: We maintain a window of characters as we traverse through the string, ensuring that no character in this window is repeated. The window's boundaries are adjusted as we find repeating characters.
   
2. **Hashmap**: A hashmap (or map in C++) will store the most recent index of each character. This allows us to quickly find the position where the character was last seen and adjust the left boundary of the sliding window accordingly.

3. **Max Length Calculation**: As we slide through the string, we continuously calculate the length of the current valid substring and update the maximum length if the current substring is longer.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables

```cpp
int prv = -1, len = 0;
map<char, int> mp;
```

- `prv`: This variable represents the index of the last character that was part of the current valid substring. Initially set to `-1` to indicate that no character has been processed yet.
- `len`: This stores the length of the longest substring found so far. It's initialized to `0`.
- `mp`: A map (hashmap) that stores each character in the string along with its most recent index. This helps in determining the most recent position of a character, allowing us to efficiently adjust the sliding window.

#### Step 2: Iterate Through the String

```cpp
for(int i = 0; i < s.size(); i++) {
    if(mp.count(s[i]))
        prv = max(prv, mp[s[i]]);
    mp[s[i]] = i;
    len = max(len, i - prv);
}
```

- **Iterating over each character**: We loop through each character of the string `s` using the variable `i`, which represents the current index.
  
  - **Checking for duplicates**:
    - `if(mp.count(s[i]))`: If the current character `s[i]` is already in the map (i.e., it has been seen before), we need to update the left boundary of the sliding window.
    - `prv = max(prv, mp[s[i]])`: The `prv` variable is updated to the most recent index of the character, ensuring the left boundary of the window is set correctly. The `max()` function ensures that we move the left boundary only forward, not backward.
  
  - **Updating the character's index**: After checking for duplicates, we update the map to reflect the current index of `s[i]` using `mp[s[i]] = i`.

  - **Calculating the substring length**:
    - `len = max(len, i - prv)`: The length of the current valid substring is calculated as the difference between the current index `i` and the updated left boundary `prv`. We continuously update the `len` variable to track the longest substring found so far.

#### Step 3: Return the Maximum Length

```cpp
return len;
```

- After iterating through the entire string, the variable `len` holds the length of the longest substring that does not contain repeating characters. We return this value as the result.

### Complexity

#### Time Complexity: **O(n)**
- Where `n` is the length of the string `s`. We are only iterating through the string once (linear pass), and each operation inside the loop (hashmap lookup and update) takes constant time, O(1). Therefore, the overall time complexity is **O(n)**.

#### Space Complexity: **O(min(n, m))**
- Where `n` is the length of the string and `m` is the size of the character set (in this case, the number of possible characters). The space complexity is determined by the hashmap `mp`, which stores at most one entry for each unique character in the string. In the worst case, when all characters are unique, the space complexity is **O(n)**. In the case of a small character set (e.g., only lowercase English letters), the space complexity could be as small as **O(m)**, but itâ€™s generally **O(n)** in the worst case.

### Conclusion

This algorithm efficiently solves the problem of finding the longest substring without repeating characters using the sliding window technique and a hashmap. The sliding window ensures that we examine each substring only once, while the hashmap allows for fast lookups and updates, ensuring that the algorithm runs in **O(n)** time. This approach is both time-efficient and space-efficient, making it well-suited for large inputs. The code provides a clean and optimal solution to the problem, with the use of a hashmap making it easy to manage the sliding window and adjust boundaries when duplicates are encountered.

By understanding and implementing this approach, you can solve similar substring problems in competitive programming or real-world applications where efficient string processing is required.
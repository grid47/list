### Problem Statement

The problem asks us to determine how many ways we can place houses on a street of length `n` such that no two houses are adjacent. We are asked to return the result modulo `10^9 + 7`. The challenge is to compute the number of valid configurations efficiently, considering that `n` can be large.

A **house** can either be placed or not placed on each unit of the street, with the restriction that no two houses can be placed next to each other. 

For example, if `n = 3`, the valid configurations are:
- No house: `[]`
- One house at position 1: `[1, 0, 0]`
- One house at position 2: `[0, 1, 0]`
- One house at position 3: `[0, 0, 1]`
- Two houses: `[1, 0, 1]`

Thus, the task is to count the number of ways to place the houses on the street following these rules.

### Approach

To solve this problem, we can use **dynamic programming** (DP). The idea is to break the problem down into smaller subproblems where we calculate how many ways houses can be placed for smaller lengths of the street, and then use these results to build up the solution for the full street.

#### Key Observations:
1. We need to keep track of whether the last position in the street is occupied by a house or not. This will help us decide whether we can place a house at the next position or not.
2. If the last position is empty, we have two choices:
   - Place a house in the current position and move to the next position (which must be empty).
   - Leave the current position empty and move to the next position.
3. If the last position is filled with a house, we can only leave the next position empty.

#### Dynamic Programming Definition:
- Let `dp[n][0]` represent the number of ways to place houses on a street of length `n` where the last position is empty.
- Let `dp[n][1]` represent the number of ways to place houses on a street of length `n` where the last position is filled with a house.

### Code Breakdown (Step by Step)

#### Step 1: Initialize DP Table
```cpp
dp.resize(n + 1, vector<int>(2, -1));
```
- Here, we initialize a DP table `dp` with dimensions `(n+1) x 2`. Each entry represents the number of ways to place houses on a street of length `i` (`i` from 0 to `n`), either with the last position empty (represented by `0`) or filled (represented by `1`).
- Initially, all values are set to `-1`, meaning they are uncomputed.

#### Step 2: Base Case for Recursive Function
```cpp
if(n == 1) return 1;
```
- If the length of the street is 1, there is exactly 1 way to place houses (either place a house or don't place a house).

#### Step 3: Recursive Function Definition
```cpp
if(dp[n][filled] != -1) return dp[n][filled];
```
- If we've already computed the result for `dp[n][filled]`, we return the stored value to avoid redundant computation.

#### Step 4: Handle the Filled Case
```cpp
if(filled) return dp[n][filled] = rec(n - 1, !filled);
```
- If the last position is filled, then the previous position must be empty, so we recursively compute the number of valid configurations for `n-1` positions with the last position empty (`!filled`).

#### Step 5: Handle the Empty Case
```cpp
else return dp[n][filled] = ( rec(n - 1, filled) + rec(n - 1, !filled) ) % mod;
```
- If the last position is empty, then we have two choices:
  - We can either place a house at the current position and recursively solve for `n-1` with the last position filled.
  - Or we can leave the current position empty and recursively solve for `n-1` with the last position empty.
- We compute the sum of these two cases and take the result modulo `10^9 + 7` (denoted as `mod`).

#### Step 6: Final Computation in `countHousePlacements`
```cpp
ll res = ( rec(n, 0) + rec(n, 1) ) % mod;
return (res * res) % mod;
```
- The final result is the square of the sum of the two possibilities: one with the last position empty (`rec(n, 0)`) and one with the last position filled (`rec(n, 1)`).
- We return this result modulo `10^9 + 7`.

### Example Walkthrough

#### Example 1: `n = 3`
We can visualize the function calls for `n = 3`:
- `countHousePlacements(3)` calls `rec(3, 0)` and `rec(3, 1)`.
- `rec(3, 0)` computes the number of ways to place houses with the last position empty.
- `rec(3, 1)` computes the number of ways to place houses with the last position filled.
- The final result is the square of the sum of these values modulo `10^9 + 7`.

#### Example 2: `n = 4`
For `n = 4`, we follow a similar recursive breakdown:
- `countHousePlacements(4)` calls `rec(4, 0)` and `rec(4, 1)`.
- Each recursive call continues breaking down the problem until the base case is reached.

### Complexity Analysis

#### Time Complexity:
- **O(n)**: The DP table has `n+1` rows and 2 columns. We compute each entry at most once, and each entry computation involves only constant-time operations. Therefore, the time complexity is O(n).

#### Space Complexity:
- **O(n)**: We store the DP table, which has a size of `(n+1) x 2`. Thus, the space complexity is O(n).

### Conclusion

This solution uses dynamic programming to efficiently count the number of ways to place houses on a street of length `n` such that no two houses are adjacent. The key insight is to recursively calculate the number of valid configurations for smaller subproblems and store the results in a DP table to avoid redundant computations.

The time and space complexity of this solution is linear in terms of the size of the input, making it suitable for large values of `n`. The final result is returned modulo `10^9 + 7` to ensure that it fits within typical integer limits and avoids overflow.
### Problem Statement

In this problem, you are given a string `s` consisting of uppercase English letters. You need to calculate the total sum of the number of unique letters in all substrings of `s`. A **unique letter** in a substring is defined as a letter that appears exactly once within that substring. Your task is to efficiently compute the sum of unique letters across all possible substrings of the string.

### Approach

To solve this problem efficiently, we need to focus on calculating the contribution of each character in `s` to the total sum. Rather than brute-forcing through all possible substrings (which would be computationally expensive), we can use a **dynamic programming** approach with efficient tracking of the positions of characters in the string.

Here's the general strategy for solving this problem:

1. **Tracking Character Positions**: For each character in the string, we want to track the positions where that character appears. Specifically, we need to know the most recent position where the character appeared, as well as the second most recent appearance. This allows us to compute the contribution of the character to the substrings that it affects.

2. **Calculating Contributions**: For each character in the string, we calculate how many substrings it contributes to in which the character appears exactly once. By updating the contribution based on its most recent appearances, we can efficiently compute the result for the entire string.

3. **Final Sum Calculation**: After processing all characters, the total sum is computed by adding the contributions of all characters to the result.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Tracking Structure

We initialize a 2D array `idx` to keep track of the positions of each character (`A` to `Z`). This array has 26 rows (one for each character) and two columns: one for the second most recent position and one for the most recent position. Initially, both columns are set to `-1`, representing the fact that the characters have not yet appeared.

```cpp
vector<vector<int>> idx(26, vector<int>(2, -1));
```

#### Step 2: Iterate Through Each Character in the String

We iterate over the string and for each character `s[i]`, we calculate the contribution of that character to the unique substrings. The variable `c` represents the index of the character (with 'A' mapped to index 0, 'B' to 1, ..., 'Z' to 25).

For each character `s[i]`, the contribution to the substrings is calculated as follows:
- `(i - idx[c][1])` represents the number of substrings that start before the most recent occurrence of the character and end at position `i`.
- `(idx[c][1] - idx[c][0])` represents the number of substrings that start after the second most recent occurrence of the character and end just before the most recent occurrence.

We update the positions of the character `s[i]` accordingly:
- `idx[c][0]` becomes the previous position `idx[c][1]`, and
- `idx[c][1]` becomes the current position `i`.

```cpp
int c = s[i] - 'A';
res += (i - idx[c][1]) * (idx[c][1] - idx[c][0]);
idx[c][0] = idx[c][1];
idx[c][1] = i;
```

#### Step 3: Handle Remaining Contributions

After the loop finishes, we need to handle the remaining substrings that include each character at the end of the string. For each character `i`, we calculate its contribution to all substrings that start from its last occurrence and end at the end of the string. This is done by updating the result with the contribution from the remaining segments.

```cpp
for (int i = 0; i < 26; i++)
    res += (n - idx[i][1]) * (idx[i][1] - idx[i][0]);
```

#### Final Step: Return the Result

Finally, the computed result, `res`, which contains the sum of the unique letters for all substrings, is returned.

```cpp
return res;
```

### Complexity Analysis

#### Time Complexity

The time complexity of this approach is **O(n)**, where `n` is the length of the string `s`. This is because:
- We iterate through the string once, and for each character, we perform constant-time operations to update the positions and calculate the contributions.
- We also iterate over the 26 possible characters (from 'A' to 'Z') once at the end to handle the final contributions, which takes constant time.

Thus, the overall time complexity is **O(n)**, which is optimal for this problem.

#### Space Complexity

The space complexity is **O(1)**, as the space required to store the position indices (`idx`) is fixed at 26 rows and 2 columns (for each character in the alphabet), regardless of the size of the input string. This results in constant space usage for the tracking array.

The only other space used is for the result variable `res`, which takes constant space.

### Example Walkthrough

Let's walk through an example to understand how the algorithm works.

#### Input:
```cpp
string s = "ABC";
```

#### Step 1: Initialize

- `idx` is a 26x2 array initialized to `-1`.

#### Step 2: Iterate Over the String

1. For `s[0] = 'A'`:
   - `c = 0` (since 'A' is at index 0).
   - There is no previous occurrence of 'A', so no contribution from this character.
   - Update `idx[0]` to `[ -1, 0 ]` (the second most recent index is -1, and the most recent is 0).

2. For `s[1] = 'B'`:
   - `c = 1` (since 'B' is at index 1).
   - There is no previous occurrence of 'B', so no contribution from this character.
   - Update `idx[1]` to `[ -1, 1 ]`.

3. For `s[2] = 'C'`:
   - `c = 2` (since 'C' is at index 2).
   - There is no previous occurrence of 'C', so no contribution from this character.
   - Update `idx[2]` to `[ -1, 2 ]`.

#### Step 3: Handle Remaining Contributions

- After the loop, for each character in `idx`, we calculate its contribution to the substrings formed by the remaining characters.
- In this case, we compute contributions for 'A', 'B', and 'C' at the end.

#### Output:
```cpp
return res;
```

The final value of `res` will be the sum of the unique letters in all substrings of "ABC".

### Conclusion

This solution efficiently calculates the total number of unique letters in all substrings of the string using dynamic programming and careful tracking of character positions. The approach runs in linear time **O(n)**, making it optimal for large strings. By leveraging the power of indexing and maintaining a rolling count of substrings, this solution avoids the computational complexity of brute-force methods, providing an elegant and efficient solution to the problem.
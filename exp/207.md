### Problem Statement

The problem asks whether it is possible to finish all courses in a university system given the prerequisites for each course. The courses and prerequisites form a directed graph where:
- Each course is a node.
- A directed edge from course A to course B means that course A is a prerequisite for course B.

Given `n` courses and a list of prerequisite pairs, we need to determine if it’s possible to finish all courses. If there's a cycle in the graph (i.e., one course depends on another, which in turn depends on the first course), it's impossible to complete all the courses. 

The function `canFinish` must return `true` if it's possible to finish all the courses, and `false` if there is a cycle or if some courses cannot be completed due to unmet prerequisites.

#### Example:
- **Input:** `n = 2`, `pre = [[1, 0]]`
- **Output:** `true`

In this example, course 0 must be taken before course 1, and there’s no cycle, so it is possible to finish all courses.

### Approach

The approach to solve this problem is based on **topological sorting** of a directed graph. The main idea is to:
1. **Construct the graph:** Treat the courses as nodes and the prerequisites as directed edges.
2. **Use Kahn's Algorithm:** This algorithm works by iteratively removing nodes (courses) that have no incoming edges (prerequisites) from the graph. If you can process all nodes, there is no cycle, and it’s possible to finish all courses. If some nodes remain with prerequisites, it means a cycle exists, making it impossible to complete all courses.

Here’s how the algorithm works:
1. **Count the dependencies (in-degree) for each course:** For each course, count how many other courses it depends on (in-degree).
2. **Topological Sort:** Use a queue to keep track of courses with no prerequisites (in-degree of 0). Process these courses by reducing the in-degree of their dependent courses. If the in-degree of a dependent course reaches 0, it is added to the queue. This continues until all courses are processed or there are still unprocessed courses with non-zero in-degrees, indicating a cycle.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Data Structures
```cpp
vector<vector<int>> graph(n);
vector<int> cnt(n, 0);
```
- **`graph[n]`**: A vector of vectors to represent the directed graph where `graph[i]` holds the list of courses that depend on course `i`.
- **`cnt[n]`**: A vector to store the number of prerequisites (in-degree) for each course.

#### Step 2: Build the Graph and Count Dependencies
```cpp
for(int i = 0; i < pre.size(); i++) {
    graph[pre[i][1]].push_back(pre[i][0]);
    cnt[pre[i][0]]++;
}
```
- **Graph Construction:** For each prerequisite pair `[a, b]`, course `b` must be taken before course `a`. Therefore, an edge is added from `b` to `a`.
- **Dependency Count:** For each course `a`, increase the dependency count (`cnt[a]`) since it has a prerequisite (course `b`).

#### Step 3: Queue Initialization (Courses with No Prerequisites)
```cpp
queue<int> q;
for(int i = 0; i < n; i++)
    if(cnt[i] == 0)
        q.push(i);
```
- **Queue Initialization:** We initialize the queue with all courses that have no prerequisites (`cnt[i] == 0`), meaning these courses can be taken first.

#### Step 4: Process Courses and Reduce Dependencies
```cpp
while(!q.empty()) {
    int size = q.size();
    while(size-- > 0) {
        int course = q.front();
        q.pop();
        for(int dep: graph[course]) {
            cnt[dep]--;
            if(cnt[dep] == 0) {
                q.push(dep);
            }
        }                
    }
}
```
- **Process Courses:** While there are courses in the queue, we:
  1. Pop a course from the queue.
  2. For each course that depends on the current course (i.e., each dependent course in `graph[course]`), we decrease its dependency count.
  3. If the dependency count for a course reaches 0, it means all its prerequisites have been processed, so we can add it to the queue to process next.

#### Step 5: Check for Cycles (Unprocessed Courses)
```cpp
for(int i = 0; i < n; i++)
    if(cnt[i] != 0)
        return false;
```
- **Cycle Detection:** After processing all courses, if any course still has a non-zero dependency count, it indicates a cycle (because the course couldn’t be processed due to unmet prerequisites). In this case, we return `false`.

#### Step 6: Return True (All Courses Can Be Finished)
```cpp
return true;
```
- If all courses were processed without finding a cycle, return `true`, indicating that it is possible to finish all courses.

### Complexity Analysis

#### Time Complexity:
- **O(V + E):** 
  - **V (vertices):** We process each course once, and the graph contains `n` courses.
  - **E (edges):** For each prerequisite pair, we add an edge, resulting in `E` edges. We process each edge once when adjusting the in-degrees and when iterating over the course’s dependencies.
  - Therefore, the time complexity is linear in the total number of courses and prerequisites, i.e., O(V + E).

#### Space Complexity:
- **O(V + E):**
  - **Graph:** We store the graph, which has `V` vertices and `E` edges.
  - **Dependency Count:** We use an array of size `V` to store the in-degrees.
  - **Queue:** The queue will store at most `V` courses at any given time, in the worst case.

Thus, the space complexity is O(V + E), which is required to store the graph and the auxiliary structures.

### Conclusion

The `canFinish` function efficiently solves the problem of determining whether all courses can be completed, utilizing a **topological sort** algorithm. By maintaining a queue of courses that have no prerequisites, processing them while reducing the in-degree of their dependent courses, we ensure that we process each course only once. The function uses **Kahn's Algorithm** for topological sorting, which is an optimal solution with **O(V + E)** time complexity and **O(V + E)** space complexity.

This approach is highly scalable and can handle large inputs efficiently. The use of Kahn’s algorithm is ideal for solving problems related to dependency resolution, like determining course prerequisites or task scheduling in directed acyclic graphs (DAGs).
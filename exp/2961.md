### Problem Statement:
Given a matrix `v` where each row contains four integers `[a, b, c, m]`, the goal is to compute a value for each row using a modular exponentiation technique and check if the result equals a given `target`. If the result matches the target, the index of that row should be added to the result list. The computation involves two stages of exponentiation. The challenge lies in efficiently calculating large powers modulo `m` and ensuring that the results are correct without causing overflow or performance issues.

### Approach:
The problem involves calculating large powers using the modular exponentiation technique, which is a method to compute powers efficiently without directly multiplying the base multiple times. The key to solving this problem is the application of **modular exponentiation** to avoid overflow and compute the values in an efficient manner.

**Modular exponentiation** is essential for this task because the numbers involved in exponentiation can grow very large, but we only need the result modulo `m`.

### Code Breakdown (Step by Step):
Let's break down the code and its parts for a deeper understanding:

#### 1. **Modular Exponentiation Function (`power`)**:
```cpp
int power(long long b, long long p, int m) {
    if (p <= 0) return 1;
    long long t = power(b, p / 2, m);
    t = ((t * t) % m);
    return (p % 2) ? (t * b) % m : t;
}
```
- This function calculates `b^p % m` using **recursive modular exponentiation**.
- **Base Case**: If `p <= 0`, return `1`. This handles the case when the exponent is zero or negative (in some contexts, negative exponents are defined as reciprocal).
- **Recursive Step**: We first recursively calculate `b^(p/2) % m` to reduce the problem size (using the divide-and-conquer approach). We then square the result to get `b^p % m`, and finally, we handle the case when `p` is odd by multiplying the result by `b` again.
- **Efficiency**: This method reduces the time complexity to **O(log(p))** instead of **O(p)**, which is a significant improvement when dealing with large exponents.

#### 2. **Main Logic (Loop through `v`)**:
```cpp
vector<int> getGoodIndices(vector<vector<int>>& v, int target) {
    vector<int> ans;
    for(int i = 0; i < v.size(); ++i) {
        long long a = v[i][0] % 10, b = v[i][1], c = v[i][2], m = v[i][3], t = 1;
        t = power(a, b, 10);
        t = power(t, c, m);
        if(t == target) ans.push_back(i);
    }
    return ans;
}
```
- **Iteration over Rows**: We iterate over each row of the input matrix `v`, where each row contains four elements `[a, b, c, m]`. These elements represent the base `a`, exponent `b`, the second exponent `c`, and modulus `m`, respectively.
  
  - `a % 10` ensures that we only consider the last digit of `a`, as the final result is only dependent on the last digit of the base `a` for the initial modular exponentiation.
  
  - **First Power Calculation**: We calculate `a^b % 10` using the `power` function to find the result of raising `a` to the power `b` and taking the result modulo `10`. This step is equivalent to reducing the base `a` to a smaller value modulo `10` before moving on to the next stage.

  - **Second Power Calculation**: The result of the first exponentiation, stored in `t`, is then raised to the power `c` modulo `m`. This is the second stage of exponentiation, which involves applying modular exponentiation to the result of the previous step.

- **Condition Check**: After calculating `t`, the value is compared to the target. If they are equal, we add the current index `i` to the `ans` vector. This means that the index `i` corresponds to a row that produces the required result.
  
- **Return Result**: Once all rows are processed, the function returns the list of indices `ans` that satisfy the condition.

### Complexity Analysis:

#### Time Complexity:
- **Modular Exponentiation**: The `power` function performs logarithmic work in terms of the exponent `p` (i.e., **O(log p)**), which ensures that the large exponents in the matrix `v` are handled efficiently.
- **Iterating Over Rows**: We iterate over each row in the matrix `v`, and for each row, we perform two modular exponentiations. Therefore, the total time complexity is the number of rows `n` times the complexity of calculating the powers, which is **O(n * log p)**, where `p` is the maximum exponent encountered in the input.
- **Final Complexity**: Assuming that the largest exponents `b` and `c` are bounded by some constant, the complexity can be simplified to **O(n)**, where `n` is the number of rows in `v`.

#### Space Complexity:
- The space complexity of this solution is **O(n)** due to the storage required for the result vector `ans`, which stores the indices of the rows that produce the desired result.
- The auxiliary space for the recursive calls in the `power` function is **O(log p)** due to the recursive depth required for modular exponentiation.

### Conclusion:
This solution efficiently computes the required modular exponentiation and checks if the computed result matches the target. By using recursive modular exponentiation, the solution avoids overflow and provides a highly efficient method for handling large numbers. The time complexity is linear with respect to the number of rows, with logarithmic time complexity for each exponentiation, making the solution scalable for large inputs.

By following this approach, we achieve an optimized solution for computing powers modulo `m` and checking the results against a target, while keeping both time and space complexities in check.
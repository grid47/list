### Problem Statement

The problem at hand is to find the **single number** in an array where every element appears exactly **three times**, except for one element which appears only once. The goal is to identify this unique number using an efficient algorithm with a minimal space complexity.

### Approach

To solve this problem, we use bitwise manipulation with two variables, `ones` and `twos`, which help keep track of the bits that appear in the numbers. By leveraging the properties of bitwise operations, we can isolate the number that appears only once, even when every other number appears three times.

The key insight here is to track the numbers that appear **once** and **twice** during the traversal of the array. The algorithm works by updating these two variables as follows:
- `ones` will store the bits that have appeared once.
- `twos` will store the bits that have appeared twice.

The algorithm ensures that any bit that appears exactly **three times** is reset, allowing us to isolate the single number that appears only once.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the `ones` and `twos` variables

```cpp
int ones = 0, twos = 0;
```
Here, `ones` and `twos` are initialized to zero. These variables will hold the bitwise representation of the numbers that appear once and twice, respectively. As we iterate over the array, these variables will be updated based on the bitwise operations.

#### Step 2: Iterate over the array and update `ones` and `twos`

```cpp
for(int i = 0; i < n; i++) {
    ones = (ones ^ nums[i]) & ~twos;
    twos = (twos ^ nums[i]) & ~ones; 
}
```
In this loop, we iterate through each element `nums[i]` in the array. The bitwise operations inside the loop ensure that we correctly track the bits that appear once and twice.

1. **Update `ones`**:
   ```cpp
   ones = (ones ^ nums[i]) & ~twos;
   ```
   - `ones ^ nums[i]` toggles the bits of `ones` with the bits of `nums[i]`. If the bit of `nums[i]` is already present in `ones`, it will be flipped, indicating that the bit has appeared an odd number of times.
   - The `& ~twos` part ensures that the bits that have appeared twice are excluded from `ones`. This prevents a bit from appearing in `ones` when it has appeared exactly twice.

2. **Update `twos`**:
   ```cpp
   twos = (twos ^ nums[i]) & ~ones;
   ```
   - `twos ^ nums[i]` toggles the bits of `twos` with `nums[i]`. This keeps track of the bits that have appeared twice.
   - The `& ~ones` part ensures that the bits that have already appeared once are excluded from `twos`. This ensures that a bit appears in `twos` only if it has appeared twice, and not more.

#### Step 3: Return the result

```cpp
return ones;
```
After processing all the numbers in the array, the variable `ones` will hold the number that appears only once. This is because, during the entire iteration:
- Any bits that appeared exactly three times will be reset (both `ones` and `twos` will cancel them out).
- The number that appeared only once will remain in `ones`.

### Complexity

#### Time Complexity:
- **O(n)**: The algorithm iterates over the array exactly once, where `n` is the number of elements in the `nums` array. Each iteration involves constant-time operations (bitwise operations), so the total time complexity is O(n).

#### Space Complexity:
- **O(1)**: The algorithm uses only two integer variables (`ones` and `twos`) to track the bitwise state. These variables use constant space, making the space complexity O(1). No additional data structures are required, which ensures the algorithm is space-efficient.

### Conclusion

This solution is optimal for finding the unique number in an array where every other number appears three times. By using bitwise operations to track the numbers that have appeared once and twice, the algorithm ensures that we can isolate the unique number in **O(n)** time with **O(1)** space complexity. This makes the solution highly efficient and suitable for large datasets.

To summarize:
- **Time Complexity**: The solution runs in linear time, O(n), where `n` is the number of elements in the input array.
- **Space Complexity**: The algorithm uses constant space, O(1), which is optimal for this problem.
- **Bitwise Operations**: By cleverly using bitwise XOR and AND operations, we can efficiently track bits that appear once and twice, allowing us to isolate the unique number.

This approach is a powerful example of how bitwise operations can be used to solve problems that require tracking occurrences of elements or manipulating individual bits. It is an excellent technique to know, especially for interview preparation, as it demonstrates both problem-solving skills and understanding of low-level bit manipulation.
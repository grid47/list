### Problem Statement

The problem asks to find the shortest superstring that contains all the given strings from a list of words. A superstring is a string that contains all the words from the list as substrings, and we want to minimize the length of this superstring. The challenge involves concatenating words optimally so that the result is as short as possible. Overlapping substrings should be taken into account, meaning that we should overlap parts of the words where possible when constructing the superstring.

### Approach

To solve this problem, we can approach it as a variation of the **Traveling Salesman Problem (TSP)**, where each word represents a node and we try to find the shortest path that visits every word exactly once. However, instead of distances, we are interested in maximizing overlaps between the words to minimize the length of the final superstring.

Here is the breakdown of the steps involved:

1. **Calculate the Overlaps**: For every pair of words, we need to calculate how much of the second word overlaps with the first word. The more overlap there is, the fewer characters need to be added to the final superstring.

2. **Dynamic Programming with Bitmasking**: We use dynamic programming (DP) with bitmasking to explore all possible ways to combine the words. The idea is to represent subsets of words using a bitmask, where each bit in the mask represents whether a word is included in the current subset. For each subset, we calculate the minimum length of the superstring that contains all the words in the subset.

3. **Reconstruction of the Superstring**: After calculating the minimal superstring lengths for all subsets of words, we reconstruct the shortest superstring by backtracking through the DP table.

### Code Breakdown (Step by Step)

#### 1. **Calculating Overlaps** (`calc` function)

The first step in solving the problem is calculating the overlap between two words. We want to find the maximum suffix of the first word that is a prefix of the second word. The function `calc` does this by iterating through all possible suffixes of the first word and checking if it matches a prefix of the second word.

```cpp
int calc(string &a, string &b) {
    for (int i = 0; i < a.size(); i++) {
        if (b.rfind(a.substr(i), 0) == 0) {
            return b.size() - a.size() + i;
        }
    }
    return b.size();
}
```
- **Explanation**: 
    - We iterate through all suffixes of `a`, checking if any of them match the beginning (prefix) of `b`.
    - `rfind` is used to check if the substring of `a` starting from position `i` matches the prefix of `b` starting at position `0`.
    - The function returns the number of characters in `b` that are left unoverlapped by the suffix of `a`.

#### 2. **Building the DP and Path Arrays**

Next, we construct a DP table where `dp[i][j]` represents the minimum length of the superstring formed by using the words corresponding to the bitmask `i` and ending with the `j`-th word. We also maintain a `path` table to keep track of which word led to the optimal superstring length.

```cpp
vector<vector<int>> dp(1 << n, vector<int>(n, INT_MAX)), path(1 << n, vector<int>(n, 0));
```
- `dp[i][j]` stores the minimum length of the superstring for the subset of words `i` ending at word `j`.
- `path[i][j]` stores the previous word in the optimal path for the subset `i` ending at word `j`.

#### 3. **Filling the DP Table**

We now use dynamic programming to fill in the DP table. For each subset `i` and for each word `j`, we check all possible previous words `k` and update the DP table by considering the overlap between the last word `k` and the current word `j`.

```cpp
for (int i = 1; i < (1 << n); i++) {
    for (int j = 0; j < n; j++) {
        if ((i & (1 << j)) > 0) {
            int prv = i - (1 << j);
            if (prv == 0) {
                dp[i][j] = words[j].size();
            } else {
                for (int k = 0; k < n; k++) {
                    if (dp[prv][k] < INT_MAX && (dp[prv][k] + grid[k][j]) < dp[i][j]) {
                        dp[i][j] = dp[prv][k] + grid[k][j];
                        path[i][j] = k;
                    }
                }
            }
        }
        if ((i == ((1 << n) - 1)) && dp[i][j] < mn) {
            mn = dp[i][j];
            last = j;
        }
    }
}
```
- We iterate over all subsets `i` and for each subset, consider all possible words `j` that could be the last word in the superstring.
- For each `j`, we check if it is the first word of the subset (`prv == 0`) or if it is part of a larger subset. If it is part of a larger subset, we calculate the minimum length by checking overlaps with other words `k`.

#### 4. **Reconstructing the Superstring**

After filling in the DP table, we reconstruct the shortest superstring by backtracking from the last word in the optimal path.

```cpp
int cur = (1 << n) - 1;
stack<int> stk;
while (cur > 0) {
    stk.push(last);
    int tmp = cur;
    cur -= (1 << last);
    last = path[tmp][last];
}

int i = stk.top();
stk.pop();
string res = words[i];
while (!stk.empty()) {
    int j = stk.top();
    stk.pop();
    res += words[j].substr(words[j].size() - grid[i][j]);
    i = j;
}
return res;
```
- **Explanation**: 
    - We backtrack from the final state `(1 << n) - 1` using the `path` array.
    - At each step, we push the word index onto a stack and reduce the current subset `cur`.
    - After backtracking, we use the stack to reconstruct the superstring by concatenating words and ensuring that we only add the non-overlapping part of each word.

### Complexity

1. **Time Complexity**: 
    - Calculating overlaps takes O(n^2 * m) time, where `n` is the number of words and `m` is the average length of a word.
    - The dynamic programming table has O(2^n * n) entries, and for each entry, we might check O(n) other words to update the table. Thus, the time complexity is approximately O(n^2 * 2^n * m).

2. **Space Complexity**: 
    - The space complexity is O(2^n * n) for storing the DP table and the path table, and O(n^2) for storing the overlap grid. Therefore, the space complexity is O(n^2 * 2^n).

### Conclusion

This approach efficiently constructs the shortest superstring by considering all possible ways to overlap the words, using dynamic programming with bitmasking to explore all subsets of words. By calculating the overlaps and reconstructing the superstring from the optimal path, this solution ensures that the final superstring is as short as possible. The complexity of the solution is manageable for moderate values of `n`, making it suitable for real-world applications where the number of words is not excessively large.
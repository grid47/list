### Problem Statement
Given an array of strings `words`, the task is to find the shortest string that contains each string in `words` as a substring. 

### Approach
1. **Calculate Overlap**:
   - Define a helper function `calc` that calculates the maximum overlap of string `a` with string `b`. It returns the length of the suffix of `b` that matches the prefix of `a`.

2. **Construct Overlap Graph**:
   - Create a 2D grid `grid` where `grid[i][j]` holds the overlap length when string `i` is followed by string `j`. This allows us to understand how much we can concatenate two strings while avoiding repetitions.

3. **Dynamic Programming Setup**:
   - Use a DP table `dp` where `dp[mask][j]` represents the minimum length of the superstring that includes the strings represented by `mask`, ending with the string `j`.
   - Use a `path` table to keep track of the previous string in the optimal path.

4. **Bitmasking**:
   - Iterate over all possible subsets of strings (using bitmasking). For each subset, calculate the minimum length superstring that can be formed by adding each string `j` to the previously calculated superstrings represented by `prv`.

5. **Reconstruct the Shortest Superstring**:
   - After filling the DP table, trace back through the `path` table to reconstruct the order of strings that results in the shortest superstring.

6. **Build the Result**:
   - Start from the last string used and append the appropriate portions of the other strings to form the final result.

### Code Walk-through
- The function initializes necessary variables and computes overlaps.
- It iterates through all subsets of `words` using bitmasking to fill the DP table.
- Finally, it reconstructs the shortest superstring based on the paths taken to reach the minimum length.

### Complexity
- **Time Complexity**: O(n^2 * 2^n), where n is the number of strings. The overlap calculation takes O(n^2) and there are 2^n subsets.
- **Space Complexity**: O(n * 2^n) for the DP and path tables.


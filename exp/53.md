### Problem Statement

The problem is to find the maximum sum of a contiguous subarray in an array of integers. This is a classic problem in dynamic programming, often referred to as the **Maximum Subarray Problem** or **Kadane’s Algorithm**. The task is to identify a subarray (which can have any length) within the given array that produces the largest possible sum. The challenge is to achieve this in linear time, O(n), which is crucial when dealing with large input arrays.

### Approach

The problem is solved efficiently using Kadane’s Algorithm, which operates in linear time (O(n)). This algorithm works by iterating through the array while maintaining two variables:
- **`l` (local maximum):** This keeps track of the current sum of the subarray being considered. If the current element can increase the sum of the previous subarray, `l` is updated; otherwise, it is reset to the current element.
- **`g` (global maximum):** This stores the maximum sum encountered so far. Every time a new local maximum (`l`) exceeds the global maximum (`g`), `g` is updated.

The algorithm iterates through the array and decides whether to include the current element in the ongoing subarray sum or start a new subarray from the current element. The result is the largest possible sum of a contiguous subarray, and it runs in O(n) time complexity, making it an optimal solution for this problem.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables

```cpp
int l = nums[0], g = nums[0];
```
- The variable `l` is initialized to `nums[0]`, the first element of the array. This represents the local maximum sum at the start (we assume the first element is part of the subarray).
- The variable `g` is initialized to `nums[0]` as well. This stores the maximum subarray sum found so far. Initially, it starts as the first element because we haven't processed any other elements yet.

#### Step 2: Iterate Through the Array

```cpp
for(int i = 1; i < nums.size(); i++) {
```
- The loop starts from `i = 1` because the first element is already accounted for in the initialization.
- The iteration goes through each element in the array and decides whether to continue the current subarray or start a new one.

#### Step 3: Update Local Maximum (`l`)

```cpp
if(nums[i] > l + nums[i])
    l = nums[i];
else
    l += nums[i];
```
- The decision here checks if adding the current element `nums[i]` to the existing subarray sum (`l + nums[i]`) is better than starting a new subarray with just `nums[i]`.
- If the current element `nums[i]` is greater than `l + nums[i]`, it means that the current subarray should be abandoned, and a new subarray starting at `nums[i]` should be considered. So, `l` is reset to `nums[i]`.
- Otherwise, it means the current subarray can be extended by including `nums[i]`, so `l` is updated by adding `nums[i]` to the existing sum.

#### Step 4: Update Global Maximum (`g`)

```cpp
g = max(g, l);
```
- After updating the local maximum `l`, the algorithm compares it to the global maximum `g`.
- If `l` is larger than `g`, `g` is updated to the new value of `l`. This ensures that `g` always holds the largest subarray sum encountered so far.

#### Step 5: Return the Result

```cpp
return g;
```
- After the loop completes, `g` contains the largest sum of any contiguous subarray, which is then returned as the final result.

### Complexity

#### Time Complexity:
- **O(n):** The algorithm iterates through the array exactly once, where `n` is the number of elements in the input array. At each iteration, only constant-time operations are performed (comparisons and additions), so the overall time complexity is O(n).

#### Space Complexity:
- **O(1):** The algorithm only uses a constant amount of extra space (for the variables `l` and `g`), regardless of the size of the input array. Hence, the space complexity is O(1).

### Conclusion

This solution to the Maximum Subarray Problem uses Kadane’s Algorithm, which is both time and space efficient. By maintaining two variables—`l` for the current subarray sum and `g` for the maximum sum found so far—the algorithm efficiently computes the result in a single pass through the array. 

With a time complexity of **O(n)** and a space complexity of **O(1)**, this algorithm is optimal for solving this problem on large datasets. It avoids the brute-force method of checking all subarrays, which would have a time complexity of **O(n^2)**, by leveraging dynamic programming principles to store and update the best subarray sum at each step.

Kadane’s Algorithm is a well-known approach for solving problems involving maximum subarrays, and this implementation provides a clean, efficient, and easy-to-understand solution. This approach is widely used in competitive programming and real-world applications where performance is crucial.
### Problem Statement

In this problem, we are tasked with simulating car fleets traveling towards a target. Each car is at a certain position on a 1D line and is traveling at a constant speed. We need to determine how many fleets will reach the target, where a fleet is a group of cars that arrive at the target simultaneously.

A fleet is formed when multiple cars are close enough to each other such that the lead car’s speed determines the speed of the whole group. If a faster car catches up to a slower car, they form a fleet, and both will reach the target at the same time.

#### Input:
- An integer `target` represents the target point on the 1D axis.
- A vector `pos` of integers, where each value represents the position of a car.
- A vector `v` of integers, where each value represents the speed of the corresponding car in the `pos` vector.

#### Output:
- The number of car fleets that will reach the target.

**Example:**
```cpp
Input: target = 12, pos = [10, 8, 0, 5, 3], v = [2, 4, 1, 1, 3]
Output: 3
```

### Approach

To solve this problem efficiently, we can use a greedy approach combined with sorting. The key insight is that the slower cars will eventually "catch up" to the faster ones if they start behind and are not too far apart.

1. **Understanding the Fleet Formation**:
    - Cars that start behind and travel faster can eventually catch up to cars in front, forming a fleet.
    - A fleet is formed when a slower car catches up with a faster car. Once a fleet forms, all cars in that fleet move as one, and they will reach the target at the same time.

2. **Plan**:
    - We will first calculate the time it takes for each car to reach the target.
    - The time to reach the target for each car is calculated as:
      \[
      \text{time} = \frac{\text{target} - \text{position}}{\text{velocity}}
      \]
    - Sort the cars by their position in descending order (from the furthest car to the nearest car).
    - Then, we will simulate the formation of fleets by iterating over the cars. For each car, if it takes longer to reach the target than the car ahead of it, it will form a new fleet. Otherwise, it will join the fleet of the car ahead.

3. **Efficiency**:
    - Sorting the cars by their position ensures that we process them from the car that is farthest away from the target to the one closest.
    - We track the lead car’s time for each fleet, and if a car behind has a longer or equal time, it joins the fleet.

### Code Breakdown (Step by Step)

#### Step 1: Store Time to Reach Target

```cpp
map<int, double> t;
for(int i = 0; i < pos.size(); i++) {
    t[-pos[i]] = (double) (target - pos[i]) / v[i];
}
```

- We create a `map` `t` to store the time it takes for each car to reach the target. The key of the map is the negative of the car's position (`-pos[i]`) to ensure cars are processed in descending order of their position (furthest first).
- The value in the map is the time it will take for the car at position `pos[i]` to reach the target, which is calculated using the formula:
  \[
  \text{time} = \frac{\text{target} - \text{position}}{\text{velocity}}
  \]
  
#### Step 2: Process Cars to Form Fleets

```cpp
int fleet = 0;
double cur = 0;

for (auto it: t) {
    if (it.second > cur) fleet++, cur = it.second;
}
```

- We initialize `fleet` to 0 to count the number of fleets, and `cur` to 0 to keep track of the current lead car’s time.
- We iterate over the `map` to process each car starting from the furthest car:
  - If the current car’s time (`it.second`) is greater than the time of the car ahead (`cur`), it means this car cannot catch up to the car ahead, so it forms a new fleet. We increment the fleet count and update `cur` to the current car's time.
  - If the current car’s time is less than or equal to `cur`, it means this car will catch up with the car ahead, so it does not form a new fleet, and it joins the existing fleet.

#### Step 3: Return Result

```cpp
return fleet;
```

- Finally, we return the total number of fleets.

### Complexity

#### Time Complexity:
- Sorting the cars by position takes **O(n log n)**, where `n` is the number of cars (i.e., the size of the `pos` vector).
- Iterating over the cars and processing them takes **O(n)** time.
- Therefore, the overall time complexity is **O(n log n)** due to the sorting step.

#### Space Complexity:
- The space complexity is **O(n)** due to the storage of the `map` which holds the time for each car.

### Conclusion

This solution efficiently solves the problem by leveraging the properties of sorting and greedy algorithms. By calculating the time to reach the target for each car and processing them from the furthest car to the nearest, we can easily determine the number of fleets that will reach the target. The use of sorting and a greedy approach ensures that we achieve the solution in **O(n log n)** time, making it suitable for large inputs.

Key points:
- **Sorting** helps us process the cars from the farthest to the nearest.
- **Greedy approach** ensures that we minimize the number of fleets by merging cars that can catch up with each other.
- The solution is efficient both in terms of time and space, making it a robust solution for the problem.

This method is a great example of applying a greedy approach to a real-world problem involving cars moving toward a target, and it showcases how sorting and optimal traversal can solve such problems efficiently.
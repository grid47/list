### üö∂‚Äç‚ôÇÔ∏è **Unique Paths in a Grid**

The problem is to calculate the total number of unique paths in an `m x n` grid, where you can only move down or right at each step, starting from the top-left corner `(0, 0)` and ending at the bottom-right corner `(m-1, n-1)`.

### üß† **Approach**

This problem is efficiently solved using **dynamic programming (DP)**. We will create a 2D table `dp` where each cell `dp[i][j]` represents the number of unique ways to reach cell `(i, j)` from the starting position `(0, 0)`.

#### Key Observations:

1. **Base Cases**:
   - For the first row (`i = 0`), you can only move right, so every cell in the first row has exactly one way to be reached (from the left).
   - Similarly, for the first column (`j = 0`), you can only move down, so every cell in the first column has exactly one way to be reached (from above).

2. **DP Transition**:
   - For any other cell `(i, j)`, the number of ways to reach that cell is the sum of the ways to reach the cell directly above it `(i-1, j)` and the cell to its left `(i, j-1)`. This leads to the recurrence relation:
     \[
     dp[i][j] = dp[i-1][j] + dp[i][j-1]
     \]

### üîç **Code Breakdown**

#### Step 1: Initialize DP Table

```cpp
vector<vector<int>> dp(m, vector<int> (n, 0));
```

- We initialize a `dp` table of size `m x n`, where all cells are initially set to `0`. This table will store the number of unique paths to each cell.

#### Step 2: Set the Starting Point

```cpp
dp[0][0] = 1;
```

- The starting position `(0, 0)` is set to `1`, as there is only one way to be at the starting position (by starting there).

#### Step 3: Initialize the First Row and First Column

```cpp
for(int i = 0; i < n; i++)
    dp[0][i] = 1;
for(int i = 0; i < m; i++)
    dp[i][0] = 1;
```

- We set all cells in the first row to `1` because each cell can only be reached from the cell to its left.
- Similarly, all cells in the first column are set to `1` because each can only be reached from the cell directly above.

#### Step 4: Fill the DP Table

```cpp
for(int i = 1; i < m; i++)
    for(int j = 1; j < n; j++)
        dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
```

- For cells that are not in the first row or column, the number of unique paths is the sum of the paths from the top (`dp[i - 1][j]`) and from the left (`dp[i][j - 1]`).

#### Step 5: Return the Final Answer

```cpp
return dp[m - 1][n - 1];
```

- The final answer is stored in `dp[m-1][n-1]`, which contains the total number of unique paths from the top-left to the bottom-right corner.

### üìä **Complexity Analysis**

#### Time Complexity:
- **O(m * n):** We iterate through each cell of the `m x n` grid once. Therefore, the time complexity is proportional to the number of cells in the grid, which is `O(m * n)`.

#### Space Complexity:
- **O(m * n):** The `dp` table requires `O(m * n)` space to store the number of unique paths for each cell. The space complexity is dominated by the size of the `dp` table.

### üåü **Conclusion**

This dynamic programming approach efficiently calculates the number of unique paths in an `m x n` grid. By breaking down the problem into overlapping subproblems and building up the solution using a DP table, we ensure an optimal solution with both time and space complexities of `O(m * n)`. This approach is ideal for solving pathfinding problems in grids of any size.

---
### Problem Statement

The problem is to find the total number of unique paths in an `m x n` grid that lead from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)`. In this grid, movement is restricted to either moving down or to the right at each step.

### Approach

This solution utilizes dynamic programming (DP) to calculate the number of unique paths. We create a 2D table, `dp`, where each cell `dp[i][j]` represents the number of ways to reach cell `(i, j)` from the starting position `(0, 0)`. 

#### Key Observations:
1. **Base Cases**:
   - If you are on the first row (i.e., `i = 0`), you can only move from the left cell. Therefore, every cell in the first row has exactly one way to reach it (moving only from the left).
   - Similarly, if you are in the first column (i.e., `j = 0`), you can only reach each cell by moving down from the cell above, so each cell in the first column has exactly one way to be reached.

2. **DP Transition**:
   - For each cell `(i, j)`, if it is not in the first row or first column, the number of ways to reach it is the sum of the paths to the cell directly above it `(i-1, j)` and the cell to its left `(i, j-1)`.
   - This leads to the recurrence relation: `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.

### Code Breakdown (Step by Step)

1. **Initialize DP Table**:
   ```cpp
   vector<vector<int>> dp(m, vector<int> (n, 0));
   ```
   - We create a 2D vector `dp` of size `m x n`, initialized to `0`. This table will store the number of unique paths to each cell.

2. **Set the Starting Point**:
   ```cpp
   dp[0][0] = 1;
   ```
   - The starting cell `(0, 0)` is set to `1` since there is only one way to be at the starting position.

3. **Initialize the First Row and First Column**:
   ```cpp
   for(int i = 0; i < n; i++)
       dp[0][i] = 1;
   for(int i = 0; i < m; i++)
       dp[i][0] = 1;
   ```
   - We populate the first row with `1`s because each cell in the first row can only be reached from the cell to its left.
   - Similarly, each cell in the first column is set to `1` because these cells can only be reached by moving down from the cell directly above.

4. **Fill the DP Table**:
   ```cpp
   for(int i = 1; i < m; i++)
       for(int j = 1; j < n; j++)
           dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
   ```
   - For cells that are not in the first row or first column, the number of paths to reach each cell is calculated as the sum of paths from the top and left cells.
   - This builds up the DP table by combining previously computed results to obtain the paths for each cell.

5. **Return the Final Answer**:
   ```cpp
   return dp[m - 1][n - 1];
   ```
   - The cell `dp[m-1][n-1]` contains the total number of unique paths from the top-left to the bottom-right corner.

### Complexity

#### Time Complexity
- **O(m * n)**: The code iterates through each cell in the `m x n` grid once, resulting in a time complexity of `O(m * n)`.

#### Space Complexity
- **O(m * n)**: The `dp` table requires `O(m * n)` space to store the number of unique paths for each cell.

### Conclusion

This dynamic programming solution is efficient and calculates the number of unique paths in an `m x n` grid with optimal time and space complexity. By systematically building up the DP table, the solution effectively combines overlapping subproblems, making it a perfect application of the DP paradigm. The approach ensures each cellâ€™s value is computed once, allowing for efficient path counting in grids of any size.

### üç¨ **Problem: Candies Distribution**

You are given a list `rate[]` where each element represents the rating of a child. Your task is to distribute candies such that:

1. Every child gets at least **one candy**.
2. A child with a **higher rating** than their neighbors should get **more candies** than their neighbors.

The goal is to find the **minimum number of candies** required to satisfy these conditions.

---

### üß† **Approach:**

To solve this efficiently, we'll use a **greedy approach**. The basic idea is:
1. **First pass (left to right)**: Ensure that a child with a higher rating than the child before them gets more candies.
2. **Second pass (right to left)**: Ensure that a child with a higher rating than the child after them gets more candies, and adjust the number of candies accordingly.

We'll go through the steps to implement this:

---

### üõ†Ô∏è **Step-by-Step Solution:**

#### Step 1: **Initialization**
We start by handling the case where there is only one child or no children. If there's one child, the answer is simply 1 candy.

```cpp
int size = rate.size();
if (size <= 1) return size;
```

We initialize an array `num[]` where each element initially has the value 1, representing that each child gets at least 1 candy.

```cpp
vector<int> num(size, 1);
```

#### Step 2: **First Pass (Left to Right)**
We go through the array from left to right (starting from index 1) and adjust the candies for children whose ratings are higher than their left neighbor.

```cpp
for (int i = 1; i < size; i++) {
    if (rate[i] > rate[i - 1]) {
        num[i] = num[i - 1] + 1;
    }
}
```

- If `rate[i] > rate[i - 1]`, it means the current child has a higher rating than the one before them, so we give them one more candy than the previous child (`num[i] = num[i - 1] + 1`).

#### Step 3: **Second Pass (Right to Left)**
Next, we go through the array from right to left (starting from the second-to-last element) to ensure that a child with a higher rating than the one after them has more candies. If they already have more candies from the first pass, we leave that value as is.

```cpp
for (int i = size - 1; i > 0; i--) {
    if (rate[i - 1] > rate[i]) {
        num[i - 1] = max(num[i - 1], num[i] + 1);
    }
}
```

- If `rate[i - 1] > rate[i]`, we check if the current child (at `i - 1`) already has more candies than the child at `i`. If not, we update it with the correct number of candies (`max(num[i - 1], num[i] + 1)`).

#### Step 4: **Summing the Total Candies**
After both passes, the array `num[]` contains the minimum number of candies required for each child. The final step is to sum up all the values in the `num[]` array.

```cpp
int res = 0;
for (int i = 0; i < size; i++) {
    res += num[i];
}
return res;
```

This will give us the total number of candies required.

---

### üîç **Time and Space Complexity:**

- **Time Complexity**:  
  We make two passes through the array: one from left to right and another from right to left. Each pass takes O(n) time, so the overall time complexity is **O(n)**, where `n` is the number of children.

- **Space Complexity**:  
  We use an extra array `num[]` to store the number of candies each child should receive. This array has a size of `n`, so the space complexity is **O(n)**.

---

### üöÄ **Conclusion**

This solution efficiently distributes candies using a greedy approach:
- **First pass** ensures that children with a higher rating than their left neighbor get more candies.
- **Second pass** ensures that children with a higher rating than their right neighbor also get more candies, adjusting the previous distribution if needed.

With a time complexity of **O(n)**, the solution is optimal for larger input sizes. The space complexity is also **O(n)** due to the `num[]` array used to track the candies.

---
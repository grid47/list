### Problem Statement

In this problem, we are tasked with designing a **NestedIterator** for a nested list of integers. The input is a list that can contain both integers and other lists, and we need to iterate over all the integers in the list in a flat manner.

#### Given:
- A nested list can contain integers or lists of integers.
- The objective is to implement an iterator that returns integers in a **flattened** order.

#### Example:
For the nested list:
```cpp
[[1,1],2,[1,1]]
```
The iterator should return:
```cpp
1,1,2,1,1
```

The iterator should work efficiently, using the `next()` method to return the next integer, and `hasNext()` to check if more integers are available.

### Approach

To solve this problem, we will utilize a **stack-based approach** that helps us keep track of the current position in the nested list structure. The stack will allow us to navigate through the nested lists by treating each list or integer as a position and allowing us to "pop" and "push" as we traverse deeper into nested lists.

#### Key Ideas:
1. **Stack-Based Iteration**: 
   We can flatten the nested list by using a stack to track the iterators of the nested lists. Each element in the stack represents a "cursor" in a specific level of the nested structure.

2. **Handling Nested Lists**:
   When encountering a list inside another list, we push the beginning and end of the inner list onto the stack. This allows us to continue flattening from the deeper level.

3. **Handling Integer Values**:
   When encountering an integer, we immediately return it.

4. **Efficiency**:
   By using the stack and only pushing and popping iterators when necessary, we can keep our solution efficient, ensuring that each call to `next()` and `hasNext()` operates in constant time relative to the size of the nested structure.

### Code Breakdown (Step by Step)

Let’s walk through the code in detail.

#### Step 1: Constructor
```cpp
NestedIterator(vector<NestedInteger> &nestedList) {
    begins.push(nestedList.begin());
    ends.push(nestedList.end());
}
```
- In the constructor, we initialize two stacks:
  - `begins`: Tracks the current iterator for each list.
  - `ends`: Tracks the end of each list.

We push the beginning and the end of the given `nestedList` into the stacks.

#### Step 2: `next()` Method
```cpp
int next() {
    hasNext();
    return (begins.top()++)->getInteger();
}
```
- The `next()` method first calls `hasNext()` to ensure that there is a next integer available.
- After `hasNext()` is called, we get the integer from the current top iterator in `begins` using the `getInteger()` method.
- The iterator is incremented (`begins.top()++`), advancing to the next position.

#### Step 3: `hasNext()` Method
```cpp
bool hasNext() {
    while (begins.size()) {
        if (begins.top() == ends.top()) {
            begins.pop();
            ends.pop();
        } else {
            auto x = begins.top();
            if (x->isInteger())
                return true;
            begins.top()++;
            begins.push(x->getList().begin());
            ends.push(x->getList().end());
        }
    }
    return false;
}
```
- The `hasNext()` method ensures that we are always pointing to an integer. 
- **Step 1**: While the `begins` stack is not empty:
  - If the top iterator of `begins` equals the top iterator of `ends` (i.e., the iterator has reached the end of the current list), we pop both stacks to move back one level.
  - If the current element is a list (checked by `isInteger()`), we traverse deeper:
    - We increment the current iterator (`begins.top()++`).
    - We push the start and end iterators of the nested list onto the stack.
  - If the current element is an integer, we return `true`, as we have found an integer.
- **Step 2**: If no integers are left, we return `false`.

#### Step 4: Stack for Nested Traversal
The stacks `begins` and `ends` hold iterators of the nested list:
- **`begins` stack**: Holds the iterator pointing to the current element in each nested list.
- **`ends` stack**: Holds the iterator pointing to the end of each nested list.

By keeping track of these iterators, we can easily navigate through any depth of nested lists and always return the next integer when `next()` is called.

### Complexity

#### Time Complexity:
- **`next()` Method**: In the worst case, the time complexity for each `next()` is **O(1)**. This is because, for each integer, we simply need to retrieve it from the top of the stack and increment the iterator. The stack operations are constant time.
- **`hasNext()` Method**: In the worst case, the `hasNext()` method might need to traverse the entire nested list to find the next integer. However, the overall time complexity is still **O(1)** per call, as we’re only visiting each element once.

#### Space Complexity:
- **O(d)**, where `d` is the maximum depth of the nested list. This is because the space is used by the stack, which holds iterators for each level of nesting. The depth of nesting determines the space required for the iterators.

### Conclusion

The **NestedIterator** class efficiently flattens a nested list using a stack-based approach. The core idea is to traverse the nested structure and manage iterators for each level of nesting. The `next()` and `hasNext()` methods work in constant time, ensuring that the iteration through the nested list is both fast and memory-efficient.

- **Efficiency**: Each call to `next()` and `hasNext()` works in constant time relative to the size of the nested list.
- **Simplicity**: By using iterators and stacks, the code keeps the solution simple and intuitive while handling complex nested structures.
- **Flexibility**: This approach is robust enough to handle deeply nested lists of arbitrary depth.

This solution is an excellent example of how to deal with nested data structures efficiently, and is optimal for problems requiring flat iteration over hierarchical data.
### Problem Statement

The problem asks to find the right interval for each interval in a given list of intervals. An interval is represented as a pair `[start, end]`, and we need to find the index of the smallest interval whose starting point is greater than or equal to the ending point of the current interval. If no such interval exists, the result should be `-1` for that interval. 

The goal is to efficiently solve this problem using a strategy that avoids brute-force comparisons, ensuring the solution is optimal even for larger datasets.

### Approach

To solve this problem, we can take advantage of sorting and binary search. The key steps in the approach are as follows:

1. **Map Intervals with Indices**:
   - First, we create a map `mk` where the keys are the start points of the intervals, and the values are the indices of the original intervals. This allows us to keep track of the original positions of the intervals after sorting by their start points.

2. **Sort Intervals by Start Points**:
   - We use a map (which inherently sorts the keys) to store the intervals based on their starting points. This helps in quickly finding the right interval using binary search.

3. **Binary Search for Each Interval**:
   - For each interval `iv[j]`, we use the `lower_bound` function of the map `mk` to find the first interval whose start point is greater than or equal to the end point of `iv[j]`. This function performs a binary search to efficiently find the desired interval.

4. **Handle Edge Cases**:
   - If no interval starts after or at the current interval's end point, the answer for that interval is `-1`.
   - If such an interval exists, we store its index in the result array.

### Code Breakdown (Step by Step)

#### Step 1: Mapping Intervals to Their Indices

```cpp
map<int, int> mk;

int n = iv.size();
for(int i = 0; i < n; i++)
    mk[iv[i][0]] = i;
```

- We initialize a map `mk`, where the key is the start point of an interval, and the value is its index in the original list.
- Then, we iterate over the input list of intervals `iv`. For each interval `iv[i]`, we insert its start point as a key and its index `i` as the corresponding value in the map. This ensures that the intervals are sorted by their start points.

#### Step 2: Preparing the Result Array

```cpp
vector<int> ans(n, -1);
```

- We initialize a result array `ans` with `n` elements (the number of intervals) and set each element to `-1` initially. This represents that, by default, each interval has no right interval, and we will update the array as we find valid intervals.

#### Step 3: Finding the Right Interval for Each Interval

```cpp
for(int j = 0; j < n; j++) {
    auto i = iv[j];
    if(mk.lower_bound(i[1]) != end(mk))
        ans[j] = mk.lower_bound(i[1])->second;
}
```

- We iterate through each interval `iv[j]`.
- For each interval, we retrieve its end point `i[1]`.
- We then use the `lower_bound` function on the map `mk`. This function returns an iterator pointing to the first element whose key is greater than or equal to `i[1]`. This corresponds to the first interval whose start point is greater than or equal to the end point of `iv[j]`.
- If `lower_bound` finds such an interval, we update the result array at index `j` with the index of the interval from the map (`mk.lower_bound(i[1])->second`).

#### Step 4: Returning the Result

```cpp
return ans;
```

- After processing all intervals, we return the result array `ans`, which contains the indices of the right intervals (or `-1` if no such interval exists).

### Complexity

#### Time Complexity:
- **Building the Map**: In the first loop, we iterate over all `n` intervals and insert them into the map. The time complexity of each insertion is `O(log n)` (due to the binary search-based structure of `map`), so the overall time complexity for this step is `O(n log n)`.
- **Finding the Right Interval**: In the second loop, for each of the `n` intervals, we perform a `lower_bound` search on the map, which takes `O(log n)` time. Thus, the total time complexity for this step is `O(n log n)`.
- **Overall Time Complexity**: Combining both steps, the total time complexity is `O(n log n)`.

#### Space Complexity:
- We use a map `mk` to store the intervals, which requires `O(n)` space.
- We also use an array `ans` of size `n` to store the result.
- Thus, the space complexity is `O(n)`.

### Conclusion

This solution is efficient, with a time complexity of `O(n log n)`, which is optimal for this type of problem. By using a map to sort the intervals and then applying binary search, we ensure that we can find the right intervals in logarithmic time for each interval, leading to an overall efficient solution.

The approach leverages key concepts such as sorting, binary search, and efficient data structures (like maps) to solve the problem in an optimal manner, making it suitable for larger datasets and competitive programming challenges.
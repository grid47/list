### Problem Statement

The task is to count the number of digits in a given integer `num` that divide `num` evenly. For example, if the input number is `1012`, we should count how many digits in the number (in this case `1`, `0`, `1`, and `2`) divide `1012` without leaving a remainder. The result will be the number of digits that satisfy this condition.

### Approach

To solve this problem, the approach is straightforward. The idea is to iterate over each digit of the number and check if it divides the number completely. If it does, we increment the counter. To implement this, we need to extract each digit of the number and check the condition `num % digit == 0`. A special case needs to be handled for the digit `0`, since division by zero is not allowed.

The solution follows these steps:
1. Extract each digit of the number.
2. For each digit, check if it divides the number without a remainder.
3. Count how many digits satisfy this condition.
4. Return the final count.

### Code Breakdown (Step by Step)

#### Function Definition:
```cpp
int countDigits(int num) {
    int res = 0;
    for (int n = num; n > 0; n /= 10)
        res += num % (n % 10) == 0;
    return res;
}
```

1. **Initialization of `res`**:
   ```cpp
   int res = 0;
   ```
   - Here, we initialize the result counter `res` to zero. This will keep track of how many digits divide `num` evenly.

2. **Iterating through the digits**:
   ```cpp
   for (int n = num; n > 0; n /= 10)
   ```
   - We start a loop that will run until `n` becomes zero.
   - `n` is initially set to `num`, and we divide `n` by `10` in each iteration, effectively removing the last digit. This continues until we have processed all digits of the number.
   - In each iteration, the loop will check one digit at a time, moving from the rightmost to the leftmost digit.

3. **Extracting the last digit**:
   ```cpp
   res += num % (n % 10) == 0;
   ```
   - `n % 10` gives the last digit of the current value of `n`.
   - `num % (n % 10)` checks if `num` is divisible by the last digit.
     - If `num % (n % 10) == 0`, it means that the digit divides `num` completely, so we increment the result counter `res`.
     - If the condition is false (i.e., the digit does not divide `num`), nothing happens, and the counter remains unchanged.

4. **Returning the result**:
   ```cpp
   return res;
   ```
   - After the loop completes and all digits have been checked, the function returns the value of `res`, which represents the count of digits in `num` that divide it evenly.

### Complexity

#### Time Complexity:
- The time complexity is dominated by the number of digits in `num`. 
  - In each iteration of the loop, we reduce the size of `n` by a factor of 10, meaning the loop runs for `O(d)` iterations, where `d` is the number of digits in `num`.
  - The number of digits in `num` is approximately \( \log_{10}(\text{num}) \). So the time complexity can be considered as `O(d)` or `O(log_{10}(\text{num}))`.
  
#### Space Complexity:
- The space complexity is `O(1)` because we are using a constant amount of extra space. We only need a few variables to store the result and the current value of `num` during the iteration.

### Conclusion

This solution efficiently counts how many digits in a number divide the number evenly. By iterating over the digits and using modulus operations, we can determine the divisibility of each digit with respect to the number. The implementation is simple and effective, with a time complexity that scales logarithmically with the size of the input number. It avoids unnecessary complexity and ensures that the problem is solved in optimal time, making it suitable for even large numbers.
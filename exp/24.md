### ğŸŒŸ **Swapping Every Two Adjacent Nodes in a Linked List**

This problem is a fun and practical exercise to manipulate linked lists. The goal is to swap every two adjacent nodes in a singly linked list. If the list contains an odd number of nodes, the last node stays as it is.

---

#### ğŸ§  **The Simple Idea**

Imagine youâ€™re working with a chain of nodes, and you want to swap every two neighboring links. The challenge is to do this efficiently, without losing track of any part of the list.

#### ğŸ‘‡ **Steps to Solve the Problem:**

1. **Check Base Cases**  
   If the list is empty or contains only one node, thereâ€™s no need for any swaps. Just return the list as it is. âœ‹

2. **Set up the Pointers**  
   Weâ€™ll need a few pointers to help with the swaps:  
   - `cur`: Points to the current node.
   - `nxt`: Points to the next node.
   - `prv`: Keeps track of the previous node (to link the swapped nodes).

3. **Iterate Through the List**  
   Start at the beginning, and swap every two adjacent nodes:  
   - Link the previous node (`prv`) to the new first node of the swapped pair.
   - Make sure to update the `next` pointers after each swap so we donâ€™t lose any nodes. ğŸ”„

4. **Handle Edge Cases**  
   When you reach the last pair (if thereâ€™s an odd number of nodes), leave it as it is and return the modified list.

---

#### ğŸ›  **Breaking Down the Code:**

1. **Handle Edge Cases Early**  
   ```cpp
   if (head == NULL || head->next == NULL) return head;
   ```
   If the list is empty or has only one node, no swaps are needed. This is a simple check to save unnecessary work. ğŸ‘

2. **Initialize the Pointers**  
   ```cpp
   ListNode* cur = head, *nxt = head->next, *ret = nxt, *prv = NULL;
   ```
   - `cur` starts at the first node.
   - `nxt` starts at the second node (weâ€™ll swap these first!).
   - `prv` is `NULL` at first, as thereâ€™s no previous node yet. But we'll use it to maintain the link after the swap.

3. **Iterate and Swap**  
   ```cpp
   while(cur != NULL && nxt != NULL) {
       if(prv != NULL) prv->next = nxt;
       prv = cur;
       cur->next = nxt->next;
       nxt->next = cur;
       cur = cur->next;
       if(cur != NULL) nxt = cur->next;
   }
   ```
   - First, check if both `cur` and `nxt` are valid. If not, we're done with the list.
   - Swap the nodes by adjusting the `next` pointers:
     - `cur->next = nxt->next`: Make `cur` point to the node after `nxt`.
     - `nxt->next = cur`: Point `nxt` to `cur`, completing the swap.
   - Move `cur` and `nxt` forward to the next pair, and repeat until done.

4. **Return the Modified List**  
   ```cpp
   return ret;
   ```
   The new head of the list is now stored in `ret`, which points to the second node from the original list (after the first swap).

---

#### â³ **Complexity Breakdown**

- **Time Complexity: O(n)**  
  We traverse the list once, and each swap operation takes constant time. Hence, the overall time complexity is linear, **O(n)**, where `n` is the number of nodes in the list. ğŸƒâ€â™€ï¸

- **Space Complexity: O(1)**  
  We use a fixed amount of extra space to keep track of the pointers. No extra data structures are used, so the space complexity is constant. ğŸ¯

---

#### ğŸ’¡ **Why This Approach Works**

- **One Pass, Efficient**: By modifying the `next` pointers in a single traversal, we achieve the desired swaps without needing to traverse the list multiple times.
- **Simplicity in Design**: The use of a few simple pointers (`cur`, `nxt`, `prv`) allows us to swap nodes effectively without complicated logic. Practice makes perfect, and this approach keeps it simple and clean.

---

#### ğŸš€ **Conclusion**

Swapping adjacent nodes in a linked list may seem tricky at first, but with the right approach and a bit of pointer manipulation, it becomes a straightforward task! ğŸ‰

- **Key Takeaways**:
  - Efficiently swapping nodes in one pass is the key to keeping this problem in **O(n)** time.
  - Always remember to handle edge cases like empty lists or single-node lists right away.
  - This approach is space-efficient (**O(1)**), so it works well even for large lists!

By mastering this technique, youâ€™ll be able to solve similar linked list problems with ease. Happy coding! ğŸ’»
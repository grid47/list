### Problem Statement

The problem requires swapping every two adjacent nodes in a singly linked list. Specifically, given a linked list, the task is to modify the list such that every two adjacent nodes are swapped, and return the modified list.

#### Input:
- A singly linked list with `n` nodes.

#### Output:
- A modified singly linked list where every two adjacent nodes have been swapped. If there is an odd number of nodes, the last node remains unchanged.

### Approach

This problem can be approached iteratively by traversing the linked list while keeping track of the current and next node, swapping them as we go. The key challenge is to properly maintain the links between the nodes to ensure no part of the list is lost during the swap process.

#### Steps to solve the problem:

1. **Base Case Check**:
   - If the linked list is empty (`head == NULL`) or only contains one node (`head->next == NULL`), there is no need to perform any swaps. We can simply return the head as-is.
   
2. **Iterative Swap Process**:
   - We initialize a pointer `cur` to the head of the list, and a pointer `nxt` to the second node (`head->next`). 
   - We also initialize a pointer `prv` to `NULL`, which will be used to link the previous node to the swapped pair.
   - In each iteration of the loop:
     - We swap `cur` and `nxt` by updating the next pointers: 
       - `cur->next` will point to the node after `nxt`, 
       - `nxt->next` will point to `cur`.
     - After the swap, `cur` is updated to the next node (which is now the node that was originally after `cur`), and `nxt` is updated to the node after `cur`.
     - We repeat this process until we reach the end of the list.
   
3. **Return the Head**:
   - The modified linked list is returned, starting from `ret`, which points to the new head of the swapped list (the second node of the original list).

### Code Breakdown (Step by Step)

#### 1. Base Case Handling

```cpp
if(head == NULL || head->next == NULL) return head;
```

- The first condition checks if the head is `NULL`, indicating an empty list. The second condition checks if the list has only one node (`head->next == NULL`). In both cases, no swaps are needed, and the original list is returned.

#### 2. Initializing Pointers

```cpp
ListNode* cur = head, *nxt = head->next, *ret = nxt, *prv = NULL;
```

- `cur`: Points to the first node (`head`) and will be used to track the current node while traversing the list.
- `nxt`: Points to the second node (`head->next`) and will be used to track the next node during the swap.
- `ret`: This is a pointer that will eventually point to the new head of the list (which is the second node of the original list).
- `prv`: A pointer initialized to `NULL`, which will be used to maintain the link to the previous node after swapping.

#### 3. Iterative Loop for Swapping Pairs

```cpp
while(cur != NULL && nxt != NULL) {
    if(prv != NULL) prv->next = nxt;
    prv = cur;
    cur->next = nxt->next;
    nxt->next = cur;
    cur = cur->next;
    if(cur != NULL) nxt = cur->next;
}
```

- The `while` loop continues as long as `cur` and `nxt` are not `NULL`, meaning there are still pairs of nodes to swap.
  
  1. **Link the Previous Node**: If `prv` is not `NULL`, update the `next` pointer of `prv` to point to `nxt`, the new head of the swapped pair.
  2. **Update Pointers**: 
     - `prv` is updated to `cur` (as `cur` is now the first node of the swapped pair).
     - `cur->next` is updated to point to `nxt->next`, which is the node after `nxt`.
     - `nxt->next` is updated to point to `cur`, completing the swap for this pair.
  3. **Move to the Next Pair**: `cur` is updated to `cur->next`, which is now the node after `cur`. If `cur` is not `NULL`, `nxt` is updated to `cur->next`, setting up the next pair for swapping.

#### 4. Return the Modified List

```cpp
return ret;
```

- After the loop finishes, `ret` points to the new head of the list (the second node of the original list). The modified list is returned.

### Complexity

#### Time Complexity:
- **O(n)**: The algorithm iterates through the linked list once, where `n` is the number of nodes. In each iteration, the nodes are swapped in constant time, so the overall time complexity is linear.

#### Space Complexity:
- **O(1)**: The algorithm uses a constant amount of extra space, regardless of the size of the input list. The space is used only for a few pointers (`cur`, `nxt`, `prv`, and `ret`).

### Conclusion

The `swapPairs` function provides an efficient solution to swap every two adjacent nodes in a singly linked list. The algorithm operates in **O(n)** time, making it suitable for large linked lists. By using a few pointers and modifying the next pointers of the nodes, we achieve the desired swaps in a single pass through the list. The algorithm's **O(1)** space complexity makes it very efficient, as it does not require any additional space beyond the given linked list.

This solution is optimal in terms of both time and space for the problem at hand, making it an excellent choice for swapping nodes in a linked list.
### Problem Statement

The problem requires determining which individuals in a network know a secret after a series of meetings between pairs of people. Each meeting occurs at a specific time, and the first person to know the secret shares it with their partner during these meetings. The goal is to identify all individuals who eventually learn the secret after all meetings have taken place. This task can be efficiently solved using the Union-Find data structure, which allows us to manage and track connected components in the graph of people.

### Approach

To solve this problem, we can outline our approach in the following steps:

1. **Model the Problem**: Treat each person as a node in a graph and each meeting as an edge connecting two nodes (people). The secret spreads through these connections.

2. **Sort Meetings by Time**: Since we need to handle the meetings chronologically, we first sort the list of meetings based on their timestamps.

3. **Union-Find Structure**: Implement the Union-Find data structure (also known as Disjoint Set Union, DSU) to efficiently manage the connectivity between people as they meet. This structure supports two key operations: connecting two nodes (people) and finding the root of a node, which helps determine if two nodes belong to the same component.

4. **Process Meetings**: For each unique time in the sorted list of meetings, connect the people who meet. After processing all meetings at the same time, check who can be connected to the first person (who knows the secret).

5. **Reset Unconnected People**: If a person is not connected to the first person, reset their connection, indicating they do not know the secret.

6. **Collect Results**: Finally, traverse through all individuals and collect those who are connected to the first person, returning this list as the result.

This approach efficiently handles the problem with respect to both time and space complexity, allowing us to manage the connections dynamically as we process the meetings.

### Code Breakdown (Step by Step)

Let's delve into the provided code and understand how each part contributes to the overall solution:

1. **Union-Find Class Definition**:
   ```cpp
   class UnionFind {
       vector<int> id;
   public:
       UnionFind(int n) : id(n) {
           iota(begin(id), end(id), 0);
       }
       void connect(int a, int b) {
           id[find(b)] = find(a);
       }
       int find(int a) {
           return id[a] == a ? a : (id[a] = find(id[a]));
       }
       bool connected(int a, int b) {
           return find(a) == find(b);
       }
       void reset(int a) { id[a] = a; }
   };
   ```
   - The `UnionFind` class initializes an array `id` to manage the parent of each node. The constructor fills this array with values such that each node is its own parent.
   - The `connect` method merges two sets by linking the root of one to the other.
   - The `find` method implements path compression, ensuring efficient retrieval of the root for any node.
   - The `connected` method checks if two nodes belong to the same connected component.
   - The `reset` method reverts a node to being its own parent, which is useful when a person cannot learn the secret.

2. **Main Solution Class**:
   ```cpp
   class Solution {
   public:
       vector<int> findAllPeople(int n, vector<vector<int>>& A, int firstPerson) {
           sort(begin(A), end(A), [](auto &a, auto &b) { return a[2] < b[2]; });
           UnionFind uf(n);
           uf.connect(0, firstPerson);
           vector<int> ppl;
           for (int i = 0, M = A.size(); i < M; ) {
               ppl.clear();
               int time = A[i][2];
               for (; i < M && A[i][2] == time; ++i) {
                   uf.connect(A[i][0], A[i][1]);
                   ppl.push_back(A[i][0]);
                   ppl.push_back(A[i][1]);
               }
               for (int n : ppl) {
                   if (!uf.connected(0, n)) uf.reset(n);
               }
           }
           vector<int> ans;
           for (int i = 0; i < n; ++i) {
               if (uf.connected(0, i)) ans.push_back(i);
           }
           return ans;
       }
   };
   ```

3. **Sorting Meetings**:
   ```cpp
   sort(begin(A), end(A), [](auto &a, auto &b) { return a[2] < b[2]; });
   ```
   The meetings are sorted by the third element (time), which ensures we process them in chronological order.

4. **Initializing Union-Find and Connecting the First Person**:
   ```cpp
   UnionFind uf(n);
   uf.connect(0, firstPerson);
   ```
   A `UnionFind` instance is created for `n` people, and the first person (indexed as `firstPerson`) is connected to the person who initially knows the secret (indexed as `0`).

5. **Processing Meetings**:
   ```cpp
   for (int i = 0, M = A.size(); i < M; ) {
       ppl.clear();
       int time = A[i][2];
       for (; i < M && A[i][2] == time; ++i) {
           uf.connect(A[i][0], A[i][1]);
           ppl.push_back(A[i][0]);
           ppl.push_back(A[i][1]);
       }
   ```
   Within this loop, we process all meetings that occur at the same time. We connect the individuals involved in the meetings and store them in the `ppl` vector for subsequent processing.

6. **Resetting Unconnected Individuals**:
   ```cpp
   for (int n : ppl) {
       if (!uf.connected(0, n)) uf.reset(n);
   }
   ```
   After processing the meetings, we check if each person in `ppl` is connected to the first person. If not, they are reset, indicating they do not know the secret.

7. **Collecting Results**:
   ```cpp
   vector<int> ans;
   for (int i = 0; i < n; ++i) {
       if (uf.connected(0, i)) ans.push_back(i);
   }
   return ans;
   ```
   Finally, we gather all individuals who are connected to the first person and return this list as the result.

### Complexity

The overall time complexity of this algorithm is O(M log M + N), where `M` is the number of meetings and `N` is the number of people. The sorting step contributes O(M log M), while the union-find operations (union and find) are nearly constant time on average, making the rest of the operations linear. The space complexity is O(N) due to the storage required for the union-find structure.

### Conclusion

In conclusion, the solution effectively determines which individuals know a secret after a series of meetings by leveraging the Union-Find data structure to manage connectivity dynamically. By processing meetings in chronological order and resetting connections as necessary, the algorithm efficiently identifies all individuals connected to the initial secret holder. This approach not only optimizes performance but also ensures clarity and maintainability in the implementation. Such strategies are crucial in various applications, including network analysis and social interactions, making this solution both practical and educational.
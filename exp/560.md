### Problem Statement:
The task is to find the number of subarrays in a given array of integers `nums` whose sum equals a given integer `k`. A subarray is any contiguous section of the array. This is a typical problem that can be solved efficiently using a combination of hashing and prefix sums.

### Approach:
This problem can be efficiently solved using a **prefix sum** approach combined with a **hash map** (unordered map). The idea is to maintain the sum of all elements from the beginning of the array up to each point, and store the number of times each sum occurs. If the difference between the current prefix sum and `k` has been seen before, it means there is a subarray whose sum equals `k`.

#### Key Observations:
- **Prefix Sum:** The sum of elements from the start of the array up to a particular index. 
- **HashMap (unordered_map):** It helps to keep track of how many times each prefix sum has occurred.
  
The algorithm works by iterating through the array while maintaining a running sum (`sum`). If at any point the difference `sum - k` has appeared previously in the array, it means that there exists a subarray that sums to `k`. By counting how many times `sum - k` has appeared, we can determine how many subarrays end at the current index that sum to `k`.

### Code Breakdown (Step by Step):

#### Step 1: Initialize Result and Data Structures
```cpp
int res = 0;  // Variable to store the final count of subarrays
unordered_map<int, int> mp;  // HashMap to store the count of prefix sums
mp[0] = 1;  // We initialize with 0 to handle cases where a subarray starting from index 0 sums to k
int sum = 0, cnt = 0;  // sum tracks the running sum of elements; cnt is for counting subarrays
```
Here, `res` is the variable that will store the final result. The map `mp` is initialized to store the frequency of prefix sums encountered during iteration. We start by assuming that the sum of 0 has occurred once, which is necessary for cases where a subarray itself directly sums to `k` from the beginning. `sum` holds the running total as we iterate through `nums`, and `cnt` tracks how many subarrays we've found.

#### Step 2: Iterate Over the Array and Calculate Prefix Sums
```cpp
for(int i = 0; i < nums.size(); i++) {
    sum += nums[i];  // Update the running sum with the current element
```
We start iterating through the array. At each step, we add the current element `nums[i]` to `sum`, which gives the prefix sum up to index `i`.

#### Step 3: Check for Subarrays with Sum Equal to k
```cpp
    if(mp.count(sum - k)) cnt += mp[sum - k];  // If sum - k has been seen, it means we have a valid subarray
```
We check if `sum - k` is a key in the hash map `mp`. If it is, it means there exists a previous prefix sum such that the difference between the current sum and this previous sum equals `k`. This means we have found a subarray with sum `k`. We increment `cnt` by the frequency of `sum - k` in `mp` because each occurrence of `sum - k` represents a valid subarray that ends at the current index.

#### Step 4: Update the HashMap with the Current Prefix Sum
```cpp
    mp[sum] += 1;  // Increment the count of the current prefix sum in the hash map
}
```
Finally, we update the hash map to record the occurrence of the current `sum`. This allows us to track how many times each prefix sum has appeared so far.

#### Step 5: Return the Result
```cpp
return cnt;  // Return the total count of subarrays found
```
After processing all elements in the array, we return the value of `cnt`, which contains the total number of subarrays that sum to `k`.

### Complexity:

#### Time Complexity:
- **O(n):** We iterate through the array exactly once, and for each element, we perform constant-time operations: updating the running sum and checking/updating the hash map. Since hash map operations (insertion, lookup) are on average O(1), the overall time complexity is O(n), where `n` is the size of the input array `nums`.

#### Space Complexity:
- **O(n):** In the worst case, the hash map can store up to `n` different prefix sums (if every sum encountered is unique). Therefore, the space complexity is O(n).

### Conclusion:

This approach leverages the efficiency of prefix sums and hash maps to solve the problem in linear time. By maintaining a cumulative sum and storing the frequency of each sum, we can quickly check for subarrays that sum to `k`. This technique is optimal and well-suited for solving problems involving subarrays and cumulative sums, providing both time and space efficiency.
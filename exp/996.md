### Problem Statement
Given a list of integers `A`, find the number of different permutations of `A` such that the sum of every pair of adjacent elements is a perfect square.

### Approach
1. **Sorting**: Start by sorting the array `A`. This helps in avoiding duplicate permutations.
2. **Backtracking**: Use a backtracking approach to generate permutations:
   - The function `pmt` is called recursively to explore all permutations starting from the current index `idx`.
   - A `seen` set is utilized to track numbers that have already been used at the current position to avoid duplicates.
3. **Valid Pair Check**: For each valid permutation, check if the sum of the current element and the previous one is a perfect square using the `isSquare` function:
   - If `idx` is `0`, simply add to the count since there's no previous element.
   - If not, check if the sum is a perfect square.
4. **Counting Valid Permutations**: Each time a valid permutation is formed (when `idx` reaches the size of `A`), increment the count.

### Code Walk-through
- The main function sorts the input array and initializes the count variable `ans`.
- The recursive function `pmt` is defined to handle the permutation generation and checking.
- A helper function `isSquare` is defined to check if a number is a perfect square.

### Complexity
- **Time Complexity**: O(n!), where `n` is the number of elements in `A`. This arises from generating all permutations.
- **Space Complexity**: O(n), which is used by the recursion stack and the `seen` set.

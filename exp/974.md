### Problem Statement

The problem is to find the total number of **subarrays** within a given array `nums` where the sum of the elements in each subarray is divisible by a given integer `k`. A subarray is defined as a contiguous portion of the array.

### Approach

To solve this problem efficiently, we can utilize the **prefix sum** technique combined with **modulo arithmetic** and a **hash map (or array)** to keep track of remainders. This approach avoids the need to explicitly calculate the sum of every possible subarray, which would be inefficient for large arrays.

#### Key Insights:

1. **Prefix Sum**:
   - A prefix sum for an array is the sum of elements from the start of the array up to a given index.
   - If we know the prefix sum up to two indices `i` and `j`, we can calculate the sum of the subarray `nums[i...j]` as:
   
   \[
   \text{sum}(nums[i...j]) = \text{prefix\_sum}[j] - \text{prefix\_sum}[i]
   \]
   
2. **Modulo Operation**:
   - To determine whether a subarray sum is divisible by `k`, we check if the sum modulo `k` equals 0.
   - If `prefix_sum[i] % k == prefix_sum[j] % k`, then the sum of the subarray `nums[i...j]` is divisible by `k`.

3. **Using a Frequency Array**:
   - As we traverse the array and compute prefix sums, we track how often each possible remainder (from the modulo operation) occurs using a frequency array `frq`. This allows us to count subarrays that satisfy the condition without explicitly checking all subarrays.
   - The key observation is that, for any index `j`, if there exists an index `i` such that `prefix_sum[i] % k == prefix_sum[j] % k`, then the sum of the subarray from `i+1` to `j` is divisible by `k`.

#### Algorithm:

1. Start by initializing the total result (`res`) to 0 and the prefix sum (`sum`) to 0.
2. Use an array `frq` to store the frequencies of remainders (modulo `k`), where `frq[rem]` stores the number of times a remainder `rem` has occurred.
3. Traverse the array, update the prefix sum, and calculate the remainder of the prefix sum modulo `k`. If this remainder has been encountered before, it means that there are subarrays ending at the current index whose sum is divisible by `k`.
4. For each remainder, increment the corresponding entry in the frequency array.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    int subarraysDivByK(vector<int>& nums, int k) {
        int res = 0, n = nums.size(), sum = 0;        
        vector<int> frq(k, 0);
        frq[0] = 1; // To count subarrays that are divisible by k from the beginning
```

1. **Initialization**:
   - `res`: This variable holds the result, which is the total number of subarrays whose sum is divisible by `k`.
   - `n`: The size of the input array `nums`.
   - `sum`: This keeps track of the cumulative sum of elements from the start to the current position in the array.
   - `frq`: An array that stores the frequency of each remainder when the prefix sum is divided by `k`. We initialize `frq[0] = 1` to account for the subarrays that are divisible by `k` starting from the first element.

```cpp
        for(int j = 0; j < n; j++) {
            sum += nums[j];
            int rm = sum % k;
            if(rm < 0) rm += k;            
            res += frq[rm];
            frq[rm]++;
        }
        return res;
    }
};
```

2. **Main Loop**:
   - We iterate through the array `nums` with the index `j`.
   - `sum += nums[j]`: We accumulate the prefix sum at the current index.
   - `rm = sum % k`: We compute the remainder when the current prefix sum is divided by `k`.
   - If `rm < 0`: This step ensures that we handle negative remainders correctly. Since the remainder of a negative number in C++ can be negative, we adjust it by adding `k` to ensure all remainders are positive.
   - `res += frq[rm]`: This is the core of the solution. If the remainder `rm` has been encountered before, it means that there are subarrays whose sum is divisible by `k` (because the difference of their prefix sums would be divisible by `k`).
   - `frq[rm]++`: We update the frequency of the remainder `rm` in the frequency array.

3. **Return Result**:
   - Finally, we return `res`, which contains the total number of subarrays whose sum is divisible by `k`.

### Complexity

- **Time Complexity**: 
   - The algorithm only loops through the array once, and each operation inside the loop (such as computing the sum and updating the frequency array) takes constant time.
   - Therefore, the time complexity is **O(n)**, where `n` is the size of the input array `nums`.

- **Space Complexity**:
   - The space complexity is **O(k)**, where `k` is the divisor. This is because we only need an array of size `k` to store the frequency of each possible remainder.
   - Additionally, the space for the input array `nums` is not considered here as it is part of the input.

### Conclusion

This solution uses the **prefix sum** technique combined with **modulo arithmetic** to efficiently count subarrays whose sum is divisible by `k`. By tracking the frequency of each remainder modulo `k`, we avoid explicitly checking every possible subarray, resulting in an efficient solution with a time complexity of **O(n)**. The approach is optimal for solving problems related to divisibility of subarray sums, especially when the input array is large.
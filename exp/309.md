### Problem Statement

The problem asks us to determine the maximum profit we can achieve from a series of stock transactions, given an array of stock prices where `prices[i]` is the price of the stock on day `i`. You are allowed to perform the following operations:
1. Buy one share of the stock.
2. Sell one share of the stock.
3. After selling a share, you must wait for one day (this is known as the "cooldown" period) before you can buy again.

The goal is to calculate the maximum profit that can be made given these rules.

### Approach

This problem can be efficiently solved using dynamic programming (DP) with memoization to avoid redundant computations. The main idea is to break down the problem into subproblems by considering the state of the problem at each day.

#### **State Representation**

The key states we need to track are:
1. **Current Day (`idx`)**: The index of the current day we are considering in the `prices` array.
2. **Buy/Not Buy (`buy`)**: A flag indicating whether we are allowed to buy on the current day (`buy = true` if we can buy, `buy = false` if we cannot).
3. **Cooldown (`cool`)**: A flag indicating if we are in a cooldown period (`cool = true` if we must wait before buying again, `cool = false` if we are free to trade).

Thus, the state can be represented by the tuple `(idx, buy, cool)`, where:
- `idx` is the current day.
- `buy` determines if we are in a "buy" state or a "sell" state.
- `cool` tells us whether we are in a cooldown period after a sale.

#### **Recursive Function with Memoization**

The `dp` function works recursively to calculate the maximum profit we can achieve from the given day onward. If we are allowed to buy, we can either:
- Skip the current day (move to the next day).
- Buy the stock and proceed to the next day, transitioning to the "cooldown" state after the purchase.

If we are in the "sell" state (i.e., `buy = false`), we can either:
- Skip the current day.
- Sell the stock (if we had previously bought it), and then move into the "cooldown" state for the next day.

Memoization is used to store the results of subproblems to avoid recalculating the same subproblem multiple times.

#### **Base Case**
The base case occurs when we have processed all the days (i.e., `idx == prices.size()`). In this case, there are no more transactions possible, so the profit is `0`.

### Code Breakdown (Step by Step)

1. **Memoization Array**:
```cpp
int memo[5001][2][2];
```
This array is used to store the results of subproblems. The size of `memo` is `5001 x 2 x 2` because:
- `5001` corresponds to the maximum number of days in the `prices` array (with one extra slot for the base case).
- `2` corresponds to whether we can buy or not (`buy = 0` or `1`).
- `2` corresponds to whether we are in the cooldown period (`cool = 0` or `1`).

2. **Recursive DP Function (`dp`)**:
```cpp
int dp(int idx, bool buy, bool cool) {
    if(idx == nums.size()) return 0; // Base case: no more days to process
    
    if(memo[idx][buy][cool] != -1) return memo[idx][buy][cool]; // If already computed, return cached result
```
- The base case is when `idx` reaches the end of the `prices` array. In this case, the profit is `0` since no transactions are left.
- If the value for the state `(idx, buy, cool)` has been computed previously, it is returned from the memoization table to avoid redundant calculations.

3. **Recursive Transitions**:
```cpp
int res = dp(idx + 1, buy, false); // Skip the current day

if(buy && !cool) { // If we can buy and we are not in cooldown
    res = max(res, dp(idx + 1, false, false) - nums[idx]); // Buy the stock
} else if(!buy) { // If we cannot buy (we are in the selling state)
    res = max(res, dp(idx + 1, true, true) + nums[idx]); // Sell the stock and go to cooldown
}
```
- If we skip the current day, the profit remains the same (`dp(idx + 1, buy, false)`).
- If we can buy (i.e., `buy = true` and `cool = false`), we calculate the maximum profit by buying the stock and subtracting the price of the stock (`nums[idx]`).
- If we are in the "sell" state (i.e., `buy = false`), we calculate the profit by selling the stock and entering a cooldown period (i.e., `dp(idx + 1, true, true)`).

4. **Memoize the Result**:
```cpp
return memo[idx][buy][cool] = res; // Store the result in the memo table
```

5. **Main Function (`maxProfit`)**:
```cpp
int maxProfit(vector<int>& prices) {
    memset(memo, -1, sizeof(memo)); // Initialize the memo table to -1
    this->nums = prices; // Store the prices in the class-level vector
    return dp(0, true, false); // Start the recursion with the first day, and we can buy on the first day
}
```
- The `maxProfit` function initializes the memoization table to `-1` (indicating that no subproblems have been solved yet).
- It stores the `prices` array in the `nums` vector of the class.
- The `dp` function is then called with `idx = 0` (starting from the first day), `buy = true` (we are allowed to buy), and `cool = false` (we are not in a cooldown state).

### Complexity

#### **Time Complexity**:
The time complexity of this solution is **O(n)**, where `n` is the length of the `prices` array. This is because the recursion tree is reduced by memoization, and we only compute each state once. There are `O(n)` days, and for each day, there are at most 4 possible states (`buy` and `cool` can be true or false), resulting in `O(4n)`, which simplifies to **O(n)**.

#### **Space Complexity**:
The space complexity is **O(n)** due to the memoization array (`memo[5001][2][2]`), which stores the results for each subproblem. In addition, the function uses constant space for auxiliary variables like `res` and `idx`.

### Conclusion

This solution uses dynamic programming with memoization to solve the problem of finding the maximum profit from stock transactions, with a cooldown period after each sale. By caching the results of previously computed subproblems, the algorithm avoids redundant computations and achieves an efficient time complexity of **O(n)**.

Key Takeaways:
1. **Dynamic Programming**: This approach leverages dynamic programming to break the problem into smaller subproblems, solving each subproblem only once using memoization.
2. **Efficient State Management**: By tracking three key states—current day, buy/sell ability, and cooldown status—the solution efficiently computes the maximum profit.
3. **Time Complexity**: The solution has a time complexity of **O(n)**, making it scalable for large input sizes.

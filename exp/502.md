### Problem Statement

The task is to maximize the capital after performing `k` investments. You start with an initial capital `w` and have `k` opportunities to invest. Each investment has a cost (`capital[i]`) and a profit (`profit[i]`), and you can only invest in a project if you have enough capital to meet the required cost. The goal is to maximize your capital after making `k` investments. This is a typical problem that requires an efficient strategy for selecting the best investments given a constraint on capital.

### Approach

To solve this problem efficiently, we need to make use of a combination of greedy algorithms and data structures like heaps (priority queues). Here's a step-by-step approach to solve the problem:

1. **Initial Setup**: We start by checking which investments can be made immediately with the initial capital `w`. We store these investments in a max-heap based on their profit. Investments that require more capital than `w` will be stored in an array and sorted by the capital requirement. This will allow us to process the investments in an optimal order later.

2. **Using the Priority Queue (Max-Heap)**:
   - We initialize a max-heap to store the profits of investments that are eligible for selection based on available capital. Since we want to maximize the profit, we use a max-heap, which allows efficient extraction of the maximum profit at each step.
   - For each of the `k` steps (or until there are no more investments left), we select the investment with the highest profit available, add its profit to our capital, and then push all the subsequent investments whose capital requirement is less than or equal to the updated capital into the heap.
   - This greedy strategy ensures that at each step, we choose the investment that gives the maximum possible increase in capital.

3. **Looping Through Investments**:
   - After each selection, we check if there are any remaining investments that can be added to the heap based on the new capital. This is done by checking the capital of each investment and pushing eligible investments into the heap.
   - We continue this process for `k` iterations (or until no more investments can be made).

4. **Sorting for Efficiency**:
   - We sort the array of investments by their capital requirement to ensure we can efficiently process them in the correct order. This helps minimize the number of times we need to check if a project can be added to the heap, as we can process them in order.

### Code Breakdown (Step by Step)

Here's a detailed breakdown of the code:

1. **Data Structures Initialization**:
   ```cpp
   vector<pair<int, int>> arr;
   priority_queue<int> pq;
   int n = capital.size();
   ```
   - `arr`: A vector to store the investments that cannot be immediately selected (i.e., investments with a capital requirement greater than the available capital `w`).
   - `pq`: A priority queue (max-heap) to store the profits of the available investments that can be made.
   - `n`: The number of investments available (size of the `capital` vector).

2. **Sorting Eligible Investments**:
   ```cpp
   for(int i = 0; i < n; i++) {
       if(capital[i] <= w) {
           pq.push(profit[i]);
       } else {
           arr.push_back({capital[i], profit[i]});
       }
   }
   sort(arr.begin(), arr.end());
   ```
   - This loop processes all the investments and categorizes them into two groups:
     - **Eligible investments**: If the capital required for an investment is less than or equal to `w`, its profit is added to the priority queue.
     - **Non-eligible investments**: If the capital required is greater than `w`, the investment is stored in the array `arr`.
   - After categorizing the investments, the array `arr` is sorted based on the capital requirement. This ensures that when we process the investments later, we can easily pick investments that we can afford with the current capital.

3. **Main Loop (Investment Selection)**:
   ```cpp
   int i = 0;
   int sum = w;
   while(k-- && !pq.empty()) {
       sum += pq.top();
       pq.pop();
       while(i < arr.size() && arr[i].first <= sum) {
           pq.push(arr[i].second);
           i++;
       }
   }
   ```
   - **Main Loop**: This loop runs for `k` iterations or until there are no more investments in the max-heap. In each iteration:
     - The investment with the highest profit is selected (i.e., `pq.top()`), and its profit is added to the current capital (`sum`).
     - The investment is then removed from the heap (`pq.pop()`).
     - **Inner Loop**: After selecting an investment, we check if any of the non-eligible investments can now be selected based on the updated capital (`sum`). If they can, they are pushed into the priority queue for future selection.

4. **Returning the Result**:
   ```cpp
   return sum;
   ```
   - After `k` selections (or fewer, if no more investments can be made), we return the final capital.

### Complexity Analysis

1. **Time Complexity**:
   - Sorting the array `arr` takes `O(n log n)` where `n` is the number of investments.
   - The priority queue operations (push and pop) are `O(log k)`, where `k` is the number of steps (up to `k`).
   - The total time complexity is dominated by the sorting step, resulting in an overall complexity of `O(n log n + k log k)`.

2. **Space Complexity**:
   - The space complexity is `O(n)` due to the additional storage used for the `arr` and the priority queue.

### Conclusion

This solution is an efficient approach to solving the problem of maximizing capital through `k` investments. By using a greedy algorithm and priority queues, the solution ensures that at each step, the investment with the highest profit is selected. Sorting the non-eligible investments allows us to efficiently process them in order, minimizing unnecessary checks. The overall time complexity of the solution is optimal for typical problem constraints, and it handles edge cases where not enough investments can be made efficiently. This approach is well-suited for maximizing capital given a limited number of investment opportunities.
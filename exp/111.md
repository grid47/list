### Problem Statement

The problem is to find the **minimum depth** of a binary tree. The **minimum depth** of a binary tree is the length of the shortest path from the root node to any leaf node. A **leaf node** is a node with no children (i.e., both its left and right children are null).

For example, in a binary tree:

```
        1
       / \
      2   3
       \
        4
```

The minimum depth is 2 (root → 3) because it's the shortest path to a leaf node. In case of an empty tree, the minimum depth is 0.

### Approach

The approach to solving the minimum depth problem is based on **depth-first search (DFS)**, a recursive strategy where we explore the tree's nodes from top to bottom, checking each node's depth by traversing both its left and right children. The algorithm follows these steps:

1. **Base Case:**
   - If the current node (`root`) is null, return `0`. This is because an empty tree has no depth.
   
2. **Recursive Calculation of Depth:**
   - If both left and right children of the node are present, we calculate the depth for both subtrees and return the minimum of the two values.
   - If only one child is present, the minimum depth of the tree is the depth of the subtree plus 1.

3. **Final Result:**
   - The result is the shortest path from the root node to the nearest leaf node.

### Code Breakdown (Step by Step)

#### Step 1: Handle the Empty Tree

```cpp
if(root == NULL) return 0;
```
- If the root is `NULL` (i.e., the tree is empty), we return `0`, as the depth of an empty tree is 0.

#### Step 2: Recursive Calculation for Left and Right Subtrees

```cpp
int l = minDepth(root->left);
int r = minDepth(root->right);
```
- We calculate the minimum depth of the left subtree (`l`) and the right subtree (`r`). These recursive calls will continue until the base case is hit (i.e., when we encounter a null node).

#### Step 3: Calculate the Minimum Depth Based on Child Nodes

```cpp
if(root->left && root->right) {
    return 1 + ((l < r) ? l : r);
}
```
- If both left and right children are present (non-null), we return `1 + min(l, r)`. This means we add 1 for the current node and then choose the minimum of the depths of the left and right subtrees.
- This ensures that we get the shortest path to a leaf node.

#### Step 4: Handle the Case When One Child Is Null

```cpp
if(root->left) {
    return 1 + l;
}
```
- If the left child is `NULL`, the minimum depth will be `1 + depth of right subtree`. Since there’s no left child to traverse, we must only consider the depth of the right subtree.

```cpp
return 1 + r;
```
- Similarly, if the right child is `NULL`, the minimum depth is `1 + depth of the left subtree`.

#### Final Result:
- The recursion continues until all nodes are visited, and the function returns the minimum depth from the root to any leaf node.

### Complexity Analysis

#### Time Complexity

The time complexity of the algorithm is **O(n)**, where `n` is the number of nodes in the tree. This is because:
- In the worst case, we visit every node in the tree exactly once to calculate its depth.
- Each recursive call involves a constant amount of work (calculating the minimum depth of two subtrees), and thus, the time complexity is linear with respect to the number of nodes in the tree.

#### Space Complexity

The space complexity of the algorithm is **O(h)**, where `h` is the height of the binary tree. This is because:
- The space complexity is dominated by the recursive call stack. In the worst case, the tree could be completely unbalanced, resulting in a recursive depth of `h = n`, giving a space complexity of **O(n)**.
- In the best case, if the tree is balanced, the height `h` would be **O(log n)**, and the space complexity would be **O(log n)**.

### Example Walkthrough

Let's walk through the code with an example to see how the solution works:

#### Example 1: A Balanced Binary Tree

Consider the following tree:

```
        1
       / \
      2   3
     / \
    4   5
```

- The root is `1`, and its left child is `2` and right child is `3`.
- We first call `minDepth(root)` for node `1`.
- The left subtree (rooted at `2`) and the right subtree (rooted at `3`) are explored.
- We recursively find the minimum depth of both the left and right subtrees.
- For the left subtree:
  - The left child is `4` (leaf), and the right child is `5` (leaf).
  - The minimum depth of this subtree is `2` (root → 2 → 4 or 2 → 5).
- For the right subtree:
  - The right child is `3` (leaf), so the minimum depth is `1` (root → 3).
- The minimum depth of the entire tree is `1 + min(2, 1) = 2`.

#### Example 2: An Unbalanced Binary Tree

Consider the following tree:

```
        1
       /
      2
     /
    3
   /
  4
```

- The root is `1`, and its left child is `2`, which has a left child `3`, and so on.
- We first call `minDepth(root)` for node `1`.
- The left subtree (rooted at `2`) is explored.
- The left child of node `2` is `3`, and the left child of node `3` is `4`.
- Finally, `4` is a leaf node.
- The minimum depth of the entire tree is `4`, because there’s only one branch to follow (root → 2 → 3 → 4).

### Conclusion

The solution effectively finds the minimum depth of a binary tree by performing a **depth-first search (DFS)**. It computes the depth of each subtree recursively, ensuring an optimal solution with **O(n)** time complexity, where `n` is the number of nodes. This is a simple yet efficient approach to handle problems related to tree depth and is widely applicable in scenarios where binary trees are involved. The use of recursion ensures that the solution is clean and easy to follow, while handling both balanced and unbalanced trees efficiently.
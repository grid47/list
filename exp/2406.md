### Problem Statement

The problem asks to determine the **minimum number of meeting rooms** required to schedule a series of meetings, where each meeting has a start and end time. The objective is to find the smallest number of rooms needed to accommodate all meetings such that no two meetings overlap in the same room.

### Approach

The solution follows the **greedy algorithm** approach combined with a **priority queue (min-heap)** to track and manage the meetings efficiently. The key idea is to keep track of the ongoing meetings and when one meeting ends, reuse that room for the next meeting that starts.

#### Key Insights:

1. **Sorting by Start Time**: We first sort the meetings by their start times. This allows us to process the meetings in the order they appear, ensuring that we can efficiently manage their room assignments.

2. **Min-Heap for Room Management**: We use a priority queue (min-heap) to track the earliest available room (i.e., the meeting that finishes the earliest). By keeping the room that gets free the soonest at the top, we can always reuse it for the next meeting that starts after the previous one ends.

3. **Greedy Allocation**: For each meeting, we check if it can fit into an existing room (by comparing its start time with the earliest available room's end time). If it fits, we assign it to that room; otherwise, we need a new room.

4. **Optimal Solution**: By processing meetings one by one and managing room allocations greedily, we ensure that the number of rooms used is minimized.

### Code Breakdown (Step by Step)

#### Step 1: Sorting the Meetings

```cpp
sort(list.begin(), list.end());
```

- First, we sort the meetings in ascending order by their start time. Sorting is necessary because it allows us to process the meetings in the order they appear and efficiently manage room assignments.
- The sorting step ensures that we always consider the earliest starting meeting first, which is crucial for the greedy approach.

#### Step 2: Initializing Variables

```cpp
int res = 1, cnt = 1;
priority_queue<int, vector<int>, greater<int>> pq;
```

- **`res`**: This variable keeps track of the maximum number of rooms used at any point in time. We initialize it to `1` because we are guaranteed to need at least one room.
- **`cnt`**: This variable tracks the current number of rooms being used.
- **`pq`**: This priority queue (min-heap) is used to store the end times of the ongoing meetings. It helps us efficiently find the room that gets free the earliest.

#### Step 3: Processing the First Meeting

```cpp
int n = list.size();
pq.push(list[0][1]);
```

- We start by pushing the end time of the first meeting (`list[0][1]`) into the priority queue.
- This initializes the room allocation process by assuming that the first meeting occupies the first room.

#### Step 4: Handling Subsequent Meetings

```cpp
if (n == 1) return 1;
for (int i = 1; i < n; i++) {
    int next = list[i][0];
    while (!pq.empty() && next > pq.top()) {
        pq.pop();
        cnt--;
    }
    pq.push(list[i][1]);
    cnt++;
    res = max(res, cnt);
}
```

- **If there's only one meeting**: We immediately return `1` because only one room is needed.
  
- **For each subsequent meeting**:
  - We first check if the next meeting can be assigned to an existing room. To do this, we compare its start time (`next = list[i][0]`) with the earliest finishing meeting (the top of the priority queue).
  - If the current meeting starts after the earliest meeting ends (i.e., `next > pq.top()`), we pop the earliest meeting from the priority queue (indicating that its room is now available) and decrement the count of rooms in use (`cnt--`).
  - Regardless of whether a room was reused, we add the current meeting's end time to the priority queue, indicating that a room is now occupied by this meeting.
  - We increment the number of rooms used (`cnt++`) and update the maximum number of rooms used (`res`).

#### Step 5: Returning the Result

```cpp
return res;
```

- After processing all meetings, we return `res`, which holds the maximum number of rooms needed at any point in time.

### Complexity

#### Time Complexity:
- **Sorting**: The sorting step takes **O(n log n)**, where `n` is the number of meetings.
- **Priority Queue Operations**: Each meeting is pushed and popped from the priority queue once. Each heap operation (push and pop) takes **O(log n)**. Since there are `n` meetings, the total complexity for heap operations is **O(n log n)**.
- Overall, the time complexity of the solution is dominated by the sorting and heap operations, which gives an overall time complexity of **O(n log n)**.

#### Space Complexity:
- **O(n)**: We store the end times of the ongoing meetings in the priority queue. In the worst case, the priority queue will hold `n` meeting end times, so the space complexity is **O(n)**.

### Conclusion

This solution efficiently determines the minimum number of rooms required to accommodate all meetings by leveraging a greedy approach combined with a priority queue (min-heap). The solution processes the meetings in sorted order, reuses rooms when possible, and tracks the maximum number of rooms used.

#### Key Points:
- **Greedy Strategy**: We always reuse rooms as soon as they become available to minimize the number of rooms used.
- **Priority Queue**: A priority queue helps us efficiently manage room availability by always keeping track of the earliest finishing meeting.
- **Time Complexity**: The solution runs in **O(n log n)**, making it efficient for large input sizes.
- **Space Complexity**: The space complexity is **O(n)**, as we store meeting end times in the priority queue.

This approach is optimal for solving the problem of meeting room allocation and can be applied to various scheduling problems where resource management is required.
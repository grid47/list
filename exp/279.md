### Problem Statement

The problem asks you to find the **least number of perfect squares** that sum up to a given number `n`. A **perfect square** is an integer that is the square of another integer. For example, the numbers `1`, `4`, `9`, `16`, `25`, and so on are perfect squares. You need to determine the minimum number of these perfect squares that add up to `n`. 

For example:
- If `n = 12`, the least number of perfect squares that sum up to `12` is `3` because `12 = 4 + 4 + 4`.
- If `n = 13`, the least number of perfect squares that sum up to `13` is `2` because `13 = 9 + 4`.

This is a typical example of a dynamic programming problem, where you aim to break the problem down into smaller subproblems and use the results of these subproblems to solve the overall problem.

### Approach

To solve this problem, we will use **dynamic programming** (DP). The main idea is to break down the problem into smaller subproblems, and each subproblem answers how many perfect squares are needed to sum up to a particular number. 

We maintain an array `cnt` where `cnt[i]` stores the minimum number of perfect squares required to sum up to `i`. We can fill this array iteratively by considering all perfect squares smaller than or equal to `i`.

**Steps:**
1. **Initialization:** Start by initializing an array `cnt` of size `n + 1` to store the results. Set `cnt[0] = 0` because no perfect square is needed to sum up to `0`.
2. **Iterate over all numbers up to `n`:** For each number `i` from `1` to `n`, we check all perfect squares smaller than or equal to `i`. For each square `j * j`, we check if we can improve the result for `cnt[i]` by considering `cnt[i - j * j] + 1`. This means we are subtracting a square from `i` and looking for the best solution for the remaining sum (`i - j * j`).
3. **Return the result for `n`:** After iterating over all numbers, the value `cnt[n]` will contain the minimum number of perfect squares that sum up to `n`.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the `cnt` Array
```cpp
vector<long> cnt(n + 1, INT_MAX);
cnt[0] = 0;
```
- We initialize a vector `cnt` of size `n + 1` with the value `INT_MAX` (which represents infinity) to signify that initially, we don't know how to sum up to any number other than `0`.
- We set `cnt[0] = 0` because no perfect squares are needed to sum up to `0`.

#### Step 2: Iterate Through All Numbers from `1` to `n`
```cpp
for (int i = 1; i <= n; i++) {
    for (int j = 1; j * j <= i; j++) {
        cnt[i] = min(cnt[i], cnt[i - j * j] + 1);
    }
}
```
- We loop through each number `i` from `1` to `n` (outer loop).
- For each `i`, we consider all perfect squares `j * j` such that `j * j <= i` (inner loop).
- We update `cnt[i]` with the minimum value between its current value and `cnt[i - j * j] + 1`. This represents using the square `j * j` and finding the best result for the remaining sum `i - j * j`.

#### Step 3: Return the Result for `n`
```cpp
return cnt[n];
```
- After filling in the array `cnt`, the result for `n` will be stored in `cnt[n]`, which represents the least number of perfect squares that sum up to `n`.

### Complexity

#### Time Complexity:
- The outer loop runs from `1` to `n`, so it executes `n` iterations.
- The inner loop iterates over all perfect squares less than or equal to `i`. For each `i`, the number of perfect squares less than or equal to `i` is approximately `sqrt(i)`. So for each `i`, the inner loop runs at most `O(sqrt(i))` times.
- Therefore, the time complexity is the sum of `sqrt(i)` for `i` from `1` to `n`. This can be approximated as `O(n * sqrt(n))`.

#### Space Complexity:
- We use a vector `cnt` of size `n + 1` to store the minimum number of perfect squares for each number up to `n`. This takes `O(n)` space.

Thus, the overall time complexity is `O(n * sqrt(n))` and the space complexity is `O(n)`.

### Conclusion

This solution is an efficient approach to the problem of finding the least number of perfect squares that sum up to a given number `n`. By using dynamic programming, we break down the problem into smaller subproblems, and iteratively compute the solution for each number from `1` to `n`. The use of the `cnt` array helps us store intermediate results, which are then reused to compute the final solution.

The time complexity of the solution is `O(n * sqrt(n))`, which is quite efficient for moderately large values of `n`. The space complexity is `O(n)`, which is manageable. This approach ensures that we can compute the result in an optimal way without unnecessary recalculations. Overall, this is a well-optimized solution for the problem and can handle large inputs effectively.
### üí° **Word Ladder Problem: Transforming One Word to Another**

The **Word Ladder** problem is a fascinating graph-based challenge where we aim to transform a starting word into an ending word, changing only one letter at a time. Each transformation must result in a valid word from the dictionary. The goal is to find the **shortest transformation sequence** from the starting word (`bg`) to the target word (`ed`).

#### **Problem Statement**
Given:
- A `begin` word (`bg`).
- A `end` word (`ed`).
- A list of valid words (`list`), each having the same length as the begin and end words.

Our task is to find the **shortest transformation sequence** such that:
1. Each transformed word must exist in the dictionary.
2. Only one letter can be changed at a time between consecutive words in the sequence.
3. The sequence starts with `bg` and ends with `ed`.

#### **Example**

- **Input**:
  - `begin = "hit"`
  - `end = "cog"`
  - `list = ["hot", "dot", "dog", "lot", "log", "cog"]`
  
- **Output**: `5`

**Explanation**: The shortest transformation sequence is `"hit" -> "hot" -> "dot" -> "dog" -> "cog"`, which has a length of 5.

---

### üõ†Ô∏è **Approach: Using Breadth-First Search (BFS)**

This problem can be effectively modeled as a **graph traversal** problem:
- **Nodes**: Each word in the dictionary and the `begin` and `end` words.
- **Edges**: There is an edge between two words if they differ by exactly one letter.

We‚Äôll solve this problem using **Breadth-First Search (BFS)**, which is perfect for finding the shortest path in an unweighted graph.

---

### ‚ú® **Steps to Solve the Problem**

#### 1Ô∏è‚É£ **Function Definition**
```cpp
int ladderLength(string bg, string ed, vector<string>& list)
```
The function `ladderLength` accepts three arguments:
- `bg`: the starting word.
- `ed`: the target word.
- `list`: a list of valid words.

---

#### 2Ô∏è‚É£ **Dictionary Initialization**
```cpp
unordered_map<string, bool> mp;
for(string x: list)
    mp[x] = true;
```
- **`mp`** is a hash map (unordered map) where each word from the dictionary is stored with a value of `true` to mark it as a valid word. This allows for **O(1)** lookup time.

---

#### 3Ô∏è‚É£ **Queue Initialization**
```cpp
queue<string> q;
q.push(bg);
```
- **Queue** (`q`) stores the words as we explore them level by level.
- The queue is initialized with the `begin` word (`bg`).

---

#### 4Ô∏è‚É£ **BFS Loop: Exploring Words Level by Level**
```cpp
int cnt = 1;
while(!q.empty()) {
    int sz = q.size();
    while(sz--) {
        string tmp = q.front();
        q.pop();
        
        if(tmp == ed) return cnt;
        if(mp.count(tmp))
            mp.erase(tmp);
```
- **`cnt`**: Keeps track of the number of transformations (levels).
- **BFS Exploration**: For each level, we process all words in the queue.
  - If we encounter the `end` word (`ed`), we return the current count (`cnt`), as we've found the shortest path.
  - If the word is valid (exists in `mp`), we remove it from `mp` to avoid revisiting it.

---

#### 5Ô∏è‚É£ **Generate Word Transformations**
```cpp
for(int j = 0; j < tmp.size(); j++) {
    char c = tmp[j];
    for(int i = 0; i < 26; i++) {
        char c1 = 'a' + i;
        tmp[j] = c1;
        if(mp.count(tmp))
            q.push(tmp);
    }
    tmp[j] = c; // Restore original character
}
```
- **Generate all transformations**: For each word, we try changing each letter one by one, generating up to 26 possible words (one for each letter of the alphabet).
- **Check validity**: If the transformed word exists in the dictionary (`mp.count(tmp)`), it is valid and added to the queue for further exploration.

---

#### 6Ô∏è‚É£ **Increment Level Counter**
```cpp
cnt++;
```
- After processing all words at the current level, we increment the counter (`cnt`) to represent the next level of transformations.

---

#### 7Ô∏è‚É£ **Return 0 if No Path is Found**
```cpp
return 0;
```
- If the BFS completes and we never encounter the `end` word, we return `0`, meaning no valid transformation sequence exists.

---

### üîç **Time and Space Complexity**

- **Time Complexity**: `O(N * M * 26)`
  - `N` is the number of words in the dictionary.
  - `M` is the length of each word.
  - We generate 26 possible transformations for each word and check if they exist in the dictionary.

- **Space Complexity**: `O(N * M)`
  - The space complexity is dominated by the dictionary (`mp`) and the queue (`q`). In the worst case, we need space to store all words and their transformations.

---

### üßë‚Äçüíª **Example Walkthrough**

Let‚Äôs go through the example **`"hit" -> "cog"`** with the dictionary **`["hot", "dot", "dog", "lot", "log", "cog"]`**:

1. **Initial Queue**: Start with `"hit"`.
2. **Level 1**: `hit` ‚Üí `hot`, `dot`.
3. **Level 2**: `hot` ‚Üí `dot` ‚Üí `dog` ‚Üí `lot`.
4. **Level 3**: `dog` ‚Üí `cog` (Found the end word!).
5. **Return**: `5` (Number of transformations).

---

### üèÅ **Conclusion**

Using **Breadth-First Search (BFS)**, we efficiently find the shortest transformation sequence from the `begin` word to the `end` word, ensuring each word in the sequence is valid and only one letter changes at a time. This solution guarantees that the first time we encounter the `end` word, it will be through the shortest transformation sequence. Keep practicing and improving your problem-solving skills! üí™‚ú®

--- 
### Problem Statement

The "Word Ladder" problem is a classic graph-based challenge in which we are given two words, a begin word (`bg`) and an end word (`ed`), and a dictionary of valid words. The goal is to find the shortest transformation sequence from the `begin` word to the `end` word, such that:
- Each transformed word must exist in the dictionary.
- Only one letter can be changed at a time between two consecutive words in the sequence.
- The sequence starts with the `begin` word and ends with the `end` word.

For example:
- **Input**: 
  - `begin = "hit"`
  - `end = "cog"`
  - `list = ["hot", "dot", "dog", "lot", "log", "cog"]`
- **Output**: `5`
  - Explanation: The shortest transformation sequence is `"hit" -> "hot" -> "dot" -> "dog" -> "cog"`, which has a length of 5.

### Approach

The problem can be modeled as a **graph traversal** problem:
- Each word in the dictionary, as well as the start (`bg`) and end (`ed`) words, can be considered as a node in a graph.
- An edge exists between two nodes (words) if you can transform one word into the other by changing exactly one letter.

We can solve this using **Breadth-First Search (BFS)**, which is well-suited for finding the shortest path in an unweighted graph:
1. **Start with the begin word**: The BFS will begin with the start word and attempt to transform it into the end word.
2. **Queue Initialization**: A queue will be used to store words at each level of transformation.
3. **Dictionary Lookup**: A hash map (unordered_map) is used to track valid words and ensure no word is visited more than once.
4. **Level-wise Traversal**: BFS explores each level one by one, transforming each word at the current level to its valid neighbors (words differing by exactly one letter).

Steps:
1. Initialize the dictionary from the list of words, storing each word as a key in a hash map for quick lookup.
2. Use a queue to start BFS with the `begin` word.
3. For each word, attempt to generate all possible valid transformations (i.e., by changing one letter at a time).
4. For each valid transformation, check if it matches the end word, or add it to the queue if it's a valid transformation and hasn't been visited.
5. Track the number of steps using a counter (`cnt`) to represent the number of transformations.
6. If the queue is exhausted and the end word has not been found, return 0, meaning no valid transformation sequence exists.

### Code Breakdown (Step by Step)

#### 1. **Function Definition**
```cpp
int ladderLength(string bg, string ed, vector<string>& list)
```
The function `ladderLength` takes three parameters:
- `bg`: the starting word.
- `ed`: the target word.
- `list`: a list of valid words (dictionary).

#### 2. **Hash Map Initialization**
```cpp
unordered_map<string, bool> mp;
for(string x: list)
    mp[x] = true;
```
- A hash map `mp` is created to store the dictionary of words for fast lookup.
- Each word from the list is inserted into the map, where the word is the key, and the value is `true` (indicating the word exists in the dictionary).

#### 3. **Queue Initialization**
```cpp
queue<string> q;
q.push(bg);
```
- A queue `q` is initialized to hold the current words at each level of transformation.
- The starting word `bg` is pushed into the queue as the first word to process.

#### 4. **BFS Loop**
```cpp
int cnt = 1;
while(!q.empty()) {
    int sz = q.size();
    while(sz--) {
        string tmp = q.front();
        q.pop();
        
        if(tmp == ed) return cnt;
        if(mp.count(tmp))
            mp.erase(tmp);
```
- The variable `cnt` is initialized to `1` (the starting word itself).
- The BFS loop begins, and it continues until the queue is empty.
  - At each level, the size of the queue (`sz`) is noted, representing the number of nodes (words) at that level.
  - Each word is processed one by one (`q.front()`), and it is removed from the queue (`q.pop()`).
  - If the current word `tmp` is equal to the `end` word `ed`, we return the current transformation count `cnt`, as this indicates we've found the shortest transformation sequence.

#### 5. **Word Transformation Generation**
```cpp
for(int j = 0; j < tmp.size(); j++) {
    char c = tmp[j];
    for(int i = 0; i < 26; i++) {
        char c1 = 'a' + i;
        tmp[j] = c1;
        if(mp.count(tmp))
            q.push(tmp);
    }
    tmp[j] = c;
}
```
- For each word `tmp`, we attempt to generate all possible transformations by changing each character one by one.
- For each character in the word, we replace it with each letter from `'a'` to `'z'`.
- If the resulting word exists in the dictionary (`mp.count(tmp)`), it is valid and is added to the queue for processing in the next level.

#### 6. **Update Counter and Continue**
```cpp
cnt++;
```
After processing all words at the current level, the counter `cnt` is incremented to indicate the next level of transformation.

#### 7. **Return Result**
```cpp
return 0;
```
If the queue is exhausted and we have not found the `end` word, return `0`, meaning no valid transformation sequence exists.

### Example Walkthrough

**Example 1**:
- **Input**: 
  - `begin = "hit"`
  - `end = "cog"`
  - `list = ["hot", "dot", "dog", "lot", "log", "cog"]`
- **Step-by-Step**:
  - Initialize queue with `"hit"`.
  - The first transformation level explores `hit` → `hot`, `dot`.
  - The second level explores `hot` → `dot` → `dog` → `lot`.
  - The third level explores `dog` → `cog`.
  - Found `"cog"`, return 5.

**Output**: `5`

### Time Complexity

- **Time Complexity**: `O(N * M * 26)`
  - `N` is the number of words in the dictionary (`list.size()`), and `M` is the length of each word. The `26` factor comes from the fact that for each word, we try to generate up to 26 possible transformations (one for each letter of the alphabet).
  - The worst-case time complexity is proportional to the number of transformations generated for all words.

- **Space Complexity**: `O(N * M)`
  - The space complexity comes from the dictionary (`mp`) and the queue (`q`). In the worst case, the queue will hold all words, and the dictionary will contain all words as keys.

### Conclusion

This solution efficiently solves the "Word Ladder" problem by utilizing a **Breadth-First Search (BFS)** algorithm. By treating the words as nodes in a graph and using BFS to explore the shortest path from the `begin` word to the `end` word, it guarantees that the first time we encounter the `end` word, it will be through the shortest transformation sequence. The use of a queue ensures that each transformation is explored level by level, and the dictionary of words is managed with a hash map for efficient lookups.
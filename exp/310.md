### Problem Statement

The problem asks us to find all the **Minimum Height Trees (MHTs)** in a given undirected graph, represented by `n` nodes and a set of `edges`. A Minimum Height Tree is a tree that has the minimum height, where the height of a tree is defined as the longest path from the root node to any leaf node.

In this problem:
- The tree has `n` nodes numbered from `0` to `n-1`.
- The graph is connected, and every edge connects two distinct nodes.
- You are tasked with returning a list of **root nodes** of all Minimum Height Trees.

### Approach

#### **Key Insights**

1. **Tree Characteristics**: In a tree, there is a unique path between any two nodes. The height of the tree depends on the distance from the root node to the farthest leaf node. To minimize the height, we should aim to find the "center" of the tree, which balances the longest paths to the leaves. A **center** of a tree is typically one or two nodes that, when chosen as roots, minimize the height of the tree.

2. **Layered Removal of Leaves**: One effective approach to finding the center(s) of a tree is to use a method that gradually removes leaves (nodes with only one edge). After removing all leaves, the remaining nodes are the center(s) of the tree, and the height of the tree will be minimized with those nodes as the root.

3. **BFS for Layered Removal**: By using a breadth-first search (BFS) approach, we can efficiently eliminate the leaves layer by layer until we are left with the center nodes. This approach works because the nodes that remain after removing leaves are the ones closest to the "core" of the tree, which are the centers.

#### **Steps to Solve the Problem**:

1. **Build the Adjacency List**: First, build an adjacency list to represent the graph from the given `edges`. This adjacency list will help us track the neighbors of each node.

2. **Track Node Degrees**: Use an array `degree` to keep track of the degree (i.e., number of neighbors) of each node. Initially, the degree of each node is the number of edges connected to that node.

3. **Identify Initial Leaves**: Any node with degree 1 is a leaf node. Push all such nodes into a queue.

4. **Remove Leaves Layer by Layer**: Begin removing leaves from the tree layer by layer using a BFS-style traversal. For each leaf node, decrease the degree of its neighbors. If any neighbor's degree becomes 1 (indicating it is now a leaf), add it to the queue. Repeat this process until there are 1 or 2 nodes left.

5. **Return the Centers**: The remaining nodes in the queue are the centers of the tree. These nodes will form the roots of the Minimum Height Trees.

### Code Breakdown (Step by Step)

1. **Edge Case for Single Node**:
```cpp
if(n == 1) return {0};
```
- If there is only one node in the tree, it is trivially the root of the tree and the only possible Minimum Height Tree.

2. **Building the Adjacency List**:
```cpp
vector<vector<int>> adj(n);
vector<int> degree(n, 0);
for(auto e: edges) {
    adj[e[0]].push_back(e[1]);
    adj[e[1]].push_back(e[0]);
    degree[e[0]]++;
    degree[e[1]]++;
}
```
- We first initialize an adjacency list `adj` to represent the graph and an array `degree` to store the degree of each node.
- For each edge in the `edges` array, we update the adjacency list and the degree of the nodes that the edge connects.

3. **Initializing the Queue with Leaves**:
```cpp
queue<int> q;
for(int i = 0; i < n; i++)
    if(degree[i] == 1)
        q.push(i);
```
- We identify the leaf nodes by checking which nodes have a degree of 1. These nodes are pushed into the queue `q` for processing.

4. **Layered Removal of Leaves**:
```cpp
vector<int> res;

while(!q.empty()) {
    res.clear();
    int sz = q.size();
    while(sz--) {
        int tmp = q.front();
        q.pop();
        res.push_back(tmp);
        for(auto nbr: adj[tmp]) {
            degree[nbr]--;
            if(degree[nbr] == 1)
                q.push(nbr);
        }
    }
}
```
- We process the nodes in the queue layer by layer. At each step, we remove a leaf node (from the front of the queue), and for each of its neighbors, we reduce its degree by 1.
- If any neighbor's degree becomes 1 (indicating it is now a leaf), it is added to the queue for the next round of processing.
- The `res` vector stores the current set of leaf nodes being removed.

5. **Return the Centers**:
```cpp
return res;
```
- Once all leaves have been removed, the remaining nodes in the `res` vector represent the centers of the tree. These nodes will minimize the height of the tree when used as the root.

### Complexity

#### **Time Complexity**:
The time complexity is **O(n)**, where `n` is the number of nodes in the tree. This is because:
- We process each node once when building the adjacency list and calculating the degrees.
- Each node is also processed once during the BFS traversal when removing leaves.

Thus, the overall complexity is linear in terms of the number of nodes.

#### **Space Complexity**:
The space complexity is **O(n)** because we are using:
- An adjacency list of size `n` to store the graph.
- A `degree` array of size `n` to track the degree of each node.
- A queue to store the leaf nodes, which at most contains `n` nodes at any point in time.

### Conclusion

This solution efficiently finds the **Minimum Height Trees (MHTs)** by gradually peeling away the leaf nodes of the tree until the center nodes are found. Using BFS for the layered removal of leaves ensures that we find the centers in an optimal way, with a time complexity of **O(n)**. The solution is well-suited for large graphs, as it processes each node and edge only a limited number of times.

Key Takeaways:
1. **Layered BFS**: The core idea behind this solution is to remove leaves layer by layer until we are left with the center(s) of the tree.
2. **Efficient Search**: This approach guarantees that we find the centers of the tree with a time complexity of **O(n)**, making it scalable for large trees.
3. **Tree Properties**: The solution exploits the properties of trees, specifically the fact that the center of a tree minimizes its height, to provide an optimal result.
### Problem Statement

The problem at hand is to find the largest value in each level of a binary tree. Given a binary tree, we are tasked with returning a list of integers where each integer corresponds to the largest value found in each level of the tree.

For example, for the binary tree:

```
         1
        / \
       3   2
      / \   \
     5   3   9
```

The output should be `[1, 3, 9]`, as:
- Level 1 has only the node `1`.
- Level 2 has the nodes `3` and `2`, with the largest value being `3`.
- Level 3 has the nodes `5`, `3`, and `9`, with the largest value being `9`.

### Approach

To solve this problem, we can use a **breadth-first search (BFS)** approach, where we traverse the tree level by level. The idea is to traverse the tree starting from the root node, and for each level, we keep track of the largest value. The BFS is ideal for this scenario because it naturally processes nodes level by level.

Hereâ€™s a step-by-step explanation of the approach:

1. **Breadth-First Search (BFS)**: We use a queue to store the nodes of the tree. The queue helps in processing nodes level by level. We start by pushing the root node into the queue.
   
2. **Iterate Through Levels**: For each level of the tree, we:
   - Track the number of nodes at that level (`sz`).
   - Traverse all nodes at the current level and find the maximum value.
   - If a node has left or right children, push those children into the queue to be processed in the next level.
   
3. **Store Maximum Value for Each Level**: After processing all nodes in a level, we store the largest value of that level.

4. **Return Result**: After all levels are processed, the result is a list of maximum values for each level of the tree.

### Code Breakdown (Step by Step)

The solution uses a breadth-first search to process the tree level by level and track the largest values for each level:

1. **Initialize a Queue and Result Vector**:
   ```cpp
   queue<TreeNode*> q;
   vector<int> res;
   if(!root) return res;
   q.push(root);
   ```
   - We initialize a queue `q` that will hold the nodes to be processed.
   - The `res` vector is used to store the largest value at each level.
   - If the tree is empty (i.e., the root is `nullptr`), we return an empty result.

2. **Process Each Level**:
   ```cpp
   while(!q.empty()) {
       int sz = q.size();
       mx = INT_MIN;
   ```
   - We enter a loop that processes each level of the tree. The variable `sz` holds the number of nodes in the current level.
   - `mx` is initialized to `INT_MIN` to keep track of the maximum value at the current level.

3. **Process Nodes at Current Level**:
   ```cpp
   while(sz-- > 0) {
       root = q.front();
       q.pop();
       mx = max(mx, root->val);
       if(root->left)  q.push(root->left);
       if(root->right) q.push(root->right);
   }
   ```
   - We process each node at the current level by popping it from the front of the queue.
   - For each node, we compare its value with `mx` to track the maximum value at the current level.
   - If the node has a left or right child, we push them into the queue for processing in the next level.

4. **Store Maximum Value for the Current Level**:
   ```cpp
   res.push_back(mx);
   ```
   - After processing all nodes at the current level, we push the maximum value found (`mx`) into the `res` vector.

5. **Return the Result**:
   ```cpp
   return res;
   ```
   - Once all levels have been processed, we return the `res` vector, which contains the largest values for each level of the tree.

### Complexity

#### Time Complexity:
- **O(n)**: We traverse each node of the tree exactly once, and at each node, we perform constant-time operations such as comparing values and enqueuing child nodes. Here `n` is the number of nodes in the tree.

#### Space Complexity:
- **O(n)**: In the worst case, the queue will contain all nodes at the last level of the tree. In a balanced binary tree, this would be roughly `n / 2` nodes, but in the worst case (e.g., a skewed tree), it could contain up to `n` nodes.

### Conclusion

In conclusion, this solution efficiently computes the largest value at each level of a binary tree using a breadth-first search (BFS) approach. The BFS ensures that we process each level of the tree sequentially, and by tracking the largest value in each level, we can build the result in linear time and space. This approach is optimal and well-suited for problems involving tree traversal where levels and node relationships are crucial, such as in binary tree level-order traversals. 

This solution is both time-efficient and space-efficient, making it a great choice for handling large binary trees where we need to compute level-based information, such as finding the largest values at each level.
### Problem Statement
Given a binary tree where each node represents the number of coins it has, distribute the coins such that each node has exactly one coin. Minimize the total number of moves, where a move is transferring a coin between two adjacent nodes.

### Approach
1. **Recursive Postorder Traversal**:
   - Use postorder traversal to calculate the balance of coins for each node.
   - Define a helper function `move` that recursively calculates the number of coins needed or in excess for each subtree.
   
2. **Move Calculation**:
   - For each node, calculate the moves required to balance its left and right subtrees.
   - Accumulate these moves in a class member variable `mv` to get the total number of moves.

3. **Returning Balance**:
   - For each node, return the net balance of coins: `(nodeâ€™s value + left balance + right balance - 1)`.
   - This result allows the parent node to know if it needs to move coins into or out of this node to balance the tree.

### Code Walk-through
1. **`distributeCoins` Method**:
   - Initializes `mv` to track moves and calls `move` to start the recursive balancing.

2. **`move` Helper Function**:
   - For each node, recursively calls `move` on left and right children to get their balances.
   - Updates `mv` with the total number of moves needed to balance left and right subtrees.
   - Returns the balance for the current node.

### Complexity
- **Time Complexity**: O(n), where `n` is the number of nodes in the tree, since each node is visited once.
- **Space Complexity**: O(h), where `h` is the height of the tree, due to the recursive call stack.

### Problem Statement

In this problem, we are given a binary tree where each node has a value representing the number of coins in that node. The goal is to distribute the coins across the tree such that each node ends up with exactly one coin. To achieve this, we are allowed to move coins between the nodes. A move consists of transferring a coin from a node to its parent or child node. The objective is to find the **minimum number of moves** required to achieve the desired state, where each node has exactly one coin.

### Approach

The problem can be solved efficiently using a **depth-first search (DFS)** traversal of the tree, combined with a recursive function to compute the required moves.

#### Key Insights:
1. **Problem Restatement**:
   - Each node must end with exactly one coin. If a node has more than one coin, it needs to give some coins to its children. If a node has fewer than one coin, it needs to receive coins from its children.
   
2. **Recursive Strategy**:
   - The solution works by recursively calculating how many coins need to be moved between nodes to achieve the target state (one coin per node).
   - For any given node, the number of coins to move depends on its left and right subtrees. Specifically:
     - If the left subtree has a surplus or deficit of coins, it contributes to the moves required to balance the current node.
     - Similarly, the right subtree contributes as well.
   
3. **Moves Calculation**:
   - For each node, we first calculate the number of coins that need to be moved to balance the left and right subtrees.
   - After the recursive call, the result for each subtree is the number of extra or missing coins that need to be moved. The result is calculated using the formula:
     ```cpp
     r->val + left + right - 1
     ```
   - The number of moves for each subtree is the **absolute sum** of extra or missing coins for both subtrees, and we accumulate this value to track the total moves.

4. **Accumulating Moves**:
   - As we traverse the tree, we update the `mv` variable to accumulate the total number of moves required. At each node, we add the absolute values of the moves required for the left and right subtrees.

5. **Base Case**:
   - If a node is `nullptr`, the function returns `0` as it doesn't require any coins to be moved.

### Code Breakdown (Step by Step)

#### 1. **TreeNode Structure**:
   - The problem defines the `TreeNode` structure, which has three properties:
     - `val`: The number of coins in the node.
     - `left`: Pointer to the left child node.
     - `right`: Pointer to the right child node.

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```

#### 2. **Solution Class**:
   - The `Solution` class has a public method `distributeCoins` that takes the root of the binary tree as input and returns the minimum number of moves required.

```cpp
class Solution {
    int mv;
public:
    int distributeCoins(TreeNode* root) {
        mv = 0;  // Initialize the move counter
        move(root, mv);  // Call the recursive function to compute moves
        return mv;  // Return the total number of moves
    }
```

#### 3. **Move Function (Recursive DFS)**:
   - The `move` function performs a depth-first search on the tree, starting from the root.
   - For each node, it calculates the number of coins that need to be moved from the left and right subtrees to balance the current node.

```cpp
    int move(TreeNode* r, int & mv) {
        if(r == nullptr) return 0;  // Base case: return 0 if the node is null
```

- **Base Case**: If the node is `nullptr`, the function returns `0` because no coins need to be moved in this case.

```cpp
        int left = move(r->left, mv);  // Calculate moves for the left subtree
        int right = move(r->right, mv);  // Calculate moves for the right subtree
        mv += abs(left) + abs(right);  // Add the moves from both subtrees to the total
```

- **Recursive Call**: The function recursively calls itself for the left and right child nodes. The result of these calls is the number of coins that need to be moved from the respective subtrees.
- **Accumulating Moves**: The `abs(left)` and `abs(right)` values represent the number of extra or missing coins in the left and right subtrees. These are added to the total move counter `mv`.

```cpp
        return r->val + left + right - 1;  // Return the number of coins at the current node, after accounting for the left and right subtrees
    }
};
```

- **Returning Value**: The function returns the number of coins that the current node has after accounting for the left and right subtrees. This is calculated by adding the number of coins in the node (`r->val`) and the total excess or deficit from the left and right subtrees. The subtraction of `1` accounts for the fact that the node itself needs exactly one coin.

### Complexity

- **Time Complexity**: 
  - The time complexity of this solution is **O(n)**, where `n` is the number of nodes in the binary tree. This is because we visit each node exactly once during the depth-first traversal.
  - Each recursive call performs constant work (calculating distances, accumulating moves), making the overall time complexity linear in terms of the number of nodes.

- **Space Complexity**:
  - The space complexity is **O(h)**, where `h` is the height of the binary tree. This is due to the space used by the recursive call stack during the depth-first traversal. In the worst case, when the tree is skewed, the height `h` could be equal to `n`, making the space complexity **O(n)**.

### Conclusion

The `distributeCoins` function efficiently calculates the minimum number of moves required to distribute the coins in a binary tree such that each node has exactly one coin. The solution leverages a depth-first search (DFS) strategy to recursively traverse the tree and compute the moves needed for the left and right subtrees. By using a simple recursive approach and efficiently calculating the number of coins to move, the solution is optimal in terms of time and space complexity.

This approach ensures that the solution works in linear time and is well-suited for large binary trees. The simplicity and elegance of the DFS solution make it an effective approach for this type of problem.
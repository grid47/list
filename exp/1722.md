### Problem Statement

The problem at hand involves determining the minimum Hamming distance between two integer arrays, `src` and `dst`. A Hamming distance measures the number of positions at which the corresponding elements of two arrays are different. Given a series of swaps defined by a 2D array `swp`, where each entry specifies two indices of `src` that can be swapped, the goal is to calculate the minimum Hamming distance after performing all possible swaps.

### Approach

To solve the problem, we can use the Disjoint Set Union (DSU) data structure, also known as Union-Find. The primary steps involved in the approach are as follows:

1. **Initialize Union-Find Structure**: We will maintain two arrays: `parent` for tracking the parent of each element and `rnk` (rank) for keeping the tree flat during union operations.

2. **Union Operations**: For each swap operation defined in the `swp` array, we will perform a union operation to group the elements that can be swapped.

3. **Count Elements in Each Component**: After processing all swaps, we will count how many times each value appears in each connected component of the `src` array.

4. **Calculate Minimum Hamming Distance**: Finally, we will iterate through the `dst` array and check if each element can be matched with the count from the corresponding component in `src`. If a value from `dst` cannot be matched with the corresponding component's counts, it contributes to the Hamming distance.

### Code Breakdown (Step by Step)

Hereâ€™s a detailed breakdown of the code implementation:

1. **Class Definition**: The solution is encapsulated in the `Solution` class.

   ```cpp
   class Solution {
       vector<int> parent, rnk;
   ```

2. **Public Method**: The `minimumHammingDistance` method is defined, taking three parameters: `src`, `dst`, and `swp`.

   ```cpp
   public:
       int minimumHammingDistance(vector<int>& src, vector<int>& dst, vector<vector<int>>& swp) {
   ```

3. **Initialization**: The size of `src` (and `dst`) is stored in `n`. Two vectors, `parent` and `rnk`, are resized to hold the parent and rank information for the union-find structure. Each element is initialized to point to itself.

   ```cpp
   int n = src.size();
   parent.resize(n, 0);
   rnk.resize(n, 0);
   for(int i = 0; i < n; i++) {
       parent[i] = i;
   }
   ```

4. **Union-Find Logic**: For each swap operation defined in `swp`, we determine the roots of the two indices to be swapped using the `find` method. If the roots are different, we perform a union operation based on their ranks to maintain a balanced tree.

   ```cpp
   for(vector<int> s: swp) {
       int x = find(s[0]);
       int y = find(s[1]);
       if(rnk[x] < rnk[y]) {
           parent[x] = y;
           rnk[y]++;
       } else {
           parent[y] = x;
           rnk[x]++;                
       }
   }
   ```

5. **Count Values in Components**: We utilize an unordered map to store the count of each value in the corresponding component identified by its root.

   ```cpp
   unordered_map<int, unordered_map<int, int>> mp;
   for(int i = 0; i < n; i++) {
       int p = find(i);
       auto &m = mp[p];
       m[src[i]]++;
   }
   ```

6. **Calculate the Result**: We initialize a counter `res` to keep track of the minimum Hamming distance. For each element in `dst`, we check if it exists in the component's count map and decrement its count. If the count becomes less than or equal to zero, it means that this value cannot be matched, and we increment the Hamming distance counter.

   ```cpp
   int res = 0;
   for(int i = 0; i < n; i++) {
       int p = find(i);
       auto &m = mp[p];
       if((m[dst[i]]--) <= 0) {
           res += 1;
       }
   }
   ```

7. **Return the Result**: Finally, we return the calculated minimum Hamming distance.

   ```cpp
   return res;
   }
   ```

8. **Find Method**: The `find` method is implemented to perform path compression, making future queries faster by ensuring that all nodes directly point to the root.

   ```cpp
   int find(int x) {
       int y = parent[x];
       if(y != x) {
           parent[x] = find(y);
       }
       return parent[x];
   }
   ```

### Complexity

- **Time Complexity**: The time complexity is \( O(n + m \cdot \alpha(n)) \), where \( n \) is the size of the arrays and \( m \) is the number of swaps. Here, \( \alpha \) is the inverse Ackermann function, which grows very slowly, making this nearly linear in practice.

- **Space Complexity**: The space complexity is \( O(n) \) due to the additional space used for the parent and rank arrays, as well as the unordered map for counting occurrences.

### Conclusion

In summary, the code efficiently calculates the minimum Hamming distance between two integer arrays while considering possible swaps. The implementation leverages the Disjoint Set Union (DSU) data structure to group indices that can be swapped, thus allowing for an efficient counting of matches between `src` and `dst`.

This solution is not only effective but also well-structured, demonstrating a clear understanding of union-find operations and their applications in problems involving connectivity and grouping. The approach ensures that we minimize the number of differences between the two arrays, optimizing the Hamming distance calculation. By maintaining clarity and modularity in the code, it is easy to follow and adaptable to similar problems involving array manipulation and component analysis.
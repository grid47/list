### Problem Statement

The problem asks whether it is possible to transform the pair of integers `(x, y)` into `(1, 1)` using the following operations:

1. If `x` is even, divide `x` by 2.
2. If `y` is even, divide `y` by 2.
3. If `x > y`, subtract `y` from `x`.
4. If `x < y`, subtract `x` from `y`.

You need to determine whether it's possible to apply these operations repeatedly until you reach `(1, 1)`.

### Approach

The solution can be approached recursively. The key insight is that, at each step, we are reducing either `x` or `y` by halving or subtracting. We continue performing these operations until we either reach `(1, 1)` or determine that it's impossible to do so.

1. **Base Case**:
   - If `x == 1` and `y == 1`, we return `true`, as this means we've reached the target.

2. **Recursive Case**:
   - If `y` is even, divide `y` by 2 and call the function recursively with the updated values of `x` and `y`.
   - If `x` is even, divide `x` by 2 and call the function recursively with the updated values of `x` and `y`.
   - If `x > y`, subtract `y` from `x` and call the function recursively with the updated values.
   - If `x < y`, subtract `x` from `y` and call the function recursively with the updated values.
   - If no condition applies, return `false`.

This approach ensures that we reduce the numbers by halving or subtracting, moving toward the goal of reaching `(1, 1)`.

### Code Breakdown (Step by Step)

#### Step 1: Base Case
```cpp
if(x == 1 && y == 1) return true;
```
The first line checks if both `x` and `y` are `1`, in which case we return `true` because we have reached the destination `(1, 1)`.

#### Step 2: Recursive Cases
##### Case 1: If `y` is even
```cpp
if(y % 2 == 0) return isReachable(x, y / 2);
```
Here, if `y` is even, we can divide `y` by 2 and call the function recursively with the updated `y`. This reduces the value of `y` while keeping `x` unchanged.

##### Case 2: If `x` is even
```cpp
if(x % 2 == 0) return isReachable(x / 2, y);
```
If `x` is even, we divide `x` by 2 and call the function recursively with the updated `x`. This reduces the value of `x` while keeping `y` unchanged.

##### Case 3: If `x > y`
```cpp
if(x > y) return isReachable(x - y, y);
```
If `x` is greater than `y`, we subtract `y` from `x` and call the function recursively with the new values of `x` and `y`. This brings `x` closer to `y`.

##### Case 4: If `x < y`
```cpp
if(x < y) return isReachable(x, y - x);
```
If `x` is less than `y`, we subtract `x` from `y` and call the function recursively with the updated values of `x` and `y`. This brings `y` closer to `x`.

#### Step 3: If No Conditions Apply
```cpp
return ans;
```
If none of the above conditions are met, we return `false`, indicating that it's impossible to reach `(1, 1)` from `(x, y)` using the given operations.

### Complexity Analysis

#### Time Complexity:
The time complexity of this solution depends on the number of recursive calls, which is determined by how much we reduce `x` and `y` in each step.

- **Dividing by 2**: Every time we divide either `x` or `y` by 2, we are halving one of the numbers. In the worst case, this will take `O(log max(x, y))` steps because dividing by 2 reduces the value exponentially.
- **Subtracting values**: If we subtract one number from the other (i.e., when `x > y` or `x < y`), the number of recursive calls depends on how much the difference between `x` and `y` reduces. In the worst case, the difference will reduce linearly.

In general, the time complexity of this recursive approach can be approximated as `O(log max(x, y))` for the halving cases. However, when subtraction occurs, the time complexity can be worse in cases where the difference between `x` and `y` is large. In the worst case, the complexity may approach `O(x + y)`.

#### Space Complexity:
The space complexity of the solution is dominated by the recursion depth. In the worst case, the depth of recursion is proportional to the logarithm of the larger number, so the space complexity is `O(log max(x, y))`.

### Conclusion

The solution efficiently checks whether it's possible to reach `(1, 1)` from `(x, y)` by performing a series of operations, including halving and subtracting. By recursively reducing the values of `x` and `y`, the function quickly narrows down the problem. The algorithm is efficient in terms of both time and space, with a time complexity of approximately `O(log max(x, y))` and a space complexity of `O(log max(x, y))`.
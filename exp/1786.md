### Problem Statement

The problem at hand is to find the number of restricted paths from a starting node to an ending node in a weighted undirected graph. A path is considered restricted if each subsequent node along the path has a strictly greater distance from the starting node than the previous one. The goal is to compute the number of such paths from node `n` to node `1` in the graph defined by a list of edges.

**Key Points:**
- We have a graph with `n` nodes and a list of edges defined by their endpoints and weights.
- The task is to count the number of paths from node `n` to node `1` where each node in the path has a distance greater than the previous node.

### Approach

To solve this problem, we employ a combination of Dijkstra's algorithm and Depth First Search (DFS). The steps are as follows:

1. **Graph Representation**: We represent the graph using an adjacency list, where each edge is stored along with its weight.

2. **Dijkstra's Algorithm**: We use Dijkstra's algorithm to compute the shortest distance from node `n` to all other nodes. This will allow us to determine the distances needed to verify if a path is restricted.

3. **DFS for Path Counting**: We perform a DFS starting from node `n` and count the number of valid restricted paths to node `1`. In this DFS, we check the distances to ensure that we only traverse to nodes that are farther away from node `n`.

4. **Memoization**: To optimize the DFS, we utilize memoization to store the results of subproblems (i.e., the number of paths from any node to node `1`), preventing redundant calculations.

### Code Breakdown (Step by Step)

```cpp
#define pii pair<int, int>
```
- We define a shorthand `pii` for a pair of integers to improve code readability, particularly when dealing with edges represented as pairs of nodes and weights.

```cpp
class Solution {
public:
    int countRestrictedPaths(int n, vector<vector<int>>& es) {
```
- We define a class `Solution` with a public method `countRestrictedPaths` that takes the number of nodes `n` and a vector of edges `es`.

```cpp
        vector<vector<pii>> gph(n + 1);
        for(int i = 0; i < es.size(); i++) {
            int u = es[i][0], v = es[i][1], d = es[i][2];
            gph[u].push_back({d, v});
            gph[v].push_back({d, u});
        }
```
- We create an adjacency list `gph` to represent the graph. For each edge, we store both directions (from `u` to `v` and from `v` to `u`), with their corresponding weights.

```cpp
        vector<int> dst(n + 1, INT_MAX);
        priority_queue<pii, vector<pii>, greater<>> pq;
        pq.push({0, n});
        dst[n] = 0;
```
- We initialize a distance array `dst` to track the shortest distances from node `n`, setting all distances to infinity initially.
- We utilize a priority queue to facilitate the execution of Dijkstra's algorithm. We start by pushing the source node `n` with a distance of `0`.

```cpp
        while(!pq.empty()) {
            auto [d, u] = pq.top();
            pq.pop();
```
- We process the nodes in the priority queue until it is empty, always extracting the node with the shortest distance.

```cpp
            for(auto & x: gph[u]) {
                int nxt = x.second, t = x.first;
                
                if(dst[nxt] > t + d) {
                    dst[nxt] = t + d;
                    pq.push({t + d, nxt});
                }
            }
        }
```
- For each neighboring node `nxt` of the current node `u`, we check if we can find a shorter path to `nxt`. If we can, we update its distance and push it onto the priority queue.

```cpp
        vector<int> dp(n + 1, -1);
        return dfs(gph, dst, n, dp);
    }
```
- After computing the shortest paths, we initialize a memoization array `dp` to store results of subproblems and call the `dfs` function to count the restricted paths from node `n`.

```cpp
    int dfs(vector<vector<pii>> &gph, vector<int> &dst, int s, vector<int> &dp) {
        if (s == 1) return 1;
        if (dp[s] != -1) return dp[s];
        
        int mod = 1e9 + 7;
        int sum = 0, w = 0, val = 0;
```
- The `dfs` function checks if the current node `s` is node `1`, in which case we return `1` since we've found a valid path. If we have already computed the number of paths from `s`, we return that value.
- We initialize the modulo value to handle large results, as the answer can exceed the typical integer range.

```cpp
        for(auto &v : gph[s]) {
            w = dst[s];
            val = dst[v.second];
            if (val > w) {
                sum = (sum % mod + dfs(gph, dst, v.second, dp) % mod) % mod;
            }
        }
```
- We iterate through the neighbors of the current node `s`. For each neighbor, we compare its distance to ensure we only consider paths where the next node is further away. We recursively call `dfs` for valid neighbors to count paths.

```cpp
        return dp[s] = sum % mod;
    }
};
```
- Finally, we store the computed number of restricted paths from node `s` in the memoization array and return it.

### Complexity

- **Time Complexity**:
  - Dijkstra's algorithm runs in \(O((n + e) \log n)\), where \(e\) is the number of edges. The subsequent DFS runs in \(O(n + e)\), leading to a combined time complexity of \(O((n + e) \log n)\).

- **Space Complexity**:
  - The space complexity is \(O(n + e)\) for the graph representation, plus \(O(n)\) for the distance and memoization arrays, resulting in a total space complexity of \(O(n + e)\).

### Conclusion

This solution effectively combines Dijkstra's algorithm and depth-first search to count the number of restricted paths in a graph, demonstrating the power of graph theory and dynamic programming. By utilizing memoization, the algorithm ensures efficient computation while preventing redundant calculations.

This approach can be applied to similar problems in graph theory where pathfinding and distance constraints play a crucial role. The code not only serves as a solution to the specific problem but also provides a framework for understanding and tackling more complex graph-related challenges in competitive programming and algorithm design. By mastering these techniques, developers can enhance their problem-solving toolkit and improve their proficiency in algorithmic thinking.
### Problem Statement

The problem asks us to implement a function `myAtoi(string s)` that converts a string representing a valid integer to an actual integer (i.e., parses the string as an integer). The string can contain leading spaces, an optional '+' or '-' sign, and numeric characters. If the string is not a valid representation of an integer, we return `0`. Additionally, the function must handle edge cases such as:
- Overflowing or underflowing the 32-bit signed integer range (`[-2147483648, 2147483647]`).
- Ignoring non-numeric characters after the valid numeric portion of the string.

### Example:

1. `myAtoi("42")` → `42`
2. `myAtoi("   -42")` → `-42`
3. `myAtoi("4193 with words")` → `4193`
4. `myAtoi("words and 987")` → `0`
5. `myAtoi("-91283472332")` → `-2147483648` (since it overflows)

### Approach

The problem can be solved in several steps:
1. **Skip Leading Whitespaces**: First, we need to skip any leading spaces in the input string.
2. **Check for an Optional Sign**: Next, check if the number has a sign (either '+' or '-') and record the sign.
3. **Convert the String to Integer**: We then process the characters of the string, converting digits into an integer.
4. **Overflow and Underflow Checks**: During the conversion, we must check if the result overflows or underflows the 32-bit integer range.
5. **Return the Result**: Finally, return the result, adjusting for the sign.

The solution follows a greedy approach, processing one character at a time and building the result step by step.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables

```cpp
int res = 0;
int sgn = 1;
int i = 0;
```

- `res`: This will store the result, initialized to `0`.
- `sgn`: This stores the sign of the number, initialized to `1` (positive).
- `i`: A pointer or index to traverse through the string, initialized to `0`.

#### Step 2: Skip Leading Whitespaces

```cpp
while(i < s.size() && s[i] == ' ') i++;
```

- This loop moves the index `i` forward until it skips all leading spaces in the input string. It ensures that the conversion starts from the first non-space character.

#### Step 3: Handle Optional Sign

```cpp
if(i < s.size() && (s[i] == '+' || s[i] == '-'))
    sgn = (s[i++] == '+') ? 1 : -1;
```

- If the current character is either a '+' or a '-', we set the sign (`sgn`) to `1` for positive or `-1` for negative. The `i++` increments `i` to skip over the sign.
- The condition `s[i++] == '+'` checks whether the current character is a '+' (if true, `sgn` remains `1`), otherwise, it sets `sgn` to `-1` for a negative number.

#### Step 4: Convert the String to Integer

```cpp
while(i < s.size() && s[i] >= '0' && s[i] <= '9') {
    if(res > INT_MAX / 10 || (res == INT_MAX / 10 && ((s[i] - '0') > (INT_MAX % 10))))
        return (sgn > 0) ? INT_MAX : INT_MIN;
        
    res = res * 10 + (s[i++] - '0');
}
```

- This loop runs while the current character is a digit (i.e., between '0' and '9').
- The first `if` condition checks if the current value of `res` exceeds the 32-bit integer limit upon adding the next digit. If adding the digit would cause an overflow or underflow:
  - If `res > INT_MAX / 10`, multiplying `res` by 10 would overflow.
  - If `res == INT_MAX / 10` and the next digit is greater than `INT_MAX % 10`, the result would exceed the maximum value.
  - Similarly, for negative numbers, we check for underflow.
- If no overflow/underflow occurs, we update the result by multiplying `res` by `10` and adding the current digit `s[i] - '0'`.

#### Step 5: Return the Final Result

```cpp
return sgn * res;
```

- Finally, we return the result multiplied by the sign (`sgn`) to account for the negative numbers. If the sign was negative, `sgn` is `-1`, and the result will be negative.

### Complexity

#### Time Complexity:
- The time complexity is **O(n)**, where `n` is the length of the string `s`. We only iterate through the string once, processing each character in constant time.

#### Space Complexity:
- The space complexity is **O(1)** because we only use a constant amount of extra space, regardless of the size of the input string.

### Conclusion

The solution to the `myAtoi` problem effectively handles all the required edge cases, such as:
- Leading and trailing spaces.
- Optional sign characters.
- Valid and invalid numerical characters.
- Integer overflow and underflow.

The function processes the string in a single pass, making it both time-efficient and space-efficient. By using simple arithmetic and comparisons, it ensures that the result remains within the bounds of a 32-bit signed integer. If any overflow or underflow condition is detected, it immediately returns the appropriate boundary value, `INT_MAX` or `INT_MIN`.
### ðŸš€ Problem Statement

In this problem, we're given a **2D grid of characters** and a list of **words**. The task is to find all the words from the list that can be formed by connecting adjacent letters in the grid (horizontally or vertically). Each letter in the grid can only be used once per word, and the goal is to efficiently search and find all the valid words.

---

### ðŸ§  Approach

To solve this, we can combine two powerful techniques:

- **Trie (Prefix Tree)**: This helps us efficiently search for words and prune paths that won't lead to valid words.
- **Depth-First Search (DFS)**: We'll use DFS to explore all possible word paths starting from each cell in the grid, while backtracking to ensure that no letter is reused in a word.

**Key Concepts:**
- **Trie**: The Trie allows us to store all words in the list, where each node represents a character. It provides fast prefix matching and helps us quickly check if the current path in the grid forms a valid prefix of any word.
- **DFS**: Starting from each grid cell, DFS explores all four directions (up, down, left, right). During this traversal, we check if a word is formed by following the characters and whether the path is still valid in the Trie.
- **Backtracking**: To ensure that each letter in the grid is only used once, we temporarily mark cells as visited and backtrack when done exploring.

---

### ðŸ”¨ Step-by-Step Code Breakdown

#### 1. **Trie Node Definition**

The first part is defining the structure of each node in our **Trie**.

```cpp
class Node {
public:
    char val;
    bool isWord;
    string word;
    vector<Node*> next;
    Node(char val, bool isWord) {
        this->val = val;
        this->isWord = isWord;
        next.resize(26, NULL);
    }
};
```

- **val**: Stores the character at the node.
- **isWord**: A flag that indicates if the current node represents the end of a valid word.
- **word**: Stores the word that ends at this node (only if `isWord` is `true`).
- **next**: A vector of 26 pointers for each letter of the alphabet, representing possible next characters.

---

#### 2. **Building the Trie**

Now, we insert all the words into the Trie:

```cpp
for(string w: words) {
    node = root;
    for(char x: w) {
        int c = x - 'a'; 
        if(node->next[c] == NULL)
            node->next[c] = new Node(x, false);
        node = node->next[c];
    }
    node->word = w;
    node->isWord = true;
}
```

- For each word, we traverse the Trie, creating nodes for each character.
- After processing the word, we mark the last node as representing the end of a word and store the word at that node.

---

#### 3. **DFS Traversal**

Next, we define the **DFS function** to explore the grid:

```cpp
void dfs(vector<string> &ans, Node* node, int i, int j) {
    char c = grid[i][j];
    
    if(c == '#' || node->next[c - 'a'] == NULL)
        return;
    
    node = node->next[c - 'a'];
    if(node->isWord) {
        ans.push_back(node->word);
        node->isWord = false;  // Avoid duplicates
    }
    grid[i][j] = '#';  // Mark the cell as visited.
    int dir[] = {0, 1, 0, -1, 0};
    for(int k = 0; k < 4; k++) {
        int x = i + dir[k], y = j + dir[k + 1];
        if(x < 0 || y < 0 || x == m || y == n)
            continue;
        dfs(ans, node, x, y);
    }
    grid[i][j] = c;  // Restore the cell after exploration.
}
```

- **DFS** starts from each valid cell, marking it as visited (by setting it to `#`).
- If we find a valid word (by checking `node->isWord`), we add it to the result list.
- We then explore all 4 adjacent cells recursively.

---

#### 4. **Main Function to Find Words**

Finally, we define the main function to set up the grid and call DFS:

```cpp
vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
    this->m = board.size(), this->n = board[0].size();
    this->grid = board;
    root = new Node(' ', false);
    Node* node;
    for(string w: words) {
        node = root;
        for(char x: w) {
            int c = x - 'a';
            if(node->next[c] == NULL)
                node->next[c] = new Node(x, false);
            node = node->next[c];
        }
        node->word = w;
        node->isWord = true;
    }
    
    vector<string> ans;
    for(int i = 0; i < m; i++)
        for(int j = 0; j < n; j++)
            dfs(ans, root, i, j);
    
    return ans;
}
```

- The grid is initialized, and we build the Trie from the list of words.
- We start DFS from every cell in the grid. If a word is found, it is added to the result list.

---

### ðŸ“ˆ Complexity Analysis

#### Time Complexity:
- **Trie Construction**: For each word in the list `words` (with `W` words and average length `L`), we insert each character into the Trie. This gives a time complexity of **O(W * L)**.
- **DFS Traversal**: In the worst case, we perform DFS from each cell of the grid, exploring 4 directions for every cell. This results in **O(m * n * 4)**, where `m` is the number of rows and `n` is the number of columns in the grid.
- **Total Time Complexity**: Combining these, the overall time complexity is **O(W * L + m * n * 4)**.

#### Space Complexity:
- The space complexity is dominated by the Trie, which requires **O(W * L)** space to store all the words and their characters.
- Additional space for DFS recursion and storing the result list is **O(m * n)**.
- Thus, the overall space complexity is **O(W * L + m * n)**.

---

### ðŸ Conclusion

By using a **Trie** combined with **DFS**, we efficiently find all valid words in the grid while ensuring that each letter is used only once per word. This approach leverages the power of prefix matching to prune unnecessary searches and provides an optimal solution for large grids and word lists. 

ðŸ’¡ **Key Takeaways**:
- Trie helps with efficient prefix matching, which speeds up the search.
- DFS ensures that we explore all possible paths in the grid while avoiding revisiting cells.
- This solution is efficient both in terms of **time complexity** and **space complexity**, making it a robust approach for word search problems in grids.


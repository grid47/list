### Problem Statement

The problem is to find all the words from a given list of words that can be formed in a 2D grid of characters. The words can be formed by connecting letters in the grid, moving horizontally or vertically, and each letter from the grid can be used only once per word.

### Approach

To solve this problem efficiently, we can employ a **Trie data structure** (prefix tree) combined with **Depth First Search (DFS)** traversal. This approach allows us to check all possible words in the grid while pruning unnecessary search paths.

**Key observations:**
- **Trie structure:** We can build a Trie for the list of words, where each node represents a character in the word, and paths through the Trie represent prefixes of the words. This way, when searching for words in the grid, we can quickly determine whether the current path is still a valid prefix of any word.
- **DFS traversal:** Starting from each cell in the grid, we can perform DFS to explore all possible words by moving horizontally or vertically. If a valid word is formed, we add it to the result list.
- **Backtracking:** As we explore the grid, we mark visited cells temporarily and restore them to their original value after the DFS exploration at that position is complete. This ensures that each letter can be used only once per word.

### Code Breakdown (Step by Step)

#### 1. Trie Node Definition

```cpp
class Node {
public:
    char val;
    bool isWord;
    string word;
    vector<Node*> next;
    Node(char val, bool isWord) {
        this->val = val;
        this->isWord = isWord;
        next.resize(26, NULL);
    }
};
```
- The `Node` class represents a Trie node. Each node stores:
  - `val`: The character stored in the node.
  - `isWord`: A boolean flag that indicates whether the current node represents the end of a valid word.
  - `word`: The word that ends at this node (only set if `isWord` is true).
  - `next`: A vector of pointers to the next possible nodes (corresponding to the 26 letters of the alphabet).

#### 2. Trie Construction

```cpp
for(string w: words) {
    node = root;
    for(char x: w) {
        int c = x - 'a';
        if(node->next[c] == NULL)
            node->next[c] = new Node(x, false);
        node = node->next[c];
    }
    node->word = w;
    node->isWord = true;
}
```
- For each word in the input list `words`, we traverse through the Trie, creating new nodes as necessary. 
- The letter `x` in the word is mapped to an index using `x - 'a'` to ensure a proper position in the `next` vector (which is of size 26).
- At the end of each word, we mark the node as the end of a word (`isWord = true`) and store the actual word in the `word` field.

#### 3. DFS Traversal

```cpp
void dfs(vector<string> &ans, Node* node, int i, int j) {
    char c = grid[i][j];
    
    if(c == '#' || node->next[c - 'a'] == NULL)
        return;
    
    node = node->next[c - 'a'];
    if(node->isWord) {
        ans.push_back(node->word);
        node->isWord = false;
    }
    grid[i][j] = '#';  // Mark the cell as visited.
    int dir[] = {0, 1, 0, -1, 0};
    for(int k = 0; k < 4; k++) {
        int x = i + dir[k], y = j + dir[k + 1];
        if(x < 0 || y < 0 || x == m || y == n)
            continue;
        dfs(ans, node, x, y);
    }
    grid[i][j] = c;  // Restore the cell after exploration.
}
```
- The DFS function explores the grid starting from cell `(i, j)`. 
- We first check if the current character (`grid[i][j]`) is valid (i.e., not visited and part of a valid Trie path).
- If the character is valid, we move to the corresponding Trie node and recursively explore all 4 possible directions (up, down, left, right).
- If a valid word is formed (i.e., `node->isWord` is true), we add it to the result list (`ans`) and mark the word as found by setting `node->isWord` to `false`.
- We temporarily mark the current cell as visited by setting `grid[i][j] = '#'` and restore it after the exploration is complete.

#### 4. Main Function to Find Words

```cpp
vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
    this->m = board.size(), this->n = board[0].size();
    this->grid = board;
    root = new Node(' ', false);
    Node* node;
    for(string w: words) {
        node = root;
        for(char x: w) {
            int c = x - 'a';
            if(node->next[c] == NULL)
                node->next[c] = new Node(x, false);
            node = node->next[c];
        }
        node->word = w;
        node->isWord = true;
    }
    
    vector<string> ans;
    for(int i = 0; i < m; i++)
        for(int j = 0; j < n; j++)
            dfs(ans, root, i, j);
    
    return ans;
}
```
- The main function initializes the `grid` and builds the Trie as described earlier.
- It then starts DFS from each cell of the grid. If a valid word is found during DFS traversal, it is added to the result list `ans`.
- Finally, the function returns the list of found words.

### Complexity

#### Time Complexity:
- Building the Trie:
  - For each word in the input list `words`, we insert each character into the Trie. Since the maximum number of words is `W` and the maximum word length is `L`, the time complexity for building the Trie is **O(W * L)**.
- DFS Traversal:
  - In the worst case, we explore each cell in the grid and attempt to follow all 4 directions for every cell, which can result in **O(m * n)** DFS calls, where `m` is the number of rows and `n` is the number of columns in the grid.
  - For each DFS call, we perform constant-time operations (checking the Trie and marking cells as visited), resulting in a total time complexity of **O(m * n * 4)** for all DFS calls.
- The overall time complexity is dominated by **O(W * L + m * n * 4)**.

#### Space Complexity:
- The space complexity is driven by the storage required for the Trie, which takes **O(W * L)** space, where `W` is the number of words and `L` is the average length of the words.
- The additional space used for DFS recursion and storing the result is **O(m * n)**.
- Therefore, the overall space complexity is **O(W * L + m * n)**.

### Conclusion

The solution efficiently finds all words from a list that can be formed in a 2D grid of characters using a Trie and DFS approach. The Trie helps in quickly pruning unnecessary search paths by ensuring that only valid prefixes of words are explored. The DFS traversal explores all possible paths in the grid while avoiding revisiting cells by marking them temporarily. This solution is optimal in terms of both time and space complexity, making it suitable for larger grids and word lists.
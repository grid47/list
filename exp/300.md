### Problem Statement

The problem is to find the length of the **longest increasing subsequence (LIS)** in a given array of integers. The longest increasing subsequence is defined as a subsequence (not necessarily contiguous) where each element is greater than or equal to the preceding one. Given an integer array `nums`, the task is to determine the length of the longest subsequence that can be obtained where each element is strictly greater than the previous element.

For example:
- Input: `[10, 9, 2, 5, 3, 7, 101, 18]`
- Output: `4`  
The longest increasing subsequence is `[2, 3, 7, 101]`, with a length of 4.

### Approach

The problem of finding the longest increasing subsequence (LIS) is a classic dynamic programming (DP) problem. The idea is to maintain an array `dp` where `dp[i]` represents the length of the longest increasing subsequence that ends at index `i`. We update `dp[i]` based on previously computed `dp[j]` values, where `j < i` and `nums[j] < nums[i]`. At each step, we ensure that the subsequence ending at `i` is as long as possible.

The process works as follows:
1. **Initialization**: We start by assuming that the LIS for each element is at least 1, so we initialize each element of the `dp` array to 1. This is because any individual element can be considered as a subsequence of length 1 by itself.
2. **Building the DP array**: For each element `i` (starting from index 1), we check all preceding elements `j` (from 0 to `i-1`). If `nums[j] < nums[i]`, we update `dp[i]` as `dp[i] = max(dp[i], dp[j] + 1)`. This represents the fact that if element `nums[j]` can be part of the subsequence ending at `nums[i]`, we update the LIS length for `i` accordingly.
3. **Finding the result**: After processing all elements, the maximum value in the `dp` array gives the length of the longest increasing subsequence.

### Code Breakdown (Step by Step)

Let's break down the provided solution:

#### **Step 1: Initialization**

```cpp
int n = nums.size(), mx = 1;
vector<int> dp(n, 1);
```
- `n` is the size of the input array `nums`.
- `mx` is initialized to 1, representing the minimum possible length of the longest increasing subsequence (since a single element can always be considered as an increasing subsequence of length 1).
- `dp` is a vector of size `n`, initialized to `1`, where each element represents the LIS ending at the respective index. Initially, each element is assumed to be a subsequence of length 1.

#### **Step 2: Main Loop for Building the DP Array**

```cpp
for(int i = 0; i < n; i++) {
    for(int j = 0; j < i; j++)
        if(nums[j] < nums[i]) {
            dp[i] = max(dp[i], dp[j] + 1);
            mx = max(mx, dp[i]);
        }
}
```
- The outer loop runs through each element `i` of the array `nums`.
- The inner loop checks all preceding elements `j` (from 0 to `i-1`), and if `nums[j] < nums[i]` (i.e., if `nums[i]` can follow `nums[j]` in an increasing subsequence), we update `dp[i]` by considering `dp[j] + 1`. This means we extend the subsequence ending at `j` by including the element `i`.
- After updating `dp[i]`, we update `mx` to be the maximum of `mx` and `dp[i]`, ensuring that we are tracking the longest increasing subsequence encountered so far.

#### **Step 3: Return the Result**

```cpp
return mx;
```
- After processing all the elements, the `mx` variable contains the length of the longest increasing subsequence in the entire array. This value is returned as the result.

### Complexity

#### **Time Complexity**:
- The time complexity of the solution is **O(n^2)**, where `n` is the number of elements in the input array `nums`.
  - The outer loop runs `n` times (once for each element).
  - The inner loop runs up to `i` times for each element `i`, resulting in a total of approximately `n^2 / 2` iterations.
  - Thus, the overall time complexity is **O(n^2)**, which is quadratic.

#### **Space Complexity**:
- The space complexity is **O(n)** due to the `dp` array, which stores the LIS values for each index.
  - The `mx` variable and other auxiliary variables take constant space, so the space complexity is dominated by the `dp` array.

### Conclusion

This solution uses dynamic programming to efficiently find the length of the longest increasing subsequence (LIS) in an input array of integers. The approach iterates through each element of the array and compares it with all preceding elements to compute the longest subsequence that ends at each index. The maximum value in the `dp` array represents the length of the overall longest increasing subsequence.

**Key Takeaways**:
1. **Dynamic Programming** is a powerful technique for solving optimization problems, especially when subproblems overlap, as in the case of finding the longest increasing subsequence.
2. **Time Complexity**: This solution has a time complexity of **O(n^2)**, which is reasonable for small to medium-sized inputs but may not scale efficiently for very large arrays.
3. **Space Complexity**: The space complexity is **O(n)** due to the storage required for the `dp` array.

This approach can be optimized further using binary search techniques, which reduce the time complexity to **O(n log n)**. However, the provided **O(n^2)** solution is simpler to understand and works well for moderate input sizes.
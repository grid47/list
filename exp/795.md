### Problem Statement
In this problem, we are tasked with counting the number of contiguous subarrays within a given array `nums` whose maximum element is within a specified range `[left, right]`. The problem is essentially about finding subarrays that have their largest value within a given boundary. We need to implement an efficient algorithm to compute the total number of valid subarrays.

A subarray is defined as any contiguous segment of the array. The problem requires us to count how many subarrays have a maximum element within the range of `[left, right]`.

### Approach
To solve this problem, we need to take the following approach:

1. **Breaking the Problem into Subparts**:
   - We first identify two parts:
     - Subarrays where all elements are strictly smaller than `left`.
     - Subarrays where all elements lie within the range `[left, right]`.
   - We can solve the problem by counting all subarrays where the maximum element is less than or equal to `right`, and subtracting subarrays where the maximum element is strictly smaller than `left`.

2. **Counting Valid Subarrays**:
   - The key observation is that we can calculate the number of subarrays where the maximum element is less than or equal to a given value using a sliding window approach. This allows us to efficiently compute the number of subarrays that meet the criteria.

3. **Efficient Calculation**:
   - We use a sliding window technique to track subarrays where the maximum element is within the range `[left, right]`.
   - By using a variable `dp` that stores the number of valid subarrays ending at the current index, we can keep updating it as we traverse through the array.

4. **Handling the Range**:
   - As we traverse through the array, we adjust the `dp` value based on the current element's value relative to the `left` and `right` boundaries. When the value exceeds `right`, we reset the count, as any subarray containing that element would no longer be valid.

### Code Breakdown (Step by Step)
The code implementation uses a sliding window approach to efficiently solve the problem. Let's break it down step by step:

#### Step 1: Initialize Variables
```cpp
int n = nums.size();
int ans = 0, dp = 0, prv = -1;
```
- `n`: The size of the `nums` array.
- `ans`: This variable keeps track of the total number of valid subarrays.
- `dp`: A variable used to count the number of valid subarrays ending at the current index. It is updated based on the current element.
- `prv`: This variable tracks the last index where a number greater than `right` was found. It is used to calculate the number of valid subarrays between two indices.

#### Step 2: Traverse Through the Array
```cpp
for(int i = 0; i < n; i++) {
    if(nums[i] < left)
        ans += dp;
```
- We iterate over each element of the array `nums`.
- If the current element is less than `left`, then any subarray ending at `i` will not contribute to the valid subarrays with a maximum within the range `[left, right]`. We add `dp` to `ans`, as the subarrays from the previous positions are still valid.

#### Step 3: Handle Elements Greater Than `right`
```cpp
    if(nums[i] > right) {
        dp = 0;
        prv = i;
    }
```
- If the current element exceeds `right`, we reset `dp` to 0 because no valid subarray can end at this index if the maximum element exceeds `right`.
- We also update `prv` to store the index of the element greater than `right`, as any valid subarrays must end before this index.

#### Step 4: Handle Elements Within the Range `[left, right]`
```cpp
    if(nums[i] >= left && nums[i] <= right) {
        dp = i - prv;
        ans += dp;
    }
```
- If the current element is within the valid range `[left, right]`, we update `dp` to the number of subarrays ending at the current index. This is calculated as `i - prv`, where `prv` is the index of the last element that exceeded `right`.
- We add `dp` to `ans`, as it represents the count of valid subarrays that end at index `i`.

#### Step 5: Return the Final Result
```cpp
return ans;
```
- Finally, the variable `ans` contains the total number of valid subarrays, and we return it.

### Complexity

#### Time Complexity:
The time complexity of this algorithm is O(n), where `n` is the length of the input array `nums`. This is because we only traverse the array once in a single loop, and each operation inside the loop takes constant time.

#### Space Complexity:
The space complexity is O(1), as we use only a few variables (`ans`, `dp`, `prv`, and `n`) to store intermediate results. The space used does not depend on the size of the input array, making the space complexity constant.

### Conclusion
The provided solution effectively solves the problem of counting the number of subarrays whose maximum element lies within the specified range `[left, right]`. The approach is efficient, with a time complexity of O(n) and space complexity of O(1), making it suitable for large input arrays.

The sliding window technique used to keep track of valid subarrays ensures that the solution handles the constraints optimally. By updating the count of valid subarrays as we traverse the array, the solution avoids unnecessary recomputation, making it a highly efficient solution for this problem.

This solution is both easy to understand and efficient, demonstrating the power of the sliding window technique in solving range-based problems. Whether the input array is large or small, the algorithm will perform efficiently, providing an optimal solution to the problem of counting subarrays with bounded maximums.
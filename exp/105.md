### Problem Statement

Given two integer arrays, **preorder** and **inorder**, representing the preorder and inorder traversal sequences of a binary tree, you are tasked with constructing the binary tree from these traversals.

- The **preorder** traversal gives the nodes of the tree in the order: **root -> left subtree -> right subtree**.
- The **inorder** traversal gives the nodes in the order: **left subtree -> root -> right subtree**.

Your goal is to construct the binary tree from the given traversals and return its root.

### Approach

To solve this problem, we can take advantage of the following properties of the **preorder** and **inorder** traversals:

1. **Preorder Traversal:** The first element of the preorder array is always the root of the tree or subtree.
2. **Inorder Traversal:** The root of the tree divides the inorder array into two parts:
   - The left part contains the nodes of the left subtree.
   - The right part contains the nodes of the right subtree.

With this in mind, we can recursively build the tree. Here's a step-by-step breakdown of the approach:

1. **Identify Root from Preorder:** The first element in the **preorder** array is the root of the tree. This root will divide the **inorder** array into two segments:
   - The elements before the root in the **inorder** array represent the left subtree.
   - The elements after the root in the **inorder** array represent the right subtree.
   
2. **Recursive Construction:** 
   - After identifying the root, we recursively build the left and right subtrees by slicing the **inorder** array into the left and right parts and adjusting the **preorder** indices accordingly.
   - We continue this process recursively until we have processed all the nodes in the arrays.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the Solution

```cpp
map<int, int> mp;
vector<int> preorder, inorder;
```

- The `mp` map is used to store the index of each element in the **inorder** array. This allows us to quickly find the position of the root element (from **preorder**) in the **inorder** array.
- The `preorder` and `inorder` vectors store the traversal arrays, respectively.

#### Step 2: Build the Tree

```cpp
TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
    this->preorder = preorder;
    this->inorder = inorder;

    for (int i = 0; i < inorder.size(); i++) {
        mp[inorder[i]] = i;
    }

    return helper(0, 0, inorder.size() - 1);
}
```

- The constructor of the class stores the input `preorder` and `inorder` arrays.
- We populate the `mp` map, where the key is the value of the node and the value is the index of that node in the **inorder** array. This helps us find the rootâ€™s position in **inorder** efficiently.
- We then call the recursive `helper` function to build the tree, starting with the first node in **preorder** (index 0) and the entire **inorder** array (indices 0 to `inorder.size() - 1`).

#### Step 3: Helper Function to Recursively Build the Tree

```cpp
TreeNode* helper(int ps, int is, int ie) {
    if (ps >= preorder.size() || is > ie) return NULL;

    TreeNode* root = new TreeNode(preorder[ps]);
    root->left  = helper(ps + 1, is, mp[root->val] - 1);
    root->right = helper(ps + mp[root->val] - is + 1, mp[root->val] + 1, ie);

    return root;
}
```

- The `helper` function takes the current index `ps` for **preorder** and the indices `is` and `ie` for the current segment of the **inorder** array that we're currently considering.
- **Base Case:** If the current `ps` index is beyond the bounds of **preorder** or if the start index `is` exceeds the end index `ie` in **inorder**, return `NULL` to indicate there are no nodes to process.
- **Create the Root Node:** The value of the current node is taken from **preorder[ps]**. A new `TreeNode` is created for this root.
- **Recursive Calls:** 
  - The left subtree is constructed by recursively calling `helper` with the next node in **preorder** (`ps + 1`), and the left segment of the **inorder** array (from `is` to the index of the root node in **inorder**).
  - The right subtree is constructed similarly, but the segment of the **inorder** array is to the right of the root node.
- The recursion proceeds until all nodes are processed, and the entire tree is constructed.

### Complexity Analysis

#### Time Complexity

The time complexity of this solution is **O(n)**, where `n` is the number of nodes in the binary tree. This is because:
- Each node in the **preorder** and **inorder** arrays is visited exactly once.
- The map `mp` is created in **O(n)** time, and each lookup of the root in **inorder** takes **O(1)** time due to the map.
- The recursive calls ensure that each node is processed once.

Thus, the overall time complexity is **O(n)**, where `n` is the number of nodes.

#### Space Complexity

The space complexity is **O(n)** due to:
1. The storage required for the `mp` map (which has `n` entries).
2. The storage for the **preorder** and **inorder** arrays, which both contain `n` elements.
3. The recursive call stack in the worst case, which can go as deep as the height of the tree, resulting in a space complexity of **O(h)**, where `h` is the height of the tree. In the worst case (a skewed tree), the height is **O(n)**, so the space complexity is **O(n)**.

### Example Walkthrough

Consider the following example:

- **Preorder**: `[3, 9, 20, 15, 7]`
- **Inorder**: `[9, 3, 15, 20, 7]`

1. The root of the tree is `3` (from **preorder[0]**).
2. Find `3` in **inorder**, which splits the array into `[9]` (left subtree) and `[15, 20, 7]` (right subtree).
3. Recursively construct the left and right subtrees using the appropriate parts of **preorder** and **inorder**.

After recursion, the constructed tree looks like this:

```
        3
       / \
      9  20
         /  \
        15   7
```

### Conclusion

This solution efficiently reconstructs a binary tree from its **preorder** and **inorder** traversal arrays. The use of a map for quick lookups of root positions in the **inorder** array ensures that the tree is built in **O(n)** time. The recursive approach elegantly divides the problem into smaller subproblems, making the solution both efficient and easy to understand. The overall time complexity is **O(n)**, and the space complexity is also **O(n)** due to the storage requirements for the map and the recursion.
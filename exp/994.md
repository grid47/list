### Problem Statement
You are given a grid representing a box of oranges. Each cell in the grid can contain:
- `0`: an empty cell,
- `1`: a fresh orange,
- `2`: a rotten orange.

Every minute, any fresh orange adjacent (4-directionally) to a rotten orange becomes rotten. Your task is to return the minimum number of minutes that must elapse until no fresh oranges remain. If this is impossible, return `-1`.

### Approach
1. **Initialization**: 
   - Use a queue to track the positions of all rotten oranges. 
   - Create a 2D vector `vis` to mark visited cells.
   - Define the directions for adjacent cells (up, down, left, right).

2. **BFS Implementation**: 
   - Enqueue all initially rotten oranges into the queue.
   - While the queue is not empty:
     - Process all oranges in the current level (representing one minute).
     - For each rotten orange, check its adjacent cells:
       - If an adjacent cell contains a fresh orange, mark it as rotten and enqueue it.
       - Keep track of the time taken to rot all fresh oranges.

3. **Final Check**:
   - After processing, check for any remaining fresh oranges. 
   - If any fresh oranges are left, return `-1`.
   - Otherwise, return the total time taken minus `2` (since we need to convert from rotten value to minutes).

### Code Walk-through
- The function initializes the queue and performs a BFS to spread rot through adjacent fresh oranges.
- After all possible rotting, it checks for any fresh oranges left and calculates the total time taken.

### Complexity
- **Time Complexity**: O(m * n), where `m` is the number of rows and `n` is the number of columns in the grid. Each cell is processed once.
- **Space Complexity**: O(m * n) for the queue and visited array.

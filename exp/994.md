### Problem Statement

The problem revolves around a grid where each cell can represent an orange: fresh (`1`), rotten (`2`), or empty (`0`). The goal is to determine the minimum time required for all fresh oranges to rot, given that rotten oranges can rot adjacent fresh oranges in all four directions (up, down, left, right) every minute. If there are any fresh oranges that cannot rot due to isolation from rotten ones, the function should return `-1` as it is impossible to rot all oranges.

### Approach

To solve this problem efficiently, we can employ a **Breadth-First Search (BFS)** approach. BFS is ideal for problems involving spreading or propagation, such as this one where rotten oranges spread rot to their neighboring fresh oranges. The BFS approach ensures that we process the freshest (or closest) rot first, and then work our way outward, minute by minute, as rotten oranges spread their effect.

### Key Steps in the Approach:

1. **Identify Initial Rotten Oranges**: We start by identifying all the rotten oranges (represented by `2`) in the grid. These will be the starting points for our BFS.
2. **BFS Traversal**: We perform a BFS starting from all the rotten oranges simultaneously, propagating the rot to their adjacent fresh oranges (represented by `1`). As we propagate the rot, we keep track of the time it takes for each fresh orange to become rotten.
3. **Tracking Rotting Process**: We track the time step by step as the rot spreads, ensuring that each fresh orange becomes rotten at the earliest possible minute.
4. **Final Check**: After BFS completes, we check if there are any remaining fresh oranges that could not be rotted. If any such oranges remain, it implies they were isolated from the rotten oranges, and we return `-1`. Otherwise, the result will be the maximum time it took for the last fresh orange to rot.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    int orangesRotting(vector<vector<int>>& grid) {
        queue<vector<int>> q;  // A queue to store the positions of rotten oranges
        int m = grid.size(), n = grid[0].size();  // Dimensions of the grid
```

1. **Initialize the Queue**:
   - We initialize a queue `q` that will store the positions of the rotten oranges. These positions are used as starting points for the BFS.
   - We also retrieve the grid dimensions `m` and `n`.

```cpp
        for(int i = 0; i < m; i++)
        for(int j = 0; j < n; j++)
            if(grid[i][j] == 2) {
                q.push({i, j});  // Add the positions of all rotten oranges to the queue
            }
```

2. **Push Rotten Oranges to the Queue**:
   - We iterate through the entire grid. Whenever we encounter a rotten orange (value `2`), we add its position (row and column) to the queue. These will serve as the initial rotten orange points for BFS.

```cpp
        vector<vector<int>> vis(m, vector<int>(n, 0));  // A 2D vector to keep track of visited cells
        int t = 0;  // Initialize the time counter
        int dir[] = {0, 1, 0, -1, 0};  // Directions for BFS (right, down, left, up)
```

3. **Visited Array and Direction Array**:
   - We create a `vis` 2D vector initialized to 0, which will be used to track whether a cell has already been visited during the BFS.
   - The `dir` array contains the directional deltas (right, down, left, up) used to explore neighboring cells.

```cpp
        while(!q.empty()) {  // Perform BFS until the queue is empty
            int sz = q.size();  // Get the number of rotten oranges in the current round
            while(sz--) {
                auto it = q.front();  // Get the front element in the queue
                q.pop();  // Pop the element from the queue
```

4. **BFS Loop**:
   - The outer `while` loop continues as long as there are rotten oranges in the queue.
   - For each level of BFS (each minute), we process the current batch of rotten oranges, indicated by the `sz` variable, which holds the number of elements in the queue for that minute.

```cpp
                if(vis[it[0]][it[1]]) continue;  // Skip if the cell is already visited
                vis[it[0]][it[1]] = 1;  // Mark the cell as visited
```

5. **Mark Visited**:
   - Before processing a rotten orange, we check if it has been visited already. If it has, we skip the processing. Otherwise, we mark it as visited to avoid revisiting the same cell in future iterations.

```cpp
                for(int i = 0; i < 4; i++) {  // Explore all four directions (right, down, left, up)
                    int x = it[0] + dir[i], y = it[1] + dir[i + 1];
                    if(x < 0 || y < 0 || x == m || y == n || vis[x][y] || grid[x][y] != 1)
                        continue;  // Skip if the cell is out of bounds, already visited, or not a fresh orange
                    grid[x][y] = grid[it[0]][it[1]] + 1;  // Mark the fresh orange as rotten (increment the time)
                    q.push({x, y});  // Push the newly rotten orange into the queue
                }
            }
        }
```

6. **Rotting Spread**:
   - For each rotten orange, we explore its four neighbors. If a neighbor is a fresh orange (`1`), we turn it into a rotten orange by updating its value to `grid[it[0]][it[1]] + 1` (indicating the time step).
   - We then push the newly rotten orange’s position to the queue for further processing in the next minute.

```cpp
        int mx = 2;  // Initialize `mx` to track the maximum time
        for(int i = 0; i < m; i++)  // Traverse the grid to check for unrotted fresh oranges and track the maximum time
        for(int j = 0; j < n; j++)
            if(grid[i][j] > mx) mx = grid[i][j];  // Update the maximum time
            else if(grid[i][j] == 1) return -1;  // If any fresh orange is left, return -1
        return mx - 2;  // The time taken is the maximum time minus 2 (to account for the initial rotten oranges)
    }
};
```

7. **Final Check**:
   - After BFS completes, we check if there are any fresh oranges (`grid[i][j] == 1`). If such oranges exist, it means they couldn’t be rotted, and we return `-1`.
   - If all fresh oranges have been rotted, we calculate the maximum time it took to rot the last orange (`mx`) and return `mx - 2`, as the initial rotten oranges are marked with a value of `2`.

### Complexity

- **Time Complexity**: The time complexity is **O(m * n)**, where `m` is the number of rows and `n` is the number of columns in the grid. This is because each cell is visited at most once during the BFS, and we perform constant time operations for each cell.
  
- **Space Complexity**: The space complexity is **O(m * n)** due to the queue and the `vis` 2D vector used for marking visited cells. The size of the queue can grow to the maximum number of cells in the grid, and the visited array stores the state of each cell.

### Conclusion

This solution efficiently solves the problem of rotting oranges by utilizing a **Breadth-First Search (BFS)** approach. By treating the rotting process as a multi-source BFS where all rotten oranges spread rot simultaneously, we ensure that the time to rot all oranges is minimized. The solution accounts for edge cases such as isolated fresh oranges that cannot be rotted, returning `-1` in such cases. The approach is both time and space efficient, making it an ideal solution for this problem.
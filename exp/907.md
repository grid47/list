### Problem Statement
Given an integer array `nums`, return the sum of the minimums of all possible subarrays. Since the answer may be large, return it modulo \(10^9 + 7\).

### Class Definition
- **Class**: `Solution`
  - **Method**: `int sumSubarrayMins(vector<int>& nums)`
    - Takes a vector of integers `nums`.
    - Returns the sum of the minimums of all subarrays modulo \(10^9 + 7\).

### Approach
1. **Initialization**:
   - Create a stack `stk_p` to store pairs of integers (value, index).
   - Initialize two vectors, `left` and `right`, to keep track of the number of subarrays where each element is the minimum:
     - `left[i]` indicates how many consecutive elements to the left (including itself) are greater than or equal to `nums[i]`.
     - `right[i]` indicates how many consecutive elements to the right (including itself) are greater than or equal to `nums[i]`.

2. **Fill Left and Right Arrays**:
   - Pre-fill `left[i]` with \(i + 1\) and `right[i]` with \(n - i\) (the default count of elements in one direction).
   - Iterate through `nums`:
     - For each element, use the stack to determine how many consecutive elements are less than or equal to the current element:
       - Pop elements from the stack while the top element is greater than the current element, updating `right` for the indices popped.
       - Update `left` based on the top of the stack (if it exists).
       - Push the current element and its index onto the stack.

3. **Calculate Result**:
   - Initialize `ans` to zero. Loop through `nums` and calculate the contribution of each element to the sum of subarray minimums using:
     - `ans += nums[i] * left[i] * right[i]`
   - Return the result modulo \(10^9 + 7\).

### Complexity
- **Time Complexity**: O(n), where n is the number of elements in `nums`, since each element is processed at most twice.
- **Space Complexity**: O(n) for the left and right arrays and the stack.

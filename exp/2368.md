### Problem Statement

The problem asks to count the number of nodes that are reachable from a starting node, with certain restricted nodes that cannot be visited. The graph is represented as an undirected graph with `n` nodes and `edges` that connect pairs of nodes. Additionally, a list of restricted nodes is given, and these nodes are considered inaccessible in the graph traversal. Your task is to implement a function that returns the number of reachable nodes, excluding the restricted nodes.

### Approach

This problem is essentially a graph traversal problem where we need to visit nodes using a Depth First Search (DFS) or Breadth First Search (BFS) while ignoring the restricted nodes. The goal is to determine how many nodes can be reached from a given starting node (in this case, node 0) under the constraint that some nodes are restricted.

The key steps involved in solving this problem are:

1. **Graph Representation**: We represent the graph as an adjacency list, where each node points to a list of its neighbors.
2. **Initialization**: Mark the restricted nodes as visited initially, because they cannot be traversed.
3. **DFS Traversal**: Start from the given node (node 0 in this case) and traverse through the graph using DFS. Each time a node is visited, we increment the count of reachable nodes.
4. **Return the Result**: Once all reachable nodes are visited, return the count of reachable nodes.

### Code Breakdown (Step by Step)

1. **Class Definition**:
    ```cpp
    class Solution {
        int ans;  // To store the count of reachable nodes
    ```
    Here, `ans` is an integer that stores the count of nodes reachable from node 0. It starts from 1 because node 0 is considered reachable by default.

2. **Solve Function (DFS)**:
    ```cpp
    void solve(vector<vector<int>>& gph, vector<bool> &vis, int i) {
        vis[i] = true;  // Mark the current node as visited
        for (int n : gph[i]) {
            if (!vis[n]) {
                ans++;  // Increment reachable node count
                vis[n] = true;  // Mark the neighbor node as visited
                solve(gph, vis, n);  // Recursively visit all connected nodes
            }
        }
    }
    ```
    This is a recursive function that performs the DFS traversal. The function takes the graph (`gph`), a visitation status vector (`vis`), and the current node (`i`). It marks the current node as visited and then recursively visits all its neighbors that are not visited yet. Each time a new node is visited, the reachable node count (`ans`) is incremented.

3. **reachableNodes Function (Main Function)**:
    ```cpp
    int reachableNodes(int n, vector<vector<int>>& edges, vector<int>& restricted) {
        ans = 1;  // Start with 1 because node 0 is reachable
        vector<vector<int>> gph(n);  // Graph represented as an adjacency list
        
        for (auto e : edges) {
            int u = e[0], v = e[1];
            gph[u].push_back(v);  // Add edge from u to v
            gph[v].push_back(u);  // Add edge from v to u (undirected graph)
        }
    ```
    The `reachableNodes` function starts by initializing the graph and marking the restricted nodes. The graph is created using an adjacency list, where each edge is added in both directions since the graph is undirected. 

    ```cpp
        vector<bool> vis(n, false);  // Visitation status vector
        for (auto i : restricted) {
            vis[i] = true;  // Mark restricted nodes as visited
        }
    ```
    We initialize the `vis` vector to `false` for all nodes. Then, we mark the restricted nodes as visited by setting their corresponding positions in `vis` to `true`. This ensures that these nodes are ignored during the DFS traversal.

    ```cpp
        solve(gph, vis, 0);  // Start DFS traversal from node 0
        return ans;  // Return the count of reachable nodes
    }
    ```
    The DFS traversal starts from node 0, and the `solve` function is invoked. Finally, the function returns the value of `ans`, which contains the number of reachable nodes.

### Complexity

1. **Time Complexity**:
    - **Building the Graph**: Constructing the graph from the list of edges takes O(E), where `E` is the number of edges.
    - **DFS Traversal**: The DFS traversal visits each node and each edge exactly once. Therefore, the time complexity of the DFS is O(V + E), where `V` is the number of nodes and `E` is the number of edges.
    
    Thus, the overall time complexity of the `reachableNodes` function is O(V + E).

2. **Space Complexity**:
    - The space complexity is determined by the graph representation and the visitation status vector:
        - The adjacency list `gph` requires O(V + E) space.
        - The `vis` vector requires O(V) space.
    
    Therefore, the overall space complexity is O(V + E).

### Conclusion

This approach efficiently solves the problem of counting reachable nodes in an undirected graph with restricted nodes. By using DFS and maintaining a visitation status for each node, the solution ensures that restricted nodes are excluded from the traversal. The algorithm operates within the time and space limits, making it suitable for large graphs with multiple nodes and edges. The solution's time complexity of O(V + E) ensures scalability, while the space complexity of O(V + E) keeps the algorithm's memory usage manageable.
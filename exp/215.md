### ğŸš€ Problem Statement

Hey there! ğŸ‘‹ In this problem, you're asked to find the `k`-th largest element in an unsorted array of integers. ğŸ“Š The number `k` represents the position of the largest element you're after, and your task is to return that element when the list is sorted in descending order.

---

### ğŸ§  Approach

To solve this efficiently, weâ€™re going to use a **priority queue**. ğŸ”‘ This clever data structure will allow us to always access the largest element in constant time while keeping track of the order of the elements. Itâ€™s like having a trusty sidekick that can instantly give you the biggest treasure in the pile! ğŸ†

#### Key Concepts:
1. **Priority Queue (Max-Heap)**: A priority queue is a special data structure that lets us efficiently get the largest or smallest element. Here, weâ€™ll use a **max-heap**, which ensures that the largest element is always at the top of the heap.
   
2. **Heap Property**: In a heap, each parent node is greater than or equal to its children (for a max-heap). So, the root always holds the largest element. ğŸŒ³

3. **How to Find the k-th Largest Element**: 
   - Insert all the elements of the array into the priority queue (max-heap).
   - Then, extract the largest element `k` times (first the largest, then the second largest, and so on).
   - After `k` extractions, the top element will be our `k`-th largest element!

---

### ğŸ”¨ Step-by-Step Code Breakdown

Letâ€™s break this down and make sure we understand every part! ğŸ”

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq;  // Step 1: Initialize a max-heap priority queue
        for(int x: nums)         // Step 2: Insert all elements from nums into the priority queue
            pq.push(x);
        
        int x;
        while(k-->0) {           // Step 3: Extract the top element k times
            x = pq.top();        // Get the largest element from the heap
            pq.pop();            // Remove the largest element
        }
        return x;                // Step 4: Return the k-th largest element
    }
};
```

#### Step-by-Step Explanation:
1. **Initialize the Priority Queue:**
   ```cpp
   priority_queue<int> pq;
   ```
   - We create a **max-heap** priority queue. In C++, `priority_queue` is a max-heap by default, so the largest element is always at the top! ğŸ”

2. **Insert Elements into the Priority Queue:**
   ```cpp
   for(int x: nums) 
       pq.push(x);
   ```
   - Here, we loop through each element `x` in the `nums` array and push it into the priority queue. Each insertion maintains the heap property, so the largest element always stays at the top. ğŸ’¥

3. **Extract the Largest Element `k` Times:**
   ```cpp
   while(k-->0) { 
       x = pq.top(); 
       pq.pop();
   }
   ```
   - The `top()` function gives us the largest element at the root of the heap.
   - We then `pop()` it off the heap, and the next largest element moves to the top.
   - We repeat this process `k` times to find the `k`-th largest element.

4. **Return the k-th Largest Element:**
   ```cpp
   return x;
   ```
   - After the loop, `x` holds the value of the `k`-th largest element. Thatâ€™s the one we return! ğŸ¯

---

### ğŸ“ˆ Complexity Analysis

Letâ€™s take a quick look at how efficient this solution is! ğŸ“Š

#### Time Complexity:
- **Inserting all elements into the priority queue**: Each `push` operation in the priority queue takes `O(log n)` time, where `n` is the number of elements in the array.
  - So, inserting all `n` elements into the heap takes `O(n log n)` time.

- **Extracting the top element `k` times**: Each `pop` operation takes `O(log n)` time. Since we perform `k` extractions, the time complexity for this part is `O(k log n)`.

Therefore, the **total time complexity** is:
\[
O(n \log n) + O(k \log n) = O(n \log n)
\]
In most cases, `k <= n`, so the time complexity is dominated by the heap insertions, which is **O(n log n)**.

#### Space Complexity:
- We store all `n` elements in the priority queue, so the **space complexity** is `O(n)`.

---

### ğŸ Conclusion

And there you have it! ğŸ‰ This solution is an efficient and intuitive way to find the `k`-th largest element in an unsorted array. By using a **max-heap**, we can efficiently track and extract the largest elements.

- **Time Complexity**: `O(n log n)`, which is great for handling even large arrays!
- **Space Complexity**: `O(n)`, due to storing the array in the priority queue.

This approach is clear, efficient, and works wonders for problems where we need to find the largest or smallest elements. ğŸš€ Keep this trick in your toolbox for future problemsâ€”it's a real lifesaver! ğŸ˜
### Problem Statement

The task is to find the `k`-th largest element in an unsorted array of integers. The number `k` represents the position of the largest element you are looking for, and the goal is to return the element at that position when the list is sorted in descending order.

### Approach

To solve this problem efficiently, we can use a **priority queue**, which allows us to always access the largest element in constant time, while maintaining the order of the elements in the heap structure.

#### Key Concepts:
1. **Priority Queue (Max-Heap)**: A priority queue is a data structure that keeps the elements sorted in a way that allows efficient retrieval of the largest (or smallest) element. In the context of this problem, we use a max-heap, which ensures that the largest element is always at the top of the heap.
   
2. **Heap Property**: A heap is a binary tree where each parent node is either greater than or equal to its child nodes (in a max-heap). The root node always contains the largest element.

3. **Efficiently Finding the k-th Largest Element**: 
   - Insert all elements of the array into the priority queue.
   - Extract the top element `k` times (because we want the largest element, the second largest, and so on).
   - The `k`-th extraction will give us the `k`-th largest element.

Using a max-heap is an intuitive approach for problems involving "largest" or "smallest" elements, and it ensures that we can solve the problem efficiently.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    int findKthLargest(vector<int>& nums, int k) {
        priority_queue<int> pq;  // Step 1: Initialize a max-heap priority queue
        for(int x: nums)         // Step 2: Insert all elements from nums into the priority queue
            pq.push(x);
        
        int x;
        while(k-->0) {           // Step 3: Extract the top element k times
            x = pq.top();        // Get the largest element from the heap
            pq.pop();            // Remove the largest element
        }
        return x;                // Step 4: Return the k-th largest element
    }
};
```

#### Step-by-Step Explanation:

1. **Initialize the Priority Queue:**
   ```cpp
   priority_queue<int> pq;
   ```
   - Here, we create a max-heap using a priority queue. In C++, the `priority_queue` is implemented as a max-heap by default, meaning that the largest element is always at the top of the queue.

2. **Insert Elements into the Priority Queue:**
   ```cpp
   for(int x: nums) 
       pq.push(x);
   ```
   - We loop through each element `x` in the `nums` array and push it into the priority queue. Each `push` operation ensures that the heap property is maintained, and the largest element remains at the top.

3. **Extract the Largest Element `k` Times:**
   ```cpp
   while(k-->0) { 
       x = pq.top(); 
       pq.pop();
   }
   ```
   - The `top()` function of the priority queue returns the largest element (root of the heap).
   - The `pop()` function removes the top element, which means that after each `pop()`, the next largest element will automatically be at the top.
   - This loop runs `k` times to remove the first `k-1` largest elements. After `k` iterations, the element at the top of the heap will be the `k`-th largest element.

4. **Return the k-th Largest Element:**
   ```cpp
   return x;
   ```
   - After the loop completes, `x` holds the value of the `k`-th largest element in the array. This is the element that was removed during the `k`-th iteration, so we return it.

### Complexity

#### Time Complexity:
- **Inserting all elements into the priority queue**: 
  - Each `push` operation in the priority queue takes `O(log n)` time because the heap structure ensures that the elements are ordered after every insertion.
  - Therefore, inserting all `n` elements from the array into the heap takes `O(n log n)` time.
  
- **Extracting the top element `k` times**:
  - Each `pop` operation takes `O(log n)` time because the heap needs to be reordered after each removal.
  - Since we are performing `k` extractions, the time complexity for this part is `O(k log n)`.

Thus, the total time complexity is the sum of these two operations:
\[
O(n \log n) + O(k \log n) = O(n \log n)
\]
This is because in most cases, `k <= n`, and the time complexity for inserting elements dominates the time complexity of the `k` extractions.

#### Space Complexity:
- The space complexity is determined by the space required to store the priority queue. Since we store all `n` elements in the heap, the space complexity is `O(n)`.

### Conclusion

The solution efficiently solves the problem of finding the `k`-th largest element in an unsorted array by using a max-heap (priority queue). The priority queue allows us to efficiently track and extract the largest elements in the array.

- **Time Complexity**: The overall time complexity is `O(n log n)`, where `n` is the number of elements in the input array. This is mainly due to the heap operations for inserting all elements and performing the `k` extractions.
- **Space Complexity**: The space complexity is `O(n)` because we store all the elements in the priority queue.

This approach is easy to understand and guarantees the correct result while being efficient for arrays of large sizes. Although alternative approaches such as sorting or using a min-heap can also solve the problem, using a max-heap allows us to access the largest elements directly and perform the extractions efficiently. This makes the solution both intuitive and performant for most practical scenarios.
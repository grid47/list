### Problem Statement

The problem at hand involves determining the number of distinct binary search trees (BSTs) that can be formed using a given array of integers, `nums`. Each integer in the array is unique, and the elements can be arranged in various ways to create different binary search trees. The challenge is to count these unique arrangements under the constraint that the result must be returned modulo \(10^9 + 7\).

A binary search tree is defined such that for any node:
1. The left subtree contains nodes with values less than the node’s value.
2. The right subtree contains nodes with values greater than the node’s value.

Given these properties, the goal is to explore how many unique BSTs can be constructed using all elements in the input array.

### Approach

The approach to solve this problem consists of two main components:
1. **Dynamic Programming (DP) with Combinatorial Counting**: 
   We utilize a combinatorial counting technique to determine the number of unique BSTs. The number of unique BSTs that can be formed with `n` nodes can be calculated using the Catalan number formula, which relates the number of nodes in the tree to the ways to arrange them.

2. **Depth-First Search (DFS)**:
   A DFS approach is employed to recursively explore all possible left and right subtrees for a given root. The root of the BST is chosen as the first element of the current array slice, and elements are categorized into left and right subtrees based on their values relative to the root. The results of the left and right subtree combinations are combined to compute the total number of unique BSTs.

### Code Breakdown (Step by Step)

Let’s analyze the code step by step to understand its implementation.

- **Class Declaration**:
    The solution is encapsulated within a class named `Solution`.

```cpp
class Solution {
public:
```

- **Modulus Declaration**:
    A constant `mod` is defined, representing \(10^9 + 7\), to ensure that results do not overflow.

```cpp
long long mod = 1e9 + 7;
```

- **DP Table Initialization**:
    A 2D vector `table` is initialized to store binomial coefficients, which will be used to calculate the number of ways to choose left and right subtrees.

```cpp
vector<vector<long long>> table;
```

- **Main Function**:
    The `numOfWays` function takes a vector of integers `nums` as input and returns the number of unique BSTs modulo \(10^9 + 7\).

```cpp
int numOfWays(vector<int>& nums) {
```

- **Size Calculation**:
    The size of the input array is stored in `n`.

```cpp
int n = nums.size();
```

- **Table Initialization**:
    The `table` is resized to accommodate combinations for all possible sizes of nodes. The first entry in each row is initialized to 1, as there is one way to choose 0 elements.

```cpp
table.resize(n);
for(int i = 0; i < n; i++) {
    table[i] = vector<long long>(i + 1, 1);
```

- **Calculate Binomial Coefficients**:
    A nested loop populates the `table` with binomial coefficients using Pascal’s triangle approach. Each entry is calculated as the sum of the two entries above it, modulo `mod`.

```cpp
for(int j = 1; j < i; j++)
    table[i][j] = (table[i - 1][j - 1] + table[i - 1][j]) % mod;
}
```

- **Call DFS Function**:
    The DFS function is called to calculate the total number of unique BSTs based on the input array. The result is stored in `ans`.

```cpp
long long ans = dfs(nums);
```

- **Final Result Calculation**:
    The result is returned after subtracting 1 (to exclude the empty tree) and taking the modulo.

```cpp
return  ans % mod - 1;
}
```

- **DFS Function Definition**:
    The `dfs` function is defined to recursively compute the number of unique BSTs.

```cpp
long long dfs(vector<int> &nums) {
```

- **Base Case**:
    If the size of `nums` is less than or equal to 2, we return 1 since there is only one way to arrange one or two nodes.

```cpp
int n = nums.size();
if( n <= 2) return 1;
```

- **Left and Right Subtree Initialization**:
    Two vectors, `left` and `right`, are created to hold the nodes of the left and right subtrees, respectively.

```cpp
vector<int> left, right;
```

- **Categorizing Nodes**:
    A loop categorizes nodes into left and right subtrees based on their values compared to the root node (the first element of `nums`).

```cpp
for(int i = 1; i < n; i++) {
    if(nums[i] < nums[0]) left.push_back(nums[i]);
    else right.push_back(nums[i]);
}
```

- **Recursive DFS Calls**:
    Recursive calls are made to the `dfs` function for both left and right subtrees to calculate the number of unique BSTs for each subtree.

```cpp
long long lc = dfs(left) % mod;
long long rc = dfs(right) % mod;
```

- **Calculate Total Unique BSTs**:
    The total number of unique BSTs is computed by multiplying the number of ways to form the left and right subtrees, and multiplying that by the binomial coefficient that counts how the left subtree can be chosen from the nodes.

```cpp
return (((table[n - 1][left.size()] * lc) % mod) * rc) % mod;
}
```

### Complexity

- **Time Complexity**: The time complexity of this approach is \(O(n^2)\) due to the recursive DFS calls combined with the construction of the `table` for binomial coefficients.

- **Space Complexity**: The space complexity is \(O(n)\) for storing the binomial coefficients in the `table`, and an additional \(O(n)\) for the recursive call stack.

### Conclusion

The `numOfWays` function effectively counts the number of distinct binary search trees that can be formed using a given array of unique integers by leveraging a combination of combinatorial counting and recursive depth-first search. This approach demonstrates the application of dynamic programming concepts in solving combinatorial problems and showcases the elegance of recursive solutions to complex counting challenges.

Understanding this solution provides insights into the construction of binary search trees, the importance of binomial coefficients in counting arrangements, and the application of modular arithmetic to manage large numbers in programming.

In summary, this algorithm serves as an excellent reference for developers facing similar combinatorial problems in competitive programming or algorithm design, emphasizing efficiency and clarity in implementation. By mastering these techniques, one can tackle a wide range of problems involving tree structures and combinatorial arrangements, making this solution a valuable addition to any algorithmic toolkit.
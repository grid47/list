### Problem Statement

The problem at hand involves finding the number of different arrays of length `n`, where each element in the array is an integer from `1` to `m`, such that the array contains exactly `k` different integers. This is a combinatorial problem that requires a dynamic programming approach to efficiently compute the number of valid arrays.

### Approach

To tackle this problem, we will use a dynamic programming (DP) technique. The key idea is to maintain a three-dimensional DP table where:

- The first dimension represents the current length of the array (`n`).
- The second dimension represents the maximum value of elements in the array (`m`).
- The third dimension represents the count of distinct integers (`k`).

We will build this DP table iteratively, computing the number of valid arrays of different lengths, maximum values, and distinct integers. The following steps summarize the approach:

1. **Initialization**: Create a DP table `ways` of size `(n + 1) x (m + 1) x (k + 1)` and initialize it to zero. Set the base case for arrays of length 1 that have 1 distinct integer.

2. **Filling the DP Table**:
   - For each possible length from `1` to `n`, for each possible maximum value from `1` to `m`, and for each possible distinct integer count from `1` to `k`, compute the number of valid arrays.
   - Use the relation that counts the number of ways to form an array based on previous results in the DP table, considering both the addition of the current maximum value and the distribution of previous distinct integers.

3. **Compute the Result**: After filling the DP table, sum up all valid configurations for the full length `n` that contain exactly `k` distinct integers.

### Code Breakdown (Step by Step)

Letâ€™s analyze the code implementation step by step:

1. **Class Declaration**:
   ```cpp
   class Solution {
   public:
   ```

   - This defines the `Solution` class where our method to solve the problem will be contained.

2. **Member Variable for Modulus**:
   ```cpp
   int mod = (int) 1e9 + 7;
   ```

   - We declare a member variable `mod` to perform modulo operations, ensuring our results do not exceed typical integer limits and conform to the constraints specified in the problem.

3. **Function Declaration**:
   ```cpp
   int numOfArrays(int n, int m, int k) {
   ```

   - The method `numOfArrays` takes three parameters: `n` (length of the array), `m` (maximum integer value), and `k` (exact number of distinct integers) and returns an integer.

4. **DP Table Initialization**:
   ```cpp
   vector<vector<vector<int>>> ways =
       vector<vector<vector<int>>>(n + 1, vector<vector<int>>(m + 1, vector<int>(k + 1, 0)));
   ```

   - We create a three-dimensional vector `ways` initialized to zero, with dimensions `(n + 1)`, `(m + 1)`, and `(k + 1)`.

5. **Base Case Initialization**:
   ```cpp
   for(int j = 1; j <= m; j++) ways[1][j][1] = 1;
   ```

   - We initialize the base case where an array of length `1` can have any integer from `1` to `m`, contributing exactly `1` way to form an array with `1` distinct integer.

6. **Filling the DP Table**:
   ```cpp
   for (int ii = 1; ii <= n; ii++)
   for (int ij = 1; ij <= m; ij++)
   for (int ik = 1; ik <= k; ik++) {
   ```

   - These nested loops iterate over each dimension of the DP table. The outermost loop iterates over lengths, the middle loop iterates over maximum values, and the innermost loop iterates over distinct integers.

7. **Calculate Ways for Current State**:
   ```cpp
   long s = ((long) ij * ways[ii - 1][ij][ik]) % mod;
   for(int l = 1; l < ij; l++) s = (s + ways[ii - 1][l][ik - 1]) % mod;
   ways[ii][ij][ik] = (ways[ii][ij][ik] + s) % mod;
   ```

   - Here, we compute the number of ways to create an array of the current length (`ii`), maximum value (`ij`), and distinct integers (`ik`):
     - The first part counts the configurations where the current maximum integer `ij` is included.
     - The second part considers arrays formed by previous lengths with distinct integers reduced by one, while allowing for the inclusion of smaller integers.
   - We then store the computed result back into the DP table.

8. **Result Computation**:
   ```cpp
   long res = 0;
   for(int ii = 1; ii <= m; ii++) res = (res + ways[n][ii][k]) % mod;
   ```

   - After populating the DP table, we sum up all ways to form arrays of length `n` using all possible maximum values that contain exactly `k` distinct integers.

9. **Return Statement**:
   ```cpp
   return (int) res;        
   }
   ```

   - Finally, we cast the result to an integer and return it.

### Complexity

- **Time Complexity**: The time complexity is \(O(n \cdot m \cdot k^2)\). This is because for every combination of `n`, `m`, and `k`, we perform operations that can involve iterating over `m` again.

- **Space Complexity**: The space complexity is \(O(n \cdot m \cdot k)\) due to the storage of the three-dimensional DP table.

### Conclusion

The `numOfArrays` function effectively calculates the number of valid arrays of a specified length with a defined range of integers and distinct count requirements using dynamic programming. The solution demonstrates the power of combinatorial counting, using a structured approach to build up from simpler subproblems.

#### Key Takeaways:

- **Dynamic Programming**: This problem exemplifies how dynamic programming can be used to solve combinatorial problems by breaking them down into smaller, manageable subproblems.
- **Efficiency**: The implementation effectively leverages modular arithmetic to keep values manageable, ensuring compliance with constraints typically found in competitive programming.
- **Combinatorial Counting**: The method illustrates how to count arrangements under specific conditions, which is a crucial skill in algorithm design.

Overall, the provided solution showcases a well-structured approach to a challenging combinatorial problem, effectively leveraging the principles of dynamic programming for an efficient resolution.
### Problem Statement

The problem requires finding all root-to-leaf paths in a binary tree such that the sum of the node values along each path is equal to a given target sum. For each path that satisfies this condition, we need to return it as a list of integers.

In other words, given a binary tree, and a target sum, you need to find all paths from the root to any leaf node where the sum of the values in the path equals the target sum. Each path should be returned as a list of integers. The paths can be traversed in any order, and you must return a list of all valid paths.

For example, given the following binary tree:

```
          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
```

If the target sum is 22, the solution should return:

```
[ [5, 4, 11, 2], [5, 8, 4, 1] ]
```

### Approach

To solve the problem, we can employ a **depth-first search (DFS)** strategy to explore each path in the binary tree. As we traverse the tree, we accumulate the sum of node values along the current path. We can recursively visit the left and right children of each node, keeping track of the sum remaining until we reach a leaf node. Once a leaf node is reached, if the accumulated sum equals the target sum, we add the current path to our list of valid paths.

Here are the main steps to approach this problem:

1. **Initialize Data Structures:**
   - A `vector<vector<int>>` called `paths` to store all valid root-to-leaf paths.
   - A `vector<int>` called `path` to store the current path from the root to a leaf node.

2. **DFS Traversal:**
   - Traverse the binary tree recursively, starting from the root.
   - At each node, add the current node's value to the path.
   - If a leaf node is reached (i.e., both left and right children are `NULL`), check if the accumulated sum equals the target sum. If it does, add the path to the result.
   - After exploring both the left and right subtrees, backtrack by removing the last node from the path to explore other possible paths.

3. **Return the Result:**
   - Once all paths are explored, return the `paths` vector containing all valid paths.

### Code Breakdown (Step by Step)

Let's break down the code implementation and understand each part in detail:

#### 1. `pathSum` Function:

```cpp
vector<vector<int>> pathSum(TreeNode* root, int sum) {
    vector<vector<int>> paths;
    vector<int> path;
    findPaths(root, sum, path, paths);
    return paths;
}
```

- This function is the main entry point. It initializes an empty `vector<vector<int>>` called `paths` to store the valid paths, and an empty `vector<int>` called `path` to keep track of the current path as we traverse the tree.
- It then calls the `findPaths` helper function to perform the DFS and populate the `paths` vector.
- Finally, it returns the list of paths.

#### 2. `findPaths` Helper Function:

```cpp
void findPaths(TreeNode* node, int sum, vector<int>& path, vector<vector<int>>& paths) {
    if (!node) return;
    path.push_back(node->val);

    if (!(node->left) && !(node->right) && sum == node->val)
        paths.push_back(path);

    findPaths(node->left, sum - node->val, path, paths);
    findPaths(node->right, sum - node->val, path, paths);

    path.pop_back();
}
```

- This is a **recursive function** that traverses the binary tree.
- It first checks if the current `node` is `NULL` (base case for recursion). If the node is `NULL`, the function returns without doing anything.
- The current node's value is added to the `path` vector.
- Then, it checks if the current node is a **leaf node** (i.e., both left and right children are `NULL`), and whether the remaining sum (`sum == node->val`) matches the target sum. If both conditions are true, it means we've found a valid path from the root to this leaf, so we add the current path to the `paths` vector.
- The function recursively calls itself for both the left and right children, reducing the target sum by the current node's value.
- Finally, after exploring both left and right subtrees, the last node is **removed from the path** (backtracking) to explore other possible paths in the tree.

#### 3. Backtracking:

The core idea here is **backtracking**. As we explore different paths from the root to the leaves, we build up a path (from the root to the current node). Once we explore a node's left and right subtrees, we backtrack by removing the last node from the path. This ensures that we do not keep any unnecessary data in the `path` while we are exploring other parts of the tree.

### Time Complexity

The time complexity of the solution is **O(n)**, where `n` is the number of nodes in the binary tree. This is because:
- We visit each node exactly once during the DFS traversal.
- The space complexity is **O(h)** for the recursion stack, where `h` is the height of the tree. In the worst case (unbalanced tree), the recursion stack depth can be as large as the number of nodes, i.e., **O(n)**.

In total, the time and space complexities are optimal for this problem.

### Space Complexity

The space complexity is **O(h)** for the recursion stack. In the worst case (if the tree is completely unbalanced), the height of the tree `h` is equal to `n`, so the space complexity would be **O(n)**. In the best case (if the tree is balanced), the space complexity is **O(log n)** due to the depth of the recursion stack.

The additional space used by the `path` vector is also proportional to the height of the tree, but this does not affect the overall space complexity, which remains **O(h)**.

### Conclusion

This solution efficiently finds all root-to-leaf paths in a binary tree that sum to a given target. Using a recursive depth-first search approach, it explores all possible paths while maintaining a running sum. The solution is efficient, with a time complexity of **O(n)** and a space complexity of **O(h)**, making it suitable for handling large binary trees.

The backtracking mechanism ensures that each path is constructed properly, and once a leaf node is reached, valid paths are added to the result. This approach is elegant and handles various edge cases, including empty trees and trees with no valid paths, effectively.

In summary, the algorithm provides a clean and optimal solution for the problem of finding all paths that sum to a given value in a binary tree, and it can be applied to various tree traversal problems with slight adjustments.
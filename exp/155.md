### Problem Statement

The problem requires implementing a data structure that supports the following operations:

1. **`push(x)`**: Push an integer `x` onto the stack.
2. **`pop()`**: Remove the element from the top of the stack.
3. **`top()`**: Retrieve the element at the top of the stack.
4. **`getMin()`**: Retrieve the minimum element in the stack.

All operations should be performed in constant time, **O(1)**. This requires a clever approach to track the minimum element in the stack without having to traverse the entire stack each time `getMin()` is called.

### Approach

To solve this problem efficiently, we can maintain a stack where each node stores:
- The value of the element itself (`val`).
- The minimum element in the stack up to that point (`mn`).
- A reference to the previous node in the stack (`node`), forming a linked list.

By storing the minimum element at each level of the stack, we can ensure that the `getMin()` operation takes constant time (`O(1)`), even if the stack grows or shrinks. This approach eliminates the need to traverse the entire stack to find the minimum value, as it will always be stored in the current node.

### Code Breakdown (Step by Step)

#### Step 1: Define the `Node` Class
```cpp
class Node {
public:
    int val; // Value of the current element in the stack
    int mn;  // Minimum value of the stack up to this point
    Node* node; // Reference to the next node in the stack

    Node(int val, int mn, Node* node) {
        this->val = val;
        this->mn = mn;
        this->node = node;
    }
};
```
- The `Node` class is the building block of the stack, and it has three fields:
  - `val`: The value of the current element in the stack.
  - `mn`: The minimum value in the stack at the time this node was created.
  - `node`: A pointer to the next node in the stack.

The constructor initializes these values when a new node is created.

#### Step 2: Define the `MinStack` Class
```cpp
class MinStack {
public:
    Node* head; // Head of the stack (top of the stack)

    MinStack() {
        head = NULL; // Initially, the stack is empty, so head is NULL
    }
```
- The `MinStack` class contains a `head` pointer that refers to the top of the stack. When the stack is empty, `head` is initialized to `NULL`.

#### Step 3: Implement the `push` Method
```cpp
    void push(int val) {
        if (!head) {
            head = new Node(val, val, NULL); // If the stack is empty, create a new node with the value
        } else {
            head = new Node(val, min(head->mn, val), head); // Create a new node with the current value and the minimum value so far
        }
    }
```
- The `push` method adds a new element to the stack.
- If the stack is empty (`!head`), a new node is created with the value `val` and the minimum value as `val` itself. The `node` pointer is set to `NULL` because this is the first element in the stack.
- If the stack is not empty, a new node is created with:
  - The current value `val`.
  - The minimum value as the smaller of the current node's minimum (`head->mn`) and the new value `val`.
  - The `node` pointer is set to the current `head` to link the new node to the previous top.

#### Step 4: Implement the `pop` Method
```cpp
    void pop() {
        head = head->node; // Move the head pointer to the next node (pop the top element)
    }
```
- The `pop` method removes the top element from the stack by updating the `head` pointer to the next node (`head->node`), effectively removing the current top node from the stack.

#### Step 5: Implement the `top` Method
```cpp
    int top() {
        return head->val; // Return the value of the current top element
    }
```
- The `top` method returns the value of the current top element by accessing the `val` field of the `head` node.

#### Step 6: Implement the `getMin` Method
```cpp
    int getMin() {
        return head->mn; // Return the minimum value stored at the top of the stack
    }
};
```
- The `getMin` method returns the minimum value in the stack, which is stored in the `mn` field of the `head` node. Since we are always storing the minimum value at each level, this operation is **O(1)**.

### Complexity

#### Time Complexity:
- **`push`**: **O(1)** – Each `push` operation only involves creating a new node and setting the minimum value, both of which are done in constant time.
- **`pop`**: **O(1)** – The `pop` operation involves simply updating the `head` pointer, which is done in constant time.
- **`top`**: **O(1)** – The `top` operation simply returns the value of the top node, which is done in constant time.
- **`getMin`**: **O(1)** – The `getMin` operation returns the minimum value stored at the top of the stack, which is also done in constant time.

#### Space Complexity:
- **O(n)**, where `n` is the number of elements in the stack. Each element is stored in a `Node` object, and each node contains three pieces of information (`val`, `mn`, and `node`). Therefore, the space complexity is linear with respect to the number of elements in the stack.

### Conclusion

This solution provides an efficient implementation of a stack that supports constant-time operations for pushing, popping, retrieving the top element, and getting the minimum element. The use of a linked list where each node stores both the value and the minimum value at that point ensures that all operations are done in constant time, **O(1)**.

#### Key Insights:
- By storing the minimum element at each level in the stack, we eliminate the need to traverse the entire stack to find the minimum, making the `getMin()` operation extremely efficient.
- The space complexity is linear with respect to the number of elements in the stack, as each element is stored in a node with additional information.
- The approach ensures that each operation, including `push`, `pop`, `top`, and `getMin`, is performed in constant time, making the solution optimal for scenarios requiring frequent minimum element retrievals in stacks.

This implementation of a **Min Stack** is particularly useful in situations where you need to maintain a stack-like structure but also frequently need to access the minimum element in the stack, such as in problems involving dynamic programming or stack-based algorithms.
### ðŸŒ Min Stack: A Stack with Constant Time Minimum Retrieval

In this problem, we are tasked with implementing a **Min Stack** that supports four operations, each performed in constant time **O(1)**:

1. **`push(x)`**: Push an integer `x` onto the stack.
2. **`pop()`**: Remove the top element from the stack.
3. **`top()`**: Retrieve the top element from the stack.
4. **`getMin()`**: Retrieve the minimum element from the stack.

The challenge is to ensure that **`getMin()`** is also executed in constant time, even as elements are added or removed from the stack.

---

### ðŸ’¡ Approach

To solve this, we use a stack with an enhancement where each node contains:
- The **value** of the element itself (`val`).
- The **minimum value** encountered so far in the stack (`mn`).
- A pointer to the **next node** in the stack (`node`), forming a linked list structure.

By storing the minimum value at each level, we can access the minimum element in **O(1)** time without needing to traverse the entire stack every time.

---

### ðŸ“ Code Breakdown (Step-by-Step)

#### ðŸ”¹ Step 1: Define the `Node` Class

```cpp
class Node {
public:
    int val;  // Value of the current element in the stack
    int mn;   // Minimum value of the stack up to this point
    Node* node;  // Reference to the next node in the stack

    Node(int val, int mn, Node* node) {
        this->val = val;
        this->mn = mn;
        this->node = node;
    }
};
```
- The `Node` class represents each element in the stack.
- Each node stores:
  - `val`: The value of the current element.
  - `mn`: The minimum value up to this point.
  - `node`: A reference to the next node in the stack.

#### ðŸ”¹ Step 2: Define the `MinStack` Class

```cpp
class MinStack {
public:
    Node* head;  // Head of the stack (top of the stack)

    MinStack() {
        head = NULL;  // Initially, the stack is empty
    }
```
- The `MinStack` class contains a `head` pointer that refers to the top of the stack.

#### ðŸ”¹ Step 3: Implement the `push` Method

```cpp
    void push(int val) {
        if (!head) {
            head = new Node(val, val, NULL);  // If the stack is empty, create a new node with the value
        } else {
            head = new Node(val, min(head->mn, val), head);  // Create a new node with the current value and the minimum value so far
        }
    }
```
- If the stack is empty, create a new node with the value `val` and set the minimum value as `val` itself.
- If the stack is not empty, create a new node where:
  - `val` is the current value.
  - `mn` is the smaller of the current minimum (`head->mn`) and the new value (`val`).
  - The new node points to the current `head`, making it the new top of the stack.

#### ðŸ”¹ Step 4: Implement the `pop` Method

```cpp
    void pop() {
        head = head->node;  // Move the head pointer to the next node (pop the top element)
    }
```
- The `pop` method removes the top element by updating the `head` pointer to the next node (`head->node`).

#### ðŸ”¹ Step 5: Implement the `top` Method

```cpp
    int top() {
        return head->val;  // Return the value of the current top element
    }
```
- The `top` method simply returns the value stored in the `head` node.

#### ðŸ”¹ Step 6: Implement the `getMin` Method

```cpp
    int getMin() {
        return head->mn;  // Return the minimum value stored at the top of the stack
    }
};
```
- The `getMin` method returns the minimum value stored in the `mn` field of the `head` node.

---

### ðŸ”Ž Complexity

#### Time Complexity:
- **`push`**: **O(1)** â€“ Each `push` operation involves creating a new node and setting the minimum value, both of which are constant-time operations.
- **`pop`**: **O(1)** â€“ The `pop` operation only updates the `head` pointer, which is done in constant time.
- **`top`**: **O(1)** â€“ The `top` operation simply returns the value of the top node, which is done in constant time.
- **`getMin`**: **O(1)** â€“ The `getMin` operation returns the minimum value stored at the top of the stack, which is done in constant time.

#### Space Complexity:
- **O(n)**, where `n` is the number of elements in the stack. Each element is stored in a `Node` object, which includes three fields (`val`, `mn`, `node`).

### âœ… Conclusion

This **Min Stack** solution ensures that all operations, including `push`, `pop`, `top`, and `getMin`, are executed in **constant time**. The key idea is storing the minimum value at each level in the stack, so it can be efficiently retrieved without traversing the entire stack.

#### Key Insights:
- Storing the minimum value at each level of the stack ensures that we can retrieve it in **O(1)** time.
- This approach provides an optimal solution for problems that require frequent access to the minimum element in a stack.
- The space complexity is linear in terms of the number of elements, as each element is stored in a node with additional metadata.

This implementation is highly efficient and suitable for applications requiring constant-time minimum retrieval, such as dynamic programming problems or scenarios involving stack-based algorithms.
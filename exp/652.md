### Problem Statement

In this problem, we are given a binary tree, and we need to find all the subtrees in the tree that are duplicates. A subtree is defined as a part of the tree that includes the node itself, along with all its descendants. Two subtrees are considered duplicate if they have the same structure and node values. The task is to return a list of the root nodes of all duplicate subtrees.

### Approach

To solve this problem, we can take advantage of **tree serialization** and a **hash map** (unordered_map) to efficiently identify and track duplicate subtrees. The idea is to convert each subtree into a unique string representation, and then store these representations in a hash map. If we encounter a subtree that has been seen before (i.e., it maps to the same string), we can be sure that it is a duplicate subtree.

The algorithm can be broken down into two main parts:
1. **Serializing the tree**: This is done by traversing the tree and creating a string that uniquely represents each subtree. For each node, we recursively serialize its left and right subtrees, and combine them with the node's value to form a string. This way, identical subtrees will result in the same string representation.
2. **Tracking duplicates**: As we serialize each subtree, we store the serialized string in a hash map. If a particular string (representing a subtree) appears more than once, we know that the subtree is a duplicate.

### Code Breakdown (Step by Step)

#### 1. **TreeNode Definition**:
```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```
- The `TreeNode` structure defines the binary tree node, containing the integer `val`, a pointer to the left child `left`, and a pointer to the right child `right`. The constructor initializes these values.

#### 2. **Main Function (findDuplicateSubtrees)**:
```cpp
vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
    unordered_map<string, vector<TreeNode*>> mp;
    serialise(mp, root);
    vector<TreeNode*> res;
    for(auto it: mp) {
        if(it.second.size() > 1)
            res.push_back(it.second[0]);
    }
    return res;
}
```
- We define a hash map `mp` that stores serialized subtree strings as keys, and vectors of `TreeNode*` as values. The vector contains all the nodes that share the same subtree structure and node values.
- The function `serialise(mp, root)` is called to fill this map by serializing all subtrees.
- After serialization, we iterate through the map to identify any subtrees that appear more than once. If the vector for a subtree has more than one element, we know that subtree is a duplicate, and we add the first occurrence of it (i.e., the root node) to the result list `res`.

#### 3. **Subtree Serialization (serialise)**:
```cpp
string serialise(unordered_map<string, vector<TreeNode*>> &mp, TreeNode* root) {
    if(root == NULL) return "";
    string s = "(" + serialise(mp, root->left) + to_string(root->val) + serialise(mp, root->right) + ")";
    mp[s].push_back(root);
    return s;
}
```
- The `serialise` function recursively serializes each subtree. If the current node is `NULL`, we return an empty string.
- For each non-NULL node, we create a string `s` by concatenating:
  - The serialized left subtree (`serialise(mp, root->left)`),
  - The current node's value (`to_string(root->val)`),
  - The serialized right subtree (`serialise(mp, root->right)`).
- This string representation ensures that the structure and node values are captured, so that identical subtrees will generate the same serialized string.
- We then store this string in the hash map `mp` and associate it with the current root node of the subtree.
- Finally, the function returns the serialized string `s`.

### Complexity

#### Time Complexity:
1. **Tree Traversal**: The algorithm performs a depth-first traversal of the entire tree to serialize each node and its subtrees. This traversal takes **O(n)** time, where `n` is the number of nodes in the tree.
2. **Serialization and Hash Map Operations**: Each node's serialization involves creating a string and performing a hash map lookup and insertion. In the worst case, the serialization string for each subtree can be linear in terms of the size of the subtree (though in practice it may be shorter). The time complexity for handling each node is **O(n)**, leading to a total time complexity of **O(n)** for the entire process.

Therefore, the overall time complexity is **O(n)**.

#### Space Complexity:
1. **Hash Map**: The space complexity is dominated by the storage required for the hash map, which stores one serialized string for each unique subtree. In the worst case, if no two subtrees are identical, the hash map will store `n` strings. Each string can be at most **O(n)** in length. Hence, the space complexity for the hash map is **O(n^2)**.
2. **Recursive Call Stack**: The depth of the recursion is the height of the tree, which is **O(n)** in the worst case for an unbalanced tree.

Thus, the overall space complexity is **O(n^2)**, dominated by the storage of the serialized strings in the hash map.

### Conclusion

The solution to finding duplicate subtrees in a binary tree efficiently uses serialization and a hash map. By recursively traversing the tree and creating a string representation for each subtree, we can easily identify duplicate subtrees by looking for duplicate strings in the hash map. The approach ensures that the problem is solved with a time complexity of **O(n)** and a space complexity of **O(n^2)**, making it suitable for most binary trees.

This method is optimal for solving subtree duplication problems, and the recursive approach allows for easy implementation while ensuring that both time and space complexities are manageable.
### Problem Statement

The problem at hand involves rearranging the nodes of a singly linked list such that all nodes at odd positions (1st, 3rd, 5th, etc.) are grouped together followed by all nodes at even positions (2nd, 4th, 6th, etc.). The relative order of nodes within the odd and even groups should remain unchanged.

For example:
- Input: `1 -> 2 -> 3 -> 4 -> 5`
- Output: `1 -> 3 -> 5 -> 2 -> 4`

The goal is to implement this in **O(n)** time complexity, where `n` is the number of nodes in the linked list. We also aim to achieve **O(1)** space complexity, meaning no extra space (like arrays or lists) should be used apart from a constant amount.

### Approach

To solve this problem efficiently, we can utilize two pointers: one to manage the odd indexed nodes and the other to manage the even indexed nodes. The strategy involves:

1. **Odd and Even List Segregation**: We'll maintain two separate lists, one for odd indexed nodes and one for even indexed nodes. The nodes of the odd list will be linked together first, followed by the even list.
   
2. **Pointer Movement**: We traverse through the linked list, updating the odd and even pointers alternately. As we go through the list:
   - Odd indexed nodes will be connected to the next odd indexed node.
   - Even indexed nodes will be connected to the next even indexed node.

3. **Termination**: The process continues until we reach the end of the list. Once the traversal ends, we connect the last odd node to the head of the even indexed list.

4. **Returning the New List**: Once we have merged the odd and even lists, the rearranged list is returned starting from the head of the list.

### Code Breakdown (Step by Step)

Let's break down the code and understand each part of it:

```cpp
if (!head) return NULL;
```
- **Null Check**: If the input list is empty (`head == NULL`), return `NULL`. This handles the edge case where the linked list is empty.

```cpp
ListNode *odd = head, *ehead = head->next, *even = head->next;
```
- **Pointer Initialization**:
  - `odd`: This pointer points to the first node (the head of the list), which is the first odd indexed node.
  - `ehead`: This pointer will point to the first even indexed node. Since the second node is at an even index, `ehead = head->next`.
  - `even`: This pointer will keep track of the current even indexed node as we iterate through the list.

```cpp
while (even && even->next) {
    odd->next = odd->next->next;
    even->next = even->next->next;
    odd = odd->next;
    even = even->next;
}
```
- **Main Loop**:
  - The `while` loop iterates through the linked list until we reach the end of the list or the end of the even nodes (`even->next` becomes `NULL`).
  - In each iteration:
    - The `odd->next` pointer is updated to point to the next odd indexed node, i.e., `odd->next = odd->next->next`.
    - Similarly, the `even->next` pointer is updated to point to the next even indexed node, i.e., `even->next = even->next->next`.
    - After that, the `odd` pointer moves to the next odd indexed node (`odd = odd->next`), and the `even` pointer moves to the next even indexed node (`even = even->next`).

```cpp
odd->next = ehead;
```
- **Connecting Odd List to Even List**: After the loop finishes, all odd indexed nodes are connected together and all even indexed nodes are connected together. Now, we connect the last odd node (`odd`) to the head of the even list (`ehead`), thereby merging the two lists.

```cpp
return head;
```
- **Return**: Finally, the rearranged linked list is returned, with the odd indexed nodes followed by the even indexed nodes.

### Complexity

#### Time Complexity:
- **O(n)**: The algorithm traverses through the linked list only once. In each iteration of the `while` loop, both `odd` and `even` pointers are moved forward. Since each node is visited only once, the time complexity is **O(n)**, where `n` is the number of nodes in the linked list.

#### Space Complexity:
- **O(1)**: The solution only uses a constant amount of extra space (pointers `odd`, `even`, and `ehead`), so the space complexity is **O(1)**. The rearranging is done in-place without requiring additional memory.

### Conclusion

This solution efficiently solves the problem of rearranging a singly linked list such that all nodes at odd indices come before those at even indices. The algorithm runs in **O(n)** time and uses **O(1)** space, which is optimal for this task. By employing two pointers, one for odd indexed nodes and another for even indexed nodes, the list is traversed and rearranged in a single pass. The approach is simple, elegant, and works well for large lists, making it suitable for practical use cases.
### Problem Statement

The problem asks to find the maximum number of chunks or partitions into which the array can be split such that, when the chunks are independently sorted, the entire array is sorted. In other words, we need to determine how many subarrays (chunks) we can divide the given array `arr` into such that each subarray, when sorted, leads to a sorted version of the entire array.

For example:

- Input: `[4, 3, 2, 1, 0]`
- Output: `1`
  
  Here, only one chunk is needed because the entire array is in reverse order, and sorting the entire array will yield the correct result.

- Input: `[1, 0, 2, 3, 4]`
- Output: `4`
  
  This is because we can divide the array into four chunks, i.e., `[1]`, `[0]`, `[2, 3, 4]`, and when each chunk is sorted, the whole array becomes sorted.

### Approach

This problem can be solved using the concept of tracking the maximum index reached during the process of sorting chunks. Hereâ€™s a step-by-step explanation:

1. **Track Original Indices**: To determine how far the elements should move to achieve a sorted order, we need to keep track of their original indices. This is crucial because elements in the original array are not necessarily in their final sorted positions.

2. **Sorting with Indices**: By sorting the array while preserving the original indices, we can then compare the indices of elements in the sorted array to determine when we can split the array into valid chunks.

3. **Partition Logic**: We iterate through the array, and at each point, we maintain the maximum index encountered from the sorted version of the array. If the current index reaches this maximum, it means we can create a chunk here, as all elements up to this point can be sorted independently.

4. **Chunk Count**: The number of times we encounter a maximum index indicates the number of valid partitions we can make. Each time the current index reaches the maximum index seen so far, we can count it as a new chunk.

### Code Breakdown (Step by Step)

#### Step 1: Create Pairs of Values and Indices

```cpp
vector<pair<int,int>> tmp;
int n = arr.size();
for(int i = 0; i < n; i++) {
    tmp.push_back({arr[i], i});
}
```

- We start by creating a vector of pairs `tmp`, where each pair contains an element from the array and its original index.
- This allows us to sort the elements while keeping track of their positions in the original array.

#### Step 2: Sort the Array Based on Values

```cpp
sort(tmp.begin(), tmp.end());
```

- We then sort the array `tmp` based on the values of the elements. The sorting algorithm will rearrange the pairs based on the first value of the pair (i.e., the elements of the original array).
- After sorting, the `tmp` array will contain pairs in increasing order of the element values, but we can still access the original indices through the second part of the pair.

#### Step 3: Traverse and Determine the Maximum Index

```cpp
int res = 0, mx = -1;
for(int i = 0; i < n; i++) {
    mx = max(mx, tmp[i].second);
    if(mx == i){
        res++;
    }
}
```

- We initialize `mx` to keep track of the maximum index encountered so far.
- We then iterate through the sorted array, and for each element, we update `mx` to be the maximum of the current value of `mx` and the index of the element in the original array (i.e., `tmp[i].second`).
- If at any point `mx == i`, this indicates that all elements up to index `i` can be sorted into a valid chunk, and we increment the chunk counter `res`.

#### Step 4: Return the Result

```cpp
return res;
```

- Once the loop completes, the value of `res` will represent the maximum number of chunks into which the array can be split such that, when each chunk is sorted, the entire array becomes sorted.

### Complexity

#### Time Complexity:
- **O(n log n)**: The most computationally expensive step is sorting the array. Sorting a vector of `n` elements takes O(n log n) time. The subsequent iteration over the array takes O(n) time. Therefore, the overall time complexity is dominated by the sorting step, which is O(n log n).

#### Space Complexity:
- **O(n)**: We use additional space to store the `tmp` vector, which contains `n` pairs. Therefore, the space complexity is O(n), where `n` is the length of the input array.

### Conclusion

This solution efficiently solves the problem of finding the maximum number of chunks into which the array can be split and still remain sorted when each chunk is sorted independently. The key idea behind the solution is to track the maximum index encountered as we sort the array based on element values and their original indices. Each time the current index matches this maximum, we can count it as a valid chunk.

#### Time Complexity:
- **O(n log n)** due to the sorting step.

#### Space Complexity:
- **O(n)** for storing the pairs of elements and their original indices.

By using sorting and greedy partitioning, we ensure that we can efficiently determine the maximum number of chunks that can be made, providing a scalable solution for larger arrays.
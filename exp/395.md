### Problem Statement

The problem asks to find the length of the longest substring in a given string `s` where each character in the substring appears at least `k` times. If no such substring exists, the function should return `0`.

For example:
- Given the string `"aaabb"`, and `k = 3`, the longest substring is `"aaa"`, as it is the only substring where each character appears at least 3 times.
- For the string `"ababbc"`, with `k = 2`, the longest substring is `"abb"`, as both 'a' and 'b' appear at least 2 times.

### Approach

The problem can be approached using a **divide and conquer** strategy, where we break down the string recursively and find substrings that meet the condition of having characters appear at least `k` times.

#### Key steps to solve the problem:
1. **Base cases**: 
   - If the string is empty or `k` is larger than the size of the string, the result is `0`.
   - If `k` is `0`, then every substring is valid, and the result is the entire string.
2. **Frequency Map**: Create a frequency map to count the occurrence of each character in the string.
3. **Divide the string**: Traverse the string, and divide it whenever a character occurs less than `k` times. This ensures that we break down the problem into smaller substrings.
4. **Recursion**: For each substring, recursively check if the condition holds. If it does, the substring is a valid candidate. We continue this until no valid substrings can be found.
5. **Combine results**: For substrings that satisfy the condition, return the longest substring by comparing results from both sides.

#### The divide and conquer approach is efficient because it progressively narrows down the search space, focusing on parts of the string that may contain the longest valid substrings.

### Code Breakdown (Step by Step)

Let’s go through the solution step by step:

#### Step 1: Base Cases
```cpp
if(s.size() == 0 || k > s.size()) return 0;
if(k == 0) return s.size();
```
- The first `if` checks if the string is empty or if `k` is greater than the size of the string. In either of these cases, we can return `0` because there cannot be any valid substring where each character appears at least `k` times.
- The second `if` checks if `k` is `0`. In that case, the entire string is valid, so we return the size of the string.

#### Step 2: Frequency Map
```cpp
unordered_map<char, int> mp;
for(int i = 0; i < s.size(); i++) {
    mp[s[i]]++;
}
```
- A frequency map `mp` is created to store the occurrence of each character in the string `s`.
- We iterate over the string and update the map with the count of each character.

#### Step 3: Splitting the String
```cpp
int idx = 0;
while(idx < s.size() && mp[s[idx]] >= k) idx++;
if(idx == s.size()) return s.size();
```
- We initialize an index `idx` to find the first character that appears fewer than `k` times.
- The `while` loop checks each character in the string. If the character occurs at least `k` times (i.e., `mp[s[idx]] >= k`), we continue moving the index forward.
- If the index reaches the end of the string, it means all characters satisfy the condition, and we return the length of the string as the result.

#### Step 4: Recursive Call on Substrings
```cpp
int left = longestSubstring(s.substr(0, idx), k);
int right = longestSubstring(s.substr(idx + 1), k);
```
- If we encounter a character that appears less than `k` times, we split the string at that point.
- We recursively call the `longestSubstring` function on two substrings: 
  1. The left substring before the character at index `idx`.
  2. The right substring after the character at index `idx`.
  
#### Step 5: Combine Results
```cpp
return max(left, right);
```
- We take the maximum length between the two recursively computed substrings, as we are interested in the longest valid substring.
- Finally, the result is returned.

### Example Walkthrough

Let’s consider an example to understand how the code works:

**Example 1:**
```cpp
longestSubstring("aaabb", 3);
```
- We first create a frequency map:
  - `{'a': 3, 'b': 2}`
- We check each character: 
  - 'a' appears 3 times (>= 3), so we continue.
  - 'b' appears 2 times (< 3), so we split the string into two substrings: `"aaa"` and `"bb"`.
- We recursively call `longestSubstring` on `"aaa"` and `"bb"`.
  - `"aaa"` satisfies the condition, so it’s returned with length 3.
  - `"bb"` does not satisfy the condition, so it’s returned with length 0.
- The final result is `max(3, 0) = 3`.

**Example 2:**
```cpp
longestSubstring("ababbc", 2);
```
- We first create a frequency map:
  - `{'a': 2, 'b': 3, 'c': 1}`
- We check each character:
  - 'a' appears 2 times (>= 2), so we continue.
  - 'b' appears 3 times (>= 2), so we continue.
  - 'c' appears 1 time (< 2), so we split the string into two substrings: `"ababb"` and `"c"`.
- We recursively call `longestSubstring` on `"ababb"` and `"c"`.
  - `"c"` does not satisfy the condition, so it returns length 0.
  - `"ababb"` satisfies the condition, so we return length 5.
- The final result is `max(5, 0) = 5`.

### Complexity

#### Time Complexity:
- **Time Complexity**: `O(n)`, where `n` is the length of the string. In the worst case, we scan each character of the string exactly once. Although we recursively call the function on substrings, the total number of recursive calls will still be linear in terms of the number of characters, since each substring progressively becomes smaller. Therefore, the overall time complexity is `O(n)`.

#### Space Complexity:
- **Space Complexity**: `O(n)`. The space complexity arises from the storage of the frequency map `mp` and the recursion stack. The map requires space proportional to the number of unique characters in the string (at most `n`), and the recursion stack can also grow to a depth of `n` in the worst case.

### Conclusion

This solution effectively handles the problem of finding the longest substring where each character appears at least `k` times. The approach is based on a divide-and-conquer strategy, where the string is recursively split into smaller substrings until all conditions are met. The use of a frequency map ensures that we can efficiently check each character's count. This approach is optimal with a linear time complexity of `O(n)` and a space complexity of `O(n)`, making it suitable for large input sizes.
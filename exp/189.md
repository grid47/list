### Problem Statement

The problem is to rotate an array of integers `nums[]` to the right by `k` steps. The array is given as an input, and the goal is to rearrange the elements such that each element is shifted to the right by `k` positions, with the last elements wrapping around to the beginning of the array.

#### Example:
- Input: `nums = [1, 2, 3, 4, 5, 6, 7]`, `k = 3`
- Output: `[5, 6, 7, 1, 2, 3, 4]`
  
- Input: `nums = [-1, -100, 3, 99]`, `k = 2`
- Output: `[3, 99, -1, -100]`

### Approach

The problem can be solved efficiently by using the **Reverse Subarray Approach**. The idea behind this approach is based on reversing parts of the array in such a way that the required rotation is achieved.

**Steps:**
1. **Modulo Operation**: If `k` is greater than the length of the array (`nums.size()`), rotating the array `k` times is equivalent to rotating it `k % nums.size()` times. This helps reduce unnecessary rotations.
   
2. **Reversing the entire array**: First, reverse the entire array. This step places the elements that need to be at the end of the array at the beginning.
   
3. **Reversing the first `k` elements**: After reversing the entire array, reverse the first `k` elements. This brings the elements that should be at the front into their correct positions.
   
4. **Reversing the remaining elements**: Finally, reverse the remaining elements from index `k` to the end of the array to restore their original order.

This approach ensures that the array is rotated in-place with constant space complexity and time complexity linear to the size of the array.

### Code Breakdown (Step by Step)

Let's break down the code to understand its working step by step.

#### 1. The `rotate` Function:
```cpp
void rotate(vector<int>& nums, int k) {
    k = k % nums.size();  // Step 1: Adjust the value of k if it's greater than the array size
    rev(nums, 0, nums.size() - 1);  // Step 2: Reverse the entire array
    rev(nums, 0, k - 1);  // Step 3: Reverse the first k elements
    rev(nums, k, nums.size() - 1);  // Step 4: Reverse the remaining elements
}
```
- **Adjust `k` with Modulo**: The first operation is to calculate `k = k % nums.size()`. This ensures that if `k` is greater than the length of the array, it is reduced to a smaller equivalent number of rotations. For instance, rotating an array of length 5 by 7 positions is equivalent to rotating it by 2 positions.
  
- **Reversing the Whole Array**: The array is reversed using the `rev` function. This will effectively place elements that need to be shifted to the front at the end of the array.
  
- **Reversing the First `k` Elements**: After the whole array is reversed, the first `k` elements are reversed again. This step places the elements that need to be at the front in their correct positions.
  
- **Reversing the Remaining Elements**: Finally, the elements from index `k` to the end are reversed. This restores their original order after the initial full array reversal.

#### 2. The `rev` Function:
```cpp
void rev(vector<int>& nums, int i, int j) {
    while(i <= j) {
        int tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
        i++;
        j--;
    }
}
```
- This helper function `rev` reverses the elements of the array between indices `i` and `j`.
- It uses a `while` loop to swap elements from both ends of the subarray, moving toward the middle. The loop continues until `i` is greater than `j`.
  
- The elements at `nums[i]` and `nums[j]` are swapped, and the pointers `i` and `j` are moved inward (`i++`, `j--`), ensuring that all elements in the specified range are reversed.

### Complexity Analysis

#### Time Complexity:
- **O(n)**: The time complexity is linear because:
  - Reversing the entire array takes `O(n)` where `n` is the size of the array.
  - Reversing the first `k` elements takes `O(k)`.
  - Reversing the remaining elements (size `n-k`) takes `O(n-k)`.
  
  The total time complexity is therefore `O(n)` as the dominant factor is the size of the array `n`.

#### Space Complexity:
- **O(1)**: The solution uses constant space because the reversal of subarrays is done in place, without requiring any extra space besides a few integer variables.

### Conclusion

The **Reverse Subarray Approach** is an efficient way to solve the problem of rotating an array in-place. By breaking the problem into three reversal operations, we can achieve the desired rotation with only a linear time complexity and constant space complexity.

#### Key Insights:
- **In-place Operation**: The solution operates directly on the input array, without needing any additional storage, which saves space.
- **Modulo Optimization**: The modulo operation ensures that we handle cases where `k` is larger than the size of the array efficiently.
- **Reversal Trick**: The key trick is reversing the entire array and then reversing the two parts (first `k` and last `n-k` elements) to achieve the desired order. This ensures that the solution is both time-efficient and easy to understand.

This approach is both elegant and efficient, making it a preferred choice for solving array rotation problems in competitive programming and technical interviews.
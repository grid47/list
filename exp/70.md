### Problem Statement

The problem is to determine the number of distinct ways to climb a staircase with `n` steps, given that you can take either 1 or 2 steps at a time. For example, if there are 3 steps, you could reach the top by taking 1+1+1 steps, 1+2 steps, or 2+1 steps, which totals three distinct ways. This is a classic dynamic programming problem that builds on smaller solutions to form an efficient approach to counting all possible ways to reach the top.

### Approach

To solve this problem, we can leverage dynamic programming (DP) to avoid recalculating the same sub-problems. In this case, we store the number of ways to reach each step in an array, where each entry is calculated as the sum of ways to reach the previous two steps. This is based on the observation that, to reach step `i`, you can either come from step `i-1` by taking one step or from step `i-2` by taking two steps.

Here’s the detailed approach:

1. **Define a DP Array**: We initialize an array `dp` of size `n+1` to store the number of ways to reach each step. Here, `dp[i]` will hold the number of ways to reach the `i`-th step.

2. **Set Base Cases**: 
   - `dp[0] = 1`: There is one way to be at the "starting point" without taking any steps.
   - `dp[1] = 1`: There is only one way to reach the first step (by taking one step).

3. **Fill the DP Array Using Recurrence Relation**: 
   - For each step `i` from 2 to `n`, calculate the number of ways to reach that step by summing the values of the previous two steps: `dp[i] = dp[i-1] + dp[i-2]`.
   - This recurrence relation is based on the fact that, to reach step `i`, you can either take a single step from `i-1` or a double step from `i-2`.

4. **Return the Result**: The final answer is `dp[n]`, which gives the total number of ways to reach the `n`-th step.

### Code Breakdown (Step by Step)

#### Step 1: Define the DP Array and Initialize Base Cases

```cpp
vector<int> dp(n + 1, 0);
dp[0] = 1;
dp[1] = 1;
```

- Here, we create a `dp` array of size `n+1` with all elements initialized to zero.
- `dp[0] = 1` and `dp[1] = 1` are the base cases: there’s one way to "stand" at the ground (step 0), and one way to reach the first step.

#### Step 2: Populate the DP Array Using the Recurrence Relation

```cpp
for(int i = 2; i < n + 1; i++)
    dp[i] = dp[i - 1] + dp[i - 2];
```

- This loop starts at `i = 2` and goes up to `n`. For each step `i`, we calculate `dp[i]` as the sum of `dp[i-1]` and `dp[i-2]`. This is because you can reach step `i` from either of the two preceding steps.

#### Step 3: Return the Result

```cpp
return dp[n];
```

- Finally, the function returns `dp[n]`, which is the number of ways to reach the `n`-th step.

### Complexity

#### Time Complexity
The time complexity is `O(n)` since we loop through `n` steps, and each operation inside the loop takes constant time.

#### Space Complexity
The space complexity is `O(n)` due to the `dp` array that stores the number of ways for each step from `0` to `n`.

### Conclusion

This dynamic programming solution is efficient and optimal for counting the ways to climb a staircase with `n` steps using only 1 or 2 steps at a time. By breaking down the problem into smaller sub-problems and storing intermediate results, the algorithm avoids redundant calculations and achieves linear time complexity. This method is commonly used in combinatorial problems where overlapping sub-problems occur, making it a valuable approach for similar challenges in dynamic programming.
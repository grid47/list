### Problem Statement
The problem asks us to count the number of "hill" and "valley" elements in the array `nums`. A *hill* is defined as an element that is greater than both its adjacent elements, while a *valley* is an element that is smaller than both its adjacent elements. The challenge here is to count these hills and valleys efficiently.

However, there are a few optimizations to consider:
- Consecutive elements that are the same should be removed before counting.
- We need to traverse the array and count hills and valleys while ignoring consecutive duplicates.

### Approach
The solution can be efficiently implemented using a **single pass** through the array with the help of a pointer (`j`) that skips over consecutive duplicate elements. The approach ensures that we:
1. Skip duplicate elements that would otherwise be counted as hills or valleys.
2. Check each element in the array (except the first and last elements) to determine whether it qualifies as a hill or valley.
3. Count the hills and valleys as we go through the array.

The strategy is:
1. Start by iterating through the array, checking each element and its neighbors.
2. Skip consecutive duplicate elements to ensure they don't affect the count.
3. For each element, check if it forms a hill or valley by comparing it with its adjacent elements.
4. Return the count of hills and valleys.

### Code Breakdown (Step by Step)

1. **Initialization:**
   ```cpp
   int res = 0;
   ```
   - `res` is initialized to 0, which will hold the count of hills and valleys.

2. **Iterating through the Array:**
   ```cpp
   for(int j = 0, i = 1; i < nums.size() - 1; i++)
   ```
   - The loop starts with `j` pointing to the first element and `i` pointing to the second element.
   - The loop will continue until `i` reaches the second-to-last element (`nums.size() - 1`), since the first and last elements can't be hills or valleys due to their lack of both neighbors.

3. **Skipping Duplicates:**
   ```cpp
   if ((nums[j] < nums[i] && nums[i] > nums[i + 1]) ||
       (nums[j] > nums[i] && nums[i] < nums[i + 1])) {
   ```
   - This condition checks if the current element (`nums[i]`) is either a hill or a valley.
   - If `nums[i]` is greater than both its neighbors (`nums[j]` and `nums[i + 1]`), it forms a hill. Similarly, if `nums[i]` is smaller than both its neighbors, it forms a valley.
   - The condition is written to ensure that we only count the element as a hill or valley when its adjacent elements are not equal, effectively skipping over duplicate numbers.

4. **Updating the Count:**
   ```cpp
   res++;
   j = i;
   ```
   - If a hill or valley is found, increment `res` and update `j` to point to the current element (`i`).
   - This ensures that we skip over consecutive duplicates and only check for hills and valleys after unique elements.

5. **Returning the Result:**
   ```cpp
   return res;
   ```
   - After completing the iteration, the function returns `res`, the total count of hills and valleys in the array.

### Complexity

#### Time Complexity:
- **O(n)**: 
  - The algorithm runs in O(n) time where `n` is the number of elements in the input array `nums`. This is because we only iterate through the array once and perform constant-time checks for each element.

#### Space Complexity:
- **O(1)**: 
  - The space complexity is O(1) because we are using only a few additional variables (`res`, `j`, and `i`), and no additional space is used that grows with the input size.

### Conclusion
This solution efficiently counts the number of hills and valleys in the input array `nums` with a single pass. It avoids counting consecutive duplicates and ensures that only elements that form valid hills or valleys are counted. The use of a single iteration through the array ensures optimal time complexity of O(n), making this solution suitable for large input sizes. Additionally, the space complexity is O(1), meaning the solution uses constant space regardless of the input size, which makes it both time and space efficient.
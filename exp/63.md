### Problem Statement

The problem is to find the total number of unique paths in an `m x n` grid from the top-left corner `(0, 0)` to the bottom-right corner `(m-1, n-1)` while avoiding obstacles. In this grid:
- Cells can contain obstacles, represented by `1`s, which cannot be traversed.
- Cells without obstacles are represented by `0`s and are free to traverse.
- Movement is restricted to either down or right at each step.

### Approach

This solution employs a dynamic programming (DP) approach to compute the number of unique paths in the grid, considering obstacles.

#### Key Observations:
1. **Starting Point**:
   - If the starting cell `(0, 0)` contains an obstacle, there are `0` ways to reach any destination, so the function immediately returns `0` paths.

2. **DP Initialization**:
   - We initialize a `dp` table where `dp[i][j]` represents the number of unique ways to reach cell `(i, j)` from the starting point `(0, 0)`.

3. **Base Cases**:
   - If the starting cell `(0, 0)` is free of obstacles, it is initialized to `1` in `dp`, indicating one way to start at that position.
   - For cells in the first row and first column, they can only be reached if there are no obstacles along their respective rows or columns. If any cell has an obstacle, all cells after it in that row or column will have `0` paths.

4. **Filling the DP Table**:
   - For each cell `(i, j)`, if it is free of obstacles (i.e., `grid[i][j] == 0`), the value of `dp[i][j]` is the sum of the values from the top cell `(i-1, j)` and the left cell `(i, j-1)`, as these are the only two directions from which you can arrive.
   - If a cell contains an obstacle (`grid[i][j] == 1`), then `dp[i][j]` is set to `0` since it is not reachable.

### Code Breakdown (Step by Step)

1. **Initialize DP Table**:
   ```cpp
   vector<vector<int>> dp(m, vector<int>(n, 0));
   ```
   - A 2D `dp` table of size `m x n` is initialized with `0`s, representing the paths to each cell.

2. **Starting Point Condition**:
   ```cpp
   dp[0][0] = grid[0][0] == 1? 0 : 1;
   ```
   - The top-left corner `dp[0][0]` is set to `1` if there’s no obstacle; otherwise, it’s set to `0`, as no paths are possible.

3. **Fill the DP Table**:
   ```cpp
   for(int i = 0; i < m; i++)
       for(int j = 0; j < n; j++) {
           if(grid[i][j] != 1) {
               dp[i][j] += ((i > 0 && grid[i - 1][j] == 0)? dp[i - 1][j] : 0) +
                           ((j > 0 && grid[i][j - 1] == 0)? dp[i][j - 1] : 0);
           }
       }
   ```
   - For each cell `(i, j)`:
     - If there is no obstacle, we add paths from the cell above `(i-1, j)` and the cell to the left `(i, j-1)` (if they exist and are also obstacle-free).
   - This approach fills up the `dp` table by leveraging already-computed paths, resulting in an efficient traversal of the grid.

4. **Return the Final Answer**:
   ```cpp
   return dp[m - 1][n - 1];
   ```
   - The final answer at `dp[m-1][n-1]` contains the total unique paths to the destination, considering any obstacles in the grid.

### Complexity

#### Time Complexity
- **O(m * n)**: We iterate through every cell in the `m x n` grid once, resulting in a time complexity of `O(m * n)`.

#### Space Complexity
- **O(m * n)**: We use an auxiliary `dp` table of size `m x n` to store intermediate results.

### Conclusion

This DP solution efficiently calculates the unique paths from the top-left to the bottom-right of a grid, incorporating obstacle restrictions. It leverages previous cell values to build up the solution, avoiding redundant calculations and ensuring optimal performance. This approach is well-suited for grids with obstacles, as it dynamically adapts based on obstacle locations.
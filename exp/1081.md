

### Problem Statement
The task is to find the smallest lexicographical subsequence of a string that contains all unique characters. A subsequence is defined as a sequence derived from another sequence where elements are deleted without changing the order of the remaining elements. The goal is to ensure that the resultant subsequence is as small as possible while including each character only once and maintaining the lexicographical order.

### Approach
To solve this problem efficiently, we will use a greedy algorithm with the help of a stack. The basic idea is to iterate through the string while maintaining a stack that contains the characters of the smallest subsequence. We will also use two auxiliary arrays: one to track the last occurrence of each character and another to check if a character is already included in the stack.

1. **Track Last Occurrences**: First, we traverse the string to record the last index of each character.
2. **Use a Stack**: We maintain a stack to build the smallest subsequence. As we iterate through the string:
   - If the character is already in the stack, we skip it.
   - If the current character is smaller than the character at the top of the stack, and if the character at the top of the stack appears later in the string, we pop the stack.
   - Finally, we push the current character onto the stack.
3. **Build Result**: After processing all characters, we convert the stack to a string, which represents the desired smallest subsequence.

### Code Breakdown (Step by Step)

1. **Class Definition**: The class `Solution` contains the method `smallestSubsequence` that will implement the solution.

   ```cpp
   class Solution {
   public:
       string smallestSubsequence(string s) {
   ```

2. **Initialization**: We declare a string `res` to hold the result and two vectors, `in` and `seen`, to track the last occurrence of each character and whether a character has been added to the stack, respectively.

   ```cpp
           int n = s.size();
           string res = "";
           vector<int> in(26, 0), seen(26, 0);
   ```

3. **Recording Last Occurrences**: We iterate through the string and record the last index for each character.

   ```cpp
           for (int i = 0; i < n; i++)
               in[s[i] - 'a'] = i;
   ```

4. **Stack for Result**: We declare a vector `stk` to act as a stack for building our result.

   ```cpp
           vector<int> stk;
   ```

5. **Main Loop**: We iterate through each character in the string `s`.

   ```cpp
           for (int i = 0; i < n; i++) {
               int c = s[i] - 'a';
   ```

6. **Skip Seen Characters**: If the character has already been added to the stack (i.e., `seen[c]` is greater than zero), we skip it.

   ```cpp
               if (seen[c]++ > 0) continue;
   ```

7. **Pop from Stack**: While the stack is not empty, and the top character of the stack is lexicographically larger than the current character, we check if the top character appears later in the string using the `in` array. If it does, we can safely pop it from the stack.

   ```cpp
               while (!stk.empty() && stk.back() > c && i < in[stk.back()]) {
                   seen[stk.back()] = 0;
                   stk.pop_back();
               }
   ```

8. **Push Current Character**: We push the current character onto the stack.

   ```cpp
               stk.push_back(c);
           }
   ```

9. **Build the Result String**: Finally, we convert the stack into a string `res` by appending the characters.

   ```cpp
           for (int i = 0; i < stk.size(); i++)
               res += ('a' + stk[i]);
           return res;
       }
   };
   ```

### Complexity Analysis
- **Time Complexity**: The time complexity of the algorithm is \(O(N)\), where \(N\) is the length of the input string. This is because we make a single pass through the string and each character is pushed and popped from the stack at most once.
  
- **Space Complexity**: The space complexity is \(O(1)\) in terms of the character set, as we are using fixed-size arrays of size 26 for the English alphabet. The stack can grow up to the size of the input string in the worst case, leading to a potential space complexity of \(O(N)\) for the stack itself.

### Conclusion
The provided C++ code efficiently solves the problem of finding the smallest lexicographical subsequence of a string containing all unique characters. By leveraging a greedy approach with a stack, the algorithm ensures that each character is included only once and that the order is maintained, resulting in an optimal solution.

This algorithm is useful in various applications, such as text processing, data compression, and similar problems where maintaining unique characters in a specific order is essential. Its linear time complexity and minimal space usage make it a robust choice for efficiently handling this type of problem.

In summary, the `smallestSubsequence` method demonstrates a clear and effective technique to achieve the desired result, showcasing the power of greedy algorithms and stack data structures in solving string-related challenges.

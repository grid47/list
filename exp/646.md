### Problem Statement

The problem requires us to find the length of the longest chain of pairs where each pair consists of two integers. A pair `(a, b)` can only follow another pair `(c, d)` if `b < c`, meaning the second element of the first pair is strictly less than the first element of the second pair. The goal is to determine the longest sequence of pairs that can form a valid chain.

For example, given a set of pairs `[[1, 2], [2, 3], [3, 4], [5, 6]]`, the longest chain would be `[[1, 2], [3, 4], [5, 6]]`, which has a length of 3.

### Approach

This problem is essentially a variant of the **Longest Increasing Subsequence (LIS)** problem, but with pairs. The basic idea is to sort the pairs and use dynamic programming (DP) to determine the longest valid chain that can be formed.

Here’s how we solve the problem:

1. **Sorting the Pairs**: 
   - First, we sort the pairs. The primary sorting criterion is the first element of each pair, and if two pairs have the same first element, we sort them based on the second element.
   - Sorting the pairs ensures that we only need to compare the second element of a pair to determine if it can form a valid chain with another pair.

2. **Dynamic Programming (DP) Setup**:
   - We use a DP array `dp[]` where each `dp[i]` represents the length of the longest chain that ends with the pair at index `i`.
   - Initially, we assume that every pair can form a chain of length `1`, so we set each `dp[i] = 1`.
   - We then iterate over all pairs and try to extend the chains by comparing the current pair to previous pairs in the sorted order. If the second element of the previous pair is less than the first element of the current pair, we can form a valid chain, and we update `dp[i]` accordingly.

3. **Max Length Calculation**:
   - As we iterate through the pairs and update the DP array, we keep track of the maximum value in `dp[]`, which will be the length of the longest chain.

### Code Breakdown (Step by Step)

Let’s break down the solution step by step to understand how it works:

#### 1. **Comparing Pairs**:
```cpp
static bool cmp(vector<int> &a, vector<int> &b) {
    if(a[0] == b[0]) return a[1] < b[1];
    else return a[0] < b[0];
}
```
- We define a static comparison function `cmp` to sort the pairs. If the first elements of two pairs are the same, we sort them by their second elements. Otherwise, we sort them by the first element.
- This ensures that the pairs are sorted in a way that makes it easy to apply the DP approach for finding the longest chain.

#### 2. **Sorting the Pairs**:
```cpp
sort(pairs.begin(), pairs.end(), cmp);
```
- We sort the input pairs using the comparison function `cmp`. Sorting is the first step in setting up the problem for the dynamic programming approach.

#### 3. **Initializing DP Array**:
```cpp
int n = pairs.size();
vector<int> dp(n, 1);
int mx = 1;
```
- We initialize the `dp[]` array with `1` since each pair, by itself, can form a chain of length `1`.
- We also initialize `mx = 1`, which will store the length of the longest chain.

#### 4. **Dynamic Programming Loop**:
```cpp
for(int i = 0; i < n; i++) {
    for(int j = 0; j < i; j++) {
        if(pairs[i][0] > pairs[j][1]) {
            dp[i] = max(dp[i], dp[j] + 1);
            mx = max(mx, dp[i]);
        }
    }
}
```
- We use two nested loops: the outer loop iterates over each pair, and the inner loop compares the current pair to all the pairs before it.
- If the first element of the current pair is greater than the second element of a previous pair (`pairs[i][0] > pairs[j][1]`), then the current pair can be added to the chain formed by the previous pair. We update `dp[i]` to be the maximum of its current value and `dp[j] + 1`, which represents extending the chain ending at pair `j` by adding the current pair.
- We also update `mx` to track the longest chain encountered so far.

#### 5. **Returning the Result**:
```cpp
return mx;
```
- Finally, after iterating through all the pairs and updating the `dp[]` array, we return `mx`, which contains the length of the longest valid chain.

### Complexity

#### Time Complexity:
- **Sorting the pairs** takes `O(n log n)`, where `n` is the number of pairs.
- **Dynamic programming** involves two nested loops, each iterating over `n` pairs. The inner loop runs `n` times for each iteration of the outer loop, resulting in a time complexity of `O(n^2)`.

Thus, the total time complexity is dominated by the `O(n^2)` term from the DP part of the solution. Therefore, the overall time complexity is **O(n^2)**.

#### Space Complexity:
- We use an array `dp[]` of size `n` to store the length of the longest chain for each pair. This results in a space complexity of **O(n)**.
- The space complexity is **O(n)** due to the DP array.

### Conclusion

The solution to the problem of finding the longest chain of pairs uses a combination of sorting and dynamic programming to efficiently determine the result. By sorting the pairs, we ensure that we only need to compare the second element of a pair with the first element of previous pairs to form a valid chain. The dynamic programming approach allows us to build the longest chain by iterating through the sorted pairs and updating the chain lengths as we go.

While the time complexity of the solution is `O(n^2)` due to the nested loops, this approach is straightforward and works well for moderately sized input arrays. The space complexity of `O(n)` is optimal since we only need to store the DP values.

This solution is both simple to understand and effective in finding the longest chain of pairs that can form a valid sequence.
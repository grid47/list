### Problem Statement

In this problem, we are given:
- Two lists of words, `pos` and `neg`. Words in the `pos` list are associated with positive points, and words in the `neg` list are associated with negative points.
- A list of student reports, where each report contains a list of words. Each word in the report contributes to the score of the student. If the word is in the `pos` list, it adds 3 points; if the word is in the `neg` list, it subtracts 1 point.
- Each student has a unique ID provided in the `id` list corresponding to each report.

We need to return the top `k` students based on their total score from the reports. If two students have the same score, the student with the smaller ID comes first.

### Approach

We will use the following steps to solve the problem:

1. **Initialize data structures**:
   - We will use two sets, `p` and `n`, to store the positive and negative words for quick lookup. The set provides constant time complexity for checking if a word belongs to the positive or negative list.
   - A priority queue will help us maintain the students' scores in descending order. If two students have the same score, the student with the smaller ID will be prioritized. This can be efficiently handled using a custom comparator.

2. **Score calculation**:
   - For each report, we will compute the total score by checking each word in the report. If the word is in the positive list (`pos`), we add 3 points; if it’s in the negative list (`neg`), we subtract 1 point.
   - The result of each student's score, along with their ID, will be stored in a priority queue.

3. **Returning top `k` students**:
   - After processing all reports and storing the scores in the priority queue, we will pop the top `k` students from the queue.

### Code Breakdown (Step by Step)

#### Step 1: Define the custom comparator class `cmp`
```cpp
class cmp {
public:
    bool operator()(vector<int> &a, vector<int> &b) {
        if(a[0] == b[0]) return a[1] > b[1];  // If scores are the same, prioritize smaller ID
        return a[0] < b[0];  // Otherwise, prioritize higher score
    }
};
```
- The comparator is used to ensure that the priority queue is ordered based on the score (`a[0]`). If two scores are equal, the student with the smaller ID (`a[1]`) is prioritized.

#### Step 2: Define the main function `topStudents`

```cpp
class Solution {
public:
    vector<int> topStudents(vector<string>& pos, vector<string>& neg, vector<string>& report, vector<int>& id, int k) {
        set<string> p, n;
        for(auto it: pos) {
            p.insert(it);  // Insert positive words into the set 'p'
        }
        for(auto it: neg) {
            n.insert(it);  // Insert negative words into the set 'n'
        }
```
- First, two sets `p` and `n` are initialized to store positive and negative words. We use sets for efficient word look-up.

```cpp
        priority_queue<vector<int>, vector<vector<int>>, cmp> pq;
```
- A priority queue (`pq`) is initialized. The queue will store pairs of score and student ID. The `cmp` class is used to ensure proper sorting in the queue.

```cpp
        int sz = report.size();
        for(int i = 0; i < sz; i++) {
            string s = report[i];  // Fetch the current student's report
            int prv = 0;
            int sum = 0;
            for(int j = 0; j < s.size(); j++) {
                if(s[j] == ' ' || j == s.size() - 1) {
                    string str = s.substr(prv, (j == s.size() - 1? s.size(): j) - prv);
                    prv = j + 1;
                    if(p.count(str)) sum += 3;  // Add 3 points if word is in 'pos'
                    if(n.count(str)) sum -= 1;  // Subtract 1 point if word is in 'neg'
                }
            }
            pq.push({sum, id[i]});  // Push the score and student ID into the priority queue
        }
```
- For each report in the `report` list:
  - We split the report into words by scanning through each character.
  - For each word, we check if it’s in the positive list `p` or the negative list `n`.
  - We calculate the score by adding 3 for positive words and subtracting 1 for negative words.
  - The total score along with the student ID is pushed into the priority queue.

#### Step 3: Extract top `k` students

```cpp
        vector<int> ans;
        while(!pq.empty() && k--) {
            ans.push_back(pq.top()[1]);  // Push the student ID of the top element into 'ans'
            pq.pop();  // Remove the top element
        }
        return ans;  // Return the list of top 'k' student IDs
    }
};
```
- After all reports are processed and the priority queue contains the students sorted by their scores (and IDs in case of ties), we pop the top `k` students from the queue.
- The student IDs of the top `k` students are collected into the `ans` vector and returned as the result.

### Example Walkthrough

Let’s walk through an example to understand how the algorithm works.

#### Example Input:

```cpp
vector<string> pos = {"math", "science", "english"};
vector<string> neg = {"history", "geography"};
vector<string> report = {"math science history", "science english geography", "math english history"};
vector<int> id = {101, 102, 103};
int k = 2;
```

#### Step-by-step Execution:
1. **Initialize sets**:
   - `p = {"math", "science", "english"}`
   - `n = {"history", "geography"}`

2. **Process reports**:
   - **Report 1**: "math science history"
     - `sum = 0`
     - Add points for "math" and "science" from `p`, subtract for "history" from `n`.
     - Final score = `3 + 3 - 1 = 5`
     - Push `(5, 101)` into the priority queue.
   
   - **Report 2**: "science english geography"
     - `sum = 0`
     - Add points for "science" and "english" from `p`, subtract for "geography" from `n`.
     - Final score = `3 + 3 - 1 = 5`
     - Push `(5, 102)` into the priority queue.
   
   - **Report 3**: "math english history"
     - `sum = 0`
     - Add points for "math" and "english" from `p`, subtract for "history" from `n`.
     - Final score = `3 + 3 - 1 = 5`
     - Push `(5, 103)` into the priority queue.

3. **Priority Queue** after processing all reports:
   - `(5, 101)`
   - `(5, 102)`
   - `(5, 103)`

4. **Extract top `k = 2` students**:
   - The first two students in the priority queue will be selected based on their ID order:
     - `101`, `102` are selected (in order of IDs).

#### Output:

```cpp
{101, 102}
```

### Complexity Analysis

#### Time Complexity:
- **Set Construction**: Constructing the sets `p` and `n` takes \(O(m)\), where \(m\) is the total number of words in the `pos` and `neg` lists.
- **Report Processing**: For each report, we process each word, which takes \(O(w)\) time, where \(w\) is the number of words in the report. Thus, processing all reports takes \(O(s \cdot w)\), where \(s\) is the number of students (size of `report`).
- **Priority Queue Operations**: We perform \(O(s \log s)\) operations for pushing all students into the priority queue and then \(O(k \log s)\) operations for extracting the top `k` students.
- **Total Time Complexity**: \(O(s \cdot w + s \log s)\), where `s` is the number of students and `w` is the average number of words in a report.

#### Space Complexity:
- **Sets for Words**: The space complexity for the sets `p` and `n` is \(O(m)\), where \(m\) is the total number of words in the `pos` and `neg` lists.
- **Priority Queue**: The priority queue stores up to `s` students, so its space complexity is \(O(s)\).
- **Total Space Complexity**: \(O(m + s)\).

### Conclusion

The solution efficiently calculates the top `k` students based on their scores, using sets for quick lookup and a priority queue for sorting students by score and ID. This approach is optimal in both time and space for handling large inputs, with a clear and maintainable implementation.
### Problem Statement

The problem involves swapping the values of the k-th node from the beginning and the k-th node from the end in a singly-linked list. Given the head of the list and an integer k, our task is to modify the list such that these two nodes are swapped, and then return the modified list. 

### Approach

To solve this problem, we can utilize a single pass through the linked list while keeping track of the k-th node from the beginning and the k-th node from the end. The steps involved in the approach are as follows:

1. **Traverse the List**: As we traverse the linked list, we will keep a pointer `n1` for the k-th node from the start and another pointer `n2` for the k-th node from the end.

2. **Determine the Length**: While traversing, we can also determine the length of the linked list. Knowing the length will allow us to identify the k-th node from the end.

3. **Swap Values**: Once we identify both nodes, we can simply swap their values.

4. **Return the Modified List**: Finally, we return the head of the modified linked list.

### Code Breakdown (Step by Step)

The provided code implements the above approach effectively. Below is a breakdown of the code:

1. **Struct Definition**: The `ListNode` struct defines the basic structure of a node in the singly-linked list.

    ```cpp
    struct ListNode {
        int val;
        ListNode *next;
        ListNode() : val(0), next(nullptr) {}
        ListNode(int x) : val(x), next(nullptr) {}
        ListNode(int x, ListNode *next) : val(x), next(next) {}
    };
    ```

2. **Class Declaration**: The solution is encapsulated within the `Solution` class.

    ```cpp
    class Solution {
    ```

3. **Public Method**: The public method `swapNodes` takes two parameters: a pointer to the head of the linked list and an integer `k`.

    ```cpp
    public:
    ListNode* swapNodes(ListNode* head, int k) {
    ```

4. **Pointer Initialization**: Two pointers `n1` and `n2` are initialized to keep track of the k-th node from the start and the end, respectively.

    ```cpp
    ListNode* n1 = nullptr, *n2 = nullptr;
    ```

5. **Traversal of the List**: A for loop iterates through the linked list using a pointer `p`.

    ```cpp
    for(ListNode *p = head; p != nullptr; p = p->next) {
    ```

    - Within the loop:
      - `n2` is moved forward only after the k-th node has been identified, ensuring that it eventually points to the k-th node from the end.
      - The k-th node from the beginning (`n1`) is identified when the counter `k` reaches zero.

6. **Decrementing k**: The counter `k` is decremented in each iteration to determine when to set `n1` to the current node `p`.

    ```cpp
    if(--k == 0) {
        n1 = p;
        n2 = head;
    }
    ```

7. **Swapping the Values**: Once both nodes are identified, their values are swapped using the `swap` function.

    ```cpp
    swap(n2->val, n1->val);
    ```

8. **Returning the Head**: Finally, the modified linked list head is returned.

    ```cpp
    return head;
    }
    ```

### Complexity

- **Time Complexity**: The time complexity of this solution is \( O(n) \), where \( n \) is the number of nodes in the linked list. This is because we traverse the list only once.

- **Space Complexity**: The space complexity is \( O(1) \) since we are only using a constant amount of extra space for the pointers `n1` and `n2`.

### Conclusion

In conclusion, the provided code efficiently swaps the values of the k-th node from the beginning and the k-th node from the end of a singly-linked list. The approach utilizes a single traversal to identify both nodes and performs the swap in constant space.

The implementation is clear, concise, and leverages the properties of linked lists effectively. This method is suitable for scenarios where linked list manipulation is necessary, such as in competitive programming or data structure courses.

The code demonstrates a good understanding of pointer manipulation in linked lists, and its efficiency in both time and space makes it a robust solution to the problem. By maintaining clarity and simplicity, it is easy to follow and adaptable to similar problems involving linked list node manipulation.
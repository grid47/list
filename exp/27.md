### Problem Statement

The problem requires removing all occurrences of a specific value from a given list (vector in this case) and returning the new length of the list after the removal. Importantly, the order of elements should be preserved, and we are required to perform the operation in-place, without using extra space for another list or array.

#### Input:
- A vector of integers `nums` and an integer `val` representing the value to remove.
  
#### Output:
- The length of the modified list after removing all occurrences of `val`.

### Approach

This problem can be solved by iterating through the list and shifting elements that are not equal to the target value `val` to the left side of the list. This will effectively remove all occurrences of `val` without the need for extra space. The approach relies on two pointers: one to traverse the list and the other to track the position of the next available slot for valid numbers.

The idea is to maintain an index `i`, which will point to the next available position to place a valid number (i.e., a number that is not equal to `val`). As we traverse through the list, we check each element:
- If the element is not equal to `val`, we assign it to `nums[i]` and increment `i`.
- By the end of the loop, all valid elements will have been shifted to the beginning of the list, and `i` will hold the new length of the list.

### Code Breakdown (Step by Step)

1. **Initialize the Pointer for the Resultant Array:**

```cpp
int i = 0;
```

- The variable `i` will act as the pointer that tracks the position in the array where the next valid element (non-equal to `val`) should be placed. It starts at 0, pointing to the first position.

2. **Iterate Through the List:**

```cpp
for(int node: nums)
```

- A for-each loop is used to iterate over each element in the `nums` vector. The loop checks each element (`node`) to determine if it should be kept in the list.

3. **Check if the Current Element Should Be Included:**

```cpp
if(node != val)
{
    nums[i] = node;
    i++;
}
```

- If the current element `node` is not equal to `val`, we assign it to the position `nums[i]` and then increment `i`. This ensures that all valid elements are moved to the front, and `i` tracks the length of the new array (without the removed value).

4. **Return the New Length of the List:**

```cpp
return i;
```

- The function returns `i`, which represents the new length of the list, i.e., the number of elements that are not equal to `val`.

### Complexity

#### Time Complexity:
- **O(n)**: The algorithm iterates through the `nums` array exactly once, where `n` is the number of elements in the array. Each element is either retained or ignored based on its value, making the process linear in time complexity.

#### Space Complexity:
- **O(1)**: The algorithm uses only a constant amount of extra space, regardless of the size of the input array. We do not use any additional data structures to store the modified list; all modifications happen in-place.

### Conclusion

The `removeElement` function efficiently removes all occurrences of a specified value from the list while preserving the order of the remaining elements. It operates in **O(n)** time and **O(1)** space, making it highly efficient. By modifying the list in-place and returning the new length, the algorithm adheres to the problem's constraints and provides an optimal solution.

This solution is optimal in both time and space complexity, making it ideal for scenarios where the list is large and memory usage needs to be minimized. The approach uses the two-pointer technique to achieve in-place removal without the need for additional memory or complex operations, ensuring the algorithm runs efficiently even for large inputs.
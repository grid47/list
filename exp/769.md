### Problem Statement

The problem requires us to determine the maximum number of chunks (subarrays) that we can split the given array into such that, when each chunk is sorted independently, the entire array becomes sorted. In other words, we need to find out how many partitions we can make in the array where each partition can be independently sorted to contribute to a globally sorted array.

**Example 1:**

- Input: `[4, 3, 2, 1, 0]`
- Output: `1`
  
  Here, the entire array is in reverse order, so only one chunk is needed to sort the entire array.

**Example 2:**

- Input: `[1, 0, 2, 3, 4]`
- Output: `4`
  
  The array can be split into four chunks: `[1]`, `[0]`, `[2, 3, 4]`. Sorting each of these chunks independently results in the sorted array `[0, 1, 2, 3, 4]`.

### Approach

This problem is a variation of partitioning the array based on certain conditions. The main idea is to determine the number of chunks by tracking the largest value encountered up to each index in the array. If at any index, the largest value encountered is equal to the current index, it indicates that we can form a valid partition up to that index.

We use the following approach:

1. **Track Maximum Value Up to Each Index**: As we iterate through the array, we keep track of the maximum value encountered so far. The logic is simple: for each index `i`, if the maximum value encountered up to `i` is equal to `i`, this means that we can partition the array up to this index and sort each partition independently.

2. **Count the Valid Partitions**: Each time the condition `mx == i` (where `mx` is the maximum value encountered so far) is met, it means we have found a valid partition where all elements up to index `i` can be sorted into a chunk. We increment the chunk count every time this condition holds true.

3. **Return the Number of Chunks**: After iterating through the entire array, the final count of partitions will be the number of chunks.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables

```cpp
int n = arr.size();
int res = 0, mx = arr[0];
```

- We first initialize the length of the array `n` and the result variable `res` to zero, which will keep track of the number of valid chunks.
- We also initialize `mx`, which tracks the maximum value encountered so far in the array. It is initially set to the first element of the array `arr[0]`.

#### Step 2: Iterate Over the Array

```cpp
for(int i = 0; i < n; i++) {
    mx = max(mx, arr[i]);
    res += (mx == i);
}
```

- We loop through each element of the array using the index `i`.
- At each step, we update `mx` to be the maximum value between the current maximum (`mx`) and the current element `arr[i]`. This ensures that `mx` always holds the largest value encountered up to index `i`.
- Then, we check if `mx == i`. This condition means that the maximum value encountered up to index `i` is exactly `i`. In this case, we know that all elements up to this index can be sorted independently in a valid chunk. If the condition holds true, we increment the chunk count `res` by 1.

#### Step 3: Return the Result

```cpp
return res;
```

- After the loop finishes, we return the value of `res`, which represents the maximum number of chunks that the array can be split into such that each chunk can be sorted independently to form a globally sorted array.

### Complexity

#### Time Complexity:
- **O(n)**: The time complexity of this solution is linear because we only iterate through the array once. The `max()` function takes constant time for each element, and we are only updating the value of `mx` and checking the condition `mx == i` at each step. Therefore, the time complexity is **O(n)**, where `n` is the length of the array.

#### Space Complexity:
- **O(1)**: The space complexity is constant because we are only using a few integer variables (`mx`, `res`, and `n`) to store intermediate results. We do not use any extra data structures that grow with the size of the input array. Therefore, the space complexity is **O(1)**.

### Conclusion

This solution efficiently solves the problem of determining the maximum number of chunks into which an array can be split and still result in a globally sorted array when each chunk is sorted independently. The approach relies on tracking the maximum value encountered up to each index in the array and counting the number of times this maximum value matches the index itself, indicating a valid partition. 

#### Key Observations:
- The array can be partitioned whenever the maximum value up to that index is equal to the index.
- The time complexity is **O(n)**, making the solution efficient for large arrays.

#### Time Complexity:
- **O(n)** because we iterate through the array once.

#### Space Complexity:
- **O(1)** due to the use of a few integer variables.

This approach is optimal in terms of both time and space, making it suitable for handling large inputs efficiently.
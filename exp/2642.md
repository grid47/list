### Problem Statement

The problem requires implementing a graph with nodes and weighted edges, and a method to find the shortest path between two nodes using Dijkstra's algorithm. The graph is initialized with a set of edges, and additional edges can be added dynamically. The task is to implement methods to:
1. Compute the shortest path between two nodes.
2. Add an edge to the graph after its initialization.

### Approach

To solve this problem, we will use **Dijkstra's algorithm** for finding the shortest path between two nodes in a weighted graph. Dijkstra’s algorithm works by exploring nodes in increasing order of distance from the source node. It is well-suited for graphs with non-negative edge weights. Here’s how we approach the problem:

1. **Graph Representation**:
   - The graph is represented using an adjacency list. Each node has a list of pairs representing its neighboring nodes and the weight of the edge connecting them.
   
2. **Dijkstra's Algorithm**:
   - We maintain a distance array that stores the shortest known distance to each node from the source node.
   - A priority queue (min-heap) is used to efficiently fetch the next node with the smallest distance.
   - At each step, we extract the node with the smallest distance, update the distances for its neighbors, and push them back into the priority queue if their distances are updated.

3. **Handling Queries**:
   - For each query to find the shortest path between two nodes, we use Dijkstra’s algorithm to compute the shortest path and return the result.
   
4. **Adding New Edges**:
   - We provide a method to add an edge between two nodes after the graph has been initialized. This updates the adjacency list and ensures that new edges are considered in subsequent shortest path queries.

### Code Breakdown (Step by Step)

#### 1. **Graph Initialization**
   
   - The `Graph` class is initialized with the number of nodes `n` and a list of edges. Each edge is represented as a triplet `[u, v, w]` where `u` is the starting node, `v` is the destination node, and `w` is the weight of the edge.
   
   ```cpp
   Graph(int n, vector<vector<int>>& edges) {
       this->n = n;
       grid.resize(n);  // Initialize an adjacency list for each node.
       for (auto e : edges) {
           grid[e[0]].push_back({e[1], e[2]});  // Add the edge to the adjacency list.
       }
   }
   ```

#### 2. **Add Edge Method**
   
   - The `addEdge` method allows adding new edges to the graph after initialization. Each edge is represented as a vector `[u, v, w]`, and it adds an edge from node `u` to node `v` with weight `w` to the adjacency list.

   ```cpp
   void addEdge(vector<int> e) {
       grid[e[0]].push_back({e[1], e[2]});  // Add the new edge to the graph.
   }
   ```

#### 3. **Dijkstra's Algorithm**

   The `diji` function implements Dijkstra’s algorithm to compute the shortest path between two nodes, `n1` and `n2`.

   - **Initialize the Distance Array**: We initialize a `dis` array where `dis[i]` holds the shortest distance from the source node to node `i`. Initially, all distances are set to infinity (`INT_MAX`), except for the source node which is set to 0.
   
   ```cpp
   vector<int> dis(n, INT_MAX);  // Distance array initialized to infinity.
   priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
   pq.push({0, n1});  // Push the source node into the priority queue with distance 0.
   dis[n1] = 0;  // Distance to the source node is 0.
   ```

   - **Processing the Queue**: In a while loop, we extract the node with the smallest distance (using a priority queue) and check its neighbors. For each neighbor, we calculate the distance from the source node and if it is smaller than the known distance, we update the distance and push the neighbor into the priority queue.

   ```cpp
   while (!pq.empty()) {
       auto it = pq.top();  // Get the node with the smallest distance.
       pq.pop();
       int node = it.second;  // Current node.
       for (auto x : grid[node]) {
           int nxt = x.first;  // Neighbor node.
           int w = x.second;  // Weight of the edge.
           if (dis[node] + w < dis[nxt]) {  // If a shorter path is found.
               dis[nxt] = dis[node] + w;
               pq.push({dis[nxt], nxt});  // Push the updated neighbor into the priority queue.
           }
       }
   }
   ```

   - **Return Result**: After the algorithm completes, if the distance to the destination node (`n2`) is still infinity, we return -1, indicating no path exists. Otherwise, we return the shortest distance to `n2`.

   ```cpp
   if (dis[n2] == INT_MAX) return -1;  // No path exists.
   return dis[n2];  // Return the shortest path distance.
   ```

#### 4. **Shortest Path Method**

   The `shortestPath` method simply calls the `diji` method to get the shortest path between two nodes.

   ```cpp
   int shortestPath(int node1, int node2) {
       return diji(node1, node2);  // Use Dijkstra's algorithm to find the shortest path.
   }
   ```

### Complexity

#### Time Complexity:
- **Graph Initialization**: The graph is initialized with `n` nodes and `m` edges. The time complexity for initializing the graph is \(O(m)\), where `m` is the number of edges.
- **Dijkstra’s Algorithm**: The time complexity of Dijkstra’s algorithm is \(O((n + m) \log n)\), where:
  - \(n\) is the number of nodes.
  - \(m\) is the number of edges.
  - The \(\log n\) factor comes from the priority queue operations.
- **Adding an Edge**: The time complexity of adding an edge is \(O(1)\), as it just involves appending an edge to the adjacency list.
  
Thus, for a single query, the time complexity is \(O((n + m) \log n)\), and for multiple queries, the complexity will depend on the number of queries.

#### Space Complexity:
- **Graph Representation**: The adjacency list uses \(O(m)\) space, where `m` is the number of edges.
- **Distance Array**: The distance array (`dis`) uses \(O(n)\) space, where `n` is the number of nodes.
- **Priority Queue**: The priority queue can store up to \(O(n)\) elements at any given time.
  
Thus, the overall space complexity is \(O(n + m)\), where `n` is the number of nodes and `m` is the number of edges.

### Conclusion

This implementation of the `Graph` class effectively handles the creation and modification of the graph using an adjacency list. Dijkstra’s algorithm is employed to compute the shortest path between any two nodes efficiently. The addition of new edges is straightforward and ensures that the graph can be dynamically updated. The solution is efficient with respect to both time and space, making it suitable for large graphs with multiple shortest path queries.
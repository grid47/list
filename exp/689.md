### Problem Statement:
The problem asks us to find the indices of three non-overlapping subarrays in an integer array `nums`, each of size `k`, such that the sum of the elements in these subarrays is maximized. The goal is to return the indices of the three subarrays.

In simpler terms, we need to select three subarrays of size `k` such that their total sum is maximized, and these subarrays should not overlap. The problem can be efficiently solved using a **dynamic programming (DP)** approach.

### Approach:
The solution is based on the idea of **Dynamic Programming** (DP) with a series of transitions to track the maximum possible sum and the corresponding subarrays at each stage.

#### Key Concepts:
1. **Prefix Sum**: The prefix sum array allows us to compute the sum of any subarray efficiently. For an array `nums`, the prefix sum at position `i` gives the sum of all elements from `0` to `i`. This allows quick computation of the sum of any subarray in constant time.
2. **Dynamic Programming (DP)**: We use DP to keep track of the maximum sum for selecting `i` subarrays by a specific position. The DP state includes:
   - The maximum sum for a certain number of subarrays.
   - The indices of the selected subarrays.

The goal is to break down the problem into smaller subproblems by iterating over potential subarray positions and optimizing the choices based on previously computed results.

### Code Breakdown (Step by Step):

#### 1. **Prefix Sum Calculation**:
```cpp
vector<int> sum = {0};
int n = nums.size();
for(int i = 0; i < n; i++) sum.push_back(sum.back() + nums[i]);
```
- The `sum` array is a prefix sum array where `sum[i]` contains the sum of elements in `nums` from the start up to `i-1`. This allows us to calculate the sum of any subarray `nums[i...j]` as `sum[j + 1] - sum[i]`.

#### 2. **DP Table Initialization**:
```cpp
vector<vector<pair<int, vector<int>>>> dp(4, vector<pair<int, vector<int>>>(n));
```
- The `dp` table stores information for solving the problem for different numbers of subarrays (1, 2, or 3) at different positions in the array. Each entry `dp[i][j]` holds:
  - The maximum sum for selecting `i` subarrays up to index `j`.
  - A vector of indices of the selected subarrays.

#### 3. **Filling the DP Table**:
```cpp
for(int i = 1; i < 4; i++) {
    int mx = 0;
    int groupLeft = 3 - i;
    for(int j = n - i * k; j >= groupLeft * k; j--) {
        int rest = j + k >= n? 0 : dp[i - 1][j + k].first;
        int amnt = rest + sum[j + k] - sum[j];
        if(amnt >= mx) {
            if(i > 1) dp[i][j].second = dp[i - 1][j + k].second;
            dp[i][j].second.push_back(j);
            dp[i][j].first = amnt;
            mx = amnt;
        } else dp[i][j] = dp[i][j+1];
    }
}
```
- **Outer Loop**: The loop `for(int i = 1; i < 4; i++)` iterates over the number of subarrays to select (1, 2, or 3).
- **Inner Loop**: The inner loop `for(int j = n - i * k; j >= groupLeft * k; j--)` iterates over possible positions to end a subarray of size `k`.
- The variable `rest` stores the maximum sum for the previous group of subarrays (i.e., the subarrays selected before the current one). If there’s no valid previous group, it’s set to 0.
- The variable `amnt` is the current sum being considered, which is the sum of the current subarray plus the sum of the previously selected subarrays.
- If the current sum (`amnt`) is greater than the previous maximum (`mx`), we update the DP table with the new maximum and store the current subarray index.
- **Subarray Indices**: The vector `dp[i][j].second` stores the indices of the subarrays selected up to the current position `j`.

#### 4. **Reversing the Result**:
```cpp
reverse(dp[3][0].second.begin(), dp[3][0].second.end());
```
- After filling the DP table, the indices of the three subarrays are stored in reverse order (because the inner loop considers subarrays in reverse order). Therefore, we reverse the order to return the correct indices in ascending order.

#### 5. **Returning the Result**:
```cpp
return dp[3][0].second;
```
- Finally, we return the indices of the three subarrays with the maximum sum. The indices are stored in `dp[3][0].second`.

### Complexity:

#### Time Complexity:
- The time complexity of this solution is **O(n * 3)**, or simply **O(n)**, where `n` is the size of the input array `nums`.
- The outer loop runs 3 times (since we are selecting 3 subarrays), and the inner loop runs up to `n`. Therefore, the overall time complexity is linear with respect to the size of the array, making this solution efficient.

#### Space Complexity:
- The space complexity is **O(n)** due to the storage required for the `sum` array and the `dp` table. The `dp` table has dimensions `(4, n)` where `4` corresponds to selecting 1, 2, or 3 subarrays, and `n` corresponds to the possible positions in the array.

### Conclusion:
This solution efficiently computes the indices of three non-overlapping subarrays with the maximum sum using a dynamic programming approach. By leveraging prefix sums and memoizing the results of subproblems, the algorithm is able to compute the maximum sum in **O(n)** time, which is optimal for this problem. The DP table stores intermediate results, ensuring that we avoid redundant computations and can efficiently build up the solution. The solution also ensures that the subarrays are selected in the correct order, and it returns the indices of the subarrays that contribute to the maximum sum.
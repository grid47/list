### Problem Statement

The problem asks to find the maximum number of strictly increasing cells that can be formed in a matrix. In this problem, the matrix consists of integers, and a cell is part of an increasing sequence if it is greater than or equal to the cells in both its row and column. The task is to return the maximum number of cells in such an increasing sequence.

### Approach

The problem can be solved using dynamic programming combined with a sorting mechanism. We need to keep track of the largest increasing sequence that can be formed along each row and column. Here's the step-by-step approach:

1. **Data Structures**:
   - We use two arrays, `row` and `col`, to store the maximum length of increasing sequences that can end at any cell in a particular row and column, respectively.
   - A `map` is used to group matrix elements by their values, which allows us to process the elements in decreasing order.

2. **Processing Strategy**:
   - We need to process the matrix elements from largest to smallest. This helps ensure that, when processing a cell, all the cells with larger values have already been processed, which is crucial for building increasing sequences.
   - For each matrix element, we update its corresponding row and column values. The key observation here is that the number of strictly increasing cells for a given cell is one more than the maximum of the increasing sequence lengths from the row and column of the cell.

3. **Dynamic Programming Update**:
   - For each matrix element, we calculate the maximum sequence length that can be extended to this cell by using the maximum values from the row and column of that cell.
   - After calculating the value for the cell, we update the row and column to reflect the maximum increasing sequence that can end at that cell.

4. **Final Result**:
   - The final answer will be the maximum of all the values in the `row` and `col` arrays, which represents the longest strictly increasing sequence that can be formed in any row or column.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables
```cpp
m = mat.size(), n = mat[0].size();
vector<int> row(m, 0), col(n, 0);
map<int, vector<vector<int>>> mp;
vector<vector<int>> tmp(m, vector<int>(n, 0));
set<int> item;
```
- `m` and `n` store the dimensions of the matrix (`m` rows and `n` columns).
- `row` and `col` are vectors used to track the maximum increasing sequence lengths for each row and column.
- `mp` is a map that groups the matrix values in descending order. Each value in the matrix will be mapped to a list of coordinates (indices) where the value occurs.
- `tmp` is a temporary matrix used to store intermediate results for the increasing sequences.
- `item` is a set to store all unique values in the matrix (in descending order).

#### Step 2: Populate the Map and Set
```cpp
for(int i = 0; i < m; i++)
    for(int j = 0; j < n; j++) {
        mp[-mat[i][j]].push_back({i, j});
        item.insert(-mat[i][j]);
    }
```
- This nested loop goes through every cell in the matrix. For each cell, it inserts the value into the map `mp`, grouped by the negative value of the element (to sort it in descending order). It also adds the negative value into the `item` set.

#### Step 3: Process the Matrix Elements in Decreasing Order
```cpp
for(int x : item) {
    for(auto v: mp[x]) {
        tmp[v[0]][v[1]] = max(row[v[0]], col[v[1]]) + 1;
    }
    
    for(auto v: mp[x]) {
        row[v[0]] = max(row[v[0]], tmp[v[0]][v[1]]);
        col[v[1]] = max(col[v[1]], tmp[v[0]][v[1]]);
    }
}
```
- The outer loop iterates over all the unique matrix values in descending order (`x` represents the matrix values).
- The first inner loop calculates the maximum sequence length for each cell `v` by taking the maximum of the current values in the row and column (`row[v[0]]` and `col[v[1]]`), and adding 1 to it. This value is then stored in the `tmp` matrix.
- The second inner loop updates the `row` and `col` arrays by using the maximum value from `tmp` for each cell.

#### Step 4: Return the Maximum Sequence Length
```cpp
return max(*max_element(row.begin(), row.end()), *max_element(col.begin(), col.end()));
```
- Finally, the function returns the maximum value found in either the `row` or `col` arrays, which represents the longest strictly increasing sequence that can be formed from any row or column in the matrix.

### Complexity

#### Time Complexity
- **O(m * n log(m * n))**: The time complexity is dominated by the sorting operation. While iterating through the matrix elements, we sort and store them in a map. The sorting of `item` will take `O(m * n log(m * n))`, where `m * n` is the number of cells in the matrix. Each cell is processed only once, and updating the `row` and `col` arrays takes constant time for each element.

#### Space Complexity
- **O(m * n)**: The space complexity is dominated by the space required to store the matrix and the temporary matrix `tmp`. We also use a map to store the elements and their indices, which can grow up to `m * n` entries.

### Conclusion

This solution efficiently computes the maximum number of strictly increasing cells in the matrix by utilizing dynamic programming combined with a sorting mechanism. The approach processes the matrix elements in descending order, ensuring that when we update each cell, the previously processed cells have already been accounted for. The algorithm is optimal in both time and space, making it suitable for large input matrices.
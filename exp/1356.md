

### Problem Statement
The problem requires sorting an array of integers based on two criteria:
1. The number of `1` bits (also known as the population count or Hamming weight) in the binary representation of each integer.
2. If two integers have the same number of `1` bits, they should be sorted in ascending order.

For example, given an array like `[0, 1, 2, 3, 4, 5, 6, 7, 8]`, the sorted order based on the above criteria would be `[0, 1, 2, 4, 3, 5, 6, 7, 8]` because:
- `0` has 0 bits set.
- `1` has 1 bit set.
- `2` has 1 bit set but comes after `1`.
- `3` has 2 bits set and comes before `4` (which has 1 bit set).

### Approach
To solve this problem, we can leverage the C++ standard library's `sort` function along with a custom comparator. The custom comparator will determine the order of the integers based on the number of `1` bits in their binary representation, and if they have the same number of `1` bits, it will sort them by their natural order.

1. **Counting `1` Bits**: The function `__builtin_popcount` is used to efficiently count the number of `1` bits in the binary representation of an integer.
2. **Custom Comparator**: The comparator function will compare two integers based on the number of `1` bits and return the appropriate order based on the criteria mentioned.

### Code Breakdown (Step by Step)

```cpp
// Custom comparator function
bool cmp(int a, int b) {
    int x = __builtin_popcount(a); // Count of 1 bits in 'a'
    int y = __builtin_popcount(b); // Count of 1 bits in 'b'
    if(x == y) return a < b; // If counts are equal, sort by value
    return x < y; // Otherwise, sort by count of 1 bits
}
```
- The `cmp` function takes two integers `a` and `b`. It first calculates the number of `1` bits in both numbers using `__builtin_popcount`.
- If both integers have the same count of `1` bits (`x` equals `y`), it sorts them in ascending order based on their natural values.
- If they differ in the number of `1` bits, it sorts them by the count, placing integers with fewer `1` bits first.

```cpp
class Solution {
public:
    vector<int> sortByBits(vector<int>& arr) {
        sort(arr.begin(), arr.end(), cmp); // Sort using the custom comparator
        return arr; // Return the sorted array
    }
};
```
- The `sortByBits` method of the `Solution` class takes a reference to a vector of integers `arr`.
- It calls the `sort` function on `arr`, passing the custom comparator `cmp`.
- Finally, it returns the sorted vector.

### Complexity Analysis
- **Time Complexity**: The sorting operation has a time complexity of \(O(n \log n)\), where \(n\) is the number of elements in the array. The custom comparator runs in \(O(1)\) time for each comparison, resulting in an overall complexity dominated by the sort operation.
- **Space Complexity**: The space complexity is \(O(1)\) for the sorting algorithm since it operates in-place. However, if we consider the space used by the vector, it is \(O(n)\) to hold the input data.

### Conclusion
The `sortByBits` function effectively sorts an array of integers based on the number of `1` bits in their binary representation, utilizing the efficiency of the C++ standard library's sorting capabilities. The use of `__builtin_popcount` allows for quick population counting, ensuring the solution is both efficient and concise.

This implementation demonstrates the use of custom sorting algorithms and bit manipulation techniques, which are valuable skills in competitive programming and technical interviews. Understanding how to combine these concepts can lead to more optimized and elegant solutions for problems involving data organization based on specific criteria.

By breaking down the code and explaining each component, this overview serves as a comprehensive educational resource, allowing readers to grasp the underlying logic and techniques used in this solution.

### Problem Statement

The problem is to determine the minimum cost of purchasing items from a store, given a list of costs associated with each item. The key condition is that for every three items purchased, the cheapest one is free. The goal is to calculate the total minimum cost incurred while following this rule.

### Approach

To efficiently calculate the minimum cost, the algorithm follows these steps:

1. **Sorting the Costs**: By sorting the costs in ascending order, we can ensure that when we select items, the most expensive ones are prioritized for payment, maximizing the savings from the free item rule.

2. **Iterating Through the Costs**: The algorithm iterates through the sorted list of costs and selectively sums the costs, skipping every third item. This ensures that the least expensive item among every three selected items is effectively counted as free.

3. **Calculating the Result**: The final result is the accumulated cost after applying the above logic, which gives us the minimum cost incurred.

### Code Breakdown (Step by Step)

1. **Class Definition**:
   ```cpp
   class Solution {
   public:
   ```
   - The class `Solution` is defined, which contains the method to solve the problem.

2. **Minimum Cost Function**:
   ```cpp
   int minimumCost(vector<int>& cost) {
   ```
   - This function takes a vector of integers (`cost`), representing the cost of each item.

3. **Sorting the Costs**:
   ```cpp
   sort(cost.begin(), cost.end());
   ```
   - The costs are sorted in ascending order to facilitate the logic of skipping the least expensive item when three items are considered.

4. **Initialization**:
   ```cpp
   int n = cost.size(), res = 0;
   ```
   - The size of the cost array (`n`) is stored, and a variable (`res`) is initialized to hold the total cost.

5. **Iterating Through the Sorted Costs**:
   ```cpp
   for(int i = 0; i < n; i++) {
       if(i % 3 == n % 3) continue;
       res += cost[i];
   }
   ```
   - A loop iterates over each cost. The condition `i % 3 == n % 3` checks whether the current index corresponds to the position of the free item based on the total count of items.
   - If the condition is true, the current item is skipped (not added to `res`).
   - If false, the cost of the item is added to `res`.

6. **Return the Result**:
   ```cpp
   return res;
   }
   ```
   - Finally, the total minimum cost (`res`) is returned as the output.

7. **End of Class**:
   ```cpp
   };
   ```
   - This closing brace signifies the end of the `Solution` class.

### Complexity Analysis

- **Time Complexity**: \(O(n \log n)\), where \(n\) is the number of items in the cost array.
  - The most time-consuming operation is sorting the costs, which runs in \(O(n \log n)\). The subsequent loop runs in linear time \(O(n)\).

- **Space Complexity**: \(O(1)\)
  - The algorithm uses a constant amount of additional space since no significant data structures are created beyond the input.

### Conclusion

The `minimumCost` function effectively calculates the minimum cost of purchasing items while adhering to the promotional rule of getting the cheapest item for free among every three items bought. 

This solution is efficient, leveraging sorting and simple iteration to achieve the desired result with optimal time complexity. By following the outlined approach, developers can handle similar problems involving conditional selections and cost optimizations in various scenarios.

Understanding and implementing this solution provides valuable insights into algorithm design, particularly in sorting-based problems and greedy algorithms where optimal decisions are made based on local conditions to achieve a global goal.

In practice, mastering these techniques will enhance your ability to tackle complex coding challenges, making you more adept in competitive programming and software development.
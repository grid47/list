### Problem Statement

The problem is to identify critical and pseudo-critical edges in a graph represented by a list of edges. Critical edges are those that, if removed, increase the weight of the minimum spanning tree (MST). Pseudo-critical edges are those that can be part of the MST but do not affect its total weight. The input consists of `n` vertices and a list of `edges`, each defined by two vertices and a weight. The goal is to return two lists: one containing the indices of critical edges and the other containing the indices of pseudo-critical edges.

### Approach

To tackle this problem, we will utilize a union-find data structure (also known as Disjoint Set Union, DSU) to efficiently manage and find connected components of the graph. The main steps involved in the solution are:

1. **Edge Preparation**: Augment the list of edges to include their original indices, then sort the edges based on their weights. This will allow us to process them in the order necessary for MST calculations.

2. **Calculate the Original MST**: Compute the weight of the MST using all edges to establish a baseline for comparison when edges are either omitted or included.

3. **Evaluate Each Edge**: For each edge in the sorted list, we will:
   - Check if removing the edge results in a higher MST weight, marking it as critical if true.
   - Check if including the edge maintains the same MST weight, marking it as pseudo-critical if true.

4. **Return Results**: Compile the results into two lists: one for critical edges and another for pseudo-critical edges.

### Code Breakdown (Step by Step)

#### UnionFind Class

This class manages the union-find operations, including the path compression technique for efficient searching and union operations.

```cpp
class UnionFind {
public:
    UnionFind(int n) {
        rank = vector<int>(n, 1);  // Initialize rank for union by rank
        f.resize(n);  // Initialize parent vector
        for (int i = 0; i < n; ++i) f[i] = i;  // Each node is its own parent initially
    }

    int Find(int x) {
        if (x == f[x]) return x;  // If x is the root, return x
        else return f[x] = Find(f[x]);  // Path compression
    }

    void Union(int x, int y) {
        int fx = Find(x), fy = Find(y);  // Find roots of x and y
        if (fx == fy) return;  // They are already in the same set
        if (rank[fx] > rank[fy]) swap(fx, fy);  // Union by rank
        f[fx] = fy;  // Make fy the parent of fx
        if (rank[fx] == rank[fy]) rank[fy]++;  // Increment rank if equal
    }

private:
    vector<int> f, rank;  // f for parent pointers, rank for union by rank
};
```

#### Solution Class

The main class that implements the logic to find critical and pseudo-critical edges.

```cpp
class Solution {
public:
    vector<vector<int>> findCriticalAndPseudoCriticalEdges(int n, vector<vector<int>>& edges) {
        // Step 1: Append the index to each edge and sort them by weight
        for (int i = 0; i < edges.size(); ++i) {
            edges[i].push_back(i);  // Add index to edges
        }
        sort(edges.begin(), edges.end(), [](const vector<int>& a, const vector<int>& b) {
            return a[2] < b[2];  // Sort by weight
        });
        
        // Step 2: Get the original MST weight
        int origin_mst = GetMST(n, edges, -1);
        vector<int> critical, non_critical;  // Prepare lists for edges
        
        // Step 3: Evaluate each edge for criticality
        for (int i = 0; i < edges.size(); ++i) {
            if (origin_mst < GetMST(n, edges, i)) {
                critical.push_back(edges[i][3]);  // Edge is critical
            } else if (origin_mst == GetMST(n, edges, -1, i)) {
                non_critical.push_back(edges[i][3]);  // Edge is pseudo-critical
            }
        }
        return {critical, non_critical};  // Return both lists
    }
    
private:
    // Helper function to calculate the MST weight with options to block an edge or include a pre-edge
    int GetMST(const int n, const vector<vector<int>>& edges, int blockedge, int pre_edge = -1) {
        UnionFind uf(n);  // Create a new UnionFind structure for MST
        int weight = 0;  // Initialize weight of MST
        if (pre_edge != -1) {
            weight += edges[pre_edge][2];  // Add weight of pre-edge
            uf.Union(edges[pre_edge][0], edges[pre_edge][1]);  // Union pre-edge
        }
        // Iterate over edges to form the MST
        for (int i = 0; i < edges.size(); ++i) {
            if (i == blockedge) continue;  // Skip the blocked edge
            const auto& edge = edges[i];  // Current edge
            if (uf.Find(edge[0]) == uf.Find(edge[1])) continue;  // Skip if already connected
            uf.Union(edge[0], edge[1]);  // Union the edge
            weight += edge[2];  // Add weight to the MST
        }
        // Check if all vertices are connected
        for (int i = 0; i < n; ++i) {
            if (uf.Find(i) != uf.Find(0)) return 1e9+7;  // If not connected, return a large value
        }
        return weight;  // Return the total weight of the MST
    }
};
```

### Detailed Steps:

1. **Edge Preparation**: Each edge is extended to include its index, allowing us to identify edges later. We then sort the edges by weight using a lambda function.

2. **Calculate Original MST**:
   - The `GetMST` function is called with all edges included to calculate the weight of the original MST. This establishes a baseline for comparing critical and pseudo-critical edges.

3. **Iterate Over Edges**:
   - For each edge, we check if it is critical by determining if removing it causes the MST weight to increase.
   - If removing the edge increases the MST weight, we classify it as a critical edge.
   - We also check if including the edge maintains the same weight for the MST, classifying it as a pseudo-critical edge.

### Complexity

- **Time Complexity**: The time complexity of the algorithm is \(O(E \log E + E \alpha(N))\), where \(E\) is the number of edges, \(N\) is the number of vertices, and \(\alpha(N)\) is the inverse Ackermann function which is nearly constant for all practical purposes. The sorting step contributes \(O(E \log E)\).

- **Space Complexity**: The space complexity is \(O(N + E)\) due to the storage of the union-find structure and the edge list.

### Conclusion

This solution effectively identifies critical and pseudo-critical edges in a graph using a union-find data structure to manage connected components efficiently. The approach involves sorting edges, calculating the original MST, and evaluating each edge's impact on the MST's weight.

**Key Takeaways**:
1. **Union-Find Optimization**: The use of union-find with path compression and union by rank makes it efficient for dynamic connectivity queries.
2. **Graph Theory Application**: The problem demonstrates practical applications in network design, reliability, and optimization problems.
3. **Performance Considerations**: The algorithm's efficiency allows it to handle large graphs within reasonable time constraints, making it suitable for real-world applications.

Overall, this implementation showcases strong algorithmic design principles while addressing a critical problem in graph theory, making it a valuable reference for similar challenges.
### Problem Statement
You are given an array of tokens and an initial amount of power. You can spend power to gain points by flipping a token face-up, or you can sacrifice points to regain power by flipping a token face-down. The goal is to maximize the number of points you can earn using the tokens.

### Approach
1. **Sorting Tokens**:
   - Start by sorting the array of tokens. This allows for a greedy approach where you can efficiently decide when to use tokens for points or regain power.

2. **Two Pointers Technique**:
   - Use two pointers: one (`i`) starting from the beginning (the smallest token) and another (`j`) from the end (the largest token).
   - While iterating through the tokens, check the following conditions:
     - If the current power is greater than or equal to the token pointed to by `i`, use that token to gain a point (increase points) and deduct its value from power.
     - If power is insufficient for the token at `i` but you have points, sacrifice a point to regain power using the token at `j`.

3. **Updating Maximum Score**:
   - Throughout the process, update the maximum score whenever a token is successfully used for points.

### Code Walk-through
- The function sorts the tokens and initializes the necessary variables: `res` for maximum score, `pts` for current points, and two pointers (`i` and `j`).
- It iteratively checks whether to gain points or regain power until all possible actions are exhausted.
- Finally, it returns the maximum score achieved.

### Complexity
- **Time Complexity**: O(n log n), where n is the number of tokens, due to the sorting step.
- **Space Complexity**: O(1), as no additional space proportional to the input size is used.


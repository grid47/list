### Problem Statement

The problem asks us to find the number of **boomerangs** in a given set of 2D points. A **boomerang** is defined as a set of three points `(i, j, k)` such that:
- The distance between points `i` and `j` is equal to the distance between points `i` and `k`.
- The points are distinct, and all points must be different.

The task is to count how many such sets of three points (boomerangs) exist in the given list of points.

### Approach

To solve the problem, we can break it down into the following steps:

1. **Understanding the Problem**:
   - We need to identify sets of three points that form boomerangs. The key insight is that for each point `i`, we can calculate the distance from `i` to all other points `j` and `k`. If two other points have the same distance from `i`, they form a boomerang with `i`.
   - To efficiently calculate the distance between points, we use the squared distance formula: `d = (x2 - x1)² + (y2 - y1)²`. Using squared distance avoids unnecessary floating-point precision errors and makes comparisons straightforward.

2. **Plan**:
   - **For each point `i`**:
     - Calculate the distance between `i` and every other point `j`.
     - Store these distances in a map (or hash map) where the key is the distance, and the value is the count of how many points are at that distance from `i`.
     - For each unique distance, if there are `n` points at that distance, then the number of ways to choose two points from these `n` points (which form a boomerang with `i`) is `n * (n - 1)`, because we choose two distinct points out of `n` and each pair can form a distinct boomerang.
     - Accumulate the boomerang count.

3. **Efficiency Consideration**:
   - The approach essentially compares all pairs of points for each point in the list, which gives a time complexity of `O(n^2)` where `n` is the number of points. This is feasible because the solution uses a hash map to efficiently count distances.

### Code Breakdown (Step by Step)

#### Step 1: Helper Function to Calculate Distance

```cpp
int getDist(vector<int> a, vector<int> b) {
    int x = a[0] - b[0];
    int y = a[1] - b[1];
    return x * x + y * y;
}
```

- The function `getDist` computes the squared distance between two points `a` and `b`. The formula used is `(x2 - x1)² + (y2 - y1)²` where `a[0]` and `a[1]` are the coordinates of point `a`, and `b[0]` and `b[1]` are the coordinates of point `b`.
- The squared distance is used to avoid floating-point calculations and maintain precision when comparing distances.

#### Step 2: Main Logic for Counting Boomerangs

```cpp
map<int, int> mp;
int res = 0;
for(int i = 0; i < points.size(); i++) {
    for(int j = 0; j < points.size(); j++) {
        int d = getDist(points[i], points[j]);
        mp[d]++;
    }
    for(auto [_, val]: mp)
        res += val * (val - 1);
    mp.clear();
}
```

- `mp` is a map that stores the frequency of distances from a given point `i` to all other points.
- We iterate through each point `i`. For each point `i`, we calculate the distance `d` between `i` and every other point `j`, and increment the count of that distance in `mp`.
- After calculating all distances from point `i` to every other point, we calculate how many boomerangs can be formed. If there are `val` points at the same distance from `i`, the number of ways to form boomerangs is `val * (val - 1)` (choosing two distinct points from `val`).
- Finally, we clear the map `mp` to prepare for the next point `i`.

#### Step 3: Return the Result

```cpp
return res;
```

- The variable `res` holds the total number of boomerangs found. Once all points have been processed, we return the final count.

### Complexity

#### Time Complexity:
- **Outer Loops**: We have two nested loops: the outer loop iterates over each point (`O(n)`), and the inner loop iterates over all points for distance calculation (`O(n)`).
- **Distance Calculation**: For each pair of points `(i, j)`, we calculate the squared distance, which is an `O(1)` operation.
- **Total Time Complexity**: The overall time complexity of the algorithm is `O(n^2)` where `n` is the number of points. This is because for each point, we compute distances to every other point.

#### Space Complexity:
- **Map Storage**: The space complexity is determined by the map `mp`, which stores the frequencies of distances. In the worst case, there can be `O(n)` distinct distances, so the space complexity is `O(n)`.
- **Total Space Complexity**: The overall space complexity is `O(n)` for the map storage.

### Conclusion

The solution effectively counts the number of boomerangs in a given set of points by calculating the squared distances between every pair of points and utilizing a map to count how many points lie at each distance. By iterating over each point and counting the possible boomerangs formed by pairs of points at the same distance, we achieve an optimal solution with a time complexity of `O(n^2)`.

This approach is efficient enough for moderate-sized input datasets and provides a clear and concise method for solving the problem using simple geometric insights and hash-based counting.
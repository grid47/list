### Problem Statement

The problem asks to find the number of "beautiful" subarrays in a given array `nums`. A subarray is considered "beautiful" if the XOR of all elements within the subarray is equal to 0. Our task is to efficiently compute the count of such subarrays in the given array.

### Approach

To solve this problem, we need to efficiently identify subarrays whose XOR results in 0. A brute force approach, where we check the XOR of every possible subarray, would be too slow for larger arrays due to its \(O(n^2)\) complexity. Instead, we can leverage a more efficient approach based on the **XOR property** and the concept of **prefix XOR**.

#### Key Observations:
1. **XOR of a Subarray**: The XOR of elements in a subarray can be computed using a prefix XOR array. The XOR of elements from index `i` to `j` in the array is given by:
   \[
   \text{XOR}(i, j) = \text{prefixXOR}[j] \oplus \text{prefixXOR}[i-1]
   \]
   where `prefixXOR[i]` represents the XOR of all elements from the beginning of the array to index `i`.

2. **Zero XOR**: If the XOR of a subarray is 0, it means the XOR of elements between indices `i` and `j` is equal. This implies:
   \[
   \text{prefixXOR}[j] = \text{prefixXOR}[i-1]
   \]
   This observation allows us to track the frequency of each prefix XOR value encountered as we iterate through the array.

#### Algorithm:
- **Step 1**: Maintain a running XOR (`tmp`), which stores the XOR of all elements from the start of the array up to the current index.
- **Step 2**: Use a `map` to store the frequency of each prefix XOR value encountered so far.
- **Step 3**: For each element `nums[i]`, update the running XOR (`tmp`) and check if `tmp` has appeared before. If it has, it means there exists a subarray between the previous occurrence of `tmp` and the current index where the XOR of the subarray is 0.
- **Step 4**: Keep a count of the number of such subarrays.

### Code Breakdown (Step by Step)

#### 1. **Initialization**:
```cpp
long long cnt = 0;
map<int, int> mp;
mp[0] = 1;
int tmp = 0;
```
- **Explanation**: 
  - We initialize `cnt` to 0, which will store the final count of beautiful subarrays.
  - We use a `map` `mp` to store the frequency of each prefix XOR encountered. The key is the XOR value, and the value is the count of occurrences of that XOR. Initially, we set `mp[0] = 1` because a subarray starting from index 0 with XOR 0 is considered a valid subarray.
  - `tmp` is the running XOR, initialized to 0.

#### 2. **Iterating Through the Array**:
```cpp
for (int i = 0; i < n; i++) {
    tmp ^= nums[i];
    if (mp.count(tmp)) cnt += mp[tmp];
    mp[tmp]++;
}
```
- **Explanation**:
  - We loop through each element `nums[i]` in the array.
  - For each element, we update `tmp` by performing an XOR with `nums[i]`. This updates `tmp` to be the XOR of all elements from the start of the array to the current element.
  - We then check if `tmp` has appeared before in the `map`. If it has, it means there are `mp[tmp]` subarrays that have a XOR of 0. We add `mp[tmp]` to `cnt`, since each occurrence of `tmp` represents a potential subarray with XOR 0.
  - We increment the count of `tmp` in the `map`, indicating that we have seen this XOR value again.

#### 3. **Returning the Result**:
```cpp
return cnt;
```
- **Explanation**: After iterating through the entire array, `cnt` contains the total number of beautiful subarrays. We return `cnt` as the final result.

### Time Complexity

The time complexity of this solution can be analyzed as follows:
1. **Iterating Over the Array**: We iterate through the array once, which takes \(O(n)\), where \(n\) is the length of the array.
2. **Updating the Map**: For each element, we perform a constant-time operation to update and check the map. The operations on the map (insertion, lookup) are \(O(\log m)\), where \(m\) is the number of distinct prefix XOR values encountered. However, since there are at most \(n\) distinct prefix XOR values, we can approximate this operation as \(O(\log n)\).
3. **Overall Complexity**: The total time complexity is \(O(n \log n)\), which is efficient enough for large inputs.

### Space Complexity

The space complexity is \(O(n)\) due to the space required to store the map `mp`, which can hold at most \(n\) distinct prefix XOR values. Additionally, the space used for the `tmp` variable is constant.

### Example Walkthrough

#### Input:
```cpp
vector<int> nums = {4, 2, 2, 6, 4};
```

1. **Step 1**: Initialize `cnt = 0`, `mp = {0: 1}`, and `tmp = 0`.
2. **Step 2**: Start iterating over `nums`.
   - **First iteration** (i = 0): 
     - `tmp ^= 4` → `tmp = 4`
     - `mp.count(4)` is 0, so we don't increment `cnt`.
     - `mp[4] = 1`
   
   - **Second iteration** (i = 1):
     - `tmp ^= 2` → `tmp = 6`
     - `mp.count(6)` is 0, so we don't increment `cnt`.
     - `mp[6] = 1`
   
   - **Third iteration** (i = 2):
     - `tmp ^= 2` → `tmp = 4`
     - `mp.count(4)` is 1, so we increment `cnt` by 1 (`cnt = 1`).
     - `mp[4] = 2`
   
   - **Fourth iteration** (i = 3):
     - `tmp ^= 6` → `tmp = 2`
     - `mp.count(2)` is 0, so we don't increment `cnt`.
     - `mp[2] = 1`
   
   - **Fifth iteration** (i = 4):
     - `tmp ^= 4` → `tmp = 6`
     - `mp.count(6)` is 1, so we increment `cnt` by 1 (`cnt = 2`).
     - `mp[6] = 2`

3. **Step 3**: The final result is `cnt = 2`.

#### Output:
```cpp
2
```

### Conclusion

This solution efficiently counts the number of "beautiful" subarrays using the concept of prefix XOR and a hashmap to track the occurrences of each prefix XOR value. By leveraging the properties of XOR, we can solve the problem in \(O(n \log n)\) time, making it scalable for large inputs. This approach is both time-efficient and space-efficient, with a clear and concise implementation.
### Problem Statement

The problem asks to color an array where each element represents a position in the array, and we are given multiple queries to color the elements at different positions. After each query, we need to compute and return the number of adjacent elements with the same color. The task is to perform these operations efficiently for large inputs.

### Approach

To solve this problem, we will simulate the coloring process and compute the number of adjacent pairs of elements with the same color for each query. We can utilize an array `c` to track the color of each element and a variable `adj` to track the number of adjacent pairs with the same color at any point in time. Hereâ€™s the step-by-step approach:

1. **Initialization**: 
   - Use an array `c` of size `n + 1` to track the color of each position. This allows us to handle the 1-based indexing of the queries easily.
   - Initialize a variable `adj` to keep track of the number of adjacent elements with the same color.
   - Initialize an empty vector `res` to store the result after each query.

2. **Processing Queries**:
   - For each query:
     - Get the position `i` (adjusted by +1 to fit the 1-based index).
     - Get the new color `color_i` for position `i`.
     - If the current color at `i` is not zero, update the adjacency count by checking whether its neighbors (`i-1` and `i+1`) have the same color. We subtract this from `adj` because the previous color no longer contributes to the adjacency count.
     - Update the color of position `i` to `color_i`.
     - Add to `adj` if the new color of position `i` matches the color of its neighbors (`i-1` and `i+1`).
   - After each query, append the current value of `adj` to the result vector `res`.

3. **Final Output**:
   - After processing all queries, return the vector `res` containing the results of each query.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables

```cpp
int c[100003] = {}, adj = 0;
vector<int> res;
```

- **Line 1**: We define an array `c` of size `100003` to track the colors of elements in the array. The array is initialized to zero, representing that initially, no element is colored.
- **Line 2**: We define the variable `adj`, initialized to `0`, to track the number of adjacent elements that have the same color.
- **Line 3**: We define a vector `res` to store the result after processing each query.

#### Step 2: Process Each Query

```cpp
for (const auto &q : queries) {
    int i = q[0] + 1, color_i = q[1];
```

- **Line 4**: We iterate over each query `q` in the `queries` array. Each query is a pair, where the first element is the index `i` (0-based in `queries` but will be adjusted to 1-based), and the second element is the color `color_i` for that index.
- **Line 5**: Adjust the index `i` by adding `1` to make it 1-based (to fit the problem description).

#### Step 3: Adjust Adjacency Count Before Updating the Color

```cpp
if (c[i])
    adj -= (c[i - 1] == c[i]) + (c[i + 1] == c[i]);
```

- **Line 6**: If the position `i` is already colored (i.e., `c[i]` is non-zero), we decrement the adjacency count `adj`. This is because the current color at position `i` will no longer contribute to the adjacency count.
- **Line 7**: We check the two adjacent elements of `i` (i.e., `i-1` and `i+1`):
  - `(c[i - 1] == c[i])`: Checks if the element to the left has the same color.
  - `(c[i + 1] == c[i])`: Checks if the element to the right has the same color.
  - We subtract the result of these conditions from `adj` to remove the previous adjacency count.

#### Step 4: Update the Color and Adjacency Count

```cpp
c[i] = color_i;
adj += (c[i - 1] == c[i]) + (c[i + 1] == c[i]);
```

- **Line 8**: We update the color of position `i` in the array `c` to `color_i`.
- **Line 9**: We then check the new adjacencies after coloring `i`:
  - `(c[i - 1] == c[i])`: Checks if the element to the left now has the same color.
  - `(c[i + 1] == c[i])`: Checks if the element to the right now has the same color.
  - We add the result of these conditions to `adj`, which increases the adjacency count.

#### Step 5: Store the Result for the Query

```cpp
res.push_back(adj);
```

- **Line 10**: After processing the current query, we append the current value of `adj` (the number of adjacent pairs with the same color) to the result vector `res`.

#### Step 6: Return the Final Result

```cpp
return res;
```

- **Line 11**: Once all the queries are processed, we return the `res` vector containing the results of each query.

### Complexity

#### Time Complexity:
- For each query, we perform constant-time operations to update the adjacency count and color array. Thus, processing each query takes **O(1)** time.
- Since we process `q` queries, the total time complexity is **O(q)**, where `q` is the number of queries.

#### Space Complexity:
- We use an array `c` of size `100003` to track the colors of the elements, and a result vector `res` to store the results. Thus, the space complexity is **O(n)**, where `n` is the size of the input array.
- The auxiliary space used is constant apart from the space used for input and output, making the space complexity **O(n)**.

### Conclusion

This solution efficiently handles the problem of coloring the array and counting adjacent pairs with the same color after each query. By using a simple array `c` to track colors and a variable `adj` to maintain the adjacency count, the solution ensures that each query is processed in constant time, resulting in an overall time complexity of **O(q)**. This approach is efficient and scalable for large inputs, making it suitable for competitive programming and real-world applications where performance is crucial.
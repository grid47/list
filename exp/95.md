### üå≥ **Problem Overview: Generate Unique Binary Search Trees (BSTs)**

You are asked to generate all unique binary search trees (BSTs) that can be constructed using integers from `1` to `n`. A binary search tree is structured such that:
- Each node has at most two children.
- The left child‚Äôs value is smaller than the parent node.
- The right child‚Äôs value is greater than the parent node.

Given an integer `n`, your goal is to return all structurally unique BSTs using the numbers `1` to `n`.

---

### üßë‚Äçüíª **Step 1: TreeNode Structure**

First, define the `TreeNode` structure to represent each node in the tree. Each node contains a value (`val`), a pointer to its left child, and a pointer to its right child.

```cpp
struct TreeNode {
    int val;           // Value of the node
    TreeNode *left;    // Pointer to the left child node
    TreeNode *right;   // Pointer to the right child node

    // Constructor with no arguments initializes to 0, nullptr for children
    TreeNode() : val(0), left(nullptr), right(nullptr) {}

    // Constructor with the node's value
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}

    // Constructor with value, left child, and right child
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```

---

### üîÑ **Step 2: Recursive Helper Function (`run`)**

The `run` function is responsible for generating all possible binary search trees for a given range of values `[l, r]`. It is a recursive function that splits the range into smaller subranges, choosing each number as the root and recursively generating the left and right subtrees.

```cpp
vector<TreeNode*> run(int l, int r) {
    vector<TreeNode*> ans, left, right;

    // Base case: If no numbers in the range, return NULL
    if (l >= r) {
        if (l == r) ans.push_back(new TreeNode(l));  // Single node tree
        else ans.push_back(NULL);  // No tree possible (empty range)
        return ans;
    }

    // Try each number i as the root of the tree
    for (int i = l; i <= r; i++) {
        // Recursively generate all left subtrees for the range [l, i-1]
        left = run(l, i - 1);
        
        // Recursively generate all right subtrees for the range [i+1, r]
        right = run(i + 1, r);

        // Combine each left and right subtree with the root i
        for (int j = 0; j < left.size(); j++) {
            for (int k = 0; k < right.size(); k++) {
                TreeNode* node = new TreeNode(i);   // Create a new node with value i
                node->left = left[j];                // Attach the left subtree
                node->right = right[k];              // Attach the right subtree
                ans.push_back(node);                 // Add the tree to the result
            }
        }
    }
    return ans;  // Return all unique trees for the range [l, r]
}
```

---

### üßë‚Äçüíª **Step 3: Main Function (`generateTrees`)**

Now, we will define the main function `generateTrees` that will call the `run` function to generate all unique BSTs for the numbers from `1` to `n`.

```cpp
vector<TreeNode*> generateTrees(int n) {
    vector<TreeNode*> ans;

    // Iterate over each number from 1 to n as the root
    for (int i = 1; i <= n; i++) {
        // Generate all left subtrees for the range [1, i-1]
        vector<TreeNode*> left = run(1, i - 1);
        
        // Generate all right subtrees for the range [i+1, n]
        vector<TreeNode*> right = run(i + 1, n);

        // Combine each left and right subtree with root i
        for (int j = 0; j < left.size(); j++) {
            for (int k = 0; k < right.size(); k++) {
                TreeNode* node = new TreeNode(i);  // Root node with value i
                node->left = left[j];               // Attach the left subtree
                node->right = right[k];             // Attach the right subtree
                ans.push_back(node);                // Add the tree to the result
            }
        }
    }
    return ans;  // Return all unique BSTs for the numbers 1 to n
}
```

---

### üí° **Explanation of the Approach**

1. **Base Case for Recursion:**
   - If the range `[l, r]` has no numbers (i.e., `l >= r`), we return a list containing `NULL` (no tree possible). If there is exactly one number, we create a single node tree.

2. **Recursive Exploration:**
   - For each number `i` from `l` to `r`, treat `i` as the root of the tree.
   - The left subtree is generated recursively from the range `[l, i-1]`, and the right subtree is generated recursively from the range `[i+1, r]`.
   - Each combination of left and right subtrees is attached to the root `i`, and the resulting tree is added to the answer.

3. **Main Function:**
   - The main function loops through each number `i` from `1` to `n` and generates all possible left and right subtrees using the `run` function. For each combination of left and right subtrees, a new tree is formed with `i` as the root.

---

### ‚è±Ô∏è **Time and Space Complexity**

#### Time Complexity:
The time complexity is approximately **O(4^n / ‚àön)** due to the recursive structure and the number of possible unique BSTs, which is related to the **Catalan number**. The complexity arises from the fact that there are **O(C_n)** unique BSTs for `n` nodes, where `C_n` is the nth Catalan number.

#### Space Complexity:
The space complexity is also **O(4^n / ‚àön)**, which accounts for:
- The storage of the generated trees.
- The recursive call stack due to the function calls.

---

### üèÅ **Conclusion**

This problem is a great exercise in recursive tree construction and combinatorics. By recursively splitting the range of numbers into smaller subranges and using **Catalan numbers** to guide tree generation, we can efficiently compute all unique BSTs for any given `n`. Although the complexity grows exponentially, this approach is optimal for small to moderate values of `n`.

---
### Problem Statement

The task is to generate all unique binary search trees (BSTs) that can be created using integers from `1` to `n`. A binary search tree is a tree where each node has at most two children, and the left subtree contains only nodes with values less than the root, while the right subtree contains only nodes with values greater than the root.

For example, if `n = 3`, the possible unique BSTs that can be formed using the numbers `1, 2, 3` are:

```
    1         3       2      1         2
     \       /       / \      / \       / \
      3     2       1   3    2   3     1   3
     /     /         \     /   /     /
    2     1           2   1   2     1
```

Your task is to write a function that generates all possible unique BSTs for a given `n`.

### Approach

To solve this problem, we will use **recursion** and **divide-and-conquer** principles. The idea is to:
1. Fix each number as the root of the tree and recursively generate all possible left and right subtrees.
2. For each number `i` in the range from `1` to `n`, consider `i` as the root of the tree. Then:
   - The left subtree can be generated from the numbers less than `i`.
   - The right subtree can be generated from the numbers greater than `i`.
3. We combine the left and right subtrees to form a complete tree with `i` as the root.

The core of the solution involves generating all trees for a range of numbers `[l, r]`. The recursive function `run` will compute all possible trees for the given range. The result is stored in a list, and for each root node `i`, we generate all trees by combining every left tree and right tree.

### Code Breakdown (Step by Step)

#### 1. TreeNode Structure

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```

This structure defines the basic **TreeNode** which will be used to construct the binary search trees. Each node contains an integer `val`, and pointers to the left and right child nodes.

#### 2. Recursive Helper Function (`run`)

```cpp
vector<TreeNode*> run(int l, int r) {
    vector<TreeNode*> ans, left, right;
    if (l >= r) {
        if (l == r) ans.push_back(new TreeNode(l));
        else ans.push_back(NULL);
        return ans;
    }
    for (int i = l; i <= r; i++) {
        left = run(l, i - 1);
        right = run(i + 1, r);
        
        for (int j = 0; j < left.size(); j++) {
            for (int k = 0; k < right.size(); k++) {
                TreeNode* node = new TreeNode(i);
                node->left = left[j];
                node->right = right[k];
                ans.push_back(node);
            }
        }
    }
    return ans;
}
```

The `run` function generates all unique BSTs for the range of values between `l` and `r`. The function works by:
- Base case: If `l >= r`, return a list containing either `NULL` (if no numbers are in the range) or a single TreeNode (if only one number is present in the range).
- For each number `i` in the range `[l, r]`, treat `i` as the root of the tree.
  - Recursively generate all possible left subtrees from the range `[l, i - 1]`.
  - Recursively generate all possible right subtrees from the range `[i + 1, r]`.
- For each pair of left and right subtrees, combine them with `i` as the root and add the resulting tree to the list `ans`.

#### 3. Main Function (`generateTrees`)

```cpp
vector<TreeNode*> generateTrees(int n) {
    vector<TreeNode*> ans, left, right;
    for (int i = 1; i <= n; i++) {
        left = run(1, i - 1);
        right = run(i + 1, n);
        
        for (int j = 0; j < left.size(); j++) {
            for (int k = 0; k < right.size(); k++) {
                TreeNode* node = new TreeNode(i);
                node->left = left[j];
                node->right = right[k];
                ans.push_back(node);
            }
        }
    }
    return ans;
}
```

The `generateTrees` function generates all unique BSTs for numbers `1` through `n`. The process is:
- For each number `i` from `1` to `n`, treat `i` as the root node of the tree.
- Use the `run` function to generate all possible left subtrees from `[1, i-1]` and all possible right subtrees from `[i+1, n]`.
- Combine each left and right subtree with `i` as the root and add the resulting tree to the final list `ans`.

#### 4. Edge Case Consideration

The base case where `l >= r` ensures that when there are no numbers in the range, we return `NULL`, and when there is exactly one number, we return a single node.

### Complexity

#### Time Complexity:

The time complexity of the solution is **O(4^n / √n)**, which arises from the Catalan number formula for generating binary search trees. This complexity is due to the fact that there are **O(C_n)** unique BSTs for `n` nodes, where `C_n` is the nth Catalan number. The number of ways to split the range into left and right subtrees is exponential, and the recursive calls cover all subproblems.

#### Space Complexity:

The space complexity is **O(4^n / √n)** as well, since we need to store the generated trees, and the recursive function calls add to the call stack. The number of recursive calls grows exponentially with the size of `n`, making both the time and space complexities quite large for higher values of `n`.

### Conclusion

The problem of generating all unique binary search trees is a classic example of a recursive and combinatorial solution. By breaking down the problem into subproblems of generating trees for different subranges of values, we are able to efficiently generate all possible BSTs for a given `n`. Although the solution involves recursive tree construction and the computation of Catalan numbers, it provides an elegant and efficient method to generate all unique BSTs. The time and space complexity grow rapidly with `n`, but for moderate values of `n`, this approach is feasible and optimal.
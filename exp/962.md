### Problem Statement
Given an integer array `nums`, you need to find the maximum width ramp in the array. The width of a ramp is defined as the difference between the indices `j` and `i` (i.e., `j - i`), where `0 <= i <= j < nums.length` and `nums[j] >= nums[i]`.

### Approach
1. **Monotonic Stack**:
   - Use a stack to maintain indices of the array `nums`. The stack will store indices in increasing order of their corresponding values in `nums`.
   - Iterate through the `nums` array. If the current number is less than the number at the index stored at the top of the stack, push the current index onto the stack.

2. **Calculate Maximum Width**:
   - After building the stack, iterate through the `nums` array from the end to the beginning. For each index `i`, check if the top of the stack (representing an index `j`) can form a valid ramp.
   - While the value at the index on the top of the stack is less than or equal to the value at the current index `i`, calculate the width as `i - s.top()`, update the maximum width if this width is larger, and pop the index from the stack.

3. **Return the Result**:
   - Finally, return the maximum width found.

### Code Walk-through
1. **`maxWidthRamp` Method**:
   - Initializes a stack to store indices and populates it based on the condition that `nums[s.top()]` should be greater than `nums[i]`.
   - Then, iterates backwards through the `nums` array to compute the maximum width using the indices stored in the stack.

2. **Stack Operations**:
   - The stack ensures that the indices are in increasing order of their values, which allows for efficient width calculation.

### Complexity
- **Time Complexity**: O(N), where N is the length of the array. Each index is pushed and popped from the stack at most once.
- **Space Complexity**: O(N) in the worst case for the stack, although in practice, it will store fewer than N indices.

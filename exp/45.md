### Problem Statement

The problem is to find the minimum number of jumps required to reach the end of an array starting from the first element. The input is an array of integers `nums`, where each element `nums[i]` represents the maximum jump length from that position. The task is to determine the fewest number of jumps needed to move from the first element to the last element of the array.

### Approach

To solve this problem efficiently, we use a **greedy approach**. The idea is to keep track of the farthest we can reach at each step and jump to the farthest position possible when necessary. Instead of evaluating every possible jump combination (which would be inefficient), the greedy approach ensures we are always making the best choice at each step. Here’s how it works:

1. **Current Position (`cur`)**: This represents the farthest position we can reach with the current number of jumps.
2. **Farthest Position (`far`)**: This keeps track of the farthest position we can reach from the current position, considering all the jumps available.
3. **Jumps (`jumps`)**: This is the count of jumps made so far.
4. **When to Jump**: If we have exhausted the current range (`i == cur`), we must jump to the farthest position reachable (`cur = far`), and increment the `jumps` count.

### Code Breakdown (Step by Step)

#### Step 1: Initializing Variables

```cpp
int jumps = 0;
int cur = 0;
int far = 0;
```

- `jumps`: This variable keeps track of the number of jumps we’ve made.
- `cur`: This variable represents the current position that we can reach with the current number of jumps.
- `far`: This variable stores the farthest position we can reach in the current iteration considering all potential jumps.

#### Step 2: Looping Through the Array

```cpp
for (int i = 0; i < nums.size() - 1; i++) {
    far = max(far, i + nums[i]);
    if (i == cur) {
        cur = far;
        jumps++;
    }
}
```

- **Line 1**: We start looping through the array starting from the first element. We don’t need to consider the last element (`nums.size() - 1`), as we already know that reaching the last element implies the end of the array.
- **Line 2**: For each element `i`, we calculate the farthest we can reach by taking the maximum of the current value of `far` and `i + nums[i]`. The expression `i + nums[i]` gives us the farthest position we can reach from index `i`.
- **Line 3**: If the current position `i` is the same as `cur`, it means we’ve exhausted all possibilities for the current jump, and now we must increment the jump count and set `cur` to `far`. This indicates that we are making a jump to the farthest reachable point.

#### Step 3: Returning the Result

```cpp
return jumps;
```

- After the loop, the `jumps` variable will contain the minimum number of jumps required to reach the last element of the array.

### Complexity

#### Time Complexity

The algorithm runs in a single pass through the array, so its time complexity is linear with respect to the size of the input array. We only iterate once over the array to calculate the number of jumps, and each iteration takes constant time to calculate the farthest reachable position.

- **Time Complexity:** `O(n)`, where `n` is the length of the input array `nums`.

#### Space Complexity

The algorithm only uses a constant amount of extra space. The variables `jumps`, `cur`, and `far` are all scalars, and we do not use any additional data structures that depend on the size of the input.

- **Space Complexity:** `O(1)`, meaning the algorithm uses constant extra space.

### Conclusion

The solution provided efficiently solves the problem of finding the minimum number of jumps to reach the end of the array. Using a greedy approach, we keep track of the farthest position that can be reached at each step and make the necessary jumps when we exhaust the current range. This ensures that we minimize the number of jumps, achieving an optimal solution with a time complexity of `O(n)` and constant space complexity.

This approach is both time and space efficient, making it suitable for large input arrays. The greedy strategy leverages the fact that at each position, we should always jump to the farthest reachable position, ensuring the fewest jumps necessary to reach the last element.
### üí° **The N-Queens Problem** ‚Äì Let's Solve It Together!

The **N-Queens** problem is a classic and fascinating challenge often used to test the ability of algorithms to solve constraint satisfaction problems. The objective is to place `n` queens on an `n x n` chessboard such that no two queens threaten each other. A queen can attack another queen if they share the same row, column, or diagonal. Our goal is to **find all possible valid configurations** where no queen can attack another.

### üìù **Problem Breakdown**

Given:
- An integer `n`, representing the number of queens to place on an `n x n` chessboard.
- The task is to place `n` queens on the board such that no two queens can attack each other.

### üîç **Approach**

The solution to the N-Queens problem involves a **backtracking** approach, which systematically explores each possible configuration. The core idea behind backtracking is to try placing queens one by one, row by row. After placing a queen, we check if it is safe to place the next queen. If we encounter a situation where a queen cannot be placed, we **backtrack** and try a different configuration. This process continues until all valid solutions are found.

### Key Steps in the Approach:

1. **Recursive Backtracking:**
   The algorithm explores every potential configuration of queens using recursion. It places a queen in one position, then recursively tries to place the next queen, continuing this process until all rows are filled or a configuration proves invalid.

2. **Check for Safety:**
   A helper function `canPlace` checks whether placing a queen at a specific position is safe. This function ensures that no other queen can attack the current position by checking the column and both diagonals.

3. **Storing Valid Solutions:**
   When a valid configuration is found (i.e., no queens threaten each other), the solution is stored. The algorithm then continues to search for other valid configurations.

4. **Backtracking:**
   If a queen cannot be placed in a given position (due to a conflict), the algorithm **backtracks** by removing the last queen placed and tries a different position.

### üßë‚Äçüíª **Code Breakdown (Step by Step)**

#### Step 1: Solve N-Queens Function

```cpp
vector<vector<string>> solveNQueens(int n) {
    vector<vector<string>> ans;  // Stores the final solutions
    string str(n, '.');  // String representing one row of the board
    vector<string> tmp(n, str);  // Vector of strings representing the board
    this->n = n;  // Initialize the board size
    bt(0, ans, tmp);  // Start the backtracking process from the first row
    return ans;  // Return the list of solutions
}
```

- `solveNQueens` is the main entry point. It initializes the board with empty cells (represented by `'.'`) and prepares an empty list (`ans`) to store the solutions.
- The backtracking process starts with `bt(0, ans, tmp)` from the first row.
- The function returns `ans`, which holds all possible valid configurations.

#### Step 2: Backtracking Function

```cpp
void bt(int i, vector<vector<string>> &ans, vector<string> &tmp) {
    if(i == n) {
        ans.push_back(tmp);  // If all queens are placed, add the current board to the answer
        return;
    }

    for(int j = 0; j < n; j++) {
        if(canPlace(tmp, i, j)) {  // Check if placing a queen in row i, column j is valid
            tmp[i][j] = 'Q';  // Place the queen
            bt(i + 1, ans, tmp);  // Move to the next row
            tmp[i][j] = '.';  // Backtrack and remove the queen
        }
    }
}
```

- The function iterates through all possible column positions in the current row `i`.
- If a queen can be safely placed (checked by `canPlace`), it places the queen and recursively moves to the next row (`i + 1`).
- Once a valid configuration is found (i.e., `i == n`), the board (`tmp`) is added to the solution list (`ans`).
- After trying all positions in the current row, it backtracks by removing the queen (`tmp[i][j] = '.'`).

#### Step 3: Safety Check Function

```cpp
bool canPlace(vector<string> &tmp, int i, int j) {
    for(int k = 0; k < i; k++) {
        if(tmp[k][j] == 'Q')  // Check the column for a queen
            return false;
    }

    int x = i - 1, y = j - 1;
    while(x >= 0 && y >= 0) {
        if(tmp[x][y] == 'Q')  // Check the top-left diagonal
            return false;
        x--, y--;
    }
    x = i - 1, y = j + 1;
    while(x >= 0 && y < n) {
        if(tmp[x][y] == 'Q')  // Check the top-right diagonal
            return false;
        x--, y++;
    }
    return true;  // If no queen can attack, return true
}
```

- The `canPlace` function checks if placing a queen at position `(i, j)` is safe.
- It first checks if there‚Äôs any queen in the same column (`tmp[k][j] == 'Q'`).
- It then checks both diagonals (top-left and top-right) to ensure no queens are positioned where they can attack the current queen.
- If no threats are found, it returns `true`, indicating it is safe to place a queen.

### ‚è±Ô∏è **Complexity Analysis**

#### Time Complexity:
- The worst-case time complexity is **O(n!)** because in the worst case, there are `n!` possible ways to arrange `n` queens on an `n x n` board.
- However, pruning via the `canPlace` function significantly reduces the number of configurations explored, improving performance.

#### Space Complexity:
- The space complexity is **O(n^2)** due to the board's 2D array of size `n x n`, where each element is a string representing a row.
- The recursive call stack adds **O(n)** space complexity because each recursive call corresponds to a single row.

### üåü **Conclusion**

The N-Queens problem is a fundamental combinatorial puzzle that can be solved elegantly using **backtracking**. The algorithm places queens on the board while ensuring no two queens can attack each other, checking for safety using column and diagonal checks. By recursively exploring valid placements and backtracking when necessary, we efficiently find all valid solutions.

With a time complexity of **O(n!)** and space complexity of **O(n^2)**, this solution is both efficient and optimal for smaller values of `n`, making it a valuable tool for solving constraint satisfaction problems.

By applying **backtracking** and **pruning**, the algorithm efficiently navigates through all possible configurations, leading to an elegant and time-efficient solution. Happy coding, and enjoy solving constraint-based puzzles like the N-Queens problem! ‚ú®

---
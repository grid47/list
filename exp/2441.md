### Problem Statement

In this problem, you are given an integer array `nums` containing both positive and negative integers. Your task is to find the largest integer `k` such that both `k` and `-k` exist in the array. If no such integer exists, return `-1`. The output should be the largest `k` such that both `k` and `-k` are present in the array.

For example:
- Input: `[3, 2, -2, 5, -3]`
- Output: `3`

Here, both `3` and `-3` exist in the array, and the largest such integer is `3`.

### Approach

The key to solving this problem efficiently is to use an auxiliary array to track the presence of both positive and negative values. The approach can be broken down into the following steps:

1. **Track the Presence of Elements**: Use an auxiliary array `arr` of size `2001` (for handling values from `-1000` to `1000`) to keep track of the occurrence of each element. By adding `1000` to the elements, we can store both positive and negative numbers as indices.
  
2. **Check for the Presence of Opposite Numbers**: For each number `n` in the array, check whether its opposite `-n` has already been encountered. If so, update the result to be the maximum of the current result and the absolute value of `n`.

3. **Update the Result**: If both `n` and `-n` are found in the array, store the maximum of `res` and the absolute value of `n`. This ensures that we keep track of the largest number whose opposite is also present in the array.

4. **Return the Final Result**: Once all elements are processed, return the largest number `k` such that both `k` and `-k` are present. If no such number is found, return `-1`.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the Auxiliary Array and Result Variable

We initialize an array `arr` of size 2001 to track the presence of both positive and negative numbers. Additionally, we initialize `res` to `-1` to represent that no valid number has been found yet.

```cpp
int arr[2001] = {}, res = -1;
```

- The `arr` array is sized `2001` to account for the range of possible values from `-1000` to `1000`.
- The index `arr[i + 1000]` will represent the number `i` in the array.

#### Step 2: Iterate Through the Array

We iterate over each element `n` in the input array `nums`. For each number, we first check if its opposite `-n` has already been encountered. If it has, we update `res` to the maximum of its current value and the absolute value of `n`.

```cpp
for (int n : nums) {
    if (arr[-n + 1000])
        res = max(res, abs(n));
    ++arr[n + 1000];
}
```

- `arr[-n + 1000]` checks if the opposite of `n` has been encountered. If it has, the value at that index is non-zero, indicating the presence of `-n`.
- `res = max(res, abs(n))` updates the result to the maximum of the current result and the absolute value of `n`.
- `++arr[n + 1000]` increments the count for `n`. This ensures that the opposite number `-n` can be checked in subsequent iterations.

#### Step 3: Return the Result

After iterating through all elements in `nums`, the variable `res` will hold the largest number `k` such that both `k` and `-k` are present in the array. If no such number exists, `res` will remain `-1`, and we return it.

```cpp
return res;
```

### Complexity

#### Time Complexity

The time complexity of this solution is **O(n)**, where `n` is the size of the array `nums`. This is because we iterate through the array once, and each iteration involves constant-time operations (checking the presence of `-n` and updating the result).

#### Space Complexity

The space complexity is **O(1)**, or constant space, since we are using a fixed-size auxiliary array `arr` of size `2001`, which does not depend on the input size. The array size is constant regardless of the input.

### Conclusion

This solution efficiently solves the problem by utilizing an auxiliary array to track the presence of both positive and negative values in the array. By iterating over the array only once and using the auxiliary array to check for the existence of opposites, we can determine the largest integer `k` such that both `k` and `-k` are present.

The time complexity of **O(n)** ensures that the solution will work efficiently even for large inputs, and the space complexity of **O(1)** makes the solution space-efficient. This approach leverages constant-time lookups and updates to efficiently track the elements and their opposites, making it an optimal solution for this problem.
### Problem Statement

The problem asks us to find the **intersection** of two integer arrays, `nums1` and `nums2`. The intersection should include only the unique elements that appear in both arrays. The result must not contain any duplicate elements, even if the intersection contains repeated numbers in either of the arrays.

For example:
- If `nums1 = [1, 2, 2, 1]` and `nums2 = [2, 2]`, the intersection would be `[2]`.

The task is to efficiently compute the intersection, ensuring that the result includes only unique elements present in both arrays.

### Approach

The solution to this problem can be approached using the following key steps:

1. **Use a Set for One Array**: First, we convert one of the input arrays (`nums1`) into an unordered set. This will allow us to perform efficient lookups when checking for the presence of elements from `nums2`. An unordered set has an average time complexity of **O(1)** for both insertion and lookup, making it an ideal data structure for this problem.
   
2. **Check for Common Elements**: Once we have `nums1` in a set, we iterate over the elements of `nums2`. For each element in `nums2`, we check if it exists in the set. If it does, it means that element is present in both arrays, and we add it to the result vector.

3. **Ensure Uniqueness**: After finding a common element, we remove it from the set to ensure that the same element is not added more than once to the result vector. This guarantees that the intersection only contains unique elements.

4. **Return the Result**: Finally, we return the vector containing the intersection of the two arrays.

This approach leverages the efficient set lookups and ensures that we are checking each element of `nums2` only once.

### Code Breakdown (Step by Step)

#### Step 1: Convert `nums1` to an Unordered Set
```cpp
unordered_set<int> m(nums1.begin(), nums1.end());
```
- The line above initializes an unordered set `m` that contains all the unique elements from `nums1`. This is achieved using the constructor of `unordered_set` that takes a pair of iterators (`nums1.begin()` and `nums1.end()`) to insert all elements from `nums1` into the set.
- Using an unordered set is beneficial because it allows fast **O(1)** average time complexity for both **insertion** and **lookup** operations. This means that we can efficiently check if an element from `nums2` exists in `nums1` by simply checking if it exists in `m`.

#### Step 2: Iterate Through `nums2` and Find Common Elements
```cpp
for (auto a : nums2)
    if (m.count(a)) {
        res.push_back(a);
        m.erase(a);
    }
```
- The `for` loop iterates through each element `a` in the array `nums2`.
- For each element `a`, the code checks if `a` is present in the set `m` using the `count` method. The `count` function checks whether the element exists in the set and returns `1` if it does and `0` otherwise.
- If `a` is found in `m`, it means that `a` is a common element between `nums1` and `nums2`. We add `a` to the result vector `res` using `res.push_back(a)`.
- After adding the element to `res`, we **erase** it from the set `m` using `m.erase(a)`. This ensures that the element is not added to `res` again, ensuring uniqueness in the result.

#### Step 3: Return the Result
```cpp
return res;
```
- Once the loop completes, the result vector `res` will contain all the unique common elements between `nums1` and `nums2`.
- We return this vector as the result.

### Complexity

#### Time Complexity:
- **O(n + m)**, where `n` is the length of `nums1` and `m` is the length of `nums2`.
  - **O(n)** for inserting all elements of `nums1` into the unordered set `m`. This takes linear time in terms of the number of elements in `nums1`.
  - **O(m)** for iterating through `nums2` and checking for each elementâ€™s presence in the set. The `count` operation on the unordered set takes **O(1)** on average, so checking all `m` elements in `nums2` will take linear time in terms of `m`.
  - Therefore, the overall time complexity is **O(n + m)**, which is optimal for this problem.

#### Space Complexity:
- **O(n)**, where `n` is the number of elements in `nums1`. This is because we are using an unordered set to store the elements of `nums1`. In the worst case, all elements of `nums1` are unique, and the set will contain `n` elements.
- Additionally, we use a result vector `res` to store the intersection, but this will take **O(min(n, m))** space in the worst case, which does not affect the overall space complexity.

### Conclusion

This solution provides an efficient way to compute the intersection of two integer arrays by leveraging a hash-based unordered set for fast lookups. The overall time complexity of **O(n + m)** ensures that the solution can handle large arrays efficiently, and the space complexity of **O(n)** is also optimal for this problem.

Key points:
- **Time Complexity**: O(n + m), where `n` and `m` are the sizes of `nums1` and `nums2`, respectively.
- **Space Complexity**: O(n), where `n` is the number of unique elements in `nums1`.
- The algorithm is both time-efficient and space-efficient, making it well-suited for problems involving intersection of large arrays.
- The use of an unordered set ensures that we can quickly check for the presence of elements from `nums2` in `nums1`, and the erasure step guarantees that we do not add duplicate elements to the result.

This approach is not only optimal but also simple and easy to implement, making it an excellent choice for solving problems involving the intersection of two arrays.
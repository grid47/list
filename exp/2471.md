### Problem Statement:
The problem requires us to find the minimum number of operations needed to sort the values of each level of a binary tree, where at each level, the nodes can be rearranged. In other words, the values of the nodes at each level should be sorted in ascending order using the minimum number of swap operations. Each node’s position can only be changed by swapping the nodes themselves (not the values). The goal is to return the number of operations (swaps) needed to sort the values at each level of the binary tree.

### Approach:
To solve this problem, we need to traverse the tree level by level and count how many swap operations are required to sort the node values at each level.

#### Step-by-Step Approach:
1. **Breadth-First Search (BFS) Traversal**: We will perform a BFS traversal to visit each level of the binary tree. BFS is ideal because it processes nodes level by level, which is exactly what we need to sort the nodes at each level.

2. **Sorting Each Level**: For each level, we need to extract the node values, and we will then determine how to sort these values using the minimum number of swaps.

3. **Counting Swaps**: The key challenge is counting the minimum number of swaps required to sort the values at each level. The number of swaps can be efficiently calculated by determining the number of cycles in the permutation of values. This can be done using the following steps:
   - Map the values of the nodes to their sorted order.
   - Use a cycle detection approach to count how many swaps are needed to sort the values.

4. **Total Swap Count**: We accumulate the swap count for each level and return the total number of swaps.

### Code Breakdown (Step by Step):
Let’s break down the code to understand its workings in detail:

1. **TreeNode Definition**:
   The problem provides the definition of a binary tree node:
   ```cpp
   struct TreeNode {
       int val;
       TreeNode *left;
       TreeNode *right;
       TreeNode() : val(0), left(nullptr), right(nullptr) {}
       TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
       TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   };
   ```
   - `TreeNode` has three properties: `val` (the value of the node), `left` (pointer to the left child), and `right` (pointer to the right child).
   - There are three constructors provided for initializing the node, either with a default value or with specific values for `val`, `left`, and `right`.

2. **Minimum Operations Function**:
   The function `minimumOperations` starts with the root of the tree and calculates the minimum number of swaps needed to sort the nodes at each level of the tree.

   ```cpp
   int minimumOperations(TreeNode* root) {
       int cnt = 0;
       queue<TreeNode*> q;
       q.push(root);
   ```
   - The function takes in the root of the binary tree.
   - `cnt` is initialized to 0. This variable will store the total number of swaps needed.
   - A queue `q` is used to facilitate BFS traversal of the tree. The root node is added to the queue.

3. **Level-wise Traversal**:
   The function proceeds with BFS by processing one level at a time.
   ```cpp
   while (!q.empty()) {
       int sz = q.size();
       vector<int> arr, idx(sz);
       while (sz--) {
           auto it = q.front();
           q.pop();
           arr.push_back(it->val);
           if (it->left != NULL) q.push(it->left);
           if (it->right != NULL) q.push(it->right);
       }
   ```
   - The while loop runs as long as there are nodes in the queue. Each iteration processes one level of the tree.
   - `sz` stores the number of nodes at the current level.
   - Two vectors are initialized: `arr` (to store the values of the nodes at the current level) and `idx` (to store the indices of these nodes).
   - For each node at the current level, we pop the node from the queue, add its value to `arr`, and enqueue its left and right children (if they exist).

4. **Sorting and Swap Calculation**:
   ```cpp
   iota(idx.begin(), idx.end(), 0);
   sort(idx.begin(), idx.end(), [&](int i, int j) { return arr[i] < arr[j]; });
   for (int i = 0; i < idx.size(); i++)
       for (; idx[i] != i; cnt++)
           swap(idx[i], idx[idx[i]]);
   ```
   - `iota(idx.begin(), idx.end(), 0)` initializes the `idx` vector with the indices of the `arr` vector (i.e., `[0, 1, 2, ..., sz-1]`).
   - We sort the `idx` vector based on the corresponding values in `arr` so that the indices of `arr` are sorted in increasing order of values.
   - The outer loop iterates through the `idx` array, and the inner loop counts the number of swaps needed to place each element in its correct position. The number of swaps needed to sort the values is equivalent to finding the number of cycles in the index mapping, and for each cycle, we perform `size - 1` swaps.
   - The swaps are counted in the variable `cnt`, and we use the `swap` function to adjust the indices.

5. **Return the Result**:
   ```cpp
   return cnt;
   ```
   After processing all levels of the tree, the function returns the total number of swaps required.

### Complexity:
Let’s analyze the time and space complexity of the solution:

- **Time Complexity**:
  - **BFS Traversal**: The BFS traversal visits each node once, so the time complexity for traversing the tree is \( O(n) \), where \( n \) is the number of nodes in the tree.
  - **Sorting and Swapping**: For each level, we sort the array `arr` and perform the swap count calculation. Sorting takes \( O(m \log m) \), where \( m \) is the number of nodes at the current level. In the worst case, each level contains at most \( n \) nodes. So, sorting and counting swaps across all levels will take \( O(n \log n) \) time in the worst case.
  
  Thus, the overall time complexity is \( O(n \log n) \), where \( n \) is the number of nodes in the tree.

- **Space Complexity**:
  - The space complexity is \( O(n) \) due to the storage of the queue for BFS traversal and the arrays used to store the node values and indices at each level.

### Conclusion:
This solution efficiently solves the problem of counting the minimum number of swaps required to sort the values at each level of the binary tree. By performing a BFS traversal and sorting the values at each level, we are able to compute the number of swaps using a cycle detection approach. The algorithm runs in \( O(n \log n) \) time and uses \( O(n) \) space, making it suitable for large binary trees with many nodes.
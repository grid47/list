### Problem Statement

In this problem, we need to create a "Search and Order Ranking Tracker" (SORTracker) that dynamically maintains a list of locations sorted by their scores and names. Specifically, each location has a `name` (string) and a `score` (integer). Higher scores have higher rankings. If two locations have the same score, they are sorted alphabetically by name in ascending order.

The SORTracker class should support two operations:
1. **add(name, score)**: Add a location with the given `name` and `score`.
2. **get()**: Return the name of the location with the highest rank that hasn’t been retrieved yet.

### Approach

The solution leverages two priority queues with custom comparators to maintain a dynamic list of locations sorted by rank. The approach ensures that locations are efficiently added and the highest rank is quickly retrieved.

We use two priority queues:
1. **`mx` queue**: Maintains locations that may become the top-ranked location in subsequent `get()` calls.
2. **`mn` queue**: Stores the current top-ranked locations, from which we retrieve the result for each `get()` call.

### Code Breakdown (Step by Step)

1. **Define Comparators**:  
   The custom comparators `CmpMx` and `CmpMn` are used to prioritize the locations based on rank.

   ```cpp
   class CmpMn {
   public:
       bool operator()(pair<int, string> &a, pair<int, string> &b) {
           if(a.first != b.first) return a.first > b.first;
           return a.second < b.second;
       }
   };

   class CmpMx {
   public:
       bool operator()(pair<int, string> &a, pair<int, string> &b) {
           if(a.first != b.first) return a.first < b.first;
           return a.second > b.second;
       }
   };
   ```
   - `CmpMn` prioritizes higher scores and, in case of a tie, lexicographically smaller names. It reverses the comparison result to ensure the smallest element remains at the top, aligning with the `get()` retrieval order.
   - `CmpMx` keeps the `mx` queue in order to push locations with the highest scores that haven’t yet been retrieved.

2. **Initialize SORTracker**:  
   The class initializes `mx` and `mn` priority queues and an integer `i` to track the number of `get()` calls.

   ```cpp
   class SORTracker {
   public:
       int i = 1;
       priority_queue<pair<int, string>, vector<pair<int, string>>, CmpMx> mx;
       priority_queue<pair<int, string>, vector<pair<int, string>>, CmpMn> mn;
   };
   ```

3. **`add()` Method**:  
   The `add` function inserts the new location into the `mx` queue. This maintains the set of locations eligible to be retrieved in future `get()` calls.

   ```cpp
   void add(string name, int score) {
       mx.push({score, name});
       mn.push(mx.top());
       mx.pop();
       if (mn.size() > i) {
           mx.push(mn.top());
           mn.pop();
       }
   }
   ```
   - After adding to `mx`, the top element of `mx` is moved to `mn` to keep the smallest elements in `mn`.
   - If the size of `mn` exceeds `i`, the extra element is moved back to `mx`, maintaining only the current top `i` locations in `mn`.

4. **`get()` Method**:  
   The `get` method retrieves the name of the top-ranked location.

   ```cpp
   string get() {
       while(mn.size() < i) {
           mn.push(mx.top());
           mx.pop();
       }
       i++;
       return mn.top().second;
   }
   ```
   - `get()` first checks if `mn` has fewer elements than the number of calls `i`. If so, it pulls elements from `mx` to ensure `mn` maintains the top `i` locations.
   - After retrieving the name of the top-ranked location, it increments `i` to mark the next highest-ranked location.

### Complexity Analysis

- **Time Complexity**: 
  - `add(name, score)`: \(O(\log(i))\), where `i` is the size of the priority queue `mn`. The insertion and rebalancing steps involve only logarithmic operations.
  - `get()`: \(O(\log(i))\), where `i` is the size of `mn` and `mx`.

- **Space Complexity**: 
  - \(O(n)\), where `n` is the total number of locations added, as both `mx` and `mn` queues store elements in memory.

### Conclusion

The `SORTracker` class demonstrates how to manage dynamically ordered data structures using two priority queues to retrieve top-ranked items efficiently. This approach ensures that new locations are appropriately prioritized in constant time, making the solution both time-efficient and memory-conscious. The use of custom comparators and careful handling of elements between `mx` and `mn` queues allows us to provide an optimal solution for dynamic rank retrieval. This implementation is well-suited for scenarios where frequent `get()` calls need to access the highest rank in an ordered list, as required by many real-world ranking applications.
### Problem Statement

The task is to find the **first and last position** of a **target value** in a **sorted array** of integers. If the target is not found in the array, return `[-1, -1]`. The array is sorted in **ascending order**, and you must find the **index range** for the target number efficiently.

For example:
- **Input:** `nums = [5, 7, 7, 8, 8, 10]`, `target = 8`
- **Output:** `[3, 4]`

- **Input:** `nums = [5, 7, 7, 8, 8, 10]`, `target = 6`
- **Output:** `[-1, -1]`

### Approach

To solve this problem efficiently, we can utilize the **binary search** technique, particularly two key functions provided in the **C++ Standard Library**: `lower_bound` and `upper_bound`.

1. **Binary Search with Lower and Upper Bound:**
   - The `lower_bound` function finds the **first occurrence** of a number that is **greater than or equal to the target**.
   - The `upper_bound` function finds the **first occurrence** of a number that is **greater than the target**.
   - By utilizing these two functions, we can easily find the **range** of the target value in a sorted array.

2. **Finding the Range of the Target:**
   - `lower_bound(nums.begin(), nums.end(), target)` gives an iterator to the first element that is **greater than or equal to the target**.
   - `upper_bound(nums.begin(), nums.end(), target)` gives an iterator to the first element that is **greater than the target**.
   - If the target exists in the array, the `lower_bound` will point to the first occurrence of the target, and the `upper_bound` will point just past the last occurrence of the target. By subtracting `1` from the position returned by `upper_bound`, we can get the index of the last occurrence of the target.

3. **Edge Case Handling:**
   - If the target is not found in the array, both the `lower_bound` and `upper_bound` will indicate positions where the target should be inserted, but no valid target is present. Therefore, if the result of `lower_bound` does not actually point to the target, we return `[-1, -1]`.

This solution leverages binary search-based functions to ensure efficient searching, making the solution **O(log n)** in time complexity, where `n` is the number of elements in the array.

### Code Breakdown (Step by Step)

```cpp
auto it1 = lower_bound(nums.begin(), nums.end(), target);
auto it2 = upper_bound(nums.begin(), nums.end(), target);
```
- **Step 1:** We first use the `lower_bound` function to find the first position where `target` could appear. The iterator `it1` will point to the first element that is **greater than or equal to** the target. If `target` exists in the array, `it1` will point to the first occurrence of `target`.
- We then use the `upper_bound` function to find the position just after the last occurrence of the target. The iterator `it2` will point to the **first element greater than** the target.

```cpp
if(it1 == nums.end() || *it1 != target) return {-1, -1};
```
- **Step 2:** We check if the iterator `it1` has reached the end of the array or if it does not point to the target. If either condition is true, it means that the target is not present in the array, and we return `[-1, -1]`.

```cpp
return {(int) (it1 - nums.begin()), (int) (it2 - nums.begin() - 1)};
```
- **Step 3:** If the target is found, we return a **range**. 
  - The index of the first occurrence is calculated by `(it1 - nums.begin())`.
  - The index of the last occurrence is calculated by `(it2 - nums.begin() - 1)`, because `it2` points just past the last occurrence of `target`.
  - Both of these are cast to `int` to return the indices as integer values.

### Complexity

#### Time Complexity:
- **O(log n):** Both `lower_bound` and `upper_bound` functions use binary search internally, so the time complexity of each function is **O(log n)**. Therefore, the overall time complexity of the `searchRange` function is **O(log n)**.

#### Space Complexity:
- **O(1):** The algorithm uses a constant amount of extra space. The space complexity is **O(1)** because no additional data structures are created other than the iterators `it1` and `it2`.

### Conclusion

This solution effectively finds the **first and last positions** of the target value in a **sorted array** using binary search-based functions `lower_bound` and `upper_bound`. The algorithm runs in **O(log n)** time complexity, making it efficient for large arrays. By leveraging the power of C++'s built-in binary search functions, the code achieves optimal performance and minimal space usage. This approach is particularly suitable for problems involving sorted arrays, ensuring fast and efficient range searches.
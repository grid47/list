### Problem Statement

The problem asks us to schedule courses such that the total number of courses attended is maximized without exceeding the given deadlines. We are provided with a list of courses, each represented by a pair of values `[duration, deadline]`. The duration is the number of days it takes to complete the course, and the deadline is the last day by which the course should be completed. The task is to find the maximum number of courses that can be scheduled while ensuring that no course exceeds its deadline.

### Approach

The solution follows a **greedy approach** with the help of a **priority queue** (or max-heap). The idea is to always pick the next course that can be completed within the available time, while attempting to complete as many courses as possible.

#### Key Insights:
1. **Sorting the Courses by Deadline:**
   - The first step is to sort the courses by their deadline (second value of the pair). This ensures that we process the courses in the order they need to be completed, making it easier to track whether we can finish a course by its deadline.

2. **Tracking the Total Time Taken:**
   - We maintain a running sum of the total time spent on courses (`sum`). For each course, we try to schedule it, adding its duration to the sum. If at any point, the sum exceeds the course's deadline, we know that scheduling that course would not allow us to meet the deadline, so we discard the longest course that we've already scheduled (using a priority queue).

3. **Using a Priority Queue (Max-Heap):**
   - The priority queue helps us efficiently track and remove the longest course when necessary. By using a max-heap, we can always remove the course that takes the longest time, ensuring that we discard the course that would contribute the most to exceeding the deadline.

4. **Maximizing the Number of Courses:**
   - The ultimate goal is to maximize the number of courses scheduled, so we continue adding courses to the schedule until we either cannot fit any more or we’ve processed all courses. The size of the priority queue at the end gives the maximum number of courses that can be scheduled without exceeding their respective deadlines.

### Code Breakdown (Step by Step)

1. **Sorting the Courses by Deadline:**
   ```cpp
   sort(nums.begin(), nums.end(), [&](vector<int> &a, vector<int> &b) { return a[1] < b[1]; });
   ```
   - We start by sorting the `nums` array (which contains the courses) based on the deadline (`a[1]` for course `a` and `b[1]` for course `b`). This allows us to process the courses in the correct order—starting with the ones that have the earliest deadlines.

2. **Iterating Over Each Course:**
   ```cpp
   int sum = 0;
   for (auto it : nums) {
       sum += it[0];
       pq.push(it[0]);
   ```
   - We initialize the `sum` variable to track the total duration of the courses we’ve scheduled so far. For each course in the sorted list:
     - We add the duration of the current course (`it[0]`) to `sum`.
     - We push the duration of the current course onto the priority queue (`pq`). The priority queue helps us keep track of the longest course.

3. **Checking if the Current Course Can Be Scheduled:**
   ```cpp
   if (sum > it[1]) {
       sum -= pq.top();
       pq.pop();
   }
   ```
   - After adding a course to the schedule, we check if the total time spent on scheduled courses exceeds the current course’s deadline (`sum > it[1]`).
     - If `sum` exceeds the deadline, we pop the longest course from the priority queue (`pq.pop()`), and subtract its duration from `sum`. This effectively removes the course that takes the most time from the schedule, ensuring that we can still make room for more courses.

4. **Returning the Maximum Number of Courses:**
   ```cpp
   return pq.size();
   ```
   - After processing all the courses, the size of the priority queue (`pq.size()`) represents the maximum number of courses that can be scheduled. We return this value as the answer.

### Complexity

#### Time Complexity:
- **Sorting the Courses:** The sorting step takes **O(n log n)** time, where `n` is the number of courses.
- **Iterating Over the Courses:** Iterating through the courses takes **O(n)** time.
- **Priority Queue Operations:** For each course, we perform two operations on the priority queue (push and pop), each of which takes **O(log n)** time. This results in **O(n log n)** time complexity for managing the priority queue.

Therefore, the total time complexity of the solution is **O(n log n)**.

#### Space Complexity:
- We use a priority queue to store the durations of the courses, so the space complexity is **O(n)**, as in the worst case, we may store all courses in the priority queue.

### Conclusion

The greedy approach with a priority queue efficiently solves the problem of scheduling courses with deadlines while maximizing the number of courses that can be completed. By sorting the courses based on their deadlines and using a max-heap to manage the total time spent on courses, we can easily discard the longest course whenever the total time exceeds the available time for a course. The time complexity of **O(n log n)** ensures that this approach can handle large inputs efficiently.
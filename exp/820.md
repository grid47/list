### Problem Statement

The task is to find the minimum length of an encoded string that includes all the words in a given list. Each word can be a suffix of another, meaning it may be part of the encoding if another word already contains it as an ending substring. The encoded string should represent each word uniquely, and each word should be followed by a `#` to distinguish where it ends. 

For example, given the words `["time", "me", "bell"]`, the minimum encoding is `"time#bell#"` with a length of 10, as "me" is already a suffix of "time".

### Approach

This problem can be solved efficiently by leveraging an unordered set and a few key insights regarding suffixes:

1. **Eliminate Redundant Suffixes**:
   - First, store each word in an unordered set. This set will help us keep track of which words need to be included in the final encoding.
   - Then, iterate through each word and attempt to remove all its suffixes from the set. This removal ensures that if one word is a suffix of another, it will not contribute to the final encoding length because it's already covered by the longer word.

2. **Calculate Encoding Length**:
   - After the set has been reduced to only the longest words (those that are not suffixes of any other words), we calculate the length of the encoded string.
   - For each remaining word in the set, we add its length plus one (`+1` for the `#` character) to represent the encoded format.

### Code Breakdown (Step by Step)

The code follows this approach to efficiently compute the minimum encoding length:

1. **Initialize Unordered Set**:
   ```cpp
   unordered_set<string> s(words.begin(), words.end());
   ```
   This line constructs an unordered set `s` containing all words from the input `words` list. This set allows for efficient O(1) average time complexity for insertions and lookups, essential for managing word suffixes.

2. **Eliminate Suffixes**:
   ```cpp
   for(string w: words)
       for(int i = 1; i < w.size(); i++)
           s.erase(w.substr(i));
   ```
   - This nested loop iterates over each word `w` in the list `words`. For each word, it generates all possible suffixes starting from index `1` (ignoring the entire word itself) and removes each suffix from the set `s`.
   - For instance, if `w = "time"`, this loop will generate `"ime"`, `"me"`, and `"e"` as suffixes and attempt to remove them from `s`.
   - By erasing all possible suffixes, we ensure only the longest necessary words remain in `s`.

3. **Calculate Encoding Length**:
   ```cpp
   int res = 0;
   for(string sk: s)
       res += (sk.size() + 1);
   ```
   - After the set is reduced to only non-suffix words, the loop calculates the minimum encoding length.
   - For each word `sk` in the set `s`, it adds `sk.size() + 1` to the result (`res`), accounting for the word length and the additional `#`.

4. **Return the Result**:
   ```cpp
   return res;
   ```
   - Finally, the function returns `res`, representing the minimum length of the encoded string that uniquely represents all words.

### Complexity

- **Time Complexity**: O(n * k^2), where `n` is the number of words, and `k` is the average length of the words. Generating each suffix of a word takes O(k^2) time, and for each word, we check or erase the suffixes in the set, which has O(1) average complexity due to the unordered set.
- **Space Complexity**: O(n * k) for storing the words and their suffixes in the unordered set `s`.

### Conclusion

This solution effectively reduces redundant suffixes and uses an unordered set to achieve an optimal encoding length. By eliminating words that are suffixes of other words, the algorithm minimizes the size of the encoded string. This approach is efficient and well-suited for handling large lists of words with varying lengths, demonstrating a practical use of hash sets to solve string encoding problems with suffix elimination.
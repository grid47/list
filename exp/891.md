### Problem Statement

The problem requires calculating the sum of the **widths of all subsequences** of a given array `nums`. The **width of a subsequence** is defined as the difference between the maximum and minimum values of that subsequence. Given an array of integers, we are to compute this sum efficiently and return the result modulo `1e9 + 7` (a large prime modulus to prevent overflow).

A subsequence of an array is any sequence that can be derived by deleting some or no elements from the array without changing the order of the remaining elements. 

The task is to calculate the sum of the widths of all subsequences modulo `1e9 + 7`.

### Approach

We need an efficient approach to compute the sum of the subsequence widths. A brute force solution, where we generate every subsequence and calculate its width, would be too slow, especially for large arrays. Instead, we can observe a mathematical property that allows us to compute the result much more efficiently.

#### Key Observations:

1. **Sorted Array Property**: The width of any subsequence is simply the difference between the maximum and minimum values of the subsequence. If the array is sorted in ascending order, the smallest elements contribute to the minimum values, and the largest elements contribute to the maximum values.

2. **Contributions to Width**: 
   - For each element in the sorted array, it can be part of several subsequences. The key observation is that an element `nums[i]` contributes as the maximum element in some subsequences and as the minimum element in others.
   - The number of subsequences where an element `nums[i]` is the minimum or maximum can be determined based on its position in the sorted array. For a given element, its contributions are based on how many subsequences it appears in as a maximum and as a minimum.

3. **Efficient Calculation Using Powers of 2**:
   - For each element `nums[i]`, the number of subsequences in which it appears as the minimum or maximum can be represented using powers of 2. Specifically:
     - The element `nums[i]` can appear in `2^i` subsequences as a minimum (since it can be combined with any subset of the previous `i` elements).
     - Similarly, `nums[i]` can appear in `2^(n - 1 - i)` subsequences as a maximum (since it can be combined with any subset of the elements after it).

#### Efficient Formula:
- For each element `nums[i]`, its contribution to the total sum can be broken down into two parts:
  - As a minimum: It contributes `nums[i] * 2^i`.
  - As a maximum: It contributes `nums[n - 1 - i] * 2^(n - 1 - i)`.
- The total sum of widths can be computed by summing the contributions of all elements in the sorted array.

### Code Breakdown (Step by Step)

1. **Modular Arithmetic Setup**:
   ```cpp
   typedef long long ll;
   ll mod = 1e9 + 7;
   ```
   - We define `ll` as a type alias for `long long` to handle large numbers. The result is required modulo `1e9 + 7`, so we store this value in `mod`.

2. **Sorting the Input Array**:
   ```cpp
   sort(nums.begin(), nums.end());
   ```
   - We first sort the array `nums` in ascending order. This is important because we want to efficiently calculate the contributions of each element as the minimum and maximum of subsequences.

3. **Iterating through the Array**:
   ```cpp
   ll res = 0;
   ll c = 1;  // Initializing the power of 2 for subsequences
   for(int i = 0; i < n; i++, c = (c * 2) % mod)
   ```
   - We initialize `res` to store the final result. The variable `c` is used to store powers of 2 modulo `mod`, starting from `2^0 = 1` for the first element.
   - The loop iterates over each element of the sorted array, computing the contributions to the total sum.

4. **Updating the Result**:
   ```cpp
   res = ((ll) nums[i] * c - (ll) nums[n - 1 - i] * c + res) % mod;
   ```
   - For each element `nums[i]`, we calculate its contribution as the minimum (`nums[i] * c`) and as the maximum (`nums[n - 1 - i] * c`), and update the result.
   - The terms are added and subtracted in modulo `mod` to prevent overflow.

5. **Returning the Final Result**:
   ```cpp
   return (int) res;
   ```
   - The result `res` is cast to an integer and returned.

### Complexity

#### Time Complexity:
- **Sorting the Array**: The time complexity of sorting the array is **O(N log N)**, where `N` is the number of elements in the array.
- **Iterating through the Array**: The iteration through the array is linear, i.e., **O(N)**.
- Thus, the total time complexity is **O(N log N)** due to the sorting step.

#### Space Complexity:
- The space complexity is **O(N)** because the algorithm uses the input array `nums` and a few auxiliary variables (like `res` and `c`), which all take constant extra space. The space complexity is dominated by the input array, which is passed by reference.

### Conclusion

This solution efficiently calculates the sum of the widths of all subsequences of a given array `nums`. By leveraging the properties of sorted arrays and the contributions of each element as a minimum and maximum in subsequences, we can compute the result in **O(N log N)** time complexity, which is optimal for this problem. The use of powers of 2 allows for an efficient way to count the number of subsequences an element contributes to, ensuring that we can calculate the total sum of widths without generating all subsequences explicitly.

By implementing this approach, we avoid the inefficiencies of brute force methods and ensure that the solution can handle large input sizes efficiently. The modulo operation ensures that the result stays within the limits of integer overflow, providing a robust solution for this problem.
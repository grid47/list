### üìù **Problem Understanding: Preorder Traversal of a Binary Tree**

We are asked to perform a **preorder traversal** on a binary tree. In preorder traversal, we visit the node first, then recursively visit its left subtree, and finally, its right subtree.

#### Example:
- **Input**: `root = [1, null, 2, 3]`
  - **Output**: `[1, 2, 3]`

In this traversal:
1. Visit the root node.
2. Traverse the left subtree.
3. Traverse the right subtree.

---

### üîß **Approach: Recursive Preorder Traversal**

To implement this, we can use a **recursive approach**:
1. **Base Case**: If the node is `NULL`, we return (i.e., nothing more to process).
2. **Recursive Case**: If the node is not `NULL`, we:
   - Process the node (add its value to the result).
   - Recursively call the function for the left child.
   - Recursively call the function for the right child.

This approach follows the standard definition of preorder traversal.

---

### üñ•Ô∏è **Code Breakdown: Step-by-Step**

#### Step 1: Define the TreeNode Structure
```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}
};
```
- `TreeNode` represents a node in the binary tree, with:
  - `val`: The value stored in the node.
  - `left`: Pointer to the left child.
  - `right`: Pointer to the right child.
  
#### Step 2: Define the Recursive Preorder Traversal Function
```cpp
void pre(TreeNode* root, vector<int>& ans) {
    if (!root) return;  // Base case: if the node is null, do nothing.
    ans.push_back(root->val);  // Visit the root node (process it).
    pre(root->left, ans);  // Recursively traverse the left subtree.
    pre(root->right, ans);  // Recursively traverse the right subtree.
}
```
- **Base Case**: If the node is `NULL`, return without doing anything.
- **Recursive Case**: Process the node (add `root->val` to `ans`), then recursively traverse the left and right children.

#### Step 3: Define the Preorder Traversal Wrapper Function
```cpp
vector<int> preorderTraversal(TreeNode* root) {
    vector<int> ans;  // Initialize an empty vector to store the result.
    pre(root, ans);  // Call the recursive preorder function.
    return ans;  // Return the result vector.
}
```
- This function initializes an empty vector `ans` to hold the preorder traversal result.
- It then calls the recursive function `pre` to process the tree, starting from the root.
- Finally, it returns the result stored in `ans`.

---

### üßÆ **Time and Space Complexity**

#### ‚è±Ô∏è **Time Complexity**:
- **O(n)**: In the worst case, we visit each node exactly once, where `n` is the number of nodes in the binary tree. Thus, the time complexity is linear, **O(n)**.

#### üß≥ **Space Complexity**:
- **O(n)**: The space complexity is determined by:
  - The space required to store the result vector `ans`, which holds `n` values.
  - The recursive call stack. In the worst case (for a completely unbalanced tree), the recursion depth can be `O(n)`.

Thus, the overall space complexity is **O(n)**.

---

### üéØ **Conclusion: Efficient Recursive Solution**

This recursive solution provides a straightforward and efficient way to perform a preorder traversal on a binary tree. It works by visiting the node first, then recursively traversing its left and right subtrees, ensuring the correct order of traversal.

#### Key Insights:
- **Simple Recursive Solution**: The algorithm uses recursion to process each node, making the solution easy to understand and implement.
- **Optimal Time Complexity**: The time complexity is linear **O(n)**, which is optimal for traversing every node in the tree.
- **Space Complexity Considerations**: The space complexity is **O(n)** due to the result vector and the recursive call stack.

This approach is highly effective for handling medium to large binary trees and ensures minimal memory usage with a clear and concise implementation.
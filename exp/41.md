### Problem Statement

The problem asks to find the **first missing positive integer** from an unsorted array of integers. The array may contain duplicates, negative numbers, and non-positive numbers. We are to find the smallest positive integer that is not present in the array.

For example:
- Input: `[3, 4, -1, 1]`
- Output: `2`

- Input: `[1, 2, 0]`
- Output: `3`

The solution should operate efficiently, ideally in **O(n)** time complexity, where `n` is the number of elements in the input array. The space complexity should be **O(1)**, meaning no extra space apart from the input array is allowed.

### Approach

To solve this problem efficiently, we can utilize the input array itself to track the presence of numbers. The key idea is to rearrange the array such that the value at each index `i` corresponds to the integer `i+1`. Once the array is in the correct format, we can easily find the first missing positive number by scanning through the array.

#### Key Steps:
1. **Rearranging the Array:** 
   - For each positive number `x` that falls within the range `[1, n]` (where `n` is the size of the array), we try to place it at its "correct" index, which is `x - 1`. 
   - We keep swapping the numbers until the current number is in its correct place or out of range.
   
2. **Scanning the Array:** 
   - After rearranging, the first index `i` where the value is not `i + 1` is the missing positive integer. 
   - If all indices are correct, then the first missing positive number will be `n + 1`.

3. **Edge Cases:** 
   - If the array is empty, the first missing positive integer is `1`.
   - If the array only contains negative numbers or numbers larger than `n`, the first missing positive integer is still `1`.

### Code Breakdown (Step by Step)

#### Step 1: Rearrange the Array

```cpp
for(int i = 0; i < nums.size(); i++) {
    if(nums[i] > 0 && nums[i] < nums.size() && nums[nums[i] - 1] != nums[i]) {
        cout << nums[i] << " " << nums[nums[i] - 1] << "\n";
        swap(nums[i], nums[nums[i]-1]);      
        i--;
    }
}
```

- We iterate through each element `nums[i]`.
- The condition `nums[i] > 0 && nums[i] < nums.size()` ensures that the number is positive and lies within the range `[1, n]`, where `n` is the size of the array.
- The condition `nums[nums[i] - 1] != nums[i]` checks if the number is already at its correct position. If not, we swap it with the number at the index `nums[i] - 1`, which is the correct position for the value `nums[i]`.
- After a swap, we decrement `i` to recheck the newly swapped element, as it might need further rearrangement.

This process ensures that all numbers within the range `[1, n]` are placed at their correct index.

#### Step 2: Scan for Missing Positive Integer

```cpp
for(int i = 0; i < nums.size(); i++) {
    if(nums[i] != i + 1)
        return i + 1;            
}
```

- After rearranging the array, we scan through each element.
- If the value at index `i` is not equal to `i + 1`, it means that `i + 1` is the first missing positive integer.
- If all indices are correct, we return `nums.size() + 1`, which is the next missing integer after the array size.

#### Step 3: Return the Result

```cpp
return nums.size() + 1;
```

- If all numbers from `1` to `n` are present in the array, the smallest missing positive integer is `n + 1`, so we return that.

### Complexity

#### Time Complexity:

- The first loop runs through all the elements once, and each swap operation is done in constant time.
- Each element is swapped at most once, so the time complexity for rearranging the array is **O(n)**, where `n` is the size of the array.
- The second loop scans the array to check for the first missing positive integer, which also takes **O(n)** time.
- Therefore, the overall time complexity of the solution is **O(n)**.

#### Space Complexity:

- The space complexity is **O(1)** because we only use a constant amount of extra space apart from the input array itself. The swapping operation does not require additional memory, and no other data structures are used.

### Conclusion

This solution solves the problem of finding the first missing positive integer efficiently with **O(n)** time complexity and **O(1)** space complexity. The key idea behind this solution is to rearrange the elements in the array such that each number is placed at its "correct" position, allowing us to easily identify the missing number in a single scan. This method is optimal for large input sizes and works within the constraints provided by the problem.

By leveraging the input array itself to track the presence of numbers, the solution avoids the need for additional space or data structures, making it both time and space efficient. This approach is well-suited for solving the problem within the time and space limits specified.
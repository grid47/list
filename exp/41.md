### 🌟 **First Missing Positive Integer**

The problem asks us to find the **first missing positive integer** from an unsorted array of integers. The array may contain duplicates, negative numbers, and non-positive numbers. Our goal is to find the smallest positive integer that is not present in the array.

#### Example:
- **Input**: `[3, 4, -1, 1]`
- **Output**: `2`

- **Input**: `[1, 2, 0]`
- **Output**: `3`

The key challenge is to find the solution with **O(n)** time complexity and **O(1)** space complexity. Let’s break down the approach.

---

### 🔑 **Approach: Rearranging the Array for Efficient Solution**

The key idea to solving this problem efficiently is to rearrange the array such that each number is placed at its "correct" position. After this rearrangement, we can easily find the missing positive integer by scanning through the array.

#### Steps:

1. **Rearranging the Array**:
   - We iterate through the array and for each positive number `x` that lies in the range `[1, n]` (where `n` is the size of the array), we try to place it at its correct index, which is `x - 1`.
   - If a number is not in its correct place, we swap it with the number at its correct position.
   
2. **Scan the Array**:
   - After rearranging the array, we scan it to find the first index `i` where the number is not equal to `i + 1`. This indicates that `i + 1` is the first missing positive integer.
   - If all indices are correct, then the missing number is `n + 1`.

---

### 🔍 **Code Breakdown**

#### Step 1: Rearranging the Array

```cpp
for (int i = 0; i < nums.size(); i++) {
    if (nums[i] > 0 && nums[i] < nums.size() && nums[nums[i] - 1] != nums[i]) {
        swap(nums[i], nums[nums[i] - 1]);
        i--; // recheck the newly swapped element
    }
}
```

- **Conditions**: 
  - We check if the number is positive and within the valid range `[1, n]`.
  - We swap the number `nums[i]` with the number at the index `nums[i] - 1`, which is its correct position.
  - After a swap, we decrement `i` to recheck the newly swapped element because it might still need to be moved.

#### Step 2: Scan for Missing Positive Integer

```cpp
for (int i = 0; i < nums.size(); i++) {
    if (nums[i] != i + 1)
        return i + 1;
}
```

- After rearranging the array, we scan it to find the first number that does not match its index + 1. This indicates the missing number.

#### Step 3: Return the Result

```cpp
return nums.size() + 1;
```

- If all numbers from `1` to `n` are present, the smallest missing positive integer will be `n + 1`.

---

### 📊 **Complexity Analysis**

- **Time Complexity**: 
  - The first loop runs through all the elements, performing constant time swaps. Each element is swapped at most once. So, the time complexity for rearranging is **O(n)**.
  - The second loop scans the array to find the first missing positive integer, which also takes **O(n)** time.
  - Overall, the time complexity is **O(n)**.

- **Space Complexity**:
  - The space complexity is **O(1)** because we do not use any extra space other than the input array itself. We perform swaps in place, and no additional data structures are used.

---

### 🏁 **Conclusion**

This solution efficiently solves the problem of finding the first missing positive integer with **O(n)** time complexity and **O(1)** space complexity. By rearranging the input array such that each number is placed at its correct index, we can easily identify the missing positive integer with a simple scan of the array.

- **Key Takeaway**: By leveraging the input array itself for rearrangement, we can avoid using extra space and achieve optimal performance in both time and space.

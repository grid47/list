### Problem Statement

The problem asks to determine how many flowers are blooming at each point in time for a given list of people's visit times. The flowers bloom at specific start and end times, and the goal is to count the number of flowers that are blooming at each person's visit time. A person can visit the flowers at any time, and we need to determine the number of flowers blooming at their visit time based on the given bloom and wither times of each flower.

### Approach

The approach for solving this problem involves sorting the flower intervals and people’s visit times, using a priority queue to keep track of the active flowers that are blooming, and efficiently counting how many flowers are blooming at each person's visit time.

#### Steps:

1. **Sort the Flowers by Start Time**: First, sort the list of flowers by their start time. This helps in processing flowers that start blooming in the correct order.

2. **Sort the People by Visit Time**: Create a pair of each person's visit time with their index so that after calculating the result, we can put the results back into the correct order.

3. **Use a Priority Queue (Min-Heap)**: A priority queue will help us maintain a list of flowers that are blooming at any given time. The flowers in the priority queue are ordered by their wither time (end time), and we can efficiently pop flowers that are no longer blooming.

4. **Process Each Person's Visit Time**:
   - For each person, we first remove all flowers from the priority queue whose wither time is less than the person's visit time.
   - Then, we add all the flowers that have started blooming by the person's visit time (i.e., those flowers whose start time is less than or equal to the person's visit time).
   - Finally, the number of flowers in the priority queue represents how many flowers are blooming at that person's visit time.

5. **Return the Result**: After processing all people, the result vector will contain the number of blooming flowers for each person, indexed by their original position.

### Code Breakdown (Step by Step)

#### Step 1: Sort the Flowers and People

```cpp
sort(flo.begin(), flo.end());
vector<pair<int, int>> pp;
for (int i = 0; i < peo.size(); i++) {
    pp.push_back(make_pair(peo[i], i));
}
sort(pp.begin(), pp.end());
```

- The flowers are sorted by their start time `flo[i][0]` to ensure that we process them in the correct order.
- The people's visit times are paired with their original indices so that we can return the results in the correct order. The visit times `peo[i]` are sorted in ascending order to process the people in the order they visit.

#### Step 2: Initialize the Answer and Priority Queue

```cpp
vector<int> ans(peo.size(), 0);
priority_queue<int, vector<int>, greater<int>> pq;
```

- A result vector `ans` is initialized with zeros. This vector will store the number of blooming flowers for each person.
- A priority queue `pq` is used to track the flowers that are currently blooming. The priority queue is implemented as a min-heap, so the flower with the earliest end time is always at the top.

#### Step 3: Process Each Person’s Visit Time

```cpp
int j = 0;
for (int i = 0; i < peo.size(); i++) {
    while (!pq.empty() && pp[i].first > pq.top()) {
        pq.pop();
    }
    while (j < flo.size() && pp[i].first >= flo[j][0]) {
        if (pp[i].first <= flo[j][1])
            pq.push(flo[j][1]);
        j++;
    }
    ans[pp[i].second] = pq.size();
}
```

- We iterate through each person (sorted by their visit time).
- For each person `pp[i]`, first, we remove any flowers from the priority queue that are no longer blooming at the current visit time (`pp[i].first`).
- Then, we add all the flowers that start blooming at or before the current visit time. For each such flower `flo[j]`, we push its wither time (`flo[j][1]`) into the priority queue.
- Finally, the number of blooming flowers at the person’s visit time is simply the size of the priority queue, which represents the number of flowers that are currently active (blooming).

#### Step 4: Return the Result

```cpp
return ans;
```

- After processing all people, we return the `ans` vector, which contains the number of blooming flowers for each person, in the original order.

### Complexity

#### Time Complexity

1. **Sorting Flowers**: Sorting the flowers takes \( O(m \log m) \), where \( m \) is the number of flowers.
2. **Sorting People**: Sorting the people based on their visit times takes \( O(n \log n) \), where \( n \) is the number of people.
3. **Processing People**: For each person, we need to iterate through the flowers and potentially push flowers into the priority queue. In the worst case, we will process all flowers for each person. The priority queue operations (push and pop) take \( O(\log m) \), and for each person, we may perform at most \( m \) such operations. Therefore, the time complexity for processing people is \( O(n \times \log m) \).

- The overall time complexity is \( O(m \log m + n \log n + n \log m) \), where:
  - \( m \) is the number of flowers,
  - \( n \) is the number of people.

#### Space Complexity

- **Priority Queue**: The space required for the priority queue is \( O(m) \), as it stores at most \( m \) flowers.
- **Result Vector**: The result vector `ans` requires \( O(n) \) space to store the number of blooming flowers for each person.
- **Other Variables**: The space used for sorting the people and storing intermediate pairs is \( O(n) \).

- Therefore, the overall space complexity is \( O(m + n) \).

### Conclusion

This solution efficiently counts how many flowers are blooming at each person's visit time using sorting and a priority queue. The sorting of flowers and people's visit times ensures that we process the flowers and people in the correct order. The priority queue allows us to efficiently track which flowers are blooming at any given time, and by processing people in sorted order, we can minimize the number of operations required to determine how many flowers are blooming at each person's visit time.

The overall time complexity of \( O(m \log m + n \log n + n \log m) \) is manageable for typical problem constraints, and the space complexity of \( O(m + n) \) is also efficient. This approach provides an optimal solution to the problem.
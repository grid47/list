### Problem Statement

The goal of this problem is to find the **k-th factor** of a given integer `n`. A factor of `n` is any integer `i` such that `n` can be evenly divided by `i` (i.e., `n % i == 0`). If `n` has fewer than `k` factors, the function should return `-1` to indicate that the k-th factor does not exist.

### Approach

To achieve this, the solution involves iterating through all integers from `1` to `n`, counting the factors as they are found. The algorithm can be outlined as follows:

1. **Iterate through possible factors**: Check every integer `i` from `1` to `n` to see if it is a factor of `n`.
2. **Count factors**: Maintain a counter to track how many factors have been found.
3. **Return the k-th factor**: When the counter reaches `k`, return the current factor. If the loop completes without finding `k` factors, return `-1`.

### Code Breakdown (Step by Step)

Let's break down the code snippet to understand its components and logic:

```cpp
class Solution {
public:
    int kthFactor(int n, int k) {
```
This defines the `Solution` class and its method `kthFactor`, which takes two integers as input: `n` (the number for which we want to find factors) and `k` (the index of the desired factor).

#### Step 1: Iterate Through Possible Factors

```cpp
        for(int i = 1; i <= n; i++) {
```
- A for loop begins, starting from `1` and iterating up to `n`. This is necessary because any integer from `1` to `n` can be a factor of `n`.

#### Step 2: Check for Factors

```cpp
            if(n % i == 0) k--;
```
- Inside the loop, the code checks whether `i` is a factor of `n` using the modulus operator. If `n` is divisible by `i`, it decrements `k` by one, indicating that one more factor has been found.

#### Step 3: Return the k-th Factor

```cpp
            if(k == 0) return i;
```
- After decrementing `k`, the code checks if `k` has reached zero. If it has, this means the current integer `i` is the k-th factor of `n`, and it is returned immediately.

#### Step 4: Handle the Case When k-th Factor Doesn't Exist

```cpp
        return -1;
    }
};
```
- If the loop completes and no k-th factor has been found (i.e., `k` is still greater than zero), the function returns `-1` to indicate that there are not enough factors.

### Complexity

#### Time Complexity
- The time complexity of this algorithm is **O(n)**, where `n` is the input integer. This is because, in the worst-case scenario, we may need to check all integers up to `n` to find its factors.

#### Space Complexity
- The space complexity is **O(1)** since the algorithm uses a fixed amount of extra space for variables (`k`, `i`), regardless of the input size.

### Conclusion

This solution effectively finds the k-th factor of an integer `n` through a straightforward iteration method. It maintains a simple yet effective logic that ensures clarity and correctness.

**Key Points**:
- **Simplicity**: The algorithm is easy to understand and implement, making it suitable for introductory programming exercises focused on factors and modular arithmetic.
- **Performance**: While the time complexity of O(n) may not be the most efficient approach for very large values of `n`, it is adequate for many practical scenarios and sufficiently straightforward for teaching purposes.
- **Edge Cases**: The solution correctly handles edge cases, such as when `k` exceeds the number of factors present for the given `n`.

This method is beneficial in various mathematical contexts, including number theory, where understanding the factors of a number can provide insights into its properties and divisibility. It also forms the basis for more complex algorithms that rely on factorization, such as those used in cryptography and advanced number theory.
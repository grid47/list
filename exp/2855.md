### Problem Statement

The task requires determining the minimum number of right shifts needed to make a rotated sorted array into a sorted array. In a sorted array, the elements are arranged in increasing order. A right shift involves moving the last element of the array to the front. If the array is already sorted or can be made sorted by a single right shift, return the number of right shifts required; otherwise, return `-1` if no such shift exists.

### Approach

The problem can be approached by checking the array for a point where the order breaks, i.e., where a number is greater than the number that follows it. If there is more than one such break, the array cannot be sorted by a single right shift, and the answer should be `-1`. However, if there is exactly one break point, we check whether the last element of the array is greater than the first element, which would prevent the array from being properly sorted with a right shift. If this condition is satisfied, the answer will be the number of shifts needed to make the array sorted.

Here is a step-by-step breakdown of how to solve the problem:

1. **Iterate Over Array Elements**: Start by iterating over the array to find if there is a point where the array stops being sorted in increasing order. 
   
2. **Check for One Break Point**: If the array is already sorted, return `0`. If there is exactly one break point where `nums[i] > nums[i+1]`, store this index and continue.

3. **Check Validity for Shift**: If there is one break point, check if shifting the array after that point will make the array sorted. This is done by comparing the last element (`nums[n-1]`) with the first element (`nums[0]`). If `nums[n-1] > nums[0]`, return `-1` because this condition implies the array cannot be sorted by a right shift.

4. **Calculate Number of Shifts**: If the above conditions are met, calculate the number of right shifts needed to move the elements after the break point to the front. This is done by subtracting the break index from the size of the array (`n - ind`).

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables
```cpp
int n = nums.size(), ind = -1, cnt = 0;
```
- `n` stores the size of the array.
- `ind` stores the index of the point where the array breaks (i.e., where the order is no longer increasing).
- `cnt` is used to ensure that there is at most one break point. If more than one break is found, the array cannot be sorted with a single right shift.

#### Step 2: Iterate Over the Array to Find the Break Point
```cpp
for(int i = 0; i < n - 1; i++) {
    if (nums[i] > nums[i + 1]) {
        if (cnt == 0) {
            ind = i + 1;
            cnt++;
        } else {
            return -1; // More than one break point found
        }
    }
}
```
- The loop iterates through the array from index `0` to `n-2`, comparing each element with the next one.
- If `nums[i] > nums[i+1]`, it marks this as a break in the sorted order.
- If a break is found for the first time, the index `ind` is set to `i + 1` (the point where the break occurs), and `cnt` is incremented to ensure that only one break is allowed. If another break is found, the function returns `-1`.

#### Step 3: Check if the Array is Already Sorted
```cpp
if (ind == -1) return 0;
```
- If no break point is found (`ind == -1`), the array is already sorted, so the function returns `0`, indicating that no shifts are needed.

#### Step 4: Check if a Right Shift is Possible
```cpp
if (nums[n - 1] > nums[0]) return -1;
```
- If a break point is found, the function checks if shifting the array to make it sorted is possible by comparing the last element (`nums[n - 1]`) with the first element (`nums[0]`).
- If the last element is greater than the first element, it means that a right shift cannot make the array sorted, and the function returns `-1`.

#### Step 5: Return the Number of Shifts
```cpp
return n - ind;
```
- If the array can be sorted with a right shift, the number of shifts required is `n - ind`. This is the number of elements that need to be moved from the end of the array to the front.

### Complexity

#### Time Complexity:
The time complexity of the solution is O(n), where `n` is the size of the input array. The algorithm iterates over the array once to find the break point and check if the array can be sorted with a single right shift. Since there is a single iteration over the array, the time complexity is linear.

#### Space Complexity:
The space complexity is O(1), as the algorithm only uses a constant amount of extra space for variables (`n`, `ind`, and `cnt`), regardless of the size of the input array. There are no additional data structures used that grow with the input size, making the space complexity constant.

### Conclusion

The problem can be solved efficiently with a time complexity of O(n) using a simple iterative approach. The solution checks if the array is sorted, finds the break point (if any), and then determines if a right shift can sort the array. If it can, the solution returns the number of shifts required; otherwise, it returns `-1` if the array cannot be sorted with a right shift. This approach is both time-efficient and space-efficient, making it suitable for solving the problem within the given constraints.
### Problem Statement

In this problem, we are given a matrix of size `n x n`, and a list of queries to perform on this matrix. Each query specifies a type of operation, the index of the row or column to be affected, and the value to be added. Our goal is to calculate the sum of all the values in the matrix after all queries have been processed.

Each query involves either adding a value to an entire row or an entire column. The sum should be updated accordingly, but each row or column can only be updated once. After processing all the queries, we are asked to return the total sum of the matrix.

### Approach

To solve the problem efficiently, we must carefully track the updates made by the queries and avoid unnecessary recalculations. We need a strategy that enables us to handle the updates in constant time rather than iterating over the entire matrix for each query.

Here’s the plan:
1. **Track Updates**: Instead of updating the matrix directly for each query, we maintain two arrays (`seen` and `cnt`) to track which rows and columns have already been updated. This allows us to avoid repeating operations on rows and columns that have already been modified.
2. **Work Backwards**: By processing the queries in reverse order, we can ensure that each query is applied efficiently. When we encounter a query that updates a row or column that hasn’t been updated yet, we apply the value to all remaining cells in the matrix that correspond to that row or column.
3. **Efficient Sum Calculation**: For each query, we multiply the value to be added by the number of remaining cells in the matrix that are affected by that query (i.e., rows or columns that have not been updated yet). This ensures that we update the sum correctly without having to iterate over the entire matrix each time.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Necessary Data Structures

```cpp
long long res = 0;
int seen[2][10001] = {};  // Track if row or column has been updated
int cnt[2] = {n, n};  // Count of rows and columns yet to be updated
```

- `res`: This will hold the running total sum of the matrix after all queries are processed.
- `seen[2][10001]`: A 2D array that tracks whether a row (`seen[0]`) or a column (`seen[1]`) has already been updated. We use a 2D array because each query updates either a row or a column.
- `cnt[2]`: An array that keeps track of how many rows and columns are yet to be updated. Initially, both are set to `n`, indicating that all rows and columns are unmodified.

#### Step 2: Process Queries in Reverse Order

```cpp
for(int i = q.size() - 1; i >= 0; i--) {
    int type = q[i][0], id = q[i][1], val = q[i][2];
```

- We iterate over the queries in reverse order using the index `i`. The reason for processing in reverse is that we want to update the matrix sum by applying only the first time a row or column is updated.

#### Step 3: Apply Updates

```cpp
if(!seen[type][id]) {
    seen[type][id] = 1;  // Mark row or column as updated
    res += val * cnt[!type];  // Add value to sum based on the remaining rows/columns
    --cnt[type];  // Decrement the count for rows or columns remaining
}
```

- **Check if Row or Column is Updated**: We check if the row or column has already been updated by looking at `seen[type][id]`. If it’s zero, we know that it hasn’t been updated yet, so we apply the update.
- **Update the Sum**: We add the value `val` multiplied by the count of the remaining rows or columns (`cnt[!type]`). This is because if a row is updated, it affects every column in that row, and if a column is updated, it affects every row in that column.
- **Decrement the Count**: We then decrement `cnt[type]` to reflect that one more row or column has been updated.

#### Step 4: Return the Total Sum

```cpp
return res;
```

- After all queries are processed, the value of `res` holds the total sum of the matrix after applying all the updates. We return this value.

### Complexity

#### Time Complexity
- **O(m)**, where `m` is the number of queries. We process each query exactly once, and each operation within the query (checking and updating arrays) takes constant time.
- The `find` and update operations for the arrays `seen` and `cnt` are done in constant time for each query. Hence, the overall time complexity is **O(m)**, where `m` is the number of queries.

#### Space Complexity
- **O(n)**, where `n` is the size of the matrix. We use two arrays (`seen` and `cnt`) to keep track of the rows and columns, both of which require `O(n)` space.
- The array `q` (queries) is given as input, but it’s not part of the space complexity analysis.

### Conclusion

This approach efficiently computes the total sum of the matrix after all updates by processing the queries in reverse order. The solution avoids the inefficiency of directly modifying the matrix, reducing the problem to a series of constant-time operations for each query. By leveraging the `seen` and `cnt` arrays, we can track updates in constant space and time. With a time complexity of **O(m)** and space complexity of **O(n)**, this solution is optimal for large inputs.
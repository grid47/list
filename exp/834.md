### Problem Statement

In this problem, you are given an undirected tree with `n` nodes and `n-1` edges. The nodes are numbered from `0` to `n-1`, and the edges are provided as a list of pairs where each pair `[u, v]` represents an undirected edge between nodes `u` and `v`. The task is to calculate the sum of distances between a given node and all other nodes in the tree for each node. 

In other words, for each node `i`, we need to calculate the sum of the distances from node `i` to all other nodes in the tree. The distance between two nodes is defined as the number of edges in the shortest path between them.

### Approach

To solve this problem efficiently, we need to avoid calculating the sum of distances for each node separately using a brute-force approach, as this would lead to a time complexity of `O(n^2)`, which is not optimal for large inputs.

Instead, we can use the following approach:
1. **First DFS (dfs1)**: The first DFS computes the sum of distances for the root node (node `0`), as well as the number of nodes in each subtree rooted at every node.
2. **Second DFS (dfs2)**: The second DFS propagates the distances from the root node to all other nodes in the tree. It uses the result of the first DFS to efficiently compute the sum of distances for each node by adjusting the sum of distances based on its parent’s value.

This method takes advantage of the structure of the tree and avoids redundant calculations, making the algorithm run in linear time, i.e., `O(n)`.

### Code Breakdown (Step by Step)

#### Step 1: Initialization

```cpp
gph.resize(n, vector<int>());
```
- We initialize the adjacency list `gph` to represent the tree, where each node has a list of its neighbors.
- The adjacency list is a 2D vector with `n` rows, where each row corresponds to a node and contains the list of its neighbors.

```cpp
res.resize(n, 0);
cnt.resize(n, 0);
```
- `res` will store the sum of distances from each node to all other nodes. We initialize it with zero values.
- `cnt` will store the size of the subtree rooted at each node. We initialize it with zero values.

#### Step 2: Building the Tree

```cpp
for(vector<int> edge: edges) {
    gph[edge[0]].push_back(edge[1]);
    gph[edge[1]].push_back(edge[0]);
}
```
- We loop through the edges and populate the adjacency list `gph`. For each edge `[u, v]`, we add `v` to the list of neighbors of `u` and `u` to the list of neighbors of `v`. This makes the graph undirected.

#### Step 3: First DFS (dfs1)

```cpp
void dfs1(int cur, int pre) {
    for (int nxt : gph[cur]) {
        if (pre == nxt) 
            continue;
        dfs1(nxt, cur);
        cnt[cur] += cnt[nxt];
        res[cur] += res[nxt] + cnt[nxt];
    }
    cnt[cur]++;
}
```
- The first DFS calculates the sum of distances for the root node and the sizes of the subtrees for each node.
- `cur` represents the current node, and `pre` represents the parent node.
- We traverse all the neighbors of the current node `cur`. For each neighbor `nxt`, we recursively call `dfs1` to explore the subtree rooted at `nxt`.
- After visiting a child node `nxt`, we:
  - Add the size of the subtree rooted at `nxt` to the size of the current node’s subtree (`cnt[cur] += cnt[nxt]`).
  - Add the sum of distances for node `nxt`, as well as the size of the subtree rooted at `nxt`, to the sum of distances for the current node (`res[cur] += res[nxt] + cnt[nxt]`).
- Finally, we increment `cnt[cur]` to account for the current node itself.

#### Step 4: Second DFS (dfs2)

```cpp
void dfs2(int cur, int pre) {
    for (int nxt : gph[cur]) {
        if (pre == nxt) continue;
        res[nxt] = res[cur] - cnt[nxt] + cnt.size() - cnt[nxt];
        dfs2(nxt, cur);
    }
}
```
- The second DFS propagates the sum of distances from the root node to all other nodes.
- Starting from the root node, we compute the sum of distances for each child node using the formula:
  - `res[nxt] = res[cur] - cnt[nxt] + cnt.size() - cnt[nxt]`
  - This formula adjusts the sum of distances for the child node `nxt` by subtracting the distances from the current node’s sum and then adding the number of nodes not in the subtree rooted at `nxt`.
- This propagation works because for each child node, we can calculate its sum of distances by using the sum of distances of its parent node and adjusting based on the number of nodes in its subtree.
- We recursively call `dfs2` to propagate the distance sums throughout the tree.

#### Step 5: Final Result

```cpp
return res;
```
- After the two DFS traversals, the vector `res` will contain the sum of distances for each node. We return `res` as the final result.

### Complexity

#### Time Complexity

- **First DFS (dfs1)**: In this traversal, we visit each node and its neighbors once, so the time complexity of the first DFS is `O(n)`, where `n` is the number of nodes.
- **Second DFS (dfs2)**: Similarly, the second DFS also visits each node and its neighbors once, so its time complexity is also `O(n)`.

Therefore, the overall time complexity of the algorithm is **O(n)**, where `n` is the number of nodes in the tree.

#### Space Complexity

- **Adjacency List**: The adjacency list `gph` requires `O(n)` space to store the tree structure.
- **Auxiliary Arrays**: The arrays `res`, `cnt`, and the recursion stack all require `O(n)` space.

Thus, the space complexity is **O(n)**, where `n` is the number of nodes in the tree.

### Example Walkthrough

#### Input

```cpp
n = 6;
vector<vector<int>> edges = {
    {0, 1},
    {0, 2},
    {2, 3},
    {2, 4},
    {2, 5}
};
```

The tree is represented as:

```
      0
     / \
    1   2
       /|\
      3 4 5
```

#### Execution

1. **First DFS** (dfs1):
   - We start from node `0`:
     - For node `1`, the sum of distances is `1` (distance from `0` to `1`).
     - For node `2`, the sum of distances is `1 + 2 = 3` (distance from `0` to `2`, then from `2` to its children).
     - We compute the sum of distances for the root and subtree sizes.

2. **Second DFS** (dfs2):
   - Starting from node `0`, we propagate the results to the other nodes:
     - For node `1`, the sum of distances is adjusted based on the sum for node `0`.
     - Similarly, we adjust the sum of distances for nodes `2`, `3`, `4`, and `5`.

#### Output

```cpp
[8, 12, 6, 10, 10, 10]
```

### Conclusion

This solution efficiently calculates the sum of distances for each node in a tree using two depth-first search (DFS) traversals. The time complexity of `O(n)` ensures that the solution works well even for large trees. By using a bottom-up approach followed by a top-down propagation of results, the algorithm minimizes redundant calculations and achieves optimal performance. The solution is both space and time efficient, making it ideal for solving problems involving tree structures where distances between nodes need to be computed.
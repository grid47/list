### Problem Statement

The problem at hand is from the well-known "House Robber" dynamic programming problem. Given a list of non-negative integers representing the amount of money stored in each house, you are tasked with determining the maximum amount of money you can rob tonight without alerting the police. The condition is that you cannot rob two adjacent houses on the same night.

**Problem Input:**
- An array `a` of non-negative integers, where `a[i]` represents the amount of money in the `i`-th house.

**Problem Output:**
- Return the maximum amount of money you can rob without robbing two adjacent houses.

For example:
- **Input:** `a = [2, 7, 9, 3, 1]`
- **Output:** `12` (Rob the first, third, and fifth house for a total of 12).

### Approach

To solve this problem efficiently, we use dynamic programming. The key idea is that we need to decide for each house whether it's better to rob that house or skip it. The decision can be made using the following approach:

1. **State Definition:**
   Let `dp[i]` represent the maximum amount of money that can be robbed from the first `i` houses (i.e., from house `0` to house `i`).

2. **Recurrence Relation:**
   - If we rob the `i`-th house, we cannot rob the `(i-1)`-th house, but we can take the money from the `(i-2)`-th house. So, the value will be `dp[i-2] + a[i]`.
   - If we skip the `i`-th house, then we simply take the value of `dp[i-1]`.
   - Therefore, the recurrence relation is:
     \[
     dp[i] = \max(dp[i-1], dp[i-2] + a[i])
     \]
   - The base cases are:
     - `dp[0] = a[0]`: If there's only one house, we rob it.
     - `dp[1] = max(a[0], a[1])`: If there are two houses, we rob the one with the higher value.

3. **Final Answer:**
   The answer will be stored in `dp[n-1]`, where `n` is the number of houses. This will contain the maximum money that can be robbed considering all the houses.

### Code Breakdown (Step by Step)

#### Step 1: Handle Small Input Sizes
```cpp
if(n == 1) return a[0];
```
- If there is only one house, we can rob it, so we immediately return the value in `a[0]`.

#### Step 2: Initialize the DP Array
```cpp
vector<int> dp(n, 0);
```
- We initialize a vector `dp` of size `n` (the number of houses) to store the maximum money that can be robbed up to each house. All elements are initially set to `0`.

#### Step 3: Set Base Cases
```cpp
dp[0] = a[0];
dp[1] = max(a[0], a[1]);
```
- For the first house (`dp[0]`), the maximum money we can rob is simply `a[0]`.
- For the second house (`dp[1]`), we can either rob the first or the second house. We choose the house with the higher amount of money, which is calculated using `max(a[0], a[1])`.

#### Step 4: Fill the DP Array for All Other Houses
```cpp
for(int i = 2; i < n; i++)
    dp[i] = max(dp[i-2] + a[i], dp[i-1]);
```
- We loop through the array starting from the third house (index 2).
- For each house `i`, we update `dp[i]` by choosing the maximum between:
  - Robbing house `i`, which gives the money `dp[i-2] + a[i]` (we add `a[i]` to the maximum robbed money from house `i-2`), or
  - Skipping house `i` and keeping the maximum robbed money from house `i-1` (i.e., `dp[i-1]`).

#### Step 5: Return the Final Result
```cpp
return dp[n-1];
```
- After processing all the houses, the final value in `dp[n-1]` will hold the maximum money that can be robbed without robbing two adjacent houses. We return this value as the answer.

### Complexity

#### Time Complexity:
- **O(n):** The solution iterates through the list of houses exactly once. For each house, we perform constant-time operations (computing the maximum between two values). Thus, the time complexity is linear in the number of houses, which is `O(n)` where `n` is the size of the input array `a`.

#### Space Complexity:
- **O(n):** The solution uses a dynamic programming array `dp` of size `n` to store intermediate results. This means the space complexity is proportional to the number of houses. In the worst case, this is `O(n)`.

### Optimization: Space Complexity Reduction

While the current solution uses `O(n)` space, we can reduce the space complexity to **O(1)** by only keeping track of the last two values of the `dp` array, because each state only depends on the previous two states (`dp[i-1]` and `dp[i-2]`). Here is an optimized version of the space complexity:

```cpp
int rob(vector<int>& a) {
    int n = a.size();
    if (n == 1) return a[0];

    int prev2 = a[0], prev1 = max(a[0], a[1]);
    for (int i = 2; i < n; i++) {
        int current = max(prev2 + a[i], prev1);
        prev2 = prev1;
        prev1 = current;
    }
    return prev1;
}
```
In this optimized solution:
- We use only two variables, `prev1` and `prev2`, to store the results of the last two houses, reducing the space complexity to **O(1)**.
- The logic and time complexity remain the same as the original solution.

### Conclusion

This dynamic programming solution effectively solves the "House Robber" problem by using a bottom-up approach to compute the maximum amount of money that can be robbed from the houses without robbing two adjacent ones. The solution efficiently calculates the result in **O(n)** time and **O(n)** space, where `n` is the number of houses.

By using a recurrence relation based on the optimal substructure of the problem, we ensure that we are only considering relevant past decisions (whether to rob the previous house or skip it). Additionally, the solution can be optimized further to achieve **O(1)** space complexity, making it highly efficient both in terms of time and space. This approach is ideal for solving similar dynamic programming problems where decisions are based on the previous states in a linear sequence.
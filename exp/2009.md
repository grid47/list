### Problem Statement

The problem requires us to determine the minimum number of operations needed to make all elements of an array equal. An operation is defined as removing any number of elements from the array. The goal is to minimize the number of elements that need to be removed to achieve an array with all identical elements.

For instance, given an input array like `nums = [1, 2, 3, 4, 5]`, we can remove elements in such a way that we end up with a single number, which minimizes the operations needed. This problem can be approached by considering the distinct elements in the array and how closely they cluster together.

### Approach

To solve the problem, we can follow these steps:

1. **Sorting the Array**: We start by sorting the input array. Sorting helps us identify and manage distinct values easily.

2. **Removing Duplicates**: Since the order doesn't matter for our final result, we can create a new array that only contains unique elements from the original sorted array.

3. **Two-Pointer Technique**: We use a two-pointer technique to traverse the unique elements:
   - The first pointer (`i`) iterates through the unique elements.
   - The second pointer (`j`) finds the farthest position where the difference between the element at the first pointer and the element at the second pointer is less than or equal to the length of the original array minus one (`n - 1`).

4. **Calculating Minimum Removals**: For each position of the first pointer, we calculate how many elements would need to be removed to form a contiguous block of identical elements. The goal is to minimize this removal count across all possible configurations.

### Code Breakdown (Step by Step)

Letâ€™s dissect the code to understand its structure and logic:

1. **Class Definition**: The implementation is encapsulated within a class named `Solution`.

    ```cpp
    class Solution {
    public:
    ```

2. **Method Declaration**: The method `minOperations` accepts a vector of integers (`nums`) and returns an integer representing the minimum number of operations needed.

    ```cpp
    int minOperations(vector<int>& nums) {
    ```

3. **Size Calculation**: We start by obtaining the size of the input array `nums`.

    ```cpp
    int n = nums.size();
    ```

4. **Sorting the Array**: The next step is to sort the array, which allows us to manage and compare distinct elements more easily.

    ```cpp
    sort(nums.begin(), nums.end());
    ```

5. **Removing Duplicates**: We create a new length variable `m` initialized to 1. We iterate through the sorted array and remove duplicates by only keeping unique elements in their original order.

    ```cpp
    int m = 1;
    for(int i = 1; i < n; i++)
        if(nums[i] != nums[i - 1])
            nums[m++] = nums[i];
    ```

6. **Two-Pointer Initialization**: We initialize two pointers: `j` (starting from the beginning) and `ans` (set to the size of the original array, representing the maximum number of operations needed).

    ```cpp
    int j = 0, ans = n;
    ```

7. **Iterating Through Unique Elements**: We then loop through the unique elements using the first pointer (`i`).

    ```cpp
    for(int i = 0; i < m; i++) {
    ```

8. **Finding the Second Pointer**: Inside this loop, we use a while loop to move the second pointer (`j`) forward until the difference between the current unique element and the element at the second pointer exceeds `n - 1`.

    ```cpp
    while(j < m && nums[j] - nums[i] <= n - 1) j++;
    ```

9. **Calculating Minimum Removals**: We calculate the minimum number of operations needed by subtracting the count of the contiguous elements from `n` (the total number of elements). This gives us the number of elements that would need to be removed to keep the elements in the current block.

    ```cpp
    ans = min(ans, n - (j - i));
    ```

10. **Return the Result**: Finally, we return the calculated minimum operations needed.

    ```cpp
    return ans;
    }
    ```

### Complexity

The time complexity of this solution is O(n log n) due to the sorting step, where `n` is the size of the input array. The subsequent operations involve linear passes through the array, leading to an overall efficient solution. The space complexity is O(1) for the pointers and counters used, as we are manipulating the input array in place.

### Conclusion

In summary, this solution provides an effective way to minimize the number of operations required to make all elements in an array equal by leveraging sorting, the two-pointer technique, and careful counting of unique elements. By transforming the input into a manageable structure and using efficient traversal methods, we can achieve the desired result with clarity and precision. This approach not only showcases the power of algorithmic thinking but also highlights the importance of optimizing operations when dealing with array data structures. Whether you're a student learning algorithms or a seasoned developer, the techniques demonstrated here serve as a solid foundation for tackling similar challenges in programming.
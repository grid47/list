### Problem Statement

The task is to generate the **Nth term** of the "Count and Say" sequence. The sequence starts as follows:

- `1` (1st term)
- `11` (2nd term)
- `21` (3rd term)
- `1211` (4th term)
- `111221` (5th term)
- `312211` (6th term)

The next term in the sequence is generated by describing the digits of the previous term, in terms of consecutive digits. For example:

- "1" is read as "one 1" → "11"
- "11" is read as "two 1s" → "21"
- "21" is read as "one 2, one 1" → "1211"
- "1211" is read as "one 1, one 2, two 1s" → "111221"

Given an integer `n`, the goal is to generate the `n`th term of the sequence.

### Approach

To solve this problem, the approach involves recursively generating the previous term of the sequence and then describing it (or "counting and saying" the digits). Specifically:

1. If `n == 1`, the answer is `"1"`.
2. For any other `n`, we calculate the (n-1)th term of the sequence recursively.
3. After calculating the (n-1)th term, the next term is formed by counting consecutive digits and appending the count followed by the digit.

The core idea is to break down the string into consecutive blocks of the same digit, count how many digits there are in each block, and then describe the block in the form of "count followed by the digit."

### Code Breakdown (Step by Step)

```cpp
if (n == 1) return "1";
```
- **Step 1:** If the input `n` is 1, the first term of the sequence is simply `"1"`, so we return `"1"` immediately. This serves as the base case for the recursion.

```cpp
string tmp = countAndSay(n-1);
```
- **Step 2:** For any `n > 1`, the function recursively calls `countAndSay(n-1)` to generate the previous term in the sequence. This previous term (`tmp`) is the string we need to process to create the next term.

```cpp
string ans = "";
```
- **Step 3:** We initialize an empty string `ans`, which will store the final result for the `n`th term.

```cpp
for(int i = 0; i < tmp.size(); ) {
```
- **Step 4:** We start iterating over each character in the string `tmp`. The loop will process each digit of `tmp` to count consecutive occurrences.

```cpp
char ch = tmp[i];
int cnt = 0;
```
- **Step 5:** For each new character `tmp[i]`, we store the character in `ch` and initialize a counter `cnt` to 0, which will track how many times the current character repeats consecutively.

```cpp
while(tmp[i] == ch && i < tmp.size()) {
    cnt++;
    i++;
}
```
- **Step 6:** Inside a `while` loop, we keep incrementing the counter `cnt` as long as the current character `tmp[i]` is equal to `ch` (i.e., it matches the previous character) and we haven't reached the end of the string. We also increment the index `i` to move to the next character.

```cpp
ans.push_back(cnt+'0');
ans.push_back(tmp[i-1]);
```
- **Step 7:** After counting all consecutive occurrences of the current character, we append the count (`cnt`) to the result string `ans` followed by the character `tmp[i-1]` (since `i` has moved past the last matching character). The `cnt` is converted to a character by adding `'0'` (the ASCII value for '0') to the integer value `cnt`.

```cpp
return ans;
```
- **Step 8:** After processing all characters in the string `tmp`, we return the constructed string `ans`, which represents the `n`th term of the sequence.

### Complexity

#### Time Complexity:
- **O(n * m):** Here, `n` is the number of terms in the sequence (which is the input `n`), and `m` is the average length of the terms. For each term, we are processing all characters of the previous term. The length of the sequence grows exponentially (about twice the size of the previous term), so the time complexity is roughly **O(n * 2^n)**, where `n` is the input value. This results from recursively building the sequence and processing the previous term each time.

#### Space Complexity:
- **O(m):** The space complexity is dominated by the string storage for the `n`th term and the recursive call stack. At each recursive call, the function needs to store the current term (which can grow exponentially), leading to a space complexity of **O(m)**, where `m` is the length of the `n`th term.

### Conclusion

This solution efficiently generates the `n`th term of the "Count and Say" sequence by recursively generating the previous term and counting consecutive digits. The approach utilizes a recursive function that processes the string one character at a time and constructs the next term by counting the occurrences of consecutive digits. The time and space complexities grow exponentially with the input `n`, making this solution feasible for small values of `n` but potentially less efficient for very large inputs due to the exponential growth of the sequence length.
### Problem Statement

The problem asks us to determine the number of servers that are active for each query in a system where multiple logs and queries are given. Each log entry contains a server ID and a timestamp, indicating when a server was active. Each query specifies a timestamp, and the task is to count how many servers are active during the time window `[query - x, query]` for each query.

For example, if the logs are as follows:
```
logs = [[1, 2], [2, 5], [3, 8], [4, 10]]
```
and we have a query at `6` with a window of `3` (`x = 3`), we want to count how many servers are active between time `3` and `6` (i.e., logs at times `2`, `5`, and `6` are relevant).

### Approach

The approach involves processing the logs and answering each query efficiently by utilizing sorting, sliding windows, and hashmaps. We can break the solution into the following steps:

1. **Sorting the Logs and Queries**:
   - First, we sort the logs based on their timestamps.
   - We also need to sort the queries so that we can answer them in increasing order of time.

2. **Sliding Window for Active Servers**:
   - For each query, we need to track which servers are active in the window `[query - x, query]`. This is done using a sliding window technique.
   - We maintain a set of active servers and a map of the count of active servers.

3. **Efficient Query Answering**:
   - For each query, we first add logs with timestamps less than or equal to the current query time.
   - Then, we remove logs where the timestamp is outside the window `[query - x, query]`.
   - The final result is calculated by subtracting the count of active servers from the total number of servers.

4. **Using Maps and Sets**:
   - We use a `set` to maintain the active servers in the current window.
   - A `map` helps keep track of the frequency of each server ID to efficiently handle removals and updates.

### Code Breakdown

#### 1. **Sorting the Queries**

```cpp
vector<pair<int,int>> qs;
for(int i = 0; i < queries.size(); i++) {
    qs.push_back({queries[i], i});  // Store the query value and its original index
}
sort(qs.begin(), qs.end());  // Sort queries based on time
```

- We store each query along with its original index in the `qs` vector.
- Sorting the queries allows us to process them in chronological order.

#### 2. **Sorting the Logs**

```cpp
sort(logs.begin(), logs.end(), [&](auto const &a, auto const &b){
    return a[1] < b[1];  // Sort logs based on their timestamps
});
```

- We sort the logs based on the timestamp, ensuring that we process the logs in chronological order.

#### 3. **Sliding Window Using Set and Map**

```cpp
set<pair<int, int>> s;  // To store the {timestamp, server_id} pairs
map<int, int> count;     // To count the number of active logs for each server
```

- `s` is a `set` used to store active servers as pairs of timestamps and IDs, so we can efficiently remove expired entries.
- `count` is a `map` that keeps track of the number of active logs for each server ID.

#### 4. **Processing Each Query**

```cpp
int i = 0;
for (auto &[q, index] : qs) {
    // Add all logs where timestamp <= current query
    while (i < logs.size() && logs[i][1] <= q) {
        s.insert({logs[i][1], logs[i][0]});
        count[logs[i][0]]++;
        i++;
    }
    
    // Remove logs where timestamp is outside the current window (i.e., < q - x)
    while (!s.empty() && s.begin()->first < q - x) {
        count[s.begin()->second]--;
        if (count[s.begin()->second] == 0) count.erase(s.begin()->second);
        s.erase(s.begin());
    }
    
    // Store the result: the number of servers not in the current window
    result[index] = n - count.size();
}
```

- For each query `q`, we:
  - Add all logs with timestamps less than or equal to `q` to the `set` and `map`.
  - Remove logs that are outside the valid window `[q - x, q]` by checking the timestamp of the smallest timestamp in the set.
  - Finally, we compute the number of inactive servers as `n - count.size()` and store it in the `result` array at the corresponding index.

#### 5. **Returning the Result**

```cpp
return result;
```

- After processing all queries, the `result` vector contains the answer for each query, which is returned to the caller.

### Complexity Analysis

#### Time Complexity

1. **Sorting Queries**: Sorting the queries takes \(O(q \log q)\), where \(q\) is the number of queries.
2. **Sorting Logs**: Sorting the logs takes \(O(m \log m)\), where \(m\) is the number of log entries.
3. **Processing Each Query**: 
   - For each query, we may insert and remove elements from the `set` and `map`, which takes \(O(\log m)\) for each log operation.
   - The number of operations is proportional to the number of logs, so for each query, processing takes \(O(m \log m)\).
4. **Overall Complexity**: 
   - The total time complexity is \(O(m \log m + q \log q)\), where \(m\) is the number of logs and \(q\) is the number of queries.

#### Space Complexity

- The space complexity is \(O(m + q)\) due to the storage required for the logs, queries, the `set`, and the `map` used to track active servers. Thus, the space complexity is \(O(m + q)\).

### Conclusion

This solution efficiently handles the task of counting active servers at each query using sorting and a sliding window approach with a `set` and `map` for active server tracking. The time complexity of \(O(m \log m + q \log q)\) ensures that the solution can handle large inputs efficiently. This approach is ideal for scenarios where you have a large number of logs and queries and need to process them quickly.
### Problem Statement

The problem is to find the length of the **longest increasing path** in a 2D matrix where each cell contains an integer. You can move from a cell to its adjacent cells (up, down, left, or right) if the value of the adjacent cell is strictly greater than the current cellâ€™s value.

Given the matrix, we need to find the length of the longest path where each move is to an adjacent cell with a greater value. The matrix may contain values that are not sorted, and we need to compute the longest increasing path efficiently.

### Approach

To solve the problem of finding the longest increasing path in a matrix, we can approach it using **Depth-First Search (DFS)** and **Memoization**. The idea is to explore all potential paths in the matrix starting from each cell, and for each cell, we will explore its adjacent cells recursively.

#### Steps:
1. **DFS for Path Exploration**: Starting from any cell in the matrix, we recursively explore its neighbors (up, down, left, right) and check if moving to that neighbor is valid. Specifically, we check if the neighbor has a larger value than the current cell.
   
2. **Memoization**: Since there are overlapping subproblems in this approach (many cells are visited multiple times during the search), we use memoization to store already computed results for each cell. This significantly reduces the number of repeated computations, improving performance.

3. **Tracking the Longest Path**: For each cell, we calculate the length of the longest increasing path that starts at that cell and store it in a memoization table. During the DFS, we update the longest path found so far.

4. **Grid Boundaries**: As we explore the grid, we need to ensure we do not go outside the boundaries of the matrix.

### Code Breakdown (Step by Step)

Let's break down the code and understand each section:

```cpp
int m, n;
vector<vector<int>> mtx, vis, memo;
```
- **Variable Initialization**:
  - `m` and `n` are the dimensions of the matrix (`m` rows and `n` columns).
  - `mtx` stores the matrix values.
  - `vis` is a 2D array used to mark the cells that have been visited during a DFS search.
  - `memo` is used to store the length of the longest increasing path starting from each cell.

```cpp
int dfs(int i, int j) {
    if (memo[i][j] != -1) return memo[i][j];
    int res = 1;
    vis[i][j] = 1;
```
- **DFS Function**:
  - The `dfs` function explores the grid starting from cell `(i, j)`. 
  - The `memo[i][j]` value stores the result of the longest increasing path from `(i, j)`. If this has already been computed, we return the memoized result.
  - If it has not been computed, we initialize the result `res = 1` since the cell itself forms a path of length 1.
  - `vis[i][j]` marks the current cell as visited.

```cpp
if (i > 0 && !vis[i - 1][j] && mtx[i - 1][j] > mtx[i][j]) 
    res = max(res, 1 + dfs(i - 1, j));
if (j > 0 && !vis[i][j - 1] && mtx[i][j - 1] > mtx[i][j]) 
    res = max(res, 1 + dfs(i, j - 1));
if (i < m - 1 && !vis[i + 1][j] && mtx[i + 1][j] > mtx[i][j]) 
    res = max(res, 1 + dfs(i + 1, j));
if (j < n - 1 && !vis[i][j + 1] && mtx[i][j + 1] > mtx[i][j]) 
    res = max(res, 1 + dfs(i, j + 1));
```
- **Exploring Neighbors**:
  - We check four possible directions: up (`i - 1`), left (`j - 1`), down (`i + 1`), and right (`j + 1`).
  - For each direction, we check if the move is valid:
    - The neighbor must be within matrix boundaries.
    - The value in the neighbor must be strictly greater than the current cell (`mtx[i - 1][j] > mtx[i][j]`).
    - The neighbor must not have been visited during the current DFS search.
  - If the move is valid, we recursively call `dfs` for that neighbor and update the `res` value to the maximum path length found.

```cpp
vis[i][j] = 0;
return memo[i][j] = res;
```
- **Marking as Unvisited**:
  - After exploring all possible directions from the current cell, we mark it as unvisited (`vis[i][j] = 0`) to allow other DFS searches to explore it.
  - The result `res` (longest path from this cell) is stored in `memo[i][j]`.

```cpp
int longestIncreasingPath(vector<vector<int>>& mtx) {
    this->m = mtx.size();
    this->n = mtx[0].size();
    this->mtx = mtx;
    memo.resize(m, vector<int>(n, -1));
    int res = 0;
    for (int i = 0; i < m; i++) 
        for (int j = 0; j < n; j++) {
            vis.resize(m, vector<int>(n, 0));
            res = max(res, dfs(i, j));
        }
    return res;
}
```
- **Main Function**:
  - First, we initialize the matrix dimensions `m` and `n`, and store the input matrix `mtx` in the class variable.
  - The `memo` table is resized to store the longest increasing path starting from each cell, initialized to `-1`.
  - We then iterate through all cells in the matrix. For each cell `(i, j)`, we invoke the `dfs` function to calculate the longest increasing path starting from that cell.
  - The `vis` array is resized for each new DFS search to ensure that the grid is not marked visited from previous searches.
  - After checking all cells, the result `res` holds the length of the longest increasing path found.

### Complexity

#### Time Complexity:
- **O(m * n)**: In the worst case, each cell is visited once for every DFS call. The DFS function is called for each cell in the matrix, and each DFS search explores four neighboring cells. Each search is bounded by the matrix dimensions, leading to a time complexity of **O(m * n)**, where `m` is the number of rows and `n` is the number of columns.

#### Space Complexity:
- **O(m * n)**: The space complexity is dominated by the `memo`, `vis`, and `mtx` matrices. All of these require **O(m * n)** space.

### Conclusion

This solution efficiently finds the longest increasing path in a matrix using Depth-First Search (DFS) combined with memoization. By caching results in the `memo` table, the algorithm avoids redundant calculations, making it much faster than a naive approach. The time and space complexities are both linear with respect to the number of cells in the matrix, making the approach scalable for large matrices.
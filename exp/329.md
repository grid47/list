### üöÄ Problem Statement

We are given a 2D matrix where each cell contains an integer. The task is to find the **length of the longest increasing path** in the matrix. You can move to an adjacent cell (up, down, left, or right) if the value of the adjacent cell is strictly greater than the current cell‚Äôs value.

Our goal is to compute the longest increasing path efficiently, even if the values in the matrix are not sorted.

---

### üß† Approach

To solve this problem, we‚Äôll use **Depth-First Search (DFS)** combined with **Memoization**. The strategy is to explore all possible paths starting from each cell and calculate the longest path for each one.

Here‚Äôs the game plan:

1. **DFS for Path Exploration**: Start from any cell in the matrix and recursively explore its neighbors (up, down, left, right), checking if each move is valid (i.e., the neighbor has a greater value).
   
2. **Memoization**: To avoid recalculating the same paths repeatedly, we store the results for each cell in a `memo` table. This dramatically reduces redundant work.

3. **Track Longest Path**: As we perform DFS, we keep track of the longest increasing path for each cell and update the result accordingly.

4. **Boundary Checks**: While exploring neighbors, we ensure we don‚Äôt go outside the matrix bounds.

---

### üî® Step-by-Step Code Breakdown

Let's break down the code to understand each part:

```cpp
int m, n;
vector<vector<int>> mtx, vis, memo;
```
- **Variable Initialization**:
  - `m` and `n` store the number of rows and columns of the matrix.
  - `mtx` holds the matrix values.
  - `vis` is a 2D array to track whether a cell has been visited in the current DFS search.
  - `memo` stores the longest increasing path starting from each cell.

```cpp
int dfs(int i, int j) {
    if (memo[i][j] != -1) return memo[i][j];
    int res = 1;
    vis[i][j] = 1;
```
- **DFS Function**:
  - We start the DFS from cell `(i, j)`.
  - If the result for this cell has already been computed (i.e., `memo[i][j] != -1`), we return the memoized result.
  - Initially, the longest path from this cell is at least `1` (the cell itself).
  - Mark the cell as visited with `vis[i][j] = 1`.

```cpp
if (i > 0 && !vis[i - 1][j] && mtx[i - 1][j] > mtx[i][j]) 
    res = max(res, 1 + dfs(i - 1, j));
if (j > 0 && !vis[i][j - 1] && mtx[i][j - 1] > mtx[i][j]) 
    res = max(res, 1 + dfs(i, j - 1));
if (i < m - 1 && !vis[i + 1][j] && mtx[i + 1][j] > mtx[i][j]) 
    res = max(res, 1 + dfs(i + 1, j));
if (j < n - 1 && !vis[i][j + 1] && mtx[i][j + 1] > mtx[i][j]) 
    res = max(res, 1 + dfs(i, j + 1));
```
- **Exploring Neighbors**:
  - For each of the four possible directions (up, down, left, right), we check if the move is valid:
    - The neighbor must be within the matrix boundaries.
    - The neighbor's value must be greater than the current cell‚Äôs value.
    - The neighbor must not have been visited in the current DFS.
  - If a move is valid, we perform a recursive DFS on the neighbor and update the longest path (`res`).

```cpp
vis[i][j] = 0;
return memo[i][j] = res;
```
- **Mark Unvisited**:
  - After exploring all neighbors, we mark the current cell as unvisited (`vis[i][j] = 0`).
  - We store the result `res` in `memo[i][j]` and return it.

```cpp
int longestIncreasingPath(vector<vector<int>>& mtx) {
    this->m = mtx.size();
    this->n = mtx[0].size();
    this->mtx = mtx;
    memo.resize(m, vector<int>(n, -1));
    int res = 0;
    for (int i = 0; i < m; i++) 
        for (int j = 0; j < n; j++) {
            vis.resize(m, vector<int>(n, 0));
            res = max(res, dfs(i, j));
        }
    return res;
}
```
- **Main Function**:
  - Initialize the matrix dimensions and the `mtx` variable.
  - Resize the `memo` table to store results for each cell, initializing each entry to `-1`.
  - Iterate through each cell in the matrix. For each cell, we invoke the `dfs` function to compute the longest increasing path starting from that cell.
  - After checking all cells, the longest path is stored in `res`, and we return it.

---

### üìà Complexity Analysis

#### ‚è±Ô∏è Time Complexity:
- **O(m * n)**: In the worst case, we perform one DFS for each cell. Since each DFS call explores a constant number of neighbors and is only done once due to memoization, the time complexity is **O(m * n)**, where `m` is the number of rows and `n` is the number of columns in the matrix.

#### üíæ Space Complexity:
- **O(m * n)**: The space complexity is dominated by the `memo`, `vis`, and `mtx` matrices. Each of these requires **O(m * n)** space to store information for each cell.

---

### üèÅ Conclusion

This solution efficiently finds the **longest increasing path** in a matrix using **DFS** combined with **memoization**. By storing intermediate results, we avoid redundant calculations, making the algorithm fast and scalable. The approach ensures that we explore each cell once, keeping both the time and space complexity manageable for large matrices.

---

### üî• Key Takeaways
- **Time Complexity**: O(m * n)
- **Space Complexity**: O(m * n)
- This approach is both time-efficient and space-efficient for finding the longest increasing path in a matrix.

Well done for exploring this problem! Keep practicing, and you'll continue to strengthen your problem-solving skills. üòéüí°
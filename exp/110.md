### Problem Statement

The problem is to determine whether a binary tree is **height-balanced**. A binary tree is considered height-balanced if for every node, the difference in heights between its left and right subtrees is at most 1. The height of a node is defined as the number of edges on the longest path from that node to a leaf. This problem is crucial for ensuring that a binary tree performs optimally in operations like insertion, deletion, and traversal.

### Approach

To solve the problem of checking whether a binary tree is height-balanced, the approach can be broken down into two key components:
1. **Recursive Check of Balance Condition:** 
   - For each node in the binary tree, we need to check whether the difference in height between its left and right subtrees is at most 1.
   - If this balance condition holds for every node in the tree, then the tree is height-balanced.
   
2. **Calculate Heights Efficiently:**
   - To check the balance condition, we must calculate the height of each subtree. 
   - A height of a node is the longest path from that node to any leaf in its subtree.
   - A direct way to do this is by recursively calculating the height of the left and right subtrees and checking the balance condition during the recursion.
   
3. **Optimization:** 
   - To avoid recalculating the height of the same subtree multiple times, we compute the height and check balance in a single pass through the tree.

### Code Breakdown (Step by Step)

#### Step 1: `isBalanced` Function

```cpp
bool isBalanced(TreeNode* root) {
    if(!root) return true;
    int l = h(root->left);
    int r = h(root->right);
    return abs(l - r) <= 1 &&
           isBalanced(root->left) &&
           isBalanced(root->right);
}
```

- **Base Case:** The first line checks if the current node (`root`) is `NULL`. If the tree is empty, it is considered balanced, so we return `true`.
- **Height Calculation:** We calculate the heights of the left and right subtrees of the current node. This is done by calling the helper function `h()` (explained in the next step).
- **Balance Condition:** The absolute difference between the left and right subtree heights is checked. If the difference is greater than 1, the tree is unbalanced, and `false` is returned.
- **Recursive Check:** The function also recursively checks the balance of the left and right subtrees. If either subtree is unbalanced, the tree is unbalanced, and `false` is returned.

#### Step 2: `h` Function (Height Calculation)

```cpp
int h(TreeNode* node) {
    if(node == NULL) return 0;
    int l = h(node->left);
    int r = h(node->right);
    return 1 + max(l, r);
}
```

- **Base Case:** The first line checks if the current node (`node`) is `NULL`. If it is, the height of the subtree is 0, as there are no nodes in this subtree.
- **Recursive Height Calculation:** We recursively calculate the height of the left subtree (`l = h(node->left)`) and the right subtree (`r = h(node->right)`).
- **Returning Height:** The height of the current node is the maximum of the heights of the left and right subtrees, plus 1 to account for the current node. The `max(l, r)` ensures we take the longer path from the current node.

### Complexity Analysis

#### Time Complexity

The time complexity of this algorithm is **O(n)**, where `n` is the number of nodes in the binary tree. This is because:
- The function `isBalanced` recursively checks every node in the tree.
- The function `h` is called for each node to compute the height of its subtrees. 
- Each node is visited exactly once, and the height is computed in constant time for each node once its subtrees have been calculated.

Thus, the overall time complexity is proportional to the number of nodes in the tree.

#### Space Complexity

The space complexity of this algorithm is **O(h)**, where `h` is the height of the binary tree. This space is required for the recursive call stack. In the worst case, the tree can be completely unbalanced, and the height `h` could be equal to `n`, resulting in a space complexity of **O(n)**. In the best case, the tree is balanced, and the height is **O(log n)**, resulting in a space complexity of **O(log n)**.

### Example Walkthrough

Let's walk through an example to see how this solution works. Consider the following binary tree:

```
        3
       / \
      9   20
         /  \
        15   7
```

1. **Step 1:** The root node is `3`. We calculate the height of its left and right subtrees:
   - The left subtree is just `9`, with a height of `0`.
   - The right subtree is a tree with root `20`. We calculate the height of the left and right subtrees of `20`:
     - The left subtree is `15`, with a height of `0`.
     - The right subtree is `7`, with a height of `0`.
   - The height of node `20` is `1 + max(0, 0) = 1`.
   - The height of node `3` is `1 + max(0, 2) = 3`.

2. **Step 2:** The balance condition for node `3` is checked. The left subtree has a height of `0`, and the right subtree has a height of `2`. The absolute difference is `2`, which is greater than `1`, so the tree is unbalanced.

The function will return `false`, indicating that the tree is not balanced.

### Conclusion

The solution efficiently checks whether a binary tree is balanced by:
- Recursively calculating the height of each subtree.
- Checking the balance condition (the height difference between left and right subtrees) at each node.
- Returning `true` if the tree is balanced and `false` if it is unbalanced.

The time complexity of **O(n)** and space complexity of **O(h)** make this solution optimal for typical binary tree problems, where `n` is the number of nodes and `h` is the height of the tree. The solution handles both balanced and unbalanced trees efficiently and uses recursion to traverse the tree while calculating heights.
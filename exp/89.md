### Problem Statement

The problem asks to generate the *Gray Code* sequence for a given integer `n`. A Gray Code sequence is a sequence of numbers where each number differs from the previous one by exactly one bit. The challenge is to generate the Gray Code sequence for `n` bits, where `n` is a non-negative integer.

For example:
- For `n = 2`, the Gray Code sequence is: `[0, 1, 3, 2]`
- For `n = 3`, the Gray Code sequence is: `[0, 1, 3, 2, 6, 7, 5, 4]`

### Approach

To generate the Gray Code sequence efficiently, we can use the iterative approach that builds the sequence incrementally. The key observation here is that:
- The Gray Code for `n` bits can be generated by reflecting the Gray Code of `n-1` bits and prefixing the old values with `0` and the reflected values with `1`.

#### Step-by-Step Approach:
1. **Base Case**: For `n = 0`, the Gray Code sequence is simply `[0]` because there is only one value, 0.
2. **Iterative Generation**: For each bit from `1` to `n`:
   - Start with the sequence from the previous iteration.
   - Reflect the current sequence and prefix the original numbers with `0` and the reflected numbers with `1`.
   - The idea is that the reflected sequence is a mirror image of the original sequence, but each number in the reflected sequence has an additional bit set to `1` at the current bit position.
3. **Final Sequence**: After the loop, we will have generated the entire Gray Code sequence for `n` bits.

### Code Breakdown (Step by Step)

#### Step 1: Initializing the Result

```cpp
vector<int> res = {0};
```

The base case for the Gray Code sequence is simply `[0]` for `n = 0`. This initializes the result vector `res` with one element, 0.

#### Step 2: Iterating Over the Bit Positions

```cpp
for (int idx = 0; idx < n; idx++) {
```

This loop iterates through each bit position from `0` to `n-1` (total `n` iterations). In each iteration, we will modify the `res` array to include the Gray Code sequence for the current number of bits.

#### Step 3: Reflecting the Sequence

```cpp
int sz = res.size();
for (int jdx = sz - 1; jdx >= 0; jdx--)
    res.push_back(res[jdx] | (1 << idx));
```

- `sz = res.size()` stores the current size of the sequence `res`.
- The inner loop processes the current sequence in reverse order (from the end of the sequence to the beginning).
- In each iteration of the inner loop, we add a new value to the sequence by OR'ing the current value `res[jdx]` with `(1 << idx)`. This operation sets the `idx`-th bit of `res[jdx]` to `1`, effectively reflecting the sequence by adding the new bit to the numbers in reverse order.

#### Step 4: Return the Final Result

```cpp
return res;
```

After the loop completes, the sequence `res` contains the Gray Code sequence for `n` bits, which is returned as the result.

### Complexity

#### Time Complexity:
The time complexity of this solution is **O(2^n)**. This is because the size of the Gray Code sequence for `n` bits is `2^n`, and the algorithm generates the sequence by adding one number to the sequence in each iteration. Each iteration of the outer loop processes `2^n` elements, making the time complexity proportional to the size of the final sequence.

- **Outer loop**: Iterates `n` times (for each bit).
- **Inner loop**: For each iteration of the outer loop, we process the current sequence of size `2^k` for the `k`-th bit, so the total number of operations across all iterations is the sum of `2^0, 2^1, ..., 2^(n-1)` which is equal to `2^n - 1`.

Thus, the time complexity is **O(2^n)**.

#### Space Complexity:
The space complexity is also **O(2^n)** because the algorithm generates and stores the Gray Code sequence of size `2^n` in the `res` vector.

### Conclusion

This solution efficiently generates the Gray Code sequence for `n` bits using an iterative approach. By reflecting the sequence and modifying each number with the new bit, the algorithm constructs the sequence incrementally, ensuring that each number differs from the previous one by exactly one bit. The time complexity is **O(2^n)**, which is optimal for this problem since the output sequence itself has `2^n` elements. The space complexity is also **O(2^n)** to store the sequence. This solution is both time and space efficient, making it suitable for generating Gray Code sequences even for relatively large values of `n`.
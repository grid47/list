### üöÄ Problem Statement

Imagine you‚Äôre given a list of integers, and you need to implement a class that can do two things:
1. **Reset**: Return the list to its original configuration.
2. **Shuffle**: Randomly shuffle the elements in the list and return the shuffled version.

For example:
- If `nums = [1, 2, 3]`, after calling `reset()`, you should get `[1, 2, 3]` back.
- After calling `shuffle()`, you should get a randomly shuffled version of `[1, 2, 3]`, like `[2, 3, 1]` or `[3, 1, 2]`.

The challenge is to implement these operations efficiently while making sure the shuffle gives all possible permutations an equal chance.

---

### üß† Approach

To solve this, we can break the problem into two main parts:

1. **Reset Operation**:
   - Store the original list in a class member variable. This lets us quickly return the list to its original state whenever `reset()` is called.
   
2. **Shuffle Operation**:
   - For shuffling, we‚Äôll use the **Fisher-Yates shuffle** (also known as **Knuth shuffle**). This is a well-known algorithm that ensures every possible permutation of the list has an equal chance of being chosen.

---

### üî® Step-by-Step Code Breakdown

Let's go through how we implement both operations in the class:

#### 1. Class Definition and Member Variables
```cpp
class Solution {
    vector<int> arr;
public:
    Solution(vector<int>& nums) {
        arr = nums;
    }
```
- We create a class `Solution` with a private member `arr` to store the original list.
- In the constructor, we initialize `arr` with the input list `nums` to store the list when the object is created.

#### 2. Reset Operation
```cpp
    vector<int> reset() {
        return arr;
    }
```
- The `reset()` method simply returns the original list, which is stored in `arr`. This is a constant-time operation because no modification is required.

#### 3. Shuffle Operation
```cpp
    vector<int> shuffle() {
        vector<int> stk(arr);
        int n = stk.size();
        for(int i = 0; i < n; i++) {
            int j = rand() % (n - i);
            swap(stk[i + j], stk[i]);
        }
        return stk;
    }
```
- The `shuffle()` method starts by copying the list `arr` into a new vector `stk`. This ensures the original list remains unchanged.
- We then perform the **Fisher-Yates shuffle**:
  - Loop through each element of `stk`, and for each position `i`, pick a random index `j` from the remaining unshuffled portion.
  - Swap the current element `i` with the randomly selected element `i + j`. This process ensures an unbiased random shuffle of the list.
- Finally, we return the shuffled list `stk`.

---

### üìà Complexity Analysis

#### Time Complexity:
- **Constructor (`Solution(vector<int>& nums)`):** The constructor runs in **O(n)** time, where `n` is the length of the input list, as we are simply copying the input list into `arr`.
- **Reset Operation (`reset()`):** The `reset()` method is **O(1)** because it only returns the stored list.
- **Shuffle Operation (`shuffle()`):** The shuffle operation involves copying the list (O(n)) and performing a loop over the list with a constant-time swap operation for each element, resulting in an overall time complexity of **O(n)**.

#### Space Complexity:
- **Space Complexity:** The space complexity is **O(n)** because of the new vector `stk` created for the shuffle operation. This vector stores a copy of the list. The original list `arr` is stored in the class, but since it's not recreated in the shuffle, we don‚Äôt count it again.

---

### üèÅ Conclusion

This solution effectively handles the two operations required:
- The `reset()` method restores the original list efficiently in constant time.
- The `shuffle()` method uses the Fisher-Yates algorithm to ensure a fair and unbiased shuffle in linear time.

Here‚Äôs a quick summary:
- **Time Complexity**: **O(n)** for both `shuffle()` and the constructor, **O(1)** for `reset()`.
- **Space Complexity**: **O(n)** due to the additional space used by the shuffled list.

The solution is both simple and efficient, making it perfect for problems that require resetting and shuffling lists. You now have a solid way to manage these operations efficiently! Happy coding! üéâ
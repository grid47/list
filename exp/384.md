### Problem Statement

The problem is to implement a class that can shuffle and reset a given list of integers. You are provided with a list of integers, and the class needs to support two operations:

1. **Reset**: Return the original configuration of the list.
2. **Shuffle**: Randomly shuffle the elements in the list and return the shuffled list.

For example:
- `nums = [1, 2, 3]`
- After calling `reset()`, the list should return `[1, 2, 3]`.
- After calling `shuffle()`, the list should return a randomly shuffled version of `[1, 2, 3]` (e.g., `[3, 1, 2]` or `[2, 3, 1]`).

You need to implement these operations efficiently while maintaining the ability to reset the list to its original configuration.

### Approach

To solve this problem, we can use the following approach:

1. **Reset Operation**: 
   - Store the original list in a data member of the class. This allows us to quickly return the original configuration whenever the `reset()` function is called.
   
2. **Shuffle Operation**: 
   - To shuffle the list randomly, we use a common technique called the **Fisher-Yates shuffle** (also known as the **Knuth shuffle**). This shuffle algorithm ensures that each permutation of the list is equally likely. 
   - The Fisher-Yates shuffle works by iterating through the list and swapping each element with another randomly chosen element that has not yet been shuffled.

The solution needs to ensure that both operations—resetting and shuffling—are efficient and that the shuffle is unbiased, meaning that each possible permutation of the list should have an equal probability of being chosen.

### Code Breakdown (Step by Step)

#### 1. Class Definition and Member Variables
```cpp
class Solution {
    vector<int> arr;
public:
    Solution(vector<int>& nums) {
        arr = nums;
    }
```
- The class `Solution` contains a private member variable `arr` that stores the original list of integers.
- The constructor accepts a vector `nums` representing the list of integers and initializes the `arr` with this list. This ensures that the list is stored in the class and can be accessed later for the `reset()` operation.

#### 2. Reset Operation
```cpp
    vector<int> reset() {
        return arr;
    }
```
- The `reset()` function simply returns the original list of integers stored in `arr`. This function does not modify the list or perform any computations. It provides the original configuration of the list as it was when the object was created.

#### 3. Shuffle Operation
```cpp
    vector<int> shuffle() {
        vector<int> stk(arr);
        int n = stk.size();
        for(int i = 0; i < n; i++) {
            int j = rand() % (n - i);
            swap(stk[i + j], stk[i]);
        }
        return stk;
    }
```
- The `shuffle()` function generates a random shuffle of the list.
- First, it creates a copy of the original list `arr` in a new vector `stk` so that the original list remains unchanged.
- The size of the list is stored in the variable `n`.
- Then, the function performs the Fisher-Yates shuffle:
  - For each index `i` in the list, it generates a random index `j` from the remaining unshuffled part of the list (`rand() % (n - i)`).
  - It swaps the element at position `i + j` with the element at position `i`.
  - This process ensures that each element is equally likely to be placed in any position of the shuffled list.
- Finally, the function returns the shuffled list `stk`.

#### 4. Usage Example
```cpp
/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(nums);
 * vector<int> param_1 = obj->reset();
 * vector<int> param_2 = obj->shuffle();
 */
```
- After creating an instance of `Solution` with a list of integers (`nums`), you can call the `reset()` method to obtain the original list and the `shuffle()` method to obtain a randomly shuffled version of the list.

### Complexity Analysis

#### Time Complexity:
- **Constructor (`Solution(vector<int>& nums)`):** 
  - The constructor simply initializes the `arr` variable with the `nums` vector, which takes **O(n)** time, where `n` is the length of the input list.
  
- **Reset Operation (`reset()`):**
  - The `reset()` operation simply returns the stored list `arr`, so it takes **O(1)** time.
  
- **Shuffle Operation (`shuffle()`):**
  - In the shuffle operation, we first copy the list to a new vector (`stk`), which takes **O(n)** time.
  - The loop performs **n** iterations, and in each iteration, a constant-time operation (`swap()`) is executed. Thus, the shuffle operation has a time complexity of **O(n)**.

Overall, the time complexity for the shuffle operation is **O(n)**, and the time complexity for the reset operation is **O(1)**.

#### Space Complexity:
- **Space Complexity:** The space complexity is **O(n)** due to the creation of the `stk` vector in the shuffle operation. This vector stores a copy of the original list, which requires space proportional to the length of the list. The `arr` vector also takes **O(n)** space, but since it's part of the object and not created in the shuffle method, we only count the space used by `stk` for the shuffle operation.

### Conclusion

The `Solution` class provides an efficient way to both reset and shuffle a list of integers. The `reset()` method allows us to return the original list at any time, and the `shuffle()` method uses the Fisher-Yates shuffle algorithm to return a random permutation of the list. 

- **Efficiency**: The time complexity of the shuffle operation is **O(n)**, and the reset operation is constant time (**O(1)**). The space complexity is **O(n)** due to the additional storage required for the shuffled list.
- **Fisher-Yates Shuffle**: The shuffle is implemented correctly using the Fisher-Yates algorithm, ensuring that each permutation of the list is equally likely.

This approach is both efficient and simple, making it a great solution to the problem.
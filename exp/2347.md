### Problem Statement

In this problem, we are given a hand of five playing cards, represented by two arrays: `ranks` and `suits`. Each element in `ranks` corresponds to the rank of a card (e.g., 2, 3, 4, ..., 10, J, Q, K, A), and each element in `suits` corresponds to the suit of the card (e.g., 'H' for hearts, 'D' for diamonds, 'C' for clubs, 'S' for spades). The task is to determine the best hand possible based on the rules of poker. The possible hands are:
- **"Flush"**: All five cards have the same suit.
- **"Three of a Kind"**: At least three cards have the same rank.
- **"Pair"**: At least two cards have the same rank.
- **"High Card"**: If none of the above hands are present, the hand is a "High Card".

### Approach

The solution works by evaluating the given hand of cards and checking for the highest-ranking poker hand it can form. The strategy is straightforward:
1. **Count the Frequency of Ranks**: We first count how many times each rank appears in the `ranks` array.
2. **Count the Frequency of Suits**: Similarly, we count how many times each suit appears in the `suits` array.
3. **Check for Flush**: If any suit appears exactly five times, the hand is a "Flush".
4. **Check for Three of a Kind**: If any rank appears at least three times, the hand is "Three of a Kind".
5. **Check for Pair**: If any rank appears exactly twice, the hand is a "Pair".
6. **Default to High Card**: If none of the above conditions are satisfied, the hand is a "High Card".

### Code Breakdown (Step by Step)

#### 1. **Initialize Maps to Track Ranks and Suits**
```cpp
unordered_map<int, int> m1;
unordered_map<char, int> m2;
```
- We use `unordered_map` to store the frequency of each rank and each suit. The map `m1` will store the count of each rank, and the map `m2` will store the count of each suit.

#### 2. **Populate Frequency Maps**
```cpp
for (auto i : ranks) m1[i]++;
for (auto i : suits) m2[i]++;
```
- We loop through the `ranks` array and update the frequency map `m1`. Each rank's count is incremented by one every time it appears in the hand.
- Similarly, we loop through the `suits` array and update the frequency map `m2`, incrementing the count of each suit.

#### 3. **Check for Flush**
```cpp
for (auto i : m2) {
    if (i.second == 5) {
        return "Flush";
    }
}
```
- The first condition we check is for a "Flush". A "Flush" occurs if all five cards have the same suit. We check the `m2` map to see if any suit appears exactly five times. If this condition is met, we immediately return "Flush".

#### 4. **Check for Three of a Kind**
```cpp
for (auto i : m1) {
    if (i.second >= 3) {
        return "Three of a Kind";
    }
```
- If no "Flush" is found, we then check for "Three of a Kind". This occurs if at least three cards have the same rank. We check the `m1` map for any rank that appears three or more times. If such a rank exists, we immediately return "Three of a Kind".

#### 5. **Check for Pair**
```cpp
else if (i.second == 2) {
    ans = "Pair";
}
```
- If neither a "Flush" nor "Three of a Kind" is found, we check for a "Pair". A "Pair" occurs if exactly two cards have the same rank. We look for any rank that appears exactly twice in the `m1` map. If such a rank is found, we update the variable `ans` to "Pair".

#### 6. **Return the Result**
```cpp
return ans == "" ? "High Card" : ans;
```
- If no "Flush", "Three of a Kind", or "Pair" is found, we return "High Card" by default. If a "Pair" was found during the previous check, we return "Pair".

### Complexity

#### Time Complexity:
- **O(n)**: We loop through the `ranks` and `suits` arrays once each, where `n` is the number of cards (which is fixed at 5). The time complexity is constant in this case, since we only have five cards.
  - **O(n) for ranks**: We iterate through the `ranks` array to count the occurrences of each rank.
  - **O(n) for suits**: We iterate through the `suits` array to count the occurrences of each suit.
  - Sorting the maps is not necessary because we don't need to check for specific ranks or suits in any particular order.

#### Space Complexity:
- **O(1)**: The space complexity is constant because we only store the counts of ranks (maximum 13 possible values for ranks) and suits (maximum 4 possible suits). Thus, we use a constant amount of extra space.

### Conclusion

This solution efficiently determines the best hand from a hand of cards by using frequency counting with hash maps (`unordered_map`). The approach is optimal for this problem since it handles small input sizes (a fixed number of 5 cards) in constant time. By checking for the highest-ranking poker hands (Flush, Three of a Kind, Pair, and High Card), the solution provides a clear and concise method for evaluating a poker hand. The space and time complexities are minimal, making this solution suitable for real-time applications where quick hand evaluations are needed.
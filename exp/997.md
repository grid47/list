### Problem Statement
In a town, there are `n` people, numbered from `1` to `n`. Some people may trust others. A person is considered a "judge" if:
1. The judge does not trust anyone.
2. Everyone trusts the judge.

You are given an array `trust`, where `trust[i] = [a, b]` indicates that person `a` trusts person `b`. The goal is to determine who the judge is. If no such person exists, return `-1`.

### Approach
1. **Degree Array**: Use an array `deg` to track the net trust level for each person:
   - Increment `deg[b]` for every trust relationship `[a, b]`, indicating that `b` is trusted.
   - Decrement `deg[a]` for every trust relationship `[a, b]`, indicating that `a` trusts someone (and thus cannot be the judge).

2. **Check for Judge**:
   - After processing all trust relationships, iterate through the `deg` array.
   - A person `i` is identified as the judge if `deg[i]` equals `n - 1`, meaning everyone else trusts `i`, and `i` trusts no one.

### Code Walk-through
- Initialize a vector `deg` of size `n + 1` to keep track of trust levels.
- Iterate through the `trust` relationships to update the `deg` values.
- Finally, check which person has a trust level of `n - 1` and return that person's index. If no such person exists, return `-1`.

### Complexity
- **Time Complexity**: O(t + n), where `t` is the number of trust relationships and `n` is the number of people. The solution processes all trust relationships and checks each person.
- **Space Complexity**: O(n) for the `deg` array to store the net trust levels.

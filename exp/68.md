### Problem Statement

The problem is to justify text such that each line has exactly `maxWidth` characters, with words evenly distributed across the line. Text justification typically involves adjusting spaces between words in a way that each line is exactly `maxWidth` characters long. The solution needs to handle three cases:
1. Evenly distributing spaces across words.
2. Adding spaces to fill lines.
3. Properly handling the last line, which should be left-justified with no extra space between words.

### Approach

To solve this, we break the input words into multiple lines and justify each line independently. Here’s a breakdown of the approach:

1. **Creating Lines of Text**: 
   We iterate through the list of words and add each word to the current line until adding another word would exceed `maxWidth`. If the line becomes too long, we store the words for that line in `res`, justified as required. We then reset and start collecting words for the next line.

2. **Handling Space Distribution**:
   For each line, spaces are distributed between words based on the following cases:
   - **Middle Lines**: These lines are justified such that each space between words is as even as possible, with any extra spaces added to the leftmost gaps.
   - **Last Line**: The final line is left-justified, with each word separated by a single space, and any remaining space is added at the end of the line.

3. **Constructing Each Line**:
   We use a helper function, `connect`, to construct each justified line by:
   - Appending words and spaces to the line according to the spacing rules for middle or last lines.
   - Adding additional spaces at the end of the line if it’s shorter than `maxWidth`.

4. **Adding Spaces Appropriately**:
   The `addSpaces` helper function calculates the number of spaces to insert between words. For middle lines, it determines the number of spaces based on the remaining space (`maxWidth - len`). For the last line, each word is separated by a single space, and any extra space is added to the end.

### Code Breakdown (Step by Step)

#### Step 1: Define the Main Function

```cpp
vector<string> fullJustify(vector<string>& words, int maxWidth) {
    vector<string> res;
    const int n = words.size();
    int begin = 0, len = 0;
```

- Here, `res` is the result vector that will hold all the justified lines.
- We define `n` as the number of words and initialize `begin` to track the starting index of each line and `len` to accumulate the length of words in the current line.

#### Step 2: Break Text into Lines

```cpp
for (int i = 0; i < n; ++i) {
    if (len + words[i].size() + (i - begin) > maxWidth) {
        res.emplace_back(connect(words, maxWidth, begin, i, len, false));
        begin = i;
        len = 0;
    }
    len += words[i].size();
}
res.emplace_back(connect(words, maxWidth, begin, n, len, true));
return res;
```

- The loop goes through each word. If adding the next word exceeds `maxWidth`, it calls `connect` to create a justified line for the current words and stores it in `res`.
- `begin` and `len` are reset to start processing the next line.
- After the loop, we handle the last line by calling `connect` with `is_last = true`.

#### Step 3: Create Justified Lines with `connect`

```cpp
string connect(const vector<string>& words, int maxWidth, int begin, int end, int len, bool is_last) {
    string s;
    int n = end - begin;
    for (int i = 0; i < n; ++i) {
        s += words[begin + i];
        addSpaces(i, n - 1, maxWidth - len, is_last, &s);
    }
    if (s.size() < maxWidth) {
        s.append(maxWidth - s.size(), ' ');
    }
    return s;
}
```

- `connect` constructs each justified line.
- It iterates through the words from `begin` to `end`. After adding each word, it calls `addSpaces` to add the necessary spaces.
- Finally, if the line’s length is still less than `maxWidth`, it pads the line with extra spaces at the end to meet the required width.

#### Step 4: Add Spaces with `addSpaces`

```cpp
void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {
    if (i < spaceCnt) {
        int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);
        s->append(spaces, ' ');
    }
}
```

- `addSpaces` decides the number of spaces to add after each word.
- For the last line, it only adds a single space between words.
- For middle lines, it calculates spaces as `maxWidth / spaceCnt` (equal distribution) plus one extra space for the leftmost gaps when there’s a remainder.

### Complexity

#### Time Complexity
The algorithm processes each word once and performs constant-time operations on each word, resulting in an overall time complexity of `O(n)`, where `n` is the number of words.

#### Space Complexity
The space complexity is also `O(n)`, primarily due to the storage of the output result in `res` and the use of helper strings during line construction.

### Conclusion

This solution efficiently justifies text by managing words and spaces in lines based on simple spacing rules, ensuring that all lines meet the `maxWidth` requirements. Each line is constructed with balanced spaces or left-justified for the last line, making it optimal and suitable for large text inputs that need precise formatting for display purposes.

### üìÑ **Text Justification**

The task is to justify text such that each line has exactly `maxWidth` characters, with words evenly distributed across the line. Text justification involves adjusting spaces between words so that each line is exactly `maxWidth` characters long. The solution needs to handle the following cases:
1. Evenly distributing spaces across words.
2. Adding spaces to fill lines.
3. Properly handling the last line, which should be left-justified with no extra space between words.

### üß† **Approach**

To solve this problem, we break the input words into multiple lines and justify each line independently. Here's a step-by-step breakdown of the approach:

#### 1. **Creating Lines of Text**

We iterate through the list of words and add each word to the current line until adding another word would exceed `maxWidth`. When the line becomes too long, we store the words for that line in `res`, justified as required. We then reset and start collecting words for the next line.

#### 2. **Handling Space Distribution**

For each line, spaces are distributed between words based on the following cases:
- **Middle Lines**: These lines are justified so that each space between words is as even as possible. Any extra spaces are added to the leftmost gaps.
- **Last Line**: The final line is left-justified, with each word separated by a single space, and any remaining space is added to the end of the line.

#### 3. **Constructing Each Line**

A helper function, `connect`, is used to construct each justified line by:
- Appending words and spaces to the line according to the spacing rules for middle or last lines.
- Adding additional spaces at the end of the line if it‚Äôs shorter than `maxWidth`.

#### 4. **Adding Spaces Appropriately**

The `addSpaces` helper function calculates the number of spaces to insert between words. For middle lines, it determines the number of spaces based on the remaining space (`maxWidth - len`). For the last line, each word is separated by a single space, and any extra space is added to the end.

### üîç **Code Breakdown (Step by Step)**

#### Step 1: Define the Main Function

```cpp
vector<string> fullJustify(vector<string>& words, int maxWidth) {
    vector<string> res;
    const int n = words.size();
    int begin = 0, len = 0;
```
- `res` stores the result, which will contain all the justified lines.
- `n` represents the number of words in the input.
- `begin` keeps track of the starting index of each line, and `len` accumulates the length of words in the current line.

#### Step 2: Break Text into Lines

```cpp
for (int i = 0; i < n; ++i) {
    if (len + words[i].size() + (i - begin) > maxWidth) {
        res.emplace_back(connect(words, maxWidth, begin, i, len, false));
        begin = i;
        len = 0;
    }
    len += words[i].size();
}
res.emplace_back(connect(words, maxWidth, begin, n, len, true));
return res;
```
- We iterate over each word. If adding the next word exceeds `maxWidth`, we use `connect` to create the justified line for the current words and add it to `res`.
- After processing each line, we reset `begin` and `len` for the next line.
- After the loop, we handle the last line by calling `connect` with `is_last = true`.

#### Step 3: Create Justified Lines with `connect`

```cpp
string connect(const vector<string>& words, int maxWidth, int begin, int end, int len, bool is_last) {
    string s;
    int n = end - begin;
    for (int i = 0; i < n; ++i) {
        s += words[begin + i];
        addSpaces(i, n - 1, maxWidth - len, is_last, &s);
    }
    if (s.size() < maxWidth) {
        s.append(maxWidth - s.size(), ' ');
    }
    return s;
}
```
- The `connect` function constructs each justified line.
- It adds words from `begin` to `end` to the line and calls `addSpaces` to handle the spacing.
- If the line‚Äôs length is less than `maxWidth`, it appends spaces to the end to reach the desired width.

#### Step 4: Add Spaces with `addSpaces`

```cpp
void addSpaces(int i, int spaceCnt, int maxWidth, bool is_last, string *s) {
    if (i < spaceCnt) {
        int spaces = is_last ? 1 : maxWidth / spaceCnt + (i < maxWidth % spaceCnt);
        s->append(spaces, ' ');
    }
}
```
- The `addSpaces` function calculates how many spaces to add after each word.
- For the last line, it adds only a single space between words.
- For middle lines, it distributes spaces as evenly as possible and adds extra spaces to the leftmost gaps when necessary.

### üìä **Complexity Analysis**

#### Time Complexity:
- **O(n)**: The algorithm processes each word once and performs constant-time operations on each word, where `n` is the number of words.

#### Space Complexity:
- **O(n)**: The space complexity is dominated by the space used for the result (`res`), which stores the justified lines, and the helper strings used during line construction.

### üåü **Conclusion**

This solution efficiently justifies text by managing words and spaces in lines based on simple spacing rules. It ensures that all lines meet the `maxWidth` requirement, with proper handling of both middle and last lines. This approach is optimal and works well for large text inputs that need precise formatting, making it suitable for display purposes where text alignment is important.

---
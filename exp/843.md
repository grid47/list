### Problem Statement

In this problem, we are tasked with finding the "secret word" by interacting with a `Master` API, which provides feedback on how many characters of our guessed word match the secret word at the exact same positions. The goal is to guess the secret word from a list of candidate words while minimizing the number of guesses required. Each guess yields feedback in the form of the number of characters that match, and the process continues until the secret word is found.

The challenge is to make the guesses intelligently, leveraging the feedback from previous guesses to eliminate candidates efficiently. We need to come up with an algorithm that minimizes the number of guesses while ensuring correctness.

### Approach

To solve this problem, the solution uses a strategy based on eliminating words from the list of possible candidates by using the feedback received after each guess. Hereâ€™s a high-level breakdown of the approach:

1. **Overlapping Word Calculation**: First, we identify a word from the list of candidate words that has the highest "overlap" with other words in the list. This means choosing the word that most frequently matches other words in terms of character positions.

2. **Feedback-Driven Elimination**: After making a guess, we receive feedback about how many characters match. We then eliminate words from the list that do not match the feedback of the guess. This helps us narrow down the set of potential candidates.

3. **Efficient Search**: The key to an efficient solution is using the feedback from each guess to quickly reduce the size of the search space. By choosing the word with the highest overlap, we increase the likelihood that the feedback will help eliminate a significant portion of the candidate words.

4. **Termination Condition**: The guessing process continues until we find the secret word, which occurs when the number of character matches equals the length of the word (6, in this case).

### Code Breakdown (Step by Step)

The provided code implements the solution in the following way:

1. **`overlap` Function**:
   This function helps in identifying which word from the list has the highest overlap with others based on the frequency of characters in each position. The function creates a frequency table `prob` where `prob[j][k]` keeps track of how many times character `k` appears at position `j` in the list of words.
   
   ```cpp
   vector<vector<int>> prob(6, vector<int>(26, 0));  // 6 positions, 26 letters
   for(int i = 0; i < words.size(); i++)
       for(int j = 0; j < 6; j++)
           prob[j][words[i][j] - 'a']++;  // Increment the frequency count for each character at each position
   ```

   The function then iterates through each word in the list, calculating a "score" for each word based on how often its characters appear at each position. The word with the highest score is chosen as the next guess.

   ```cpp
   long long cur = 0;
   for(int j = 0; j < 6; j++)
       cur += prob[j][words[i][j] - 'a'];  // Calculate the overlap score for the current word
   ```

2. **`tally` Function**:
   This function compares two words and counts how many characters match at the same positions. It is used to compare the guess with each word in the list after receiving feedback from the `Master`.

   ```cpp
   int res = 0;
   for(int i = 0; i < 6; i++)
       res += (a[i] == b[i]);  // Increment res if the characters at position i match
   ```

3. **`findSecretWord` Function**:
   This is the main function that repeatedly guesses words from the list of candidates and narrows down the possibilities based on the feedback from the `Master`. The process continues until the secret word is found (when the number of matching characters equals 6).

   - **Guess Selection**: In each iteration, we select a word to guess using the `overlap` function.
   - **Feedback Handling**: The guess is made by calling `master.guess()`, and the feedback (i.e., the number of matching characters) is stored in `match`.
   - **Candidate Elimination**: We create a new list of candidate words that match the feedback from the guess using the `tally` function. Only words that match the feedback are kept in the list for the next guess.

   ```cpp
   int match = 0;
   while(match != 6) {
       int i = overlap(words);  // Choose the word with the highest overlap
       match = master.guess(words[i]);  // Make the guess and get the feedback
       vector<string> tmp;
       for(auto it : words) {
           if(match == tally(it, words[i])) {  // Eliminate words that do not match the feedback
               tmp.push_back(it);
           }
       }
       words = tmp;  // Update the candidate list for the next guess
   }
   ```

### Complexity

The time and space complexity of this solution can be analyzed as follows:

- **Time Complexity**:
   - The `overlap` function processes each word in the list and calculates the overlap score in `O(n * 6)` time, where `n` is the number of words and 6 is the fixed word length. Thus, the time complexity of `overlap` is O(n).
   - In each iteration of the `while` loop in `findSecretWord`, we guess a word and update the list of candidates. The list of candidates decreases over time because we eliminate words that do not match the feedback.
   - Each iteration requires `O(n)` time to filter the words based on feedback.
   - In the worst case, the size of the list of candidate words reduces by a constant fraction with each guess, and since there are 6 positions in the word, the algorithm will take at most `O(6 * n)` time in total. This gives an overall time complexity of `O(n)`.

- **Space Complexity**:
   - The space complexity is determined by the storage of the list of words (`words`), the frequency table `prob`, and temporary arrays used in filtering candidates. The space complexity is `O(n)`.

### Conclusion

This solution provides an efficient way to guess the secret word by leveraging the feedback from the `Master` API and narrowing down the list of candidates intelligently. By using a frequency-based approach to determine the word with the highest overlap, we can minimize the number of guesses required to find the secret word. The time complexity is linear with respect to the number of words, making this solution scalable for large input sizes.
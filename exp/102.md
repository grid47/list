
### ðŸŒ³ **Level Order Traversal of Binary Tree**

The problem asks us to return the **level order traversal** of a binary tree. In level order traversal, nodes are visited level by level from left to right. The result should be a list of lists, where each inner list contains the values of the nodes at a specific level of the tree.

---

### ðŸ”‘ **Approach:**

To solve this problem, we will utilize a **Breadth-First Search (BFS)** algorithm, which is ideal for level-order traversal of trees. This can be efficiently implemented using a **queue**, which processes nodes level by level:
1. Start with the root node in the queue.
2. Process all nodes at the current level, dequeueing them from the queue and adding their values to the result.
3. For each node, enqueue its left and right children (if they exist).
4. Repeat the process until all nodes have been processed, ensuring the nodes are visited in the correct order.

---

### ðŸ’» **Code Breakdown (Step by Step):**

#### **1. Function Definition**

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
```

- The function `levelOrder` is part of the `Solution` class. It takes a pointer to the root of the binary tree as input and returns a vector of vectors of integers, where each inner vector represents the values of nodes at each level of the tree.

#### **2. Initializing the Result Container**

```cpp
        vector<vector<int>> ans;
        if(!root) return ans;
```

- `ans` is a vector of vectors that will store the result of the level-order traversal.
- The condition checks if the root is `NULL`. If the root is `NULL`, it means the tree is empty, and we return an empty result immediately.

#### **3. Initializing the Queue**

```cpp
        queue<TreeNode*> q;
        q.push(root);
```

- A queue `q` is used to manage the nodes during the level-order traversal.
- The root node is pushed into the queue to begin the traversal.

#### **4. Processing the Tree Level by Level**

```cpp
        while(!q.empty()) {
            int sz = q.size();
            vector<int> res;
```

- The `while` loop continues as long as there are nodes in the queue, meaning there are still levels to process.
- `sz` stores the number of nodes at the current level (i.e., the size of the queue).
- `res` is a temporary vector that will hold the values of nodes at the current level.

#### **5. Processing Each Node at the Current Level**

```cpp
            while(sz--) {
                TreeNode* tmp = q.front();
                res.push_back(tmp->val);
                q.pop();
```

- The inner `while` loop iterates over all nodes at the current level. The loop runs `sz` times, corresponding to the number of nodes at the current level.
- For each node, we dequeue it from the front of the queue, add its value to the `res` vector, and check its left and right children.

#### **6. Enqueueing the Children of the Current Node**

```cpp
                if(tmp->left) q.push(tmp->left);
                if(tmp->right) q.push(tmp->right);
            }
```

- After processing the current node, we enqueue its left and right children (if they exist) to be processed in the next iteration of the outer loop.
- This ensures that the nodes are processed level by level, starting from the root.

#### **7. Adding the Current Levelâ€™s Result to the Final Answer**

```cpp
            ans.push_back(res);
```

- After processing all nodes at the current level, the `res` vector, which contains the values of nodes at that level, is added to the `ans` vector.

#### **8. Returning the Final Result**

```cpp
        return ans;
    }
};
```

- Once all levels have been processed and the queue is empty, we return the `ans` vector containing the level-order traversal of the tree.

---

### ðŸ§  **Time and Space Complexity:**

#### **Time Complexity:**

The time complexity of this solution is **O(n)**, where `n` is the number of nodes in the binary tree. Each node is processed exactly once, and each operation (enqueuing and dequeuing a node) takes constant time. Therefore, the overall time complexity is linear in the number of nodes.

#### **Space Complexity:**

The space complexity is **O(n)**, where `n` is the number of nodes in the tree. In the worst case, the queue will store all the nodes at the last level, which could be half of the nodes in a perfectly balanced binary tree. Additionally, the result vector `ans` stores all the node values, which requires `O(n)` space.

---

### ðŸŽ¯ **Conclusion:**

This solution efficiently solves the problem of level-order traversal by utilizing the **Breadth-First Search (BFS)** algorithm. It uses a queue to process the nodes level by level, ensuring that the nodes are visited in the correct order. The time complexity is **O(n)**, and the space complexity is **O(n)**, making this solution both time and space efficient. By storing the node values at each level, the solution provides the desired output: a list of lists where each inner list represents the values of nodes at a specific level of the tree.

---

**Happy coding!** ðŸŒ±âœ¨
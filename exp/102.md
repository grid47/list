### Problem Statement

The problem asks us to return the **level order traversal** of a binary tree. In level order traversal, nodes are visited level by level from left to right. For example:
- Given a binary tree, the output should be a list of lists, where each inner list contains the values of the nodes at each level of the tree.

### Approach

To solve this problem, we will utilize a **Breadth-First Search (BFS)** algorithm, which is well-suited for level-order traversal of trees. This can be done using a **queue** where we process nodes level by level:
1. Start with the root node in the queue.
2. Process all nodes at the current level, dequeueing them from the queue and adding their values to the result.
3. For each node, enqueue its left and right children (if they exist).
4. Repeat the process until all nodes have been processed, which will ensure that nodes are visited in the correct order.

### Code Breakdown (Step by Step)

#### 1. Function Definition

```cpp
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
```
- The function `levelOrder` is defined in the `Solution` class. It takes a pointer to the root of the binary tree as input and returns a vector of vectors of integers, where each inner vector represents a level of the tree.

#### 2. Initializing the Result Container

```cpp
        vector<vector<int>> ans;
        if(!root) return ans;
```
- `ans` is a vector of vectors that will store the result of the level-order traversal.
- The first condition checks if the root is `NULL`. If the root is `NULL`, this means the tree is empty, and we immediately return an empty result.

#### 3. Initializing the Queue

```cpp
        queue<TreeNode*> q;
        q.push(root);
```
- A queue `q` is used to help with the level-order traversal.
- The root node is initially pushed into the queue to start the traversal.

#### 4. Processing the Tree Level by Level

```cpp
        while(!q.empty()) {
            int sz = q.size();
            vector<int> res;
```
- The `while` loop runs as long as there are nodes left in the queue. This indicates that there are more levels to process.
- `sz` stores the number of nodes at the current level (i.e., the size of the queue).
- `res` is a temporary vector that will hold the values of nodes at the current level.

#### 5. Processing Each Node at the Current Level

```cpp
            while(sz--) {
                TreeNode* tmp = q.front();
                res.push_back(tmp->val);
                q.pop();
```
- The inner `while` loop iterates over all nodes at the current level. The loop runs `sz` times, which is the number of nodes at the current level.
- For each node, we dequeue it from the front of the queue, add its value to the `res` vector, and then check its left and right children.

#### 6. Enqueueing the Children of the Current Node

```cpp
                if(tmp->left) q.push(tmp->left);
                if(tmp->right) q.push(tmp->right);
            }
```
- After processing the current node, we enqueue its left and right children (if they exist) to be processed in the next iteration of the outer loop.
- This ensures that the nodes are processed level by level, starting from the root.

#### 7. Adding the Current Levelâ€™s Result to the Final Answer

```cpp
            ans.push_back(res);
```
- After processing all nodes at the current level, the `res` vector, which contains the values of the nodes at that level, is added to the `ans` vector.

#### 8. Returning the Final Result

```cpp
        return ans;
    }
};
```
- Once all levels have been processed and the queue is empty, we return the `ans` vector containing the level-order traversal of the tree.

### Complexity

#### Time Complexity:

The time complexity of this solution is **O(n)**, where `n` is the number of nodes in the binary tree. Each node is processed exactly once, and each operation (enqueuing and dequeuing a node) takes constant time. Therefore, the overall time complexity is linear in the number of nodes in the tree.

#### Space Complexity:

The space complexity is **O(n)**, where `n` is the number of nodes in the tree. In the worst case, the queue will store all the nodes at the last level, which could be half of the nodes in a perfectly balanced binary tree. Additionally, the result vector `ans` stores all the node values, which requires `O(n)` space.

### Conclusion

This solution efficiently solves the problem of level-order traversal by utilizing the **Breadth-First Search (BFS)** algorithm. It uses a queue to process the nodes level by level, ensuring that the nodes are visited in the correct order. The time complexity is **O(n)**, and the space complexity is **O(n)**, making this solution both time and space efficient. By storing the node values at each level, the solution provides the desired output: a list of lists where each inner list represents the values of nodes at a specific level of the tree.
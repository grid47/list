### 📝 **Scrambled String Problem**

Given two strings, `s1` and `s2`, the task is to determine if `s2` is a scrambled version of `s1`. A scrambled string is formed by recursively swapping non-empty substrings of the original string.

### 🔍 **Approach**

We can solve this problem using **Dynamic Programming (DP)** with **memoization**. This ensures that we avoid recomputing results for the same pair of strings multiple times, making the solution more efficient.

### 🧑‍💻 **Step-by-Step Code Breakdown**

#### Step 1: Base Case Check

```cpp
if (s1 == s2)
    return true;
```

If the two strings are identical, we immediately return `true`, as they are trivially scrambled versions of each other.

#### Step 2: Memoization Check

```cpp
if (m.count(make_pair(s1, s2))) {
    return m[make_pair(s1, s2)];
}
```

We check if the result for the pair `(s1, s2)` has already been computed. If it has, we return the stored result to avoid redundant computations.

#### Step 3: Character Frequency Check

```cpp
int len = s1.length();
int count[26] = {0};
for (int i = 0; i < len; i++) {
    count[s1[i] - 'a']++;
    count[s2[i] - 'a']--;
}
for (int i = 0; i < 26; i++) {
    if (count[i] != 0)
        return false;
}
```

We perform a frequency check of characters in both strings. If the two strings do not have identical character frequencies, they cannot be scrambled versions of each other. In that case, we return `false`.

#### Step 4: Recursive Substring Checking

```cpp
for (int i = 1; i <= len - 1; i++) {
    if (isScramble(s1.substr(0, i), s2.substr(0, i)) && isScramble(s1.substr(i), s2.substr(i)))
        return true;
    if (isScramble(s1.substr(0, i), s2.substr(len - i)) && isScramble(s1.substr(i), s2.substr(0, len - i)))
        return true;
}
```

We then recursively check all possible ways to split the strings into two parts:
1. **Normal Split:** The first `i` characters of `s1` match the first `i` characters of `s2`, and the remaining characters of `s1` match the remaining characters of `s2`.
2. **Cross Split:** The first `i` characters of `s1` match the last `i` characters of `s2`, and the remaining characters of `s1` match the first `len-i` characters of `s2`.

If either of these conditions holds, we recursively call `isScramble` on the corresponding substrings. If both recursive checks return `true`, then we return `true`.

#### Step 5: Storing the Result

```cpp
m[make_pair(s1, s2)] = false;
return false;
```

If neither of the recursive checks returns `true`, we store the result `false` for the pair `(s1, s2)` in the memoization map and return `false`.

### 🔢 **Time and Space Complexity**

#### Time Complexity:

The time complexity of this solution is **O(n^4)** in the worst case. Here's why:
- **Recursive calls:** At each level of recursion, we perform two recursive checks (for normal and cross splits). The recursion depth can be as large as `O(n)`.
- **Substring operations:** In each recursive call, we perform `substr` operations, which take **O(n)** time in the worst case. This adds an additional **O(n)** work per recursion level.

Thus, the total time complexity is approximately **O(n^4)**.

#### Space Complexity:

The space complexity is **O(n^2)** due to the following:
- **Memoization:** We store results for every possible pair of substrings, which can be at most **O(n^2)** pairs.
- **Recursion Stack:** The maximum depth of the recursion can be **O(n)**.

Thus, the overall space complexity is **O(n^2)**.

### 🎯 **Conclusion**

This solution efficiently determines if two strings are scrambled versions of each other using recursion and memoization. By avoiding redundant computations with memoization, the algorithm is optimized for larger inputs, though its worst-case time complexity is **O(n^4)**.

**Key Takeaways:**
- The problem is solved using recursion and memoization.
- A frequency check is essential to rule out impossible cases early on.
- The solution explores all possible splits of the strings, ensuring correctness.
- The time complexity of **O(n^4)** is acceptable for relatively smaller inputs, but could be a limitation for very large strings.

---

#### 🌟 **Final Thoughts**: Keep practicing, and you'll master these dynamic programming problems!
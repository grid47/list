### Problem Statement

The problem requires implementing an **RLEIterator** class that simulates a run-length encoded (RLE) iterator. The class should be initialized with an array representing the run-length encoding of some sequence. The `next(n)` method should return the next value in the sequence after consuming `n` elements, based on the encoding provided.

**Run-Length Encoding (RLE)** is a compression technique that represents consecutive repeated elements as a single value and its count. For example, the sequence `[1, 1, 2, 2, 2, 3]` can be encoded as `[2, 1, 3, 2, 1, 3]` meaning "two 1's, three 2's, and one 3."

In this problem, the iterator should retrieve the value corresponding to the next `n` elements by simulating the consumption of encoded sequences. If there are not enough elements left, the method should return `-1` to indicate the end of the sequence.

### Approach

1. **Understanding RLE**: The encoding format consists of pairs `[count, value]`, where:
   - `count` is the number of occurrences of `value`.
   - The sequence is represented as a list of such pairs: `[count_1, value_1, count_2, value_2, ..., count_k, value_k]`.

   For example, encoding `[2, 1, 3, 2, 1, 3]` represents the sequence: `1, 1, 2, 2, 2, 3`.

2. **Problem Requirements**: The task requires:
   - `RLEIterator` class to be initialized with the encoded sequence.
   - `next(n)` method to return the value corresponding to the `n`-th element of the sequence, consuming the elements as you go.
   - If there are fewer elements left than required, return `-1`.

3. **Design**:
   - We will maintain an index (`idx`) to track our position in the encoded array.
   - The `next(n)` method will process each pair `[count, value]` in the encoding, decrementing the count and moving to the next pair when necessary.

### Code Breakdown (Step by Step)

#### **Class Constructor**
```cpp
RLEIterator(vector<int>& encoding) {
    arr = encoding;
    idx = 0;
}
```
- **Initialization**: The constructor takes a reference to a vector of integers (`encoding`) that represents the RLE-encoded sequence. It initializes the member variable `arr` with this encoding and sets the index (`idx`) to 0, indicating the current position in the sequence.

#### **Next Method**
```cpp
int next(int n) {
    while(idx < arr.size()) {
        if(n > arr[idx]) {
            n -= arr[idx];
            idx += 2;
        } else {
            arr[idx] -= n;
            return arr[idx + 1];
        }
    }
    return -1;
}
```
- **Iterate Over Encoded Pairs**: The `next(n)` method is designed to retrieve the next `n` elements from the sequence based on the run-length encoding.
  
  1. **While Loop**:
     - The loop continues until all elements in the encoding array have been processed (`idx < arr.size()`).

  2. **Check If `n` Is Greater Than Current Run Length**:
     - If the required number of elements `n` is greater than the current count (`arr[idx]`), it means we need to skip over this entire run.
     - We subtract the current run length from `n`, and then move the index forward by 2 (as each pair consists of a `count` and a `value`).
     
     ```cpp
     if(n > arr[idx]) {
         n -= arr[idx];
         idx += 2;
     }
     ```

  3. **Consume Elements**:
     - If `n` is less than or equal to the current count, we decrement the `count` by `n`, and return the `value` of the current pair (`arr[idx + 1]`).
     
     ```cpp
     else {
         arr[idx] -= n;
         return arr[idx + 1];
     }
     ```

  4. **Return -1 If Out of Bounds**:
     - If the loop exits because there are no more elements to process (i.e., `idx` exceeds `arr.size()`), it means there are not enough elements left, and we return `-1`.
     
     ```cpp
     return -1;
     ```

#### **Example Usage**

```cpp
RLEIterator* obj = new RLEIterator(encoding);
int param_1 = obj->next(n);
```
- The object `obj` is created by passing the encoded array `encoding` to the constructor.
- The `next(n)` function is called with an integer `n`, which will return the value at the `n`-th position in the sequence based on the RLE encoding.

### Complexity

#### **Time Complexity**

- The time complexity of the `next(n)` function is **O(n)** in the worst case, where `n` represents the number of calls or the number of elements that need to be consumed from the sequence. In the worst case, we may need to traverse through multiple pairs in the encoding list to retrieve the required number of elements.

- Each call to `next(n)` only processes a part of the sequence, and the iterator progresses in constant steps, moving through the encoded sequence in a linear manner. Thus, the overall time complexity is dependent on how many elements are remaining to be processed.

#### **Space Complexity**

- The space complexity of the algorithm is **O(m)**, where `m` is the size of the encoding array, because the space used is directly proportional to the length of the input encoding.
  
- There are no additional data structures that grow with the input size. The class only maintains the index (`idx`) and the encoding array (`arr`), both of which are proportional to the input size.

### Conclusion

This solution efficiently implements an **RLEIterator** that simulates iterating over a run-length encoded sequence. The `next(n)` method dynamically processes each run of the sequence by reducing the count of remaining elements and returns the corresponding value when necessary.

The code is optimized for linear time traversal of the encoded sequence, making it suitable for handling large datasets. The complexity is proportional to the size of the input encoding, with each call to `next(n)` efficiently processing the sequence in a straightforward manner.

This approach offers a clean and effective way to work with run-length encoded sequences, providing constant-time operations for each retrieval when necessary, while minimizing unnecessary recomputations.
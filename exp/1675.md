### Problem Statement

The problem is to find the minimum deviation of an array of integers. The deviation of an array is defined as the difference between the maximum and minimum elements of the array. We can perform the following operations to modify the array:

1. If the number is even, we can divide it by 2.
2. If the number is odd, we can multiply it by 2.

Given these operations, the goal is to minimize the deviation. 

### Approach

The approach to solving this problem involves the following steps:

1. **Normalization**: Convert all odd numbers to even by multiplying them by 2, since all operations on the numbers must eventually yield even numbers to allow for efficient reductions (divisions).
  
2. **Max-Heap**: Use a max-heap (priority queue) to continuously extract the maximum element of the array. The max-heap allows efficient retrieval and removal of the largest number.

3. **Minimum Tracking**: Keep track of the minimum value in the current array. Initially, this will be the smallest even number from the original or transformed numbers.

4. **Iterative Reduction**: While the maximum element in the heap is even, repeatedly reduce it by dividing by 2 and update the minimum value. After each reduction, check the current deviation (maximum - minimum) and update the minimum deviation found.

5. **Final Check**: After exiting the loop, check the deviation one last time with the maximum element in the heap to ensure no smaller deviation is missed.

### Code Breakdown (Step by Step)

Hereâ€™s the implementation of the approach in C++:

```cpp
class Solution {
public:
    int minimumDeviation(vector<int>& nums) {
```
- **Class Definition**: We define a class `Solution` and a public method `minimumDeviation`, which takes a vector of integers `nums`.

```cpp
        int n = nums.size(), mn = -1;
        priority_queue<int> pq;
```
- **Initialization**: We store the size of the input array `n` and initialize `mn` to -1 (to track the minimum value). A max-heap `pq` is also initialized to store the modified values.

```cpp
        for(int i = 0; i < n; i++) {
            int tmp = nums[i] % 2 ? nums[i] * 2 : nums[i];
            if(mn == -1 || mn > tmp)
                mn = tmp;
            pq.push(tmp);
        }
```
- **Normalization and Heap Construction**: For each number in the input array:
  - If the number is odd (i.e., `nums[i] % 2` is true), we multiply it by 2 to convert it to an even number.
  - We update the minimum value `mn` if it is the first number or if the current transformed number is less than the current minimum.
  - Each transformed number is pushed into the max-heap `pq`.

```cpp
        int ans = INT_MAX;
```
- **Setting Up Result**: Initialize `ans` to the maximum integer value, which will eventually store the minimum deviation found.

```cpp
        while((pq.top() % 2) == 0) {
            ans = min(ans, pq.top() - mn);
```
- **Main Loop**: We enter a loop that continues as long as the top of the heap (maximum element) is even:
  - Calculate the current deviation using the maximum element from the heap and the minimum value tracked so far. Update `ans` with the minimum of the current deviation and the previous `ans`.

```cpp
            int tmp = pq.top() / 2;
            mn = min(mn, tmp);
            pq.pop();
            pq.push(tmp);
        }
```
- **Reduction and Updating**:
  - Divide the maximum element by 2 (the only operation possible when it is even).
  - Update the minimum value `mn` to be the minimum of the current minimum and the new value obtained from dividing the maximum.
  - Remove the old maximum from the heap and insert the new value back into the heap.

```cpp
        return min(ans, pq.top() - mn);
    }
};
```
- **Final Result**: After exiting the loop, we perform a final check to see if the current top of the heap provides a smaller deviation compared to `ans`. Finally, return the minimum deviation found.

### Complexity

- **Time Complexity**: The time complexity is \( O(n \log n) \) due to the operations involved in building the heap and performing heap operations (insertion and extraction). The loop iterates at most \( O(\log n) \) times for each element.

- **Space Complexity**: The space complexity is \( O(n) \) due to the storage used for the heap that contains the transformed values of the original array.

### Conclusion

The algorithm efficiently calculates the minimum deviation of an array by leveraging the properties of a max-heap and the transformations allowed by the problem statement. By continuously extracting the largest element and reducing it, while keeping track of the minimum, we can ensure that we explore all possible configurations of the array effectively.

The key strengths of this solution include:

1. **Efficiency**: The use of a max-heap allows for quick retrieval and modification of the largest elements, ensuring that the algorithm runs efficiently even for larger input sizes.

2. **Simplicity**: The logic is straightforward, following a clear pattern of normalization, reduction, and deviation checking.

3. **Robustness**: The approach handles edge cases gracefully, such as when all elements are odd or even initially.

Overall, this solution exemplifies a smart application of data structures to solve a problem with specific constraints, ensuring optimal performance while maintaining clarity and simplicity in the implementation.
### üîÑ **Group Anagrams**

The task is to group anagrams from a given list of strings. An **anagram** is a word or phrase formed by rearranging the letters of another word or phrase, using all the original letters exactly once. The goal is to return a list of lists, where each list contains words that are anagrams of each other.

### üìä **Example**

Given the input list of strings:

```plaintext
["eat", "tea", "tan", "ate", "nat", "bat"]
```

The output should be:

```plaintext
[["eat", "tea", "ate"], ["tan", "nat"], ["bat"]]
```

### üß† **Approach**

To solve this problem efficiently, we will use the following approach:

1. **Generate a Signature (Mask) for Each Word**:
   Two words are anagrams if they have the exact same frequency of characters. Therefore, we can represent each word with a frequency distribution (a "mask"), which allows us to group words that share the same distribution.

2. **Use a Map to Group Words**:
   We use a map to store words, where the key is the "mask" and the value is a list of words that share the same mask. If two words have the same mask, they are anagrams.

3. **Return the Grouped Anagrams**:
   After processing all words, the map will contain the anagram groups. We return these groups as a list of lists.

### üíª **Code Breakdown (Step by Step)**

#### Step 1: **Creating the Mask for a Word**

We create a mask for each word based on the frequency of its characters:

```cpp
string code(string x) {
    vector<int> q(26, 0);  // Initialize a vector to store the frequency of each letter in the word.
    for(int i = 0; i < x.size(); i++) {
        q[x[i] - 'a']++;  // Increment the count of the character.
    }
    stringstream ss;  // Use a stringstream to construct the string representation of the frequency array.
    for(int i = 0; i < 26; i++) {
        if(i != 0) ss << ',';  // Separate counts by commas.
        ss << q[i];  // Append the count of the current character to the stringstream.
    }
    return ss.str();  // Return the generated mask as a string.
}
```

1. **Frequency Array**: We use an array `q` of size 26 (one for each letter of the alphabet) initialized to zero, which stores the frequency of each character in the word.
2. **Counting Characters**: For each character in the word, we increment the corresponding index in the array `q`.
3. **Build the Mask**: We use a `stringstream` to create a string that represents the frequency of each character, separated by commas.
4. **Return Mask**: The final string represents the word's frequency distribution and serves as its signature.

#### Step 2: **Group Words by Their Masks**

We group words by their corresponding masks in a map:

```cpp
vector<vector<string>> groupAnagrams(vector<string>& strs) {
    map<string, vector<string>> ma;  // Map to store groups of anagrams, using the mask as the key.
    for(string x: strs) {
        string mask = code(x);  // Get the mask for the current word.
        ma[mask].push_back(x);  // Group the word by its mask.
    }
    vector<vector<string>> ans;  // Vector to store the final result.
    for(auto [key, val]: ma)
        ans.push_back(val);  // Add all groups of anagrams to the result vector.
    
    return ans;  // Return the list of anagram groups.
}
```

1. **Initialize the Map**: We initialize a map `ma` where the key is the mask, and the value is a vector of words sharing the same mask (i.e., anagrams).
2. **Process Each Word**: For each word, we calculate its mask using the `code` function and insert it into the corresponding vector in the map.
3. **Build Final Result**: After processing all words, the map contains the anagram groups. We iterate through the map and add each group of anagrams to the result vector `ans`.
4. **Return Result**: We return the list of anagram groups.

### ‚è±Ô∏è **Time and Space Complexity**

#### Time Complexity

- **Generating the Mask**: The time to generate the mask for each word is proportional to the length of the word. If the total number of characters in all words is `n`, the time for generating masks is `O(n)`.
- **Grouping Words**: Inserting a word into the map takes `O(log m)` time, where `m` is the number of distinct masks. The total time for this step is `O(n log m)`, where `n` is the number of words and `m` is the number of distinct masks.
- **Final Grouping**: The final step, iterating through the map and collecting the results, takes `O(n)` time.

Thus, the overall time complexity is `O(n log m)` where `n` is the number of words and `m` is the number of distinct masks (which in the worst case could be `n`), resulting in a time complexity of `O(n log n)`.

#### Space Complexity

- **Space for Masks**: We need `O(n)` space to store the frequency masks for each word.
- **Space for Map and Result**: The map stores the words grouped by their masks, and the result stores all words. Therefore, the total space complexity is `O(n)`.

### üéØ **Conclusion**

This approach efficiently groups anagrams by leveraging a frequency-based mask for each word. Using a map to store words with the same mask allows us to group anagrams in a time-efficient manner. The algorithm has a **time complexity of O(n log n)** and a **space complexity of O(n)**, making it suitable for large inputs.

---

Happy coding! Keep grouping those anagrams efficiently! üéâ
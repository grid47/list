### 🚀 Problem Statement

In this problem, we are tasked with **inverting a binary tree**! In simpler terms, our job is to **swap the left and right child nodes** for every node in the tree. This inversion should be done recursively, and we must return the **root** of the inverted tree. 🌳🔄

The binary tree node structure is given as:
```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```

### 🧠 Approach

To solve this, we can use a **recursive depth-first traversal** approach to invert the binary tree. Here's how it works:

1. **Base Case**: If the current node is `NULL`, return `NULL`. We don’t need to do anything for empty subtrees.
2. **Recursive Step**: For each node:
   - Swap its left and right children.
   - Recursively invert both left and right subtrees.
   - Finally, return the current node after performing these operations.

This method efficiently handles the inversion process by visiting each node and flipping its children, ensuring the tree is inverted from top to bottom.

---

### 🔨 Step-by-Step Code Breakdown

Here’s how we can implement this solution in C++:

```cpp
class Solution {
public:
    // Function to invert a binary tree
    TreeNode* invertTree(TreeNode* root) {
        // Step 1: Base case - if the current node is NULL, return NULL
        if (!root) return NULL;
        
        // Step 2: Temporarily store the left child
        TreeNode* tmp = root->left;
        
        // Step 3: Recursively invert the right subtree and assign it to the left child
        root->left = invertTree(root->right);
        
        // Step 4: Recursively invert the left subtree (which was temporarily stored) and assign it to the right child
        root->right = invertTree(tmp);
        
        // Step 5: Return the root node after inversion
        return root;
    }
};
```

#### 📌 Step-by-Step Explanation

1. **Base Case**:
   ```cpp
   if (!root) return NULL;
   ```
   If the current node is `NULL`, we return `NULL` to stop further recursion.

2. **Temporary Storage**:
   ```cpp
   TreeNode* tmp = root->left;
   ```
   We store the left child of the current node in `tmp` before swapping.

3. **Invert Right Subtree**:
   ```cpp
   root->left = invertTree(root->right);
   ```
   We recursively invert the right subtree and assign it to the left child.

4. **Invert Left Subtree**:
   ```cpp
   root->right = invertTree(tmp);
   ```
   We recursively invert the left subtree (originally the right subtree) and assign it to the right child.

5. **Return the Root**:
   ```cpp
   return root;
   ```
   After inverting the children, we return the current node, which is now the root of the inverted tree.

---

### 📈 Complexity Analysis

#### 🕒 Time Complexity

The **time complexity** of this solution is **O(n)**, where `n` is the number of nodes in the binary tree. We visit each node exactly once, performing constant-time operations (swapping and recursion) at each step.

#### 💻 Space Complexity

The **space complexity** is **O(h)**, where `h` is the height of the tree. This is due to the space required by the recursion stack. 

- In the worst case (a skewed tree), the height of the tree is **O(n)**, so the space complexity would be **O(n)**.
- In the best case (a balanced tree), the height of the tree is **O(log n)**, so the space complexity is **O(log n)**.

---

### 🏁 Conclusion

In this solution, we’ve successfully inverted a binary tree using a recursive approach. By swapping the left and right children of each node and recursively inverting the subtrees, we achieve the desired result. 🌲🔄

#### Key Points:
- **Time Complexity**: **O(n)** — Each node is visited once.
- **Space Complexity**: **O(h)** — Determined by the height of the tree due to recursion.

This approach is elegant, simple to implement, and uses recursion to break the problem into manageable subproblems. Perfect for working with binary trees! 💡

### 🌟 Motivational Ending

Great job for tackling this problem! Remember, recursive solutions are often the key to solving tree-based problems efficiently. Keep practicing, and you'll continue mastering the art of recursion! ✨
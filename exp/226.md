### Problem Statement

The problem asks us to invert a binary tree. In other words, we need to swap the left and right child nodes for every node in the binary tree. This inversion should be performed recursively, and the final result should return the root of the inverted tree.

The definition of a **binary tree node** is given as follows:
```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode() : val(0), left(nullptr), right(nullptr) {}
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
    TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
};
```

We are tasked with creating a function that inverts the binary tree and returns the root of the modified tree.

### Approach

To invert the binary tree, we can use a **recursive depth-first traversal** approach. At each node, we swap its left and right children, and then recursively invert the left and right subtrees.

The recursive approach works as follows:
1. **Base Case**: If the node is `NULL`, simply return `NULL`. This is because an empty subtree does not need any inversion.
2. **Recursive Step**:
   - Swap the left and right child nodes of the current node.
   - Recursively invert the left and right subtrees.
   - Return the current node after inverting its children.

This method works because, in a binary tree, every node has a left and right child, and inverting the tree requires flipping the left and right child pointers at every level of the tree.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    // Function to invert a binary tree
    TreeNode* invertTree(TreeNode* root) {
        // Step 1: Base case - if the current node is NULL, return NULL
        if (!root) return NULL;
        
        // Step 2: Temporarily store the left child
        TreeNode* tmp = root->left;
        
        // Step 3: Recursively invert the right subtree and assign it to the left child
        root->left = invertTree(root->right);
        
        // Step 4: Recursively invert the left subtree (which was temporarily stored) and assign it to the right child
        root->right = invertTree(tmp);
        
        // Step 5: Return the root node after inversion
        return root;
    }
};
```

#### Step 1: Base Case
```cpp
if (!root) return NULL;
```
- The base case checks if the current node is `NULL`. If it is, we simply return `NULL`. This ensures that we stop the recursion when we reach the leaf nodes, which don't have any children to invert.

#### Step 2: Temporary Storage of the Left Child
```cpp
TreeNode* tmp = root->left;
```
- We store the left child of the current node (`root->left`) in a temporary variable `tmp`. This is necessary because we need to swap the left and right children, and we cannot directly overwrite the left child without losing it.

#### Step 3: Invert the Right Subtree
```cpp
root->left = invertTree(root->right);
```
- In this step, we recursively invert the right subtree. The recursive call to `invertTree(root->right)` inverts the right subtree of the current node. Once the right subtree is inverted, it is assigned to the left child of the current node.

#### Step 4: Invert the Left Subtree
```cpp
root->right = invertTree(tmp);
```
- In this step, we recursively invert the left subtree (which was originally the right subtree before swapping) by calling `invertTree(tmp)`. The left child (`tmp`) is now assigned to the right child of the current node.

#### Step 5: Return the Root Node
```cpp
return root;
```
- After swapping the left and right children and recursively inverting the subtrees, we return the current node (`root`), which is now the root of the inverted binary tree or subtree.

### Time Complexity

The time complexity of this solution is **O(n)**, where `n` is the number of nodes in the binary tree.

- Each node is visited exactly once. For each node, we perform constant-time operations: swapping the left and right children and making recursive calls to invert the left and right subtrees.
- Therefore, the total time complexity is proportional to the number of nodes in the tree, i.e., **O(n)**.

### Space Complexity

The space complexity is **O(h)**, where `h` is the height of the binary tree.

- The space complexity is determined by the depth of the recursive call stack. In the worst case, the tree could be skewed (like a linked list), and the recursion would need to go as deep as the height of the tree. In this case, the space complexity would be **O(n)**.
- In the best case, if the tree is balanced, the recursion depth would be proportional to the height of the tree, which is **O(log n)**.

Thus, the space complexity is **O(h)**, where `h` is the height of the tree, which can range from **O(log n)** to **O(n)** depending on the structure of the tree.

### Example Walkthrough

Consider the following binary tree:
```
       4
     /   \
    2     7
   / \   / \
  1   3 6   9
```

- **Initial Tree**:
  ```
         4
       /   \
      2     7
     / \   / \
    1   3 6   9
  ```

- After the `invertTree` function is called on the root node (4):
  1. Swap the left and right children of node 4.
  2. Recursively invert the left and right subtrees of node 4.
  
- **Inverted Tree**:
  ```
         4
       /   \
      7     2
     / \   / \
    9   6 3   1
  ```

- The left and right subtrees are recursively inverted, and the final tree is the mirror image of the original tree.

### Conclusion

In this solution, we successfully invert a binary tree using recursion. The algorithm works by swapping the left and right child nodes at each step, then recursively inverting the left and right subtrees. This solution efficiently handles the inversion of the tree in **O(n)** time, where `n` is the number of nodes, and it uses **O(h)** space, where `h` is the height of the tree due to the recursion stack.

This approach is optimal and easy to understand, making it a standard technique for solving problems involving tree manipulations. The recursive method is elegant and leverages the power of recursion to break down the problem into manageable subproblems, leading to an elegant and efficient solution.
### Problem Statement

The problem is to calculate the average waiting time for customers in a restaurant given their arrival and service times. Each customer arrives at a certain time and requires a specified duration for service. The challenge lies in handling the scheduling of customers in a way that minimizes their waiting time, particularly when some customers may arrive while others are still being served.

### Approach

To solve this problem, we need to simulate the service process based on customer arrival times and their corresponding service durations. We can maintain a variable that keeps track of the current time, which represents when the last customer finishes their service. As we iterate through the list of customers, we will:

1. Check if the current time is greater than the arrival time of the next customer. If so, it means the previous customer has finished service and the next customer can start immediately.
2. If the current time is less than or equal to the arrival time of the next customer, we set the current time to the arrival time of the next customer, indicating that we will wait for them.
3. After determining when the next customer starts their service, we update the current time by adding the service duration.
4. We keep a running total of waiting times for each customer, which is calculated as the difference between the current time and their arrival time.

Finally, we compute the average waiting time by dividing the total waiting time by the number of customers.

### Code Breakdown (Step by Step)

Let's examine the code step-by-step:

1. **Initialization**: We start by initializing `cur`, which will track the current time as we process each customer. It is initially set to the arrival time of the first customer. We also calculate the total number of customers `n` and initialize `sum`, which will accumulate the total waiting time.

    ```cpp
    int cur = cust[0][0]; // Start with the arrival time of the first customer
    double n = cust.size(); // Total number of customers
    double sum = 0; // Total waiting time initialized to 0
    ```

2. **Loop through each customer**: We loop through each customer using a for loop. For each iteration:

    ```cpp
    for(int i = 0; i < n; i++) {
    ```

3. **Determine current time based on arrival**: Inside the loop, we check if the current time (`cur`) is greater than the arrival time of the current customer (`cust[i][0]`). If it is, we update the current time to include the service duration.

    ```cpp
    if(cur > cust[i][0])
        cur += cust[i][1]; // Customer starts service immediately
    ```

4. **Handle waiting customers**: If the current time is less than or equal to the customer's arrival time, we update `cur` to the arrival time plus the service duration.

    ```cpp
    else
        cur = cust[i][0] + cust[i][1]; // Wait for the customer to arrive
    ```

5. **Calculate waiting time**: After determining when the service for the current customer ends, we calculate their waiting time and add it to `sum`.

    ```cpp
    sum += cur - cust[i][0]; // Update total waiting time
    ```

6. **Calculate average waiting time**: After processing all customers, we return the average waiting time by dividing the total waiting time by the number of customers.

    ```cpp
    return sum / n; // Average waiting time
    ```

### Complexity

The time complexity of this algorithm is O(n), where n is the number of customers. This is because we iterate through the list of customers exactly once, performing constant-time operations for each customer. The space complexity is O(1), as we only use a few variables for calculations and do not utilize any additional data structures that grow with input size.

### Conclusion

In summary, this implementation efficiently calculates the average waiting time for customers at a restaurant based on their arrival and service durations. By simulating the service process and keeping track of the current time, we can accurately determine how long each customer has to wait. This approach not only provides the correct solution but does so in a manner that is optimal in terms of both time and space complexity, making it suitable for real-time applications where customer service efficiency is crucial.
### Problem Statement

The task is to count the number of **range sums** in a given array `nums` that fall within a specified range `[lower, upper]`. A range sum is defined as the sum of any subarray (i.e., contiguous segment) of the array. The challenge is to compute the number of such range sums efficiently.

Given:
- An array `nums` of integers.
- A lower and upper bound for the range sum, i.e., you need to find all subarrays where the sum of the elements lies within `[lower, upper]`.

The problem requires an efficient solution, as a brute force approach that checks every subarray would have a time complexity of **O(n^2)**, which is too slow for large arrays.

### Approach

To solve this problem efficiently, the algorithm uses **prefix sums** combined with a **modified merge sort**. The key observation is that instead of explicitly computing the sum of every subarray, we can use **prefix sums** to reduce the problem to counting how many subarrays satisfy the range condition.

#### Steps:
1. **Prefix Sum Calculation**: The prefix sum of an array `nums` is an array where each element `sum[i]` represents the sum of the elements from the start of the array to index `i-1`. For example:
   - `sum[i] = sum[i-1] + nums[i-1]`.
   - This helps in calculating the sum of any subarray `nums[i...j]` as `sum[j+1] - sum[i]`.

2. **Modified Merge Sort**:
   - Instead of just sorting the prefix sums, we also count how many of the prefix sums fall within the given range `[lower, upper]`.
   - During the merge step of merge sort, we count how many pairs of prefix sums (from the left and right halves) satisfy the condition `lower <= sum[right] - sum[left] <= upper`.
   - This is done efficiently using a two-pointer technique within the merge step.

3. **Efficient Counting**:
   - For each prefix sum `sum[i]`, we count how many `sum[j]` values (from the right half) satisfy the range condition using binary search or two-pointer methods.

By leveraging the divide-and-conquer approach of merge sort, we can solve this problem in **O(n log n)** time, where `n` is the size of the array.

### Code Breakdown (Step by Step)

#### Step 1: Initialization
```cpp
vector<long> sum(n + 1, 0), tmp(n + 1, 0);
for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + nums[i];
```
- `sum[i]` stores the prefix sum up to index `i-1`. Initially, `sum[0] = 0`.
- We then compute the prefix sum for each element in `nums`.

#### Step 2: Calling `merge_sort`
```cpp
merge_sort(sum, 0, n, tmp);
```
- This starts the modified merge sort process. `merge_sort` will recursively divide the array into two halves, sort them, and count the valid range sums during the merge step.

#### Step 3: Merge Sort Recursive Step
```cpp
void merge_sort(vector<long>& sum, int left, int right, vector<long>& tmp) {
    if (left >= right) return;
    long mid = (left + right) / 2;
    merge_sort(sum, left, mid, tmp);
    merge_sort(sum, mid + 1, right, tmp);
    merge(sum, left, right, mid, tmp);
}
```
- The merge sort algorithm divides the `sum` array into two halves recursively until the base case is reached (`left >= right`).
- After dividing, it merges the two halves and counts the number of valid range sums during the merge.

#### Step 4: Merge Step
```cpp
void merge(vector<long>& sum, int left, int right, int mid, vector<long>& tmp) {
    int k = mid + 1, j = mid + 1;
    int high = mid + 1, common = left;
    
    for (int low = left; low <= mid; low++) {
        while (k <= right && sum[k] - sum[low] < lower) k++;
        while (j <= right && sum[j] - sum[low] <= upper) j++;
        cnt += j - k;
        
        while (high <= right && sum[high] < sum[low]) tmp[common++] = sum[high++];
        tmp[common++] = sum[low];
    }
    while (high <= right) tmp[common++] = sum[high++];
    
    for (int pos = left; pos <= right; pos++) sum[pos] = tmp[pos];
}
```
- In the merge step, we count how many of the prefix sums from the right half are within the range `[sum[low] + lower, sum[low] + upper]`.
- This is done using two pointers (`k` and `j`), which traverse the right half of the array to find the valid prefix sums that satisfy the condition.
- The prefix sums are then merged back into the `tmp` array in sorted order.

#### Step 5: Counting the Result
```cpp
return cnt;
```
- Finally, after the merge sort process is completed, the total count of valid range sums is stored in the `cnt` variable, which is returned as the result.

### Complexity

#### Time Complexity:
- **Merge Sort**: The merge sort algorithm has a time complexity of **O(n log n)**, where `n` is the number of elements in the `sum` array.
- **Counting Range Sums**: During the merge step, we are counting valid range sums in **O(n)** time, since each prefix sum is processed once for each merge step.
- Therefore, the overall time complexity is **O(n log n)**.

#### Space Complexity:
- **Space Complexity**: The space complexity is **O(n)** due to the auxiliary space used by the `tmp` array and the recursive call stack used by the merge sort algorithm.

### Conclusion

This solution provides an efficient way to count the number of subarrays with sums within a given range using **prefix sums** and **modified merge sort**. The algorithm leverages a divide-and-conquer approach, which reduces the problem to counting valid range sums during the merge step. The time complexity of **O(n log n)** ensures that this solution is optimal for large inputs, while the space complexity remains manageable at **O(n)**. This method is much faster than brute-force approaches and is suitable for real-world applications where performance is critical.
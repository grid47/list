### ðŸš€ Problem Statement

The task is to count the number of **range sums** in a given array `nums` that fall within a specified range `[lower, upper]`. A range sum is defined as the sum of any subarray (i.e., contiguous segment) of the array. The challenge is to compute the number of such range sums efficiently without brute-forcing through all the subarrays.

Given:
- An array `nums` of integers.
- A lower and upper bound for the range sum, i.e., you need to find all subarrays where the sum of the elements lies within `[lower, upper]`.

Since a brute force approach would have a time complexity of **O(nÂ²)**, which is inefficient for large arrays, we need to find a more efficient solution!

---

### ðŸ§  Approach

To solve this problem efficiently, we'll combine **prefix sums** with **modified merge sort**. The idea is to count how many subarrays have sums in the given range without explicitly calculating the sum of each subarray.

#### Key Steps:
1. **Prefix Sum Calculation**: 
   The prefix sum helps us quickly compute the sum of any subarray. By building a `prefix sum` array, where each element `sum[i]` is the sum of elements from `nums[0]` to `nums[i-1]`, we can calculate the sum of any subarray `nums[i...j]` as `sum[j+1] - sum[i]`.

2. **Modified Merge Sort**:
   - We use merge sort to divide and conquer. As we merge the prefix sums, we count how many valid subarray sums fall within the range `[lower, upper]`.
   - By using a two-pointer technique during the merge process, we can efficiently count how many subarray sums satisfy the condition without having to check every single pair of prefix sums.

3. **Efficient Counting**:
   - Instead of brute-forcing through all subarrays, we leverage the merge step in merge sort to count how many prefix sum pairs fall within the desired range.

This approach reduces the problem to **O(n log n)** time complexity, making it feasible even for large inputs!

---

### ðŸ”¨ Step-by-Step Code Breakdown

#### Step 1: Initialization
```cpp
vector<long> sum(n + 1, 0), tmp(n + 1, 0);
for (int i = 0; i < n; i++) sum[i + 1] = sum[i] + nums[i];
```
- We initialize a `sum` array where `sum[i]` holds the sum of elements from `nums[0]` to `nums[i-1]`.
- The prefix sum helps us calculate subarray sums efficiently.

#### Step 2: Calling `merge_sort`
```cpp
merge_sort(sum, 0, n, tmp);
```
- This kicks off the merge sort process, where `merge_sort` will recursively divide the `sum` array and count the valid range sums.

#### Step 3: Merge Sort Recursive Step
```cpp
void merge_sort(vector<long>& sum, int left, int right, vector<long>& tmp) {
    if (left >= right) return;
    long mid = (left + right) / 2;
    merge_sort(sum, left, mid, tmp);
    merge_sort(sum, mid + 1, right, tmp);
    merge(sum, left, right, mid, tmp);
}
```
- The array is divided into smaller halves, and then the `merge` function is called to merge the two halves and count valid range sums.

#### Step 4: Merge Step
```cpp
void merge(vector<long>& sum, int left, int right, int mid, vector<long>& tmp) {
    int k = mid + 1, j = mid + 1;
    int high = mid + 1, common = left;
    
    for (int low = left; low <= mid; low++) {
        while (k <= right && sum[k] - sum[low] < lower) k++;
        while (j <= right && sum[j] - sum[low] <= upper) j++;
        cnt += j - k;
        
        while (high <= right && sum[high] < sum[low]) tmp[common++] = sum[high++];
        tmp[common++] = sum[low];
    }
    while (high <= right) tmp[common++] = sum[high++];
    
    for (int pos = left; pos <= right; pos++) sum[pos] = tmp[pos];
}
```
- During the merge step, we efficiently count how many prefix sums fall within the given range using two pointers (`k` and `j`).
- The counts are updated as the subarrays are merged back into sorted order.

#### Step 5: Counting the Result
```cpp
return cnt;
```
- The final count of valid subarray sums is stored in the `cnt` variable and returned.

---

### ðŸ“ˆ Complexity Analysis

#### Time Complexity:
- **Merge Sort**: The time complexity of the merge sort algorithm is **O(n log n)**, where `n` is the size of the array.
- **Counting Range Sums**: The counting of valid range sums during the merge step takes **O(n)** time.
- Therefore, the overall time complexity is **O(n log n)**, which is efficient even for large input sizes.

#### Space Complexity:
- **Space Complexity**: The space complexity is **O(n)** due to the auxiliary space used by the `tmp` array and the recursive call stack in merge sort.

---

### ðŸ Conclusion

This solution efficiently counts the number of subarrays whose sums lie within the given range using **prefix sums** and a **modified merge sort**. By combining divide-and-conquer with efficient counting, the algorithm runs in **O(n log n)** time, which is optimal for large datasets. This approach is much faster than brute-force methods and provides a solid foundation for solving similar range sum problems. Whether you're tackling competitive programming challenges or optimizing real-world applications, this method is both effective and scalable. Happy coding! ðŸŽ‰

---

### âœ¨ Key Takeaways:
- Use **prefix sums** to quickly compute subarray sums.
- **Merge sort** helps divide and conquer, making counting range sums much faster.
- The solution runs in **O(n log n)** time, making it perfect for large arrays. 

This approach is both efficient and elegant â€“ a real win for solving range sum problems! ðŸš€
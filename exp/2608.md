### Problem Statement

The task requires finding the length of the shortest cycle in an undirected graph. A cycle is a path where the start and end vertices are the same, and it must have at least three vertices. Given a graph represented by `n` vertices and a list of edges, the goal is to determine the shortest cycle's length. If no cycle exists, the function should return `-1`.

### Approach

To solve this problem, we can use **Depth-First Search (DFS)**. The key idea is to traverse the graph starting from each vertex and detect cycles as we go. We track the visited vertices and their distances during traversal, and if we encounter a previously visited vertex that is not the parent of the current vertex, we have found a cycle. We then calculate the cycle's length and update the minimum cycle length.

### Detailed Explanation

1. **Graph Representation**: 
   - The graph is represented as an adjacency list, where `grid[i]` contains all vertices connected to vertex `i`. This allows us to easily access the neighbors of any vertex during traversal.
   
2. **DFS Traversal**:
   - We use a **DFS** to explore all vertices starting from each vertex. During the DFS, we maintain a `vis` array where `vis[i]` stores the distance of vertex `i` from the starting vertex. If we encounter a vertex that was already visited, we check if it forms a cycle.
   
3. **Cycle Detection**:
   - If a vertex `x` has been visited and is not the parent of the current vertex, it indicates a cycle. The length of the cycle is calculated as `abs(vis[x] - vis[i]) + 1`, where `i` is the current vertex. The absolute difference between `vis[x]` and `vis[i]` gives the number of vertices between `x` and `i` in the cycle, and adding `1` accounts for the vertex `i` itself.

4. **Tracking the Shortest Cycle**:
   - During the DFS traversal, the minimum cycle length is updated whenever a cycle is detected. After the DFS from all vertices is complete, the answer will contain the length of the shortest cycle found. If no cycle was found, the answer will remain as `INT_MAX`, and we return `-1`.

### Code Breakdown (Step by Step)

#### 1. **Graph Construction**:

```cpp
grid.resize(n);
for(auto e: edges) {
    grid[e[0]].push_back(e[1]);
    grid[e[1]].push_back(e[0]);
}
```

- **Purpose**: We initialize an adjacency list `grid` to represent the graph. Each edge `e` connects two vertices, `e[0]` and `e[1]`. For each edge, we add `e[1]` to the adjacency list of `e[0]` and vice versa (since the graph is undirected).
- **Time Complexity**: This step takes \(O(m)\), where \(m\) is the number of edges.

#### 2. **DFS for Cycle Detection**:

```cpp
for(int i = 0; i < n; i++) {
    vector<int> vis(n, INT_MAX);
    dfs(-1, i, 0, vis);
}
```

- **Purpose**: For each vertex `i`, we start a DFS traversal. The `vis` array is initialized to `INT_MAX` for all vertices, indicating they are unvisited. The `dfs` function is called with the current vertex as `i` and its parent as `-1` (since the starting vertex has no parent).
- **Time Complexity**: This step involves running DFS from each vertex, which is \(O(n)\) for each call. So, the total complexity of this loop is \(O(n^2)\).

#### 3. **DFS Function**:

```cpp
void dfs(int par, int i, int run, vector<int>& vis) {
    vis[i] = run;
    for(int x: grid[i]) {
        if(x == par) continue;
        if(vis[x] != INT_MAX) {
            ans = min(ans, abs(vis[x] - vis[i]) + 1);
        } else {
            dfs(i, x, run + 1, vis);
        }
    }
}
```

- **Purpose**: This function performs a DFS traversal starting from vertex `i`. The parameter `par` is the parent vertex to avoid revisiting it. The parameter `run` keeps track of the current distance from the starting vertex.
  
  - We mark `vis[i]` with the current distance `run` to indicate that vertex `i` has been visited at this distance.
  
  - We then iterate over all the neighbors `x` of the current vertex `i`. If the neighbor is the parent vertex (i.e., `x == par`), we skip it, as we don't want to revisit the parent during the traversal.
  
  - If a neighbor `x` has already been visited (i.e., `vis[x] != INT_MAX`), it indicates that a cycle has been detected. We calculate the length of the cycle as `abs(vis[x] - vis[i]) + 1` and update `ans` to store the minimum cycle length found so far.
  
  - If the neighbor `x` has not been visited, we continue the DFS by recursively calling `dfs` with `x` as the current vertex and `i` as its parent, and the distance `run + 1`.
  
- **Time Complexity**: Each DFS call visits every vertex and edge at most once, so the time complexity of each DFS is \(O(n + m)\), where \(n\) is the number of vertices and \(m\) is the number of edges.

#### 4. **Returning the Result**:

```cpp
return ans == INT_MAX ? -1 : ans;
```

- **Purpose**: After running DFS for all vertices, the variable `ans` will either contain the length of the shortest cycle or `INT_MAX` if no cycle was found. We return `-1` if no cycle was found; otherwise, we return the shortest cycle length.
- **Time Complexity**: This step is \(O(1)\).

### Complexity Analysis

#### Time Complexity:
- **Graph Construction**: Building the adjacency list takes \(O(m)\), where \(m\) is the number of edges.
- **DFS Traversal**: The DFS is called once for each vertex. Each DFS call visits each edge and vertex once, so the time complexity of DFS is \(O(n + m)\). Since we call DFS for each vertex, the total time complexity for DFS calls is \(O(n(n + m))\).
- **Overall Time Complexity**: The overall time complexity is \(O(n(n + m))\), where \(n\) is the number of vertices and \(m\) is the number of edges.

#### Space Complexity:
- **Adjacency List**: The adjacency list takes \(O(n + m)\) space to store the graph.
- **Visited Array**: The `vis` array takes \(O(n)\) space for each DFS call.
- **Overall Space Complexity**: The overall space complexity is \(O(n + m)\).

### Conclusion

This solution uses **Depth-First Search (DFS)** to efficiently find the shortest cycle in an undirected graph. By exploring the graph starting from each vertex and keeping track of visited vertices and their distances, we can detect cycles and compute their lengths. The algorithm efficiently computes the shortest cycle by considering all vertices and cycles in the graph. The time complexity is \(O(n(n + m))\), making it suitable for relatively large graphs. If no cycle is found, the function returns `-1`.
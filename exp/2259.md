### Problem Statement

The problem asks us to remove one occurrence of a specified digit from a given string `n` representing a number, in such a way that the resulting number is the largest possible. The string `n` is made up of digits (from '0' to '9'), and we need to remove one digit so that the remaining string represents the largest possible value. The challenge is to identify which occurrence of the digit to remove, ensuring that the result is maximized.

### Approach

The approach to solve this problem is to strategically decide which digit to remove in order to maximize the number. The key observation is that we want to maximize the value of the remaining number after one digit is removed. To do this:

1. **Remove the first occurrence of the digit when the next digit is greater than it**: This ensures that the resulting number after the removal is the largest possible value by keeping the higher digits intact.
2. **If no such occurrence is found**: We need to remove the last occurrence of the digit to avoid reducing the size of the number unnecessarily.

### Code Breakdown (Step by Step)

#### Step 1: Iterate Through the String

```cpp
for (int i = 0; i < n.size() - 1; ++i)
    if (n[i] == digit && n[i + 1] > digit)
        return n.substr(0, i) + n.substr(i + 1);
```

- The goal is to check each character in the string `n` and see if it matches the specified `digit`.
- We look ahead to the next character in the string (`n[i + 1]`), and if this character is greater than the current character (`n[i]`), it indicates that removing `n[i]` will result in a larger number because the next character is higher.
- If this condition is met, we remove the digit by concatenating the substring before the current digit (`n.substr(0, i)`) with the substring after the current digit (`n.substr(i + 1)`).
- This approach ensures that we always maximize the value of the number by removing the digit where possible.

#### Step 2: Handle the Case Where No Digit Is Removed for Maximization

```cpp
int last_d = n.rfind(digit);
return n.substr(0, last_d) + n.substr(last_d + 1);
```

- If no such condition (where the next digit is larger) is found during the loop, the next best option is to remove the **last occurrence** of the specified `digit`.
- We use `rfind` to find the last occurrence of `digit` in the string. The function `rfind` returns the index of the last occurrence of the specified character or `string::npos` if the character is not found.
- Once we know the position of the last occurrence, we can remove the digit by concatenating the substring before and after this position (`n.substr(0, last_d)` and `n.substr(last_d + 1)`).

#### Step 3: Return the Result

- The result is the string after removing the specified digit. Depending on the situation, the digit is removed either from a position where the next digit is larger, or from the last occurrence of the digit.

### Complexity

#### Time Complexity

1. **Loop Iteration**: The first loop iterates over the string `n` once, which has a time complexity of \(O(n)\), where `n` is the length of the string.
2. **String Operations**: The `substr()` method, used to create new substrings, runs in linear time with respect to the size of the substring being created. Therefore, both `n.substr(0, i)` and `n.substr(i + 1)` take \(O(n)\) time, where `n` is the length of the string.
3. **Last Digit Search**: The `rfind()` method also takes \(O(n)\) time in the worst case.

Thus, the overall time complexity is \(O(n)\), where `n` is the length of the input string `n`.

#### Space Complexity

1. **Space for Substrings**: The space complexity primarily comes from creating new substrings. The space required for the substrings generated by `substr()` depends on the length of the substrings being created. In the worst case, we need additional space proportional to the length of the string for the result.
2. **Overall Space Complexity**: Therefore, the overall space complexity is \(O(n)\), where `n` is the length of the string `n`.

### Conclusion

This solution efficiently removes a digit from the string `n` to maximize the resulting number. The approach works by iterating through the string, looking for an optimal position to remove a digit (where the next digit is greater), or, if such a position isn't found, removing the last occurrence of the specified digit. The time and space complexity of this solution are both \(O(n)\), making it optimal for large strings.
### Problem Statement

The problem is to simplify an absolute file path, given as a string, to its canonical form. For example, given a path like `/a/./b/../../c/`, the canonical path should be `/c`. The path simplification should remove redundant components such as:
- Single dots (`.`) which represent the current directory.
- Double dots (`..`) which represent moving up to the parent directory.
- Extra slashes (`/`) which should be treated as a single separator.

### Approach

This solution uses a **stack-based approach** to process each component in the path. Here’s how it works:

1. **Initialize Set for Skipping Components**:
   - We define a set `dot` containing values `{"..", ".", ""}` to identify parts of the path that should be ignored or handled specifically. 
   - The empty string (`""`) handles cases of consecutive slashes in the path, and `"."` represents the current directory, which can be ignored.

2. **Tokenize the Path**:
   - A `stringstream` is used to split the `path` string by each `/` delimiter. Each extracted component is then stored in `tmp` to examine if it’s a directory or a special token (`..`, `.`, or empty).

3. **Process Each Component Using a Stack**:
   - For each component `tmp`:
     - If `tmp` is `".."`, we move up one directory by popping the top element from the stack (unless the stack is empty).
     - If `tmp` is not in the `dot` set (i.e., it’s a valid directory name), we push it onto the stack.
   - By the end of this loop, the stack contains the sequence of directories that make up the simplified path.

4. **Construct the Result**:
   - We pop each element from the stack and prepend it to `res` with a `/` to reconstruct the simplified path in canonical form.
   - If the `res` string is empty after processing, we return `/` as the root directory.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the Set, Stream, and Stack

```cpp
set<string> dot = {"..", ".", ""};
string res = "", tmp;
stringstream ss(path);
stack<string> stk;
```

- We create a set `dot` to handle cases where the component is `".."`, `"."`, or an empty string.
- `res` will eventually store the canonical path.
- `tmp` holds each component of the path as we process it.
- `stack<string> stk` is used to manage directories in the path as we build the simplified form.

#### Step 2: Process the Path Using `stringstream` and Stack

```cpp
while(getline(ss, tmp, '/')) {
    if(tmp == ".." && !stk.empty()) stk.pop();
    else if (!dot.count(tmp)) stk.push(tmp);
}
```

- We loop through each part of `path` by splitting it on `/`.
- If the component `tmp` is `".."` and the stack isn’t empty, we pop the top element from the stack (i.e., we move up one directory).
- If `tmp` isn’t in the `dot` set (meaning it’s a valid directory), we push it onto the stack.

#### Step 3: Construct the Result from the Stack

```cpp
while(!stk.empty()) {
    res = "/" + stk.top() + res;
    stk.pop();
}
return res == ""? "/": res;
```

- We build the result path from the stack by adding each directory to `res`, ensuring each is prefixed by `/`.
- If `res` is empty after processing, we return `/`, indicating the root directory.

### Complexity

#### Time Complexity
The time complexity is `O(n)`, where `n` is the length of the input `path`. This is because each component is processed once, and stack operations (push and pop) are `O(1)`.

#### Space Complexity
The space complexity is also `O(n)`, primarily for storing the stack that may hold all directories in the worst case.

### Conclusion

This solution is efficient and optimal for simplifying absolute file paths. By using a stack, we efficiently manage directory traversal, ensuring that each `..` correctly backtracks, and each valid directory is correctly added to the canonical path. This stack-based approach is ideal for problems involving hierarchical paths, making it a practical solution for file system path simplification.
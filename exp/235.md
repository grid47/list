### Problem Statement

The problem at hand is to find the **Lowest Common Ancestor (LCA)** of two given nodes in a **Binary Search Tree (BST)**. The Lowest Common Ancestor of two nodes `p` and `q` in a tree is defined as the deepest node that is an ancestor of both `p` and `q`. In simpler terms, it is the last common node on the path from `p` to the root and from `q` to the root.

In a **Binary Search Tree (BST)**, the key property is that for any given node:
- The **left** subtree contains values less than the node's value.
- The **right** subtree contains values greater than the node's value.

Thus, given this property, we need to traverse the BST in such a way that we identify the node where the paths to both `p` and `q` diverge. This node will be the **Lowest Common Ancestor**.

The function should return the **LCA node**. If either `p` or `q` is not present in the tree, we should assume they are present, and we aim to find the LCA assuming they are valid nodes in the tree.

### Approach

To solve this problem efficiently, we can take advantage of the properties of the **Binary Search Tree (BST)**. The key observation is:
- If both `p` and `q` are smaller than the current node's value, then both nodes must lie in the left subtree.
- If both `p` and `q` are greater than the current node's value, then both nodes must lie in the right subtree.
- If one node is smaller and the other is greater (or one of them is equal to the current node), we have found the **Lowest Common Ancestor**.

In simpler terms:
1. Start from the root of the tree.
2. If both `p` and `q` are on the right side of the current node, move to the right child.
3. If both `p` and `q` are on the left side of the current node, move to the left child.
4. If one of `p` or `q` is on one side and the other is on the opposite side (or one of them is equal to the current node), the current node is the **LCA**.

By leveraging the properties of the BST, this approach ensures that we can efficiently find the LCA in **O(log n)** time on average for balanced BSTs.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
```
- We define a `Solution` class and implement the function `lowestCommonAncestor` which takes the root of the tree (`root`), and two nodes (`p` and `q`) as inputs. The function will return the **LCA** of nodes `p` and `q`.

```cpp
        if(root->val < p->val && root->val < q->val)
            return lowestCommonAncestor(root->right, p, q);
```
- We start by checking if both `p` and `q` have values greater than the current `root` node's value. If so, this means both nodes are in the right subtree, and we recursively call the function on the right child of the current root (`root->right`).

```cpp
        if(root->val > p->val && root->val > q->val)
            return lowestCommonAncestor(root->left, p, q);
```
- If both `p` and `q` have values smaller than the current `root` node's value, this means both nodes are in the left subtree, and we recursively call the function on the left child of the current root (`root->left`).

```cpp
        return root;
```
- If neither of the above conditions is true, this means that `p` and `q` are on either side of the current root node, or one of them is the current root itself. In this case, the current `root` node is the **Lowest Common Ancestor** of `p` and `q`, and we return it.

### Complexity

#### Time Complexity:
- The time complexity of this solution is **O(h)**, where `h` is the height of the binary search tree. In the worst case, we may have to traverse the entire height of the tree to find the LCA. 
  - In a **balanced** BST, the height `h` is **O(log n)**, where `n` is the number of nodes in the tree.
  - In an **unbalanced** tree, the height `h` can be **O(n)** in the worst case (when the tree degenerates into a linked list).

Thus, the time complexity can be considered **O(log n)** for balanced trees and **O(n)** for unbalanced trees.

#### Space Complexity:
- The space complexity is **O(1)** as we are using only a constant amount of extra space for the recursion (no additional data structures are used). 
- However, if we consider the recursive stack, the space complexity would be **O(h)**, where `h` is the height of the tree (this is the maximum depth of recursion in the worst case).

### Conclusion

This solution efficiently finds the **Lowest Common Ancestor (LCA)** of two nodes in a **Binary Search Tree (BST)** by exploiting the properties of the tree:
- Nodes with values smaller than the current node are in the left subtree.
- Nodes with values greater than the current node are in the right subtree.
- The **LCA** is the node where the paths to the two given nodes `p` and `q` diverge or where one of the nodes is the root.

By leveraging this property, the algorithm efficiently finds the **LCA** in **O(log n)** time on average for balanced trees. For unbalanced trees, the time complexity can degrade to **O(n)**.

#### Key Highlights:
- **Optimal for BSTs**: The solution is highly efficient for binary search trees due to the logarithmic time complexity in balanced trees.
- **Simple Recursive Solution**: The approach is based on simple recursion with a straightforward conditional check to determine whether we need to move left or right in the tree.
- **Space Efficient**: The space complexity is constant for the recursive call stack, making this solution space efficient.

This approach is an ideal solution for finding the **Lowest Common Ancestor** in binary search trees and is commonly asked in coding interviews due to its simplicity and effectiveness.
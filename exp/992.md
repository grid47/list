### Problem Statement

The problem asks us to find the number of subarrays with exactly **k distinct integers** in a given array `nums`. A subarray is any contiguous portion of the array, and the number of distinct integers in that subarray is counted.

For example:
- Input: `nums = [1, 2, 1, 2, 3]`, `k = 2`
- Output: `7`  
    The subarrays with exactly 2 distinct integers are:
    - `[1, 2]`, `[2, 1]`, `[1, 2]`, `[2, 3]`, `[1, 2, 3]`, `[2, 1, 2]`, `[1, 2]`.

The goal is to efficiently find the count of such subarrays for a given `k`.

### Approach

To solve this problem, we use a **sliding window** approach combined with a helper function to count subarrays with at most `k` distinct integers. The idea is to use this helper function to calculate the number of subarrays with **at most k distinct integers**, and then subtract the number of subarrays with **at most k - 1 distinct integers** from that count.

#### Key Insight:

- If we can compute the number of subarrays with at most `k` distinct integers, we can subtract the number of subarrays with at most `k-1` distinct integers to get the number of subarrays with exactly `k` distinct integers. This is because the subarrays with exactly `k` distinct integers are the difference between those with at most `k` distinct integers and those with at most `k-1` distinct integers.

The function `atmost(nums, k)` calculates the number of subarrays with at most `k` distinct integers by using a sliding window approach. The window expands as long as the number of distinct integers inside it is less than or equal to `k`. If the window contains more than `k` distinct integers, the window shrinks from the left to maintain the condition.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    int subarraysWithKDistinct(vector<int>& nums, int k) {
        // Return the number of subarrays with exactly k distinct integers.
        return atmost(nums, k) - atmost(nums, k - 1);
    }

    int atmost(vector<int>& nums, int k) {
        // This helper function counts the number of subarrays with at most k distinct integers.
        int res = 0, j = 0;
        map<int, int> ma;  // A map to store the frequency of elements in the sliding window.
        
        // Iterate through each element in the array with the index `i`
        for(int i = 0; i < nums.size(); i++) {
            ma[nums[i]]++;  // Add the current element to the map
            // If it's the first occurrence of this element, decrement k
            if(ma[nums[i]] == 1) k--;
            
            // If the number of distinct elements exceeds k, shrink the window
            while(k < 0) {
                ma[nums[j]]--;  // Remove the leftmost element from the window
                if(ma[nums[j]] == 0) k++;  // If an element's frequency becomes 0, increment k
                j++;  // Move the left pointer of the window
            }
            
            // Add the number of valid subarrays ending at `i` to the result
            res += (i - j + 1);
        }
        
        return res;
    }
};
```

#### Step-by-Step Explanation:

1. **Main Function: `subarraysWithKDistinct`**:
   - This function is the main driver. It calls the helper function `atmost(nums, k)` twice:
     - First to count subarrays with **at most k** distinct integers.
     - Second to count subarrays with **at most k-1** distinct integers.
   - The result is the difference between these two counts, which gives the number of subarrays with exactly **k** distinct integers.
   
   ```cpp
   return atmost(nums, k) - atmost(nums, k - 1);
   ```

2. **Helper Function: `atmost`**:
   - This helper function is responsible for counting the number of subarrays with at most `k` distinct integers using a sliding window approach.
   
   **Sliding Window Approach**:
   - We maintain a window represented by two pointers: `j` (left pointer) and `i` (right pointer).
   - We use a map `ma` to track the frequency of elements in the window.
   - For each element `nums[i]`, we add it to the map and update the number of distinct elements inside the window.
   - If the number of distinct elements exceeds `k`, we shrink the window by moving the left pointer `j` to the right, removing elements from the map until the window contains at most `k` distinct elements.
   
   **Result Calculation**:
   - For every valid position of `i`, the number of subarrays ending at `i` is `(i - j + 1)`. This is because the subarrays are formed by varying the left boundary from `j` to `i`.
   - We accumulate these counts in the variable `res`.
   
3. **Edge Case**:
   - If `k == 0`, the number of subarrays with exactly 0 distinct elements is trivially 0 because there are no valid subarrays that could have 0 distinct elements.

### Time and Space Complexity Analysis

#### Time Complexity:
- The sliding window approach ensures that both `i` and `j` only move forward, meaning each element is processed at most twice (once when expanding the window and once when shrinking it).
- Therefore, the time complexity of each call to `atmost(nums, k)` is **O(n)**, where `n` is the size of the array.
- The `subarraysWithKDistinct` function calls `atmost(nums, k)` twice, so the overall time complexity is **O(n)**.

#### Space Complexity:
- The space complexity is dominated by the map `ma`, which stores the frequency of elements in the current window. The size of the map is proportional to the number of distinct elements in the window, which can be at most `n` in the worst case.
- Thus, the space complexity is **O(n)**.

### Conclusion

This solution efficiently calculates the number of subarrays with exactly `k` distinct integers using the sliding window technique and the concept of subarrays with at most `k` distinct integers. By leveraging a helper function to compute the count of subarrays with at most `k` distinct integers and subtracting the result for `k-1` distinct integers, we can determine the number of subarrays with exactly `k` distinct integers in linear time. The time and space complexities of the solution are optimal for large input sizes.
### Problem Statement

The problem is to generate an `n x n` matrix filled with elements from 1 to `n^2` in a spiral order. Starting from the top-left corner, the matrix should be filled in a clockwise spiral pattern. Given an integer `n`, the goal is to return a matrix where the numbers are arranged in such a spiral order.

For example, for `n = 3`, the output should be:
```
[[1, 2, 3],
 [8, 9, 4],
 [7, 6, 5]]
```

### Approach

To solve this problem, the strategy involves simulating the process of filling a matrix in a spiral pattern. The idea is to iterate through the matrix layer by layer, starting from the outermost layer and working our way inward. This can be achieved by maintaining four variables that represent the boundaries of the matrix that we are currently filling: the top row, the bottom row, the left column, and the right column.

We will repeatedly fill in the matrix by traversing the outermost unfilled layer in the following sequence:
1. Move from left to right across the topmost row.
2. Move from top to bottom along the rightmost column.
3. Move from right to left across the bottommost row (if there are still rows remaining).
4. Move from bottom to top along the leftmost column (if there are still columns remaining).

After completing these steps for each layer, the boundaries are reduced, and the next layer is filled in the same manner, until the entire matrix is populated.

### Code Breakdown (Step by Step)

#### Step 1: Initialize the Matrix and Boundaries

```cpp
vector<vector<int>> mtx(n, vector<int>(n, 0));
int cBgn = 0, cEnd = n - 1, rBgn = 0, rEnd = n - 1;
```

- **`mtx`:** We initialize the matrix `mtx` with dimensions `n x n`. All elements are initially set to `0`.
- **Boundaries:** The variables `cBgn` (column beginning), `cEnd` (column end), `rBgn` (row beginning), and `rEnd` (row end) represent the current unfilled region of the matrix. These boundaries will gradually shrink as we fill in the matrix in a spiral order.

#### Step 2: Start Filling the Matrix

```cpp
int num = 1;
while(cBgn <= cEnd && rBgn <= rEnd) {
```

- **`num`:** The variable `num` starts at 1 and will increment with each step, filling the matrix from 1 to `n^2`.
- The `while` loop continues as long as there are rows and columns left to fill, i.e., while the top boundary (`rBgn`) is less than or equal to the bottom boundary (`rEnd`) and the left boundary (`cBgn`) is less than or equal to the right boundary (`cEnd`).

#### Step 3: Fill the Top Row

```cpp
for(int i = cBgn; i <= cEnd; i++)
    mtx[rBgn][i] = num++;
rBgn++;
```

- We first traverse the top row from left to right (i.e., across columns from `cBgn` to `cEnd`), and assign each cell the current value of `num`. Then, we increment `num` and move the top boundary (`rBgn`) down by one to indicate that this row has been filled.

#### Step 4: Fill the Right Column

```cpp
for(int i = rBgn; i <= rEnd; i++)
    mtx[i][cEnd] = num++;
cEnd--;
```

- Next, we move down the rightmost column (i.e., across rows from `rBgn` to `rEnd`), filling each cell with the current value of `num` and then incrementing `num`. Afterward, we move the right boundary (`cEnd`) left by one, as this column is now filled.

#### Step 5: Fill the Bottom Row (if necessary)

```cpp
if(rBgn <= rEnd)
    for(int i = cEnd; i >= cBgn; i--)
        mtx[rEnd][i] = num++;
rEnd--;
```

- If there are still rows remaining (i.e., `rBgn` is still less than or equal to `rEnd`), we traverse the bottom row from right to left (i.e., across columns from `cEnd` to `cBgn`), filling each cell with the current value of `num` and then incrementing `num`. Afterward, we move the bottom boundary (`rEnd`) up by one.

#### Step 6: Fill the Left Column (if necessary)

```cpp
if(cBgn <= cEnd)
    for(int i = rEnd; i >= rBgn; i--)
        mtx[i][cBgn] = num++;
cBgn++;
```

- If there are still columns remaining (i.e., `cBgn` is still less than or equal to `cEnd`), we move up the leftmost column (i.e., across rows from `rEnd` to `rBgn`), filling each cell with the current value of `num` and incrementing `num`. Afterward, we move the left boundary (`cBgn`) right by one.

#### Step 7: Return the Matrix

```cpp
return mtx;
```

- After all layers have been filled, we return the populated matrix `mtx` that now contains the numbers in a spiral order from 1 to `n^2`.

### Complexity

#### Time Complexity:
- **O(n^2):** The time complexity is O(n^2) because we are filling an `n x n` matrix, and each cell needs to be visited exactly once. Therefore, the time complexity is proportional to the number of elements in the matrix, which is `n^2`.

#### Space Complexity:
- **O(n^2):** The space complexity is also O(n^2) because we need to store the `n x n` matrix. The auxiliary space used by the algorithm (i.e., variables and indices) is constant, but the matrix itself takes up O(n^2) space.

### Conclusion

The solution to the problem of generating a matrix in spiral order involves a simple yet efficient approach using a series of nested loops to fill the matrix layer by layer. By maintaining boundaries for the rows and columns, we can easily navigate and fill the matrix in a clockwise spiral pattern. The time and space complexities are optimal for this problem, both being O(n^2), which is expected when dealing with matrix-based problems. This solution is efficient, easy to understand, and provides the correct result in an intuitive manner.
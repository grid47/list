### üåÄ **Generate Spiral Matrix**

The problem requires generating an `n x n` matrix filled with elements from 1 to `n^2` in a spiral order, starting from the top-left corner. The matrix should be filled in a clockwise spiral pattern.

For example, for `n = 3`, the output should be:
```
[[1, 2, 3],
 [8, 9, 4],
 [7, 6, 5]]
```

### üß† **Approach**

To solve this, we simulate the process of filling a matrix in a spiral pattern by traversing the matrix layer by layer. We use four variables representing the boundaries of the matrix: the top row, bottom row, left column, and right column. As we fill the matrix, these boundaries shrink until all elements are placed.

The filling sequence for each layer is as follows:
1. Move from left to right across the top row.
2. Move from top to bottom along the right column.
3. Move from right to left across the bottom row (if rows are still remaining).
4. Move from bottom to top along the left column (if columns are still remaining).

These steps repeat until the entire matrix is filled.

### üîç **Code Breakdown**

#### Step 1: Initialize Matrix and Boundaries

```cpp
vector<vector<int>> mtx(n, vector<int>(n, 0));
int cBgn = 0, cEnd = n - 1, rBgn = 0, rEnd = n - 1;
```

- **`mtx`:** We initialize a matrix of size `n x n` with all elements set to `0`.
- **Boundaries:** The variables `cBgn`, `cEnd`, `rBgn`, and `rEnd` represent the current unfilled region of the matrix, starting from the outermost layer. These boundaries will gradually shrink as we fill the matrix in a spiral order.

#### Step 2: Start Filling the Matrix

```cpp
int num = 1;
while(cBgn <= cEnd && rBgn <= rEnd) {
```

- **`num`:** This variable starts at 1 and will increment as we fill each cell in the matrix, from 1 to `n^2`.
- The `while` loop continues as long as there are rows and columns to fill, i.e., while `rBgn <= rEnd` and `cBgn <= cEnd`.

#### Step 3: Fill the Top Row

```cpp
for(int i = cBgn; i <= cEnd; i++)
    mtx[rBgn][i] = num++;
rBgn++;
```

- We fill the top row by moving from left to right (i.e., across columns from `cBgn` to `cEnd`). After filling each cell, we increment `num` and move the top boundary (`rBgn`) down by one.

#### Step 4: Fill the Right Column

```cpp
for(int i = rBgn; i <= rEnd; i++)
    mtx[i][cEnd] = num++;
cEnd--;
```

- We then move down the rightmost column (i.e., across rows from `rBgn` to `rEnd`), filling each cell with the current value of `num` and then incrementing `num`. Afterward, we move the right boundary (`cEnd`) left by one.

#### Step 5: Fill the Bottom Row (if necessary)

```cpp
if(rBgn <= rEnd)
    for(int i = cEnd; i >= cBgn; i--)
        mtx[rEnd][i] = num++;
rEnd--;
```

- If there are still rows remaining (`rBgn <= rEnd`), we traverse the bottom row from right to left (i.e., across columns from `cEnd` to `cBgn`), filling each cell with the current value of `num` and incrementing `num`. Afterward, we move the bottom boundary (`rEnd`) up by one.

#### Step 6: Fill the Left Column (if necessary)

```cpp
if(cBgn <= cEnd)
    for(int i = rEnd; i >= rBgn; i--)
        mtx[i][cBgn] = num++;
cBgn++;
```

- If there are still columns remaining (`cBgn <= cEnd`), we move up the leftmost column (i.e., across rows from `rEnd` to `rBgn`), filling each cell with the current value of `num` and incrementing `num`. Afterward, we move the left boundary (`cBgn`) right by one.

#### Step 7: Return the Matrix

```cpp
return mtx;
```

- After all layers are filled, we return the completed matrix `mtx` containing the numbers in spiral order.

### üìä **Complexity Analysis**

#### Time Complexity:
- **O(n^2):** The time complexity is O(n^2), where `n^2` is the number of cells in the `n x n` matrix. Each cell is visited exactly once during the filling process, so the time complexity is proportional to the total number of elements.

#### Space Complexity:
- **O(n^2):** The space complexity is O(n^2) because we need to store the matrix. The auxiliary space used by the algorithm (variables and indices) is constant, but the matrix itself takes up O(n^2) space.

### üåü **Conclusion**

This solution to generating a matrix in spiral order uses an intuitive approach of filling the matrix layer by layer. By maintaining boundaries for the rows and columns, we can efficiently traverse the matrix in a clockwise spiral pattern. Both the time and space complexities are O(n^2), which is optimal for matrix-related problems. This solution is straightforward, efficient, and provides the correct result in an easy-to-understand manner.

---
### Problem Statement

The task is to find the maximum product of any contiguous subarray in a given array of integers. The array may contain both positive and negative integers, and we need to consider subarrays of any length. A subarray is any contiguous portion of the array, and our goal is to return the maximum product that can be obtained from any such subarray.

For example, given an input array like `[-2, 3, -4]`, the subarray with the maximum product is `[3, -4]`, and its product is `-12`. The problem becomes particularly interesting because of the presence of negative numbers, which can flip the sign of the product and potentially create larger products when combined with other negative numbers.

### Approach

To solve this problem efficiently, we can take advantage of dynamic programming (DP) principles while maintaining two variables at each step:
1. **`mx`** (maximum product so far)
2. **`mn`** (minimum product so far)

At each index in the array, we need to keep track of both the maximum and minimum products because a negative number can flip the sign of the product. The key idea is:
- If the current number is positive, the maximum product can either be the current number itself or the product of the maximum product so far and the current number.
- If the current number is negative, the minimum product can become the maximum product when multiplied by the negative number, and vice versa.

By keeping track of both the maximum and minimum products at each step, we can efficiently compute the maximum product of any subarray in a single pass through the array.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Variables
```cpp
int mx = 1, mn = 1;
int res = INT_MIN;
```
We initialize three variables:
- `mx`: This variable will hold the maximum product up to the current index. We initialize it to 1 because the product of no numbers is 1.
- `mn`: This variable holds the minimum product up to the current index. We initialize it to 1 for the same reason as `mx`.
- `res`: This variable will store the global maximum product, which we initialize to the smallest possible integer value (`INT_MIN`), ensuring that any product will be larger.

#### Step 2: Iterate Through the Array
```cpp
for(int i = 0; i < nums.size(); i++) {
    if(nums[i] < 0) swap(mx, mn);
```
We loop through the array `nums` one element at a time. For each element, we check if the current number is negative. If it is, we swap `mx` and `mn` because multiplying a negative number by a larger negative number could turn the smallest product into the largest.

#### Step 3: Update Maximum and Minimum Products
```cpp
    mx = max(nums[i], mx * nums[i]);
    mn = min(nums[i], mn * nums[i]);
```
After handling the negative number case (if necessary), we update the `mx` and `mn` values:
- `mx = max(nums[i], mx * nums[i])`: This ensures that the current number is either treated as a new starting point for the subarray (just `nums[i]`) or the product of the current subarray extended by `nums[i]` (`mx * nums[i]`).
- `mn = min(nums[i], mn * nums[i])`: Similarly, we update `mn` to track the minimum product so far. A negative number may flip the sign of the current minimum product, so it's essential to account for that as well.

#### Step 4: Update Global Maximum
```cpp
    res = max(res, mx);
```
At each step, we update `res` to ensure it always holds the largest product encountered so far.

#### Step 5: Return the Result
```cpp
return res;
```
Once the loop finishes, the value of `res` will be the maximum product of any contiguous subarray in the array, and we return it.

### Complexity

#### Time Complexity:
- **O(n)**, where `n` is the number of elements in the input array `nums`.
  - We only need to traverse the array once, performing constant-time operations for each element (comparing values and updating variables).

#### Space Complexity:
- **O(1)**, since we are only using a constant amount of extra space to store `mx`, `mn`, and `res`. We are not using any additional data structures that depend on the input size.

### Conclusion

This solution is highly efficient with a time complexity of `O(n)` and a space complexity of `O(1)`. The approach cleverly keeps track of both the maximum and minimum products up to the current index to handle the flip in sign caused by negative numbers. By maintaining only a few variables and iterating through the array once, the solution can compute the maximum product of any contiguous subarray in linear time, making it suitable for large inputs.

#### Key Insights:
- The problem hinges on the ability to handle negative numbers properly. A negative number can flip the sign of both the maximum and minimum products, so we need to track both at every step.
- The dynamic programming-like approach used here, which tracks two variables (maximum and minimum), is efficient and avoids the need to explicitly store all subarrays, thus reducing space complexity.

This method is optimal for this problem and works well even when there are a mix of positive and negative numbers in the array.
### Problem Statement

The problem at hand is to find the maximum profit that can be made from buying and selling a stock, given an array of stock prices where each element represents the price of the stock on a particular day. The goal is to determine the maximum profit that can be achieved by buying the stock on one day and selling it on a later day. The catch is that the stock must be bought before it is sold. If no profit is possible, the answer should be `0`.

For example:
- **Input**: `prices = [7, 1, 5, 3, 6, 4]`
- **Output**: `5`
  - Explanation: Buy on day 2 (price = 1), sell on day 5 (price = 6), profit = `6 - 1 = 5`.

- **Input**: `prices = [7, 6, 4, 3, 1]`
- **Output**: `0`
  - Explanation: No transaction can be made because the prices are always decreasing.

### Approach

The key insight into solving this problem is recognizing that the problem can be reduced to tracking the minimum price observed so far and calculating the potential profit by selling at each day's price. To maximize the profit, we need to:
1. Track the minimum price (`l`) encountered at each step.
2. For each price, calculate the potential profit by subtracting the minimum price from the current price.
3. Keep track of the maximum profit (`g`) encountered during the process.

Thus, the algorithm follows these steps:
- Initialize the minimum price `l` to the first element in the `prices` array.
- Iterate through each price:
  - Update the minimum price if the current price is lower than `l`.
  - Calculate the potential profit if the stock were sold at the current price and update the maximum profit if necessary.
- Return the maximum profit after processing all prices.

### Code Breakdown (Step by Step)

#### 1. **Function Signature**
```cpp
int maxProfit(vector<int>& prices)
```
This function takes in a vector of integers `prices` representing the prices of the stock on different days and returns an integer representing the maximum profit that can be made from a single buy and sell transaction.

#### 2. **Initialize Variables**
```cpp
int l = prices[0], g = 0;
```
- `l` is initialized to the first price in the `prices` array. This will represent the lowest price observed so far.
- `g` is initialized to `0`, representing the maximum profit. Initially, no profit has been made.

#### 3. **Iterate Over Prices**
```cpp
for(int x: prices) {
    l = min(l, x);
    g = max(g, x - l);
}
```
- The `for` loop iterates through each price `x` in the `prices` array.
  - `l = min(l, x)`: For each price, we update `l` to be the minimum of the current value of `l` and the current price `x`. This ensures that `l` always holds the lowest price encountered so far.
  - `g = max(g, x - l)`: The potential profit if the stock were sold at the current price `x` is `x - l`. We update `g` to be the maximum of the current `g` and this potential profit, ensuring that `g` holds the highest profit encountered during the loop.

#### 4. **Return the Maximum Profit**
```cpp
return g;
```
After iterating through all prices, the variable `g` will contain the maximum profit that could be made. This is returned as the result.

### Example Walkthrough

Letâ€™s go through an example to see how the algorithm works:

**Input**: `prices = [7, 1, 5, 3, 6, 4]`

1. **Initialization**:
   - `l = 7`, `g = 0`.

2. **Iterate Through Prices**:

   - **Price 7**:
     - `l = min(7, 7) = 7`.
     - `g = max(0, 7 - 7) = 0`.

   - **Price 1**:
     - `l = min(7, 1) = 1`.
     - `g = max(0, 1 - 1) = 0`.

   - **Price 5**:
     - `l = min(1, 5) = 1`.
     - `g = max(0, 5 - 1) = 4`.

   - **Price 3**:
     - `l = min(1, 3) = 1`.
     - `g = max(4, 3 - 1) = 4`.

   - **Price 6**:
     - `l = min(1, 6) = 1`.
     - `g = max(4, 6 - 1) = 5`.

   - **Price 4**:
     - `l = min(1, 4) = 1`.
     - `g = max(5, 4 - 1) = 5`.

3. **Final Output**:
   - The maximum profit is `5`, so the function returns `5`.

### Time Complexity

- **Time Complexity**: `O(n)`
  - The algorithm iterates over the `prices` array once, where `n` is the number of days (or length of the `prices` array). The operations inside the loop (finding the minimum and maximum) are constant time operations, so the overall time complexity is linear with respect to the size of the input array.

- **Space Complexity**: `O(1)`
  - The algorithm only uses a few integer variables (`l` and `g`), and does not require any additional space that grows with the input size. Therefore, the space complexity is constant.

### Conclusion

This solution efficiently solves the problem of finding the maximum profit from a single buy and sell transaction in a list of stock prices. By iterating over the prices once and maintaining the minimum price and the maximum profit encountered, it ensures an optimal solution with a time complexity of `O(n)` and a space complexity of `O(1)`. This makes the solution highly efficient and suitable for large input sizes. The algorithm leverages a greedy approach to ensure that the maximum profit is obtained in the most efficient manner possible.
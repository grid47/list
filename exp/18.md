### Problem Statement

The problem at hand is to find all unique quadruplets in an array that sum up to a specific target. Specifically, given an integer array `nums` and an integer `target`, you need to return all unique quadruplets `[nums[i], nums[j], nums[k], nums[l]]` such that:

- `i < j < k < l`
- `nums[i] + nums[j] + nums[k] + nums[l] == target`

The challenge is to solve this problem in a way that handles large input sizes efficiently while avoiding duplicate quadruplets.

### Approach

This problem is a variant of the "4Sum" problem, which can be solved using a combination of sorting and the two-pointer technique. Here’s the detailed approach for solving the problem efficiently:

#### 1. **Sorting**:
   - The first step is to sort the input array `nums` in ascending order. Sorting helps in efficiently checking combinations and avoiding duplicates.
   - After sorting, we can use two-pointer techniques to find two numbers that sum up to a given target for each pair of numbers.

#### 2. **Using a Set to Track Unique Quadruplets**:
   - We use a set to store the quadruplets. The reason for using a set is that it automatically ensures that all quadruplets are unique. Even if the same quadruplet is encountered multiple times, it will only be stored once.
   - The set will store each quadruplet as a vector of integers, and the set will internally handle the uniqueness based on the values of the quadruplets.

#### 3. **Two Nested Loops for First Two Elements**:
   - The outer two loops iterate over the array to select the first two elements of the quadruplet. These loops are indexed by `i` and `j` such that `i < j`.
   - For each pair `(nums[i], nums[j])`, the remaining two numbers that need to sum to a new target are found using the two-pointer technique.

#### 4. **Two-Pointer Technique for the Remaining Two Elements**:
   - After selecting the first two numbers, we calculate a new target, `newTarget`, which is the original target minus the sum of the first two numbers, i.e., `newTarget = target - nums[i] - nums[j]`.
   - We then use two pointers, `low` and `high`, initialized to the positions just after `j` and at the end of the array, respectively.
   - The two-pointer technique is used to find the other two numbers such that their sum equals `newTarget`. If the sum of the two numbers at `low` and `high` is less than `newTarget`, we increment `low`. If the sum is greater than `newTarget`, we decrement `high`. If the sum is equal to `newTarget`, we add the quadruplet to the set and move both pointers inward.

#### 5. **Storing the Result**:
   - Once all quadruplets are found, we transfer the elements from the set into the output vector. The set ensures that there are no duplicates, and the result is a list of unique quadruplets.

### Code Breakdown (Step by Step)

Here’s how the solution works in detail:

#### Step 1: Sorting the Input Array
```cpp
sort(nums.begin(), nums.end());
```
- The input array `nums` is sorted in ascending order. This makes it easier to manage the two-pointer approach and helps in skipping duplicate elements.

#### Step 2: Outer Loops for First Two Elements
```cpp
for(int i = 0; i < n - 3; i++) {
    for(int j = i + 1; j < n - 2; j++) {
        long long newTarget = (long long)target - (long long)nums[i] - (long long)nums[j];
```
- The outer loops iterate over the first two elements, `nums[i]` and `nums[j]`, of the potential quadruplet. The condition `i < j` ensures that the first element comes before the second element.
- `newTarget` is calculated by subtracting `nums[i]` and `nums[j]` from the target.

#### Step 3: Two-Pointer Approach for Remaining Elements
```cpp
int low = j + 1, high = n - 1;
while (low < high) {
    if (nums[low] + nums[high] < newTarget) {
        low++;
    } else if (nums[low] + nums[high] > newTarget) {
        high--;
    } else {
        set.insert({nums[i], nums[j], nums[low], nums[high]});
        low++; high--;
    }
}
```
- After calculating the `newTarget`, two pointers `low` and `high` are used to find two numbers whose sum is equal to `newTarget`.
- If the sum of `nums[low] + nums[high]` is less than `newTarget`, we increment `low` to increase the sum. If the sum is greater than `newTarget`, we decrement `high` to reduce the sum.
- If the sum equals `newTarget`, we add the quadruplet `{nums[i], nums[j], nums[low], nums[high]}` to the set and move both pointers inward.

#### Step 4: Transfer Results from Set to Output
```cpp
for (auto it : set) {
    output.push_back(it);
}
```
- After all combinations are found, the unique quadruplets stored in the set are transferred to the `output` vector.

#### Step 5: Return the Result
```cpp
return output;
```
- Finally, the function returns the `output` vector containing all unique quadruplets that sum up to the target.

### Complexity

#### Time Complexity:
- **Sorting** the array takes `O(n log n)`.
- The **nested loops** to select the first two elements (`i` and `j`) iterate `O(n^2)` times, where `n` is the length of the input array.
- The **two-pointer approach** inside the loops runs in `O(n)` for each pair of `i` and `j`.
- Overall, the time complexity is **O(n^3)**, where `n` is the size of the input array.

#### Space Complexity:
- The space complexity is primarily determined by the space needed to store the unique quadruplets, which can be at most `O(n^3)` in the worst case.
- Additionally, we use a set to store the unique quadruplets and a vector for the result, so the space complexity is **O(n^3)**.

### Conclusion

The solution to the "4Sum" problem utilizes a combination of sorting and the two-pointer technique, which allows us to efficiently find all unique quadruplets that sum to the target. By sorting the array first and then using a set to store the quadruplets, we can avoid duplicates and ensure the solution is both time-efficient and space-efficient. Although the time complexity is **O(n^3)**, this approach is much faster than a brute-force method, which would have a time complexity of **O(n^4)**. This makes the solution feasible for moderately large input sizes.
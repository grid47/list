### Problem Statement:
The problem asks to find the minimum number of straight cuts required to divide a circle into `n` equal pieces. The number of cuts should be minimized such that each piece is an equal size. If the number of pieces `n` is odd, each cut will increase the number of pieces in the circle, and if the number of pieces is even, fewer cuts will be necessary. The task is to compute the minimum number of cuts based on the value of `n`.

### Approach:
To approach this problem, we need to determine how the number of cuts increases as we attempt to divide the circle into equal parts. The key observation here is:
- **If `n == 1`**, no cuts are required because the circle is already in one piece.
- **If `n` is even**, the minimum number of cuts required to divide the circle into `n` equal pieces is `n / 2`. This is because a single cut can create two equal pieces, and each additional cut can create two more pieces. So, for even `n`, we need exactly `n / 2` cuts.
- **If `n` is odd**, each cut can only increase the number of pieces by 1. To divide the circle into `n` pieces, we need exactly `n` cuts.

This gives us the following insights:
- For even `n`, we can cut the circle into two equal parts each time and continue halving until we have `n` parts. The number of cuts required will be `n / 2`.
- For odd `n`, each cut can only add one additional piece, so we need `n` cuts to reach `n` pieces.

### Code Breakdown (Step by Step):
Let’s break down the code line by line:

```cpp
class Solution {
public:
    int numberOfCuts(int n) {
        if (n == 1) return 0;
        return n % 2 ? n : n / 2;
    }
};
```

1. **Class Definition**:
   - The class `Solution` encapsulates the function that calculates the number of cuts.

2. **Function Definition**:
   - `int numberOfCuts(int n)` is the function that calculates and returns the minimum number of cuts required to divide the circle into `n` pieces.
   - The function takes a single parameter `n`, which represents the number of pieces we want to divide the circle into.

3. **Base Case**:
   ```cpp
   if (n == 1) return 0;
   ```
   - This condition checks if `n` is 1. If `n` is 1, it means the circle is already in one piece, so no cuts are required. The function immediately returns 0 in this case.

4. **Even or Odd Case**:
   ```cpp
   return n % 2 ? n : n / 2;
   ```
   - This line uses the ternary operator to determine whether `n` is odd or even.
   - **If `n` is odd**: The expression `n % 2` will be true (non-zero), and the function will return `n`. This means that we need exactly `n` cuts to divide the circle into `n` equal pieces when `n` is odd.
   - **If `n` is even**: The expression `n % 2` will be false (zero), and the function will return `n / 2`. This means that when `n` is even, we only need `n / 2` cuts to divide the circle into `n` equal pieces.

### Complexity:
- **Time Complexity**: 
  - The function performs a constant-time operation for both the base case check (`n == 1`) and for the decision to return either `n` or `n / 2` based on whether `n` is odd or even. Both of these operations are \(O(1)\).
  - Therefore, the time complexity of this solution is **O(1)**.

- **Space Complexity**: 
  - The space complexity is also **O(1)** because the function only uses a constant amount of space to store variables (i.e., no data structures that grow with the input size are used).

### Conclusion:
The function `numberOfCuts` efficiently calculates the minimum number of straight cuts required to divide a circle into `n` equal pieces. The solution leverages a simple condition to check whether `n` is even or odd and computes the result accordingly in constant time. The algorithm’s time and space complexities are both \(O(1)\), making it extremely efficient and scalable even for large inputs. This makes the solution ideal for scenarios where performance is crucial, and the problem size can be large. The simplicity of the solution ensures that it runs with minimal computational overhead.
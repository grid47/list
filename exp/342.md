### üöÄ Problem Statement

In this problem, we're asked to check if a given number `num` is a power of four. A number is considered a power of four if it can be expressed as `4^x` where `x` is a non-negative integer. Essentially, we need to determine if there exists an integer `x` such that `num == 4^x`.

#### Example:
- `16` is a power of four because it can be expressed as `4^2`.
- `5` is **not** a power of four because no such integer `x` exists where `4^x == 5`.

---

### üß† Approach

We can solve this problem efficiently by leveraging two key properties of numbers:

1. **Power of Two Property**:
   - A power of four is always a power of two. This means that if a number is a power of four, it will have exactly one `1` bit set in its binary representation.
   - You can check if a number is a power of two using the condition `num & (num - 1) == 0`, which works because numbers that are powers of two have only one `1` bit.

2. **Divisibility by Three**:
   - When you subtract 1 from a power of four, the result is always divisible by 3. For example:
     - `4^1 = 4`, and `4 - 1 = 3`, which is divisible by 3.
     - `4^2 = 16`, and `16 - 1 = 15`, which is divisible by 3.
     - `4^3 = 64`, and `64 - 1 = 63`, which is divisible by 3.
   - So, if `num - 1` is divisible by 3, it's a good indicator that `num` is a power of four.

By combining these properties, we can check if a number is a power of four in a very efficient manner!

---

### üî® Step-by-Step Code Breakdown

Let‚Äôs walk through the code that implements this solution:

```cpp
bool isPowerOfFour(int num) {
    return num > 0 && (num & (num - 1)) == 0 && (num - 1) % 3 == 0;
}
```

#### Step 1: Check if `num` is positive
```cpp
num > 0
```
- We first check if `num` is greater than zero. Powers of four are always positive, so if `num` is non-positive, we immediately return `false`.

#### Step 2: Check if `num` is a power of two
```cpp
(num & (num - 1)) == 0
```
- This bitwise operation checks if `num` is a power of two. It works because numbers that are powers of two have only one `1` bit in their binary representation.
- For example, `16` (which is `10000` in binary) and `8` (which is `1000` in binary) will satisfy this condition because subtracting `1` from these numbers flips all the bits to the right of the highest `1` bit, leaving no common bits.

#### Step 3: Check if `num - 1` is divisible by 3
```cpp
(num - 1) % 3 == 0
```
- This checks if the number `num - 1` is divisible by 3. As we mentioned earlier, subtracting 1 from a power of four always results in a number that is divisible by 3.

#### Final Return Value:
- The function will return `true` if all three conditions are satisfied:
  1. `num` is positive.
  2. `num` is a power of two.
  3. `num - 1` is divisible by 3.

---

### üìà Complexity Analysis

#### Time Complexity:
- **O(1)**: The function only performs a few simple operations‚Äîeach of which runs in constant time. So, the overall time complexity is constant.

#### Space Complexity:
- **O(1)**: We only use a few variables and a constant amount of space to perform the checks, so the space complexity is constant as well.

---

### üèÅ Conclusion

We‚Äôve successfully solved the problem using an efficient approach based on bitwise operations and modular arithmetic. Here‚Äôs a recap:

#### Key Points:
- **Power of Two**: A power of four is always a power of two. We can check if a number is a power of two using a simple bitwise operation.
- **Divisibility by Three**: The difference between any power of four and one is divisible by 3, which helps us identify powers of four specifically.
- **Efficiency**: The solution works in constant time and uses constant space, making it optimal.

By mastering this approach, you'll be able to quickly determine if a number is a power of four‚Äîperfect for performance-critical applications or coding interviews! Keep practicing and improving your problem-solving skills! üí™üöÄ
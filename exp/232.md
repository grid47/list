### Problem Statement

In this problem, we are tasked with implementing a queue using two stacks. A queue is a linear data structure that follows the **First In, First Out (FIFO)** principle, which means that the first element added to the queue is the first one to be removed.

The goal is to design a queue with the following operations:
1. **push(x)**: Push the element `x` to the back of the queue.
2. **pop()**: Removes the element from the front of the queue and returns it.
3. **peek()**: Returns the element at the front of the queue without removing it.
4. **empty()**: Returns `true` if the queue is empty, otherwise `false`.

However, the challenge is to implement these operations using two **stacks**. A stack follows the **Last In, First Out (LIFO)** principle, so the queue must be simulated using stack operations.

### Approach

To simulate a queue using stacks, we need to exploit the stack's LIFO behavior and adapt it so we can perform queue operations (FIFO). This can be done by maintaining two stacks: `s1` for pushing elements and `s2` for popping and peeking elements.

#### Steps:
1. **Push Operation**: 
   - We push the new element onto the first stack (`s1`). This operation is straightforward as stacks naturally support adding elements to the top.
   
2. **Pop Operation**:
   - To dequeue an element, we first check if the second stack (`s2`) is empty. If it is empty, we transfer all elements from the first stack (`s1`) to the second stack (`s2`). This reversal ensures that the oldest element (which was first pushed into the queue) is now at the top of `s2`, ready to be popped.
   - If `s2` is not empty, we simply pop the top element from `s2`, which corresponds to the front of the queue.
   
3. **Peek Operation**:
   - The peek operation follows the same logic as the pop operation. If `s2` is empty, we transfer elements from `s1` to `s2`. We then return the element at the top of `s2` without removing it.
   
4. **Empty Operation**:
   - The queue is empty if both stacks are empty. So we check if both `s1` and `s2` are empty and return `true` if both are empty, otherwise `false`.

### Code Breakdown (Step by Step)

```cpp
class MyQueue {
public:
    stack<int> s1, s2;
```
- We define a class `MyQueue` and declare two stacks, `s1` and `s2`. Stack `s1` is used to push new elements, and stack `s2` is used for popping and peeking.

```cpp
    MyQueue() {
        
    }
```
- The constructor initializes the queue. Both stacks `s1` and `s2` are empty initially, so no additional initialization is required.

```cpp
    void push(int x) {
        s1.push(x);
    }
```
- The `push` function adds an element `x` to the back of the queue. We simply push the element onto `s1`, which is the first stack.

```cpp
    int pop() {
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        int x = s2.top();
        s2.pop();
        return x;
    }
```
- The `pop` function removes and returns the element from the front of the queue. If `s2` is empty, we transfer all elements from `s1` to `s2`. This ensures that the oldest element, which should be popped first, is now at the top of `s2`. After transferring, we pop the top element from `s2` and return it.

```cpp
    int peek() {
        if(s2.empty()) {
            while(!s1.empty()) {
                s2.push(s1.top());
                s1.pop();
            }
        }
        return s2.top();
    }
```
- The `peek` function is similar to `pop`, but it only returns the element at the front of the queue without removing it. If `s2` is empty, we transfer elements from `s1` to `s2`. After the transfer, we return the top element of `s2`.

```cpp
    bool empty() {
        return s1.empty() && s2.empty();
    }
};
```
- The `empty` function checks if both stacks `s1` and `s2` are empty. If both are empty, the queue is empty, and the function returns `true`. Otherwise, it returns `false`.

### Complexity

#### Time Complexity:
- **push(x)**: The time complexity of the push operation is **O(1)** because we simply push the element onto `s1`, which is a constant time operation.
  
- **pop()**: The time complexity of the pop operation is **O(n)** in the worst case, where `n` is the number of elements in the queue. This happens when `s2` is empty and we need to transfer all elements from `s1` to `s2`. After the transfer, popping from `s2` takes constant time **O(1)**.

- **peek()**: The time complexity of the peek operation is also **O(n)** in the worst case, similar to `pop()`, since we might need to transfer elements from `s1` to `s2`. After the transfer, peeking from `s2` is **O(1)**.

- **empty()**: The time complexity of the empty operation is **O(1)**, as it only checks if both stacks `s1` and `s2` are empty.

#### Space Complexity:
- **Space Complexity**: The space complexity is **O(n)**, where `n` is the number of elements in the queue. We store all elements in the two stacks, and the space is proportional to the number of elements.

### Conclusion

This solution implements a queue using two stacks and provides all the necessary operations (`push`, `pop`, `peek`, and `empty`) to mimic the behavior of a queue. The use of two stacks ensures that the **First In, First Out (FIFO)** principle is maintained while taking advantage of the **Last In, First Out (LIFO)** behavior of stacks. Although the time complexity of the `pop()` and `peek()` operations can be **O(n)** in the worst case when transferring elements between stacks, this approach is simple and elegant. 

#### Key Highlights:
- **Efficient Queue Operations**: Even though the transfer between stacks occurs, the algorithm simulates queue operations using a small number of stack manipulations.
- **Space Efficient**: The space complexity is linear in relation to the number of elements, which is typical for a queue.
  
This solution is particularly useful in situations where you need to simulate queue operations using stacks, making it an ideal choice for certain types of coding interviews and algorithm challenges.
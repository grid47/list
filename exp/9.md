### Problem Statement

The problem asks us to determine whether a given integer is a palindrome. A number is considered a palindrome if it reads the same forwards and backwards. For example, `121` is a palindrome, but `123` is not. The challenge requires us to implement an efficient solution that checks if a number is a palindrome without converting the number to a string.

### Example:

1. `isPalindrome(121)` → `true`
2. `isPalindrome(-121)` → `false` (negative numbers are not considered palindromes)
3. `isPalindrome(10)` → `false` (as 10 is not a palindrome)

### Approach

To determine if an integer `x` is a palindrome, we can follow these steps:

1. **Negative Numbers**: A negative number can never be a palindrome since a palindrome is always positive (the negative sign doesn't mirror itself in a reverse number). Hence, the function immediately returns `false` if `x` is less than 0.
2. **Reversing the Number**: We can reverse the digits of the number and compare the reversed number with the original. If they are the same, then the number is a palindrome; otherwise, it is not.
3. **Optimization Considerations**: 
   - The function needs to handle overflow or potential integer size limitations. Hence, we'll work with a `long long int` to avoid overflow when reversing the number.

### Code Breakdown (Step by Step)

#### Step 1: Handle Negative Numbers

```cpp
if(x < 0) return false;
```

- The first check is to handle negative numbers. Since a negative number cannot be a palindrome (the negative sign is on the left and doesn't reflect in the reverse), if `x` is negative, the function returns `false` immediately.

#### Step 2: Set Up Variables for Reversal

```cpp
long long int y = x, z = 0;
```

- We create two variables:
  - `y`: Stores the original value of `x`. This will be used to compare against the reversed value to check for equality later.
  - `z`: Will be used to store the reversed number. Initially, it's set to `0`.

#### Step 3: Reverse the Digits of the Number

```cpp
while(x) {
    z = z * 10 + x % 10;
    x /= 10;
}
```

- We enter a loop where the number `x` is repeatedly divided by 10, and each digit is extracted using the modulus operator (`% 10`).
- The extracted digit is added to `z`, and the number `x` is divided by `10` to move on to the next digit. The digits of `x` are added to `z` in reverse order, effectively reversing the number.

#### Step 4: Compare the Reversed Number with the Original

```cpp
return y == z;
```

- Once the entire number has been reversed, we compare the reversed number (`z`) with the original number (`y`). If they are equal, it means the number is a palindrome, and the function returns `true`. Otherwise, it returns `false`.

### Complexity

#### Time Complexity:

- **O(log(x))**: The time complexity is logarithmic because we are dividing the number `x` by 10 in each iteration, and the number of iterations depends on how many digits the number has. The number of digits in `x` is proportional to the logarithm of `x`.

#### Space Complexity:

- **O(1)**: The space complexity is constant because we only use a fixed amount of extra space for the variables `y` and `z` (both integers), regardless of the input size.

### Conclusion

This solution is both efficient and easy to understand. It works by reversing the digits of the number and comparing the reversed number with the original. This method ensures that we can check if a number is a palindrome without converting the number into a string, which might be inefficient or unnecessary for larger numbers.

- **Handling of Negative Numbers**: The algorithm immediately rejects negative numbers as palindromes.
- **Reversal Approach**: By reversing the digits and comparing, we can determine whether the number is the same forwards and backwards.
- **Efficiency**: The solution runs in logarithmic time and uses constant space, making it optimal for large numbers. 

This approach is simple, avoids unnecessary conversions, and works efficiently for a wide range of integer inputs.

### Problem Statement
The task is to sort the array `arr1` based on the relative order defined by another array `arr2`. The sorting should follow these rules:
1. The elements in `arr1` that are present in `arr2` should appear in the same order as they appear in `arr2`.
2. The elements in `arr1` that are not present in `arr2` should be sorted in ascending order and should appear after all elements that are in `arr2`.

For example, given `arr1 = [2, 1, 2, 5, 3, 3]` and `arr2 = [2, 1]`, the output should be `[2, 2, 1, 3, 3, 5]`, as `2` comes first (appearing twice), followed by `1`, and finally the remaining elements sorted.

### Approach
To achieve the required sorting, the algorithm follows these steps:
1. **Index Mapping**: Create an array to map the indices of elements in `arr2`. This allows for efficient comparison when sorting `arr1`.
2. **Custom Sorting**: Use a custom comparator with the `sort` function to sort `arr1` based on the mapped indices. If two elements from `arr1` are both present in `arr2`, they will be sorted based on their indices in `arr2`. If they are not both present, they will be sorted by their values in ascending order.

### Code Breakdown (Step by Step)

1. **Class Definition**: The `Solution` class is defined, which contains the public method `relativeSortArray`.

   ```cpp
   class Solution {
   public:
   ```

2. **Method Definition**: The method `relativeSortArray` takes two vectors, `arr1` and `arr2`, and returns the sorted version of `arr1`.

   ```cpp
       vector<int> relativeSortArray(vector<int>& arr1, vector<int>& arr2) {
   ```

3. **Variable Initialization**: The sizes of `arr1` and `arr2` are stored in `n1` and `n2`, respectively. An auxiliary array `a2i` is initialized to hold the indices of elements in `arr2`.

   ```cpp
           int n1 = arr1.size(), n2 = arr2.size();
           int a2i[1001]; // Assuming the range of arr2 values is [0, 1000]
   ```

4. **Index Mapping**: The `fill` function initializes all elements of `a2i` to `n2`, which indicates that the elements are not present in `arr2`. A loop is then used to map the indices of each element in `arr2` to `a2i`.

   ```cpp
           fill(a2i, end(a2i), n2); // Fill the array with a value indicating "not present"
           for(int i = 0; i < n2; i++)
               a2i[arr2[i]] = i; // Map the element to its index in arr2
   ```

5. **Custom Sorting Logic**: The `sort` function is called on `arr1`, with a lambda function as the comparator. This lambda function compares the indices from `a2i` for two elements and decides their order based on the mapped indices or the values themselves.

   ```cpp
           sort(arr1.begin(), arr1.end(), [&](int x, int y) {
               if (a2i[x] == a2i[y]) return x < y; // If both are in arr2, sort by value
               return a2i[x] < a2i[y]; // Otherwise, sort by index in arr2
           });
   ```

6. **Return Result**: Finally, the sorted array `arr1` is returned.

   ```cpp
           return arr1;
       }
   };
   ```

### Complexity Analysis
- **Time Complexity**: The overall time complexity of this solution is \(O(n \log n)\), where \(n\) is the size of `arr1`. This is due to the sorting operation.
- **Space Complexity**: The space complexity is \(O(1)\) if we consider the auxiliary space for the index mapping, as `a2i` has a constant size regardless of the input size.

### Conclusion
The `relativeSortArray` function effectively sorts `arr1` based on the relative order specified by `arr2`, leveraging a custom sorting mechanism with a precomputed index mapping. This approach ensures that the elements of `arr1` that are present in `arr2` are arranged in the desired order, while the remaining elements are sorted in ascending order.

The use of a lambda function for custom comparison demonstrates a powerful feature of C++'s Standard Template Library (STL), allowing for elegant and efficient code. This implementation is not only optimal in terms of time complexity but also easy to understand, making it a valuable tool for developers dealing with similar sorting and ordering problems.

In summary, this solution highlights effective techniques for manipulating and sorting arrays in C++, showcasing best practices in algorithm design and implementation. It serves as an excellent reference for those looking to deepen their understanding of sorting algorithms, data structures, and the capabilities of the C++ STL.

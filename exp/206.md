### Problem Statement

The problem requires reversing a **singly linked list**. Given the head of a singly linked list, the goal is to reverse the list such that the last node becomes the first, and the first becomes the last. The function must return the head of the reversed list.

#### Example:
- **Input:** `head = [1, 2, 3, 4, 5]`
- **Output:** `head = [5, 4, 3, 2, 1]`

The function must be efficient in terms of both time and space, operating in linear time complexity and constant space.

### Approach

The problem can be solved using an **iterative approach** by maintaining three pointers:
1. **`head`**: Initially points to the first node of the list.
2. **`prv` (previous)**: Initially set to `nullptr` because the new tail will point to `nullptr`.
3. **`nxt` (next)**: This will store the next node in the list while rearranging the links.

#### Step-by-Step Approach:
1. **Initialize pointers:** 
   - `prv` is set to `nullptr` because the last node will point to `nullptr` after reversing.
   - `nxt` is temporarily used to store the next node of the current node so that we don’t lose track of the remaining list.
2. **Iterate through the list:** 
   - For each node, set its `next` pointer to the previous node (`prv`).
   - Move the `prv` pointer to the current node.
   - Move the `head` pointer to the next node (`nxt`).
3. **End condition:** When `head` becomes `nullptr`, the list is fully reversed, and the `prv` pointer will point to the new head of the reversed list.

The method is **iterative**, so there is no need for recursion, which helps in reducing the overhead of function calls, making the solution space-efficient.

### Code Breakdown (Step by Step)

#### Step 1: Initialize Pointers
```cpp
ListNode* nxt, *prv = NULL;
```
- **`nxt`**: A temporary pointer to store the next node of the list, ensuring we don’t lose track of the rest of the list when we modify the `next` pointer of the current node.
- **`prv`**: The previous node, initially set to `nullptr`, which will ultimately become the new head of the reversed list.

#### Step 2: Traverse the List
```cpp
while(head) {
    nxt = head->next; // Store the next node
    head->next = prv; // Reverse the current node's next pointer
    prv = head;       // Move `prv` to the current node
    head = nxt;       // Move to the next node in the list
}
```
- **Loop condition:** The loop continues as long as `head` is not `nullptr`. The list is traversed from the start to the end.
- **`nxt = head->next`:** We temporarily store the next node so we don’t lose the reference to the rest of the list.
- **`head->next = prv`:** The core operation where we reverse the `next` pointer of the current node to point to the previous node.
- **`prv = head`:** We then move the `prv` pointer to the current node, preparing for the next iteration.
- **`head = nxt`:** Move `head` to the next node in the list, which was stored in `nxt`.

#### Step 3: Return the New Head
```cpp
return prv;
```
- After the loop completes, `prv` will be pointing to the new head of the reversed list. We return `prv` as the result.

### Complexity Analysis

#### Time Complexity:
- **O(n):** 
  - We iterate through each node of the list exactly once, where `n` is the number of nodes in the list. In each iteration, we perform a constant amount of work (updating pointers), so the overall time complexity is linear in the size of the list.

#### Space Complexity:
- **O(1):**
  - The space complexity is constant because we are only using a few additional pointers (`prv`, `nxt`), regardless of the size of the input list. The space used does not depend on the size of the input list, so the space complexity is constant.

### Conclusion

The solution provided efficiently reverses a singly linked list using an iterative approach with three pointers. This method is optimal in terms of time complexity, operating in **O(n)**, where `n` is the number of nodes in the list. The space complexity is **O(1)**, making it highly space-efficient since only a few pointers are used, regardless of the size of the list.

#### Key Advantages:
1. **Time Efficiency:** The algorithm runs in linear time, which is the best achievable time complexity for this problem, as we need to visit each node.
2. **Space Efficiency:** It uses constant space, which is ideal for handling large lists as it avoids the overhead of recursion or additional data structures.
3. **Simplicity:** The iterative approach is simple to understand and avoids the complexities of recursion, making the code easy to maintain and debug.

This solution is well-suited for reversing linked lists in situations where both time and space efficiency are crucial. It handles even the largest input sizes efficiently and is an excellent choice for problems that involve manipulating singly linked lists.
### Problem Statement

The problem is to determine the minimum number of **columns** that need to be deleted from a list of strings such that the remaining columns are sorted in non-decreasing order. A column is sorted if the characters in that column (when read top-to-bottom) form a sequence that is lexicographically non-decreasing. The goal is to find the smallest number of columns to delete while ensuring that the remaining columns are sorted.

### Approach

The problem can be approached by using a **dynamic programming (DP)** technique. The key idea is to treat this as a problem of finding the longest subsequence of columns that are already sorted, and then removing all the others. Here's a step-by-step breakdown of the approach:

1. **Dynamic Programming Setup**:
   - We will maintain two memoization tables:
     - `memo[idx][prv]`: This table stores the length of the longest valid subsequence starting at column `idx` with the previous column being `prv`. If the subsequence ends at column `idx`, it ensures that the characters at column `idx` are greater than or equal to the characters in the column `prv`.
     - `cmem[idx][prv]`: This table stores a boolean value indicating whether column `idx` is lexicographically greater than or equal to column `prv` across all rows in the input strings.
   
2. **Lexicographical Check**:
   - Before considering whether two columns can form a valid subsequence, we need to check if the characters in the current column are greater than or equal to the characters in the previous column for all the strings. This check is done in the `check(idx, prv)` function, which compares the characters in `strs[i][idx]` and `strs[i][prv]`.

3. **Recursive DP Function**:
   - The `dp(idx, prv)` function computes the length of the longest subsequence of columns starting from column `idx`, given that the previous column was `prv`.
   - If the characters in the current column (`idx`) are valid in the context of the previous column (`prv`), then we can include this column in the subsequence. Otherwise, we skip the current column and proceed to the next.
   - The `dp` function uses memoization to store already computed values for subproblems, which reduces redundant calculations and optimizes the solution.

4. **Result Calculation**:
   - The final result is computed by subtracting the length of the longest valid subsequence (obtained from the `dp(0, -1)` call) from the total number of columns. The result represents the minimum number of columns that need to be deleted.

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    vector<string> strs;  // A vector of strings to store the input list of strings.
    int memo[101][105], cmem[101][105];  // Memoization tables to store intermediate results.

    bool check(int idx, int prv) {
        // This function checks if the column idx is lexicographically greater than or equal to column prv.
        if(cmem[idx][prv] != -1) return cmem[idx][prv];  // Return previously computed result if it exists.

        // Loop through each string in strs and check if strs[i][idx] >= strs[i][prv].
        for(int i = 0; i < strs.size(); i++) {
            if(strs[i][idx] < strs[i][prv])
                return cmem[idx][prv] = false;  // If any string fails the condition, mark it false.
        }
        return cmem[idx][prv] = true;  // If all strings pass the condition, mark it true.
    }

    int dp(int idx, int prv) {
        // This is the recursive DP function to calculate the longest subsequence of columns.
        if(idx == strs[0].size()) return 0;  // Base case: If we've processed all columns, return 0.
        
        if(memo[idx][prv + 1] != -1) return memo[idx][prv + 1];  // Return memoized result if already computed.

        // Recursively calculate the result without including the current column.
        int ans = dp(idx + 1, prv);
        
        // If the previous column was -1 (indicating no previous column) or the current column is valid in the context
        // of the previous column, consider including the current column in the subsequence.
        if(prv == -1 || check(idx, prv)) {
            ans = max(ans, dp(idx + 1, idx) + 1);  // Take the maximum between including or excluding the column.
        }
        
        return memo[idx][prv + 1] = ans;  // Memoize the result for future use.
    }

    int minDeletionSize(vector<string>& strs) {
        this->strs = strs;  // Store the input strings in the strs member variable.
        memset(memo, -1, sizeof(memo));  // Initialize memoization table with -1.
        memset(cmem, -1, sizeof(cmem));  // Initialize cmem table with -1.

        return strs[0].size() - dp(0, -1);  // Subtract the length of the longest subsequence from the total columns.
    }
};
```

1. **Initialization**:
   - The input list of strings is stored in the `strs` variable. We initialize two memoization tables `memo` and `cmem` to store intermediate results for the DP and lexicographical checks.

2. **Check Function**:
   - The `check` function compares two columns (`idx` and `prv`) for each string. If any character in the column `idx` is less than the corresponding character in column `prv`, it returns false, indicating that these columns cannot form a valid subsequence. Otherwise, it returns true.

3. **Recursive DP Function**:
   - The `dp` function recursively calculates the longest subsequence of columns. It checks if the current column can be included in the subsequence by either skipping the current column or including it if it's lexicographically valid. The results are memoized to avoid redundant computations.

4. **Result Calculation**:
   - The function `minDeletionSize` calls the `dp` function starting from the first column (index 0) with no previous column (`-1`), and then returns the total number of columns minus the length of the longest valid subsequence.

### Complexity

- **Time Complexity**: 
  - The time complexity is **O(m * n)**, where `m` is the number of strings and `n` is the number of columns. This is because we perform a check for every pair of columns (`check` function) and calculate the longest subsequence using a DP approach. For each pair of columns, we perform a linear scan across all strings, resulting in a complexity of `O(m * n)`.
  
- **Space Complexity**: 
  - The space complexity is **O(m * n)** due to the storage required for the memoization tables (`memo` and `cmem`). These tables store intermediate results for each pair of columns, and thus require space proportional to the size of the input grid (`m` rows and `n` columns).

### Conclusion

This solution efficiently solves the problem of finding the minimum number of columns to delete in order to make the remaining columns sorted. By using dynamic programming and memoization, we avoid redundant calculations, making the solution both time and space efficient. The approach carefully handles the lexicographical checks for valid subsequences and ensures that we compute the longest subsequence of columns that can remain after deletion.
### Problem Statement

The problem at hand is to calculate the number of ways to tile a `2 x n` grid using dominoes (2x1 tiles) and trominoes (2x2 tiles). The solution must return the result modulo `10^9 + 7`. This problem is a variation of the famous "domino tiling problem" and requires the computation of different ways to tile the grid based on the size of `n`.

Given `n`, the number of columns in the grid, we are tasked with determining the number of ways to fill the entire grid with dominoes and trominoes, under the constraint that the grid dimensions are `2 x n`.

### Approach

The problem is a classical dynamic programming problem. To break it down efficiently, we observe a pattern in the number of ways to tile grids of different sizes. Let's define a function `dp(n)` that represents the number of ways to tile a `2 x n` grid.

We can approach this problem by considering the following:

1. **Base Cases**:
   - A `2 x 1` grid can only be tiled in one way (using a single domino). Thus, `dp(1) = 1`.
   - A `2 x 2` grid can be tiled in two ways: two dominoes (vertically) or one tromino. Thus, `dp(2) = 2`.
   - A `2 x 3` grid can be tiled in five ways, using combinations of dominoes and trominoes. Thus, `dp(3) = 5`.

2. **Recursive Formula**:
   For `n > 3`, we can deduce that:
   - You can always add a vertical domino to a `2 x (n-1)` grid.
   - Alternatively, you can add two horizontal dominoes to a `2 x (n-2)` grid.
   - You can also add a tromino (which covers a `2 x 2` area) to a `2 x (n-3)` grid.

   This leads to the recursive relation:
   \[
   dp(n) = 2 \times dp(n-1) + dp(n-3)
   \]
   The reasoning behind this formula is:
   - The term `2 \times dp(n-1)` accounts for placing a vertical domino and then solving the problem for a grid of size `2 x (n-1)`.
   - The term `dp(n-3)` corresponds to placing a tromino and solving the problem for a grid of size `2 x (n-3)`.

3. **Modulo Operation**:
   Since the result can grow very large, we compute the result modulo `10^9 + 7` to prevent integer overflow and ensure the result fits within standard integer limits.

### Code Breakdown (Step by Step)

Let's walk through the code line by line to understand how the dynamic programming approach is implemented:

```cpp
class Solution {
public:
    int numTilings(int n) {
        int mod = 1e9 + 7;  // Define the modulus for large number handling
        vector<long long> v(10001, 0);  // Create a vector to store the DP values, initialized to 0
        v[1] = 1;  // Base case: 1 way to tile a 2x1 grid
        v[2] = 2;  // Base case: 2 ways to tile a 2x2 grid
        v[3] = 5;  // Base case: 5 ways to tile a 2x3 grid
        if(n <= 3) return v[n];  // If n is 3 or less, directly return the precomputed value
        for(int i = 4; i <= n; i++) {  // Loop to fill the DP table for values n >= 4
            v[i] = (2 * v[i-1] + v[i-3]);  // Apply the recurrence relation
            v[i] %= mod;  // Take the result modulo 10^9 + 7 to prevent overflow
        }
        return v[n];  // Return the result for dp(n)
    }
};
```

### Explanation of the Code

1. **Initialization**:
   - We define a large modulus value `mod = 1e9 + 7` to handle large results and prevent overflow.
   - We initialize a vector `v` of size 10001 (which covers all possible values of `n` up to the maximum value of `n = 10000`). This vector is used to store the computed results for each `n`. It is initialized with all zeros.

2. **Base Case Setup**:
   - `v[1] = 1`: There is only one way to tile a `2 x 1` grid.
   - `v[2] = 2`: There are two ways to tile a `2 x 2` grid (either two vertical dominoes or one tromino).
   - `v[3] = 5`: There are five ways to tile a `2 x 3` grid.

3. **Handling Small Values of `n`**:
   - If `n` is 1, 2, or 3, the function immediately returns the precomputed value from the `v` vector.

4. **Iterative Calculation**:
   - The loop iterates from `i = 4` to `n`, applying the recurrence relation for each `i`:
   \[
   dp(i) = 2 \times dp(i-1) + dp(i-3)
   \]
   - The result is taken modulo `10^9 + 7` after each calculation to prevent the value from growing too large.

5. **Final Result**:
   - After the loop completes, the value `v[n]` contains the number of ways to tile a `2 x n` grid, which is then returned.

### Complexity Analysis

- **Time Complexity**:
  The time complexity of this solution is **O(n)**, where `n` is the input value. The loop iterates from `i = 4` to `n`, and each iteration performs constant-time operations: the recurrence calculation and modulo operation.

  Thus, the overall time complexity is linear in terms of `n`, i.e., **O(n)**.

- **Space Complexity**:
  The space complexity is **O(n)** because the solution uses a vector `v` of size `n` to store the results of the dynamic programming computation. Since the size of `n` is constrained by the problem, this space usage is efficient.

### Conclusion

This solution provides an efficient and elegant way to solve the tiling problem using dynamic programming. By leveraging a recurrence relation and storing intermediate results, we can compute the number of ways to tile a `2 x n` grid in linear time. The space complexity is also linear, making this solution both time-efficient and space-efficient.

- **Key Takeaways**:
  - The solution uses dynamic programming to build up the number of ways to tile grids of increasing size.
  - The recurrence relation is based on adding vertical dominoes, horizontal dominoes, and trominoes to smaller subproblems.
  - The result is computed modulo `10^9 + 7` to handle large values and prevent overflow.
  
- **Efficiency**:
  - **Time Complexity**: O(n), where `n` is the size of the grid.
  - **Space Complexity**: O(n), storing intermediate results.

This solution is optimal for the problem and works efficiently within the given constraints.
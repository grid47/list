### Problem Statement

The problem at hand is to calculate the **maximum depth** (or height) of a binary tree. The depth of a binary tree is the length of the longest path from the root node down to the farthest leaf node. This path includes the root and all nodes along the way to the leaf.

Given the root node of a binary tree, we need to find the maximum depth of the tree.

### Approach

To solve this problem, we can use a **recursive depth-first search (DFS)** approach. Here's how we can think about the problem:

- If the tree is empty (i.e., the root is `NULL`), the depth is `0`.
- Otherwise, the maximum depth of the tree is **1 plus the maximum depth of its left and right subtrees**.

This approach can be broken down into the following steps:

1. **Base Case:** If the current node is `NULL`, return a depth of `0`. This represents the case where we've reached beyond a leaf node in the tree.
2. **Recursive Case:** If the current node is not `NULL`, recursively calculate the maximum depth of both the left and right subtrees and return the maximum of the two depths, adding `1` for the current node.

### Code Breakdown (Step by Step)

#### Step 1: Base Case

```cpp
if(root == NULL) return 0;
```

- The first line of the function checks if the `root` node is `NULL`, which would mean the tree is empty (or we have reached a leaf node's child).
- If the node is `NULL`, the function returns a depth of `0`, indicating that we've reached the end of a path.

#### Step 2: Recursive Case

```cpp
return 1 + max(maxDepth(root->left), maxDepth(root->right));
```

- If the node is not `NULL`, the function proceeds by recursively calling `maxDepth` on the left and right child nodes (`root->left` and `root->right`).
- The `max` function is used to select the maximum of the two depths returned from the left and right subtrees. This ensures that the function keeps track of the longest path.
- Finally, we add `1` to account for the current node itself, as we are calculating the total depth of the tree from the root.

### Complexity Analysis

#### Time Complexity

The time complexity of this solution is **O(n)**, where `n` is the number of nodes in the binary tree. This is because the function needs to visit each node exactly once to calculate the depth of the left and right subtrees.

For each node, the `maxDepth` function is called recursively on both its left and right children. As each node is visited once, the total time complexity is proportional to the number of nodes in the tree.

#### Space Complexity

The space complexity of this solution is **O(h)**, where `h` is the height of the binary tree. This is due to the recursive call stack that keeps track of function calls during the depth-first traversal of the tree.

- In the worst case, the tree could be skewed (i.e., a linked list), and the height `h` would be equal to `n`. In this case, the space complexity would be **O(n)**.
- In the best case, where the tree is balanced, the height `h` would be **O(log n)**, and the space complexity would be **O(log n)**.

Thus, the space complexity depends on the shape of the tree.

### Example Walkthrough

Let's walk through an example to see how the code works:

#### Example 1: Balanced Binary Tree

Consider the following binary tree:

```
        1
       / \
      2   3
     / \
    4   5
```

- Starting at the root (`1`), we recursively calculate the depth of its left and right subtrees.
- The left subtree has root `2`, and its maximum depth is `1 + max(2, 2)` where `2` is the depth of the left and right subtrees (`4` and `5`). So, the depth of the left subtree is `2`.
- The right subtree has root `3`, and its maximum depth is `1` (since it has no children).
- Finally, the depth of the entire tree is `1 + max(2, 1) = 3`.

Thus, the maximum depth of the tree is `3`.

#### Example 2: Skewed Binary Tree

Consider the following binary tree:

```
    1
     \
      2
       \
        3
         \
          4
```

- Starting at the root (`1`), we recursively calculate the depth of its left and right subtrees.
- The left subtree of node `1` is `NULL`, so its depth is `0`.
- The right subtree of node `1` has root `2`, and we continue calculating the depth in the same manner.
- The depth of the tree is `1 + max(0, 3) = 4`.

Thus, the maximum depth of the skewed tree is `4`.

### Conclusion

This solution efficiently computes the **maximum depth** of a binary tree using a **recursive depth-first search (DFS)** approach. The time complexity of the solution is **O(n)**, where `n` is the number of nodes in the tree, and the space complexity is **O(h)**, where `h` is the height of the tree. This solution is optimal for the problem and works efficiently for both balanced and skewed trees.
### üöÄ Problem Statement

The task is to count the number of **1-bits** (also known as Hamming Weight or Population Count) in the binary representation of each number from `0` to `n` inclusive, where `n` is a non-negative integer. Given a number `n`, we need to return an array where the `i`-th element represents the number of `1`-bits in the binary representation of `i`.

For example, given `n = 5`, the output should be:
```
[0, 1, 1, 2, 1, 2]
```
This is because:
- `0` in binary is `0` ‚Üí 0 bits set
- `1` in binary is `1` ‚Üí 1 bit set
- `2` in binary is `10` ‚Üí 1 bit set
- `3` in binary is `11` ‚Üí 2 bits set
- `4` in binary is `100` ‚Üí 1 bit set
- `5` in binary is `101` ‚Üí 2 bits set

---

### üß† Approach

To solve this efficiently, we'll use a **dynamic programming (DP)** approach that leverages previously computed results. Here's how it works:

#### Key Insight:
1. **Bitwise Shifting**: 
   - The number of `1`-bits in a number `i` can be broken down into:
     - The number of `1`-bits in `i >> 1` (right-shifting `i` by one position).
     - The least significant bit (`i & 1`), which is `1` if `i` is odd and `0` if `i` is even.
   - The formula for counting bits is:
     ```
     countBits(i) = countBits(i >> 1) + (i & 1)
     ```

2. **Dynamic Programming**:
   - For each number `i` from `0` to `n`, we can calculate the number of `1`-bits using the formula above. Since the result for `i >> 1` is already known, this makes each calculation efficient, leading to an **O(n)** time complexity.

3. **Space Optimization**:
   - We store the results for each number in an array `res`. As we iterate through the numbers, we update this array using the formula.

---

### üî® Step-by-Step Code Breakdown

Let‚Äôs break down the code into manageable steps to see how it works:

#### Step 1: Initialize the Result Vector
```cpp
vector<int> res(n + 1, 0);
```
- We initialize a vector `res` of size `n + 1` to store the number of `1`-bits for each number from `0` to `n`. It starts with all values set to `0`, since `0` has zero `1`-bits.

#### Step 2: Loop Over All Numbers from `0` to `n`
```cpp
for(int i = 0; i <= n; i++) {
    res[i] = res[i >> 1] + (i & 1);
}
```
- We loop through each integer `i` from `0` to `n`. For each `i`, we calculate the number of `1`-bits:
  - **`res[i >> 1]`**: This gives the number of `1`-bits for the number `i >> 1` (right-shifted version of `i`).
  - **`(i & 1)`**: This checks if `i` is odd (`1`) or even (`0`). It contributes `1` to the bit count if `i` is odd.
- Adding these two values gives us the total number of `1`-bits for `i`.

#### Step 3: Return the Result
```cpp
return res;
```
- After filling the `res` vector with the number of `1`-bits for each number, we return the result.

---

### üìà Complexity Analysis

#### Time Complexity:
- **O(n)**: The loop runs from `0` to `n`, and for each number, we perform a constant amount of work (bitwise shifting and bitwise AND operation). Hence, the overall time complexity is **O(n)**, where `n` is the input number.

#### Space Complexity:
- **O(n)**: We use a vector `res` of size `n + 1` to store the results, which gives a space complexity of **O(n)**.

---

### üèÅ Conclusion

This approach efficiently solves the problem of counting the number of `1`-bits in the binary representations of numbers from `0` to `n`. By using dynamic programming and bitwise operations, we reduce the complexity to **O(n)**, which is optimal for this type of problem.

#### Key Benefits:
- **Efficient**: The time complexity is **O(n)**, making the solution scalable for large values of `n`.
- **Intuitive**: The use of bitwise operations and the simple DP approach makes the solution both easy to implement and understand.
- **Space Optimized**: The space complexity is minimal at **O(n)**, ensuring the solution is memory-efficient.

This method is highly effective for counting `1`-bits, and it works seamlessly even for larger values of `n`. Keep practicing dynamic programming and bit manipulation‚Äîthese are powerful tools for solving many problems efficiently! üåü
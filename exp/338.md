### Problem Statement

The problem asks to find the number of **1-bits** (also known as Hamming Weight or Population Count) for each number from `0` to `n` inclusive, where `n` is a non-negative integer. Given a number `n`, the task is to return an array where the `i`-th element represents the number of `1`-bits in the binary representation of `i`.

For example, given `n = 5`, the output should be:
```
[0, 1, 1, 2, 1, 2]
```
Here, the binary representations are:
- `0`: `0` → 0 bits set
- `1`: `1` → 1 bit set
- `2`: `10` → 1 bit set
- `3`: `11` → 2 bits set
- `4`: `100` → 1 bit set
- `5`: `101` → 2 bits set

### Approach

This problem can be solved efficiently by using a **dynamic programming** approach that leverages previously computed results. The key insight is to use the fact that the number of `1`-bits for a number `i` can be derived from the number of `1`-bits in the number `i >> 1` (right-shifted by one position). Additionally, we can leverage the fact that a number `i` and its shifted counterpart have a predictable relationship when considering the number of `1`-bits.

#### Key Insights:
1. **Bitwise Shifting**: 
   - The number of `1`-bits in a number `i` can be broken down into two parts:
     - The number of `1`-bits in `i >> 1` (i.e., right-shifted version of `i`).
     - The least significant bit (`i & 1`), which is `1` if `i` is odd and `0` if `i` is even.
   - The relationship is thus:
     ```
     countBits(i) = countBits(i >> 1) + (i & 1)
     ```

2. **Dynamic Programming**:
   - For each number `i` from `0` to `n`, we can calculate the number of `1`-bits using the formula above. Since the result for `i >> 1` is already known, the computation for each number is efficient, making this approach **O(n)** in terms of time complexity.

3. **Space Optimization**:
   - We store the results for each number in an array `res`. The array is initialized with `0` values, and as we iterate through the numbers, we update the array based on the formula above.

### Code Breakdown (Step by Step)

Let’s go through the code line by line to understand how it works.

#### Step 1: Initialize the Result Vector
```cpp
vector<int> res(n + 1, 0);
```
- We first initialize a vector `res` of size `n + 1`, where `n` is the input number. This vector will store the number of `1`-bits for each number from `0` to `n`.
- The vector is initialized to `0` since the number of `1`-bits for `0` is `0`.

#### Step 2: Loop Over All Numbers from `0` to `n`
```cpp
for(int i = 0; i <= n; i++) {
    res[i] = res[i >> 1] + (i & 1);
}
```
- We loop through each integer `i` from `0` to `n`.
- For each `i`, we calculate the number of `1`-bits:
  - **`res[i >> 1]`**: This retrieves the number of `1`-bits for the number obtained by right-shifting `i` by one bit (`i >> 1`).
  - **`(i & 1)`**: This checks whether `i` is odd or even. If `i` is odd, the least significant bit is `1`; otherwise, it is `0`.
- By adding the two values, we get the total number of `1`-bits for `i`.

#### Step 3: Return the Result
```cpp
return res;
```
- After filling in the `res` vector with the number of `1`-bits for each number from `0` to `n`, we return the result.

### Complexity

#### Time Complexity:
- **O(n)**: The loop runs from `0` to `n`, and for each number, we perform a constant amount of work (bitwise shifting and bitwise AND operation). Therefore, the overall time complexity is **O(n)**, where `n` is the input number.

#### Space Complexity:
- **O(n)**: We use a vector `res` of size `n + 1` to store the results, so the space complexity is **O(n)**.

### Conclusion

This approach provides a very efficient solution to the problem of counting the number of `1`-bits in the binary representation of numbers from `0` to `n`. The key idea is to use a dynamic programming technique, where we calculate the number of `1`-bits for each number by utilizing the previously computed results for smaller numbers. 

#### Key Benefits:
- **Efficiency**: The solution runs in **O(n)** time, making it suitable for large values of `n`.
- **Simplicity**: The formula used to compute the number of `1`-bits is simple and relies on bitwise operations, which are both fast and intuitive.
- **Memory Usage**: The space complexity is **O(n)**, which is optimal for this type of problem.

Overall, this is a highly efficient and straightforward approach to solving the problem of counting `1`-bits, and it works well for both small and large values of `n`.
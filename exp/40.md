### Problem Statement

The **Combination Sum II** problem is a variation of the classic **Combination Sum** problem, where you are given a list of candidate numbers and a target sum. The task is to find all unique combinations of numbers from the list that add up to the target sum. Each number in the list can only be used once per combination, and duplicates should not appear in the result.

### Approach

This problem can be solved using the **backtracking** approach, which is a systematic method of exploring all possible combinations. We start with an empty combination and attempt to build a valid combination by either including or excluding each number in the list. The main difference between **Combination Sum** and **Combination Sum II** is that we must handle **duplicate numbers** in the candidate list. To avoid generating duplicate combinations, we need to skip over any numbers that are the same as the previous one during the backtracking process.

Key ideas for this approach:
1. **Sort the candidate array**: Sorting the array helps us easily skip duplicate numbers.
2. **Backtracking**: We recursively try different combinations by adding elements to the current combination and checking if the sum becomes zero. If it exceeds the target, we backtrack.
3. **Skipping duplicates**: During the backtracking step, if the current number is the same as the previous one (and is not the first occurrence), we skip it to avoid duplicate combinations.

### Code Breakdown (Step by Step)

#### Function: `combinationSum2`

```cpp
vector<vector<int>> combinationSum2(vector<int>& cand, int target) {
    vector<vector<int>> ans;
    vector<int> tmp;
    mp.clear();
    sort(cand.begin(), cand.end());
    bt(ans, cand, 0, target, tmp);
    return ans;
}
```

- **Input**: 
  - `cand`: A vector of integers representing the list of candidates.
  - `target`: The target sum we need to achieve.
- **Process**:
  - **Clear previous results**: The `mp` map (used to store combinations) is cleared at the start.
  - **Sort the candidates**: Sorting ensures that duplicates can be skipped during the backtracking process.
  - **Backtracking**: The function calls the backtracking function `bt` to explore all possible combinations.

#### Function: `bt`

```cpp
void bt(vector<vector<int>> &ans, vector<int> &nums, int idx, int sum, vector<int> &tmp) {
    if(sum == 0) {
        ans.push_back(tmp);
        return;
    }
    if(sum < 0 || idx == nums.size()) return;

    for(int i = idx; i < nums.size(); i++) {
        if(i && i > idx && nums[i] == nums[i-1]) continue;
        tmp.push_back(nums[i]);
        bt(ans, nums, i + 1, sum - nums[i], tmp);
        tmp.pop_back();
    }
}
```

- **Base Case 1**: If the remaining sum `sum == 0`, it means the current combination `tmp` is valid and the function adds it to the result `ans`.
  
- **Base Case 2**: If the sum becomes negative (`sum < 0`) or we've reached the end of the candidate list (`idx == nums.size()`), we return from the function as no valid combination can be formed from this path.

- **Loop through candidates**: 
  - For each candidate at index `i`, we check if it is the first occurrence or a duplicate of the previous candidate. If it is a duplicate, we skip it (`if(i && i > idx && nums[i] == nums[i-1]) continue;`).
  - We add the current candidate `nums[i]` to the temporary combination `tmp` and make a recursive call with the updated sum (`sum - nums[i]`).
  - After the recursive call, we backtrack by removing the last added element from `tmp` using `tmp.pop_back()` to explore other potential combinations.

### Key Concepts in This Code

1. **Sorting to handle duplicates**: The candidate list is sorted at the beginning of the algorithm. This ensures that duplicates are adjacent to each other, allowing us to skip them during backtracking to avoid generating duplicate combinations.

2. **Backtracking**: The function uses a recursive backtracking technique to explore all possible combinations. By trying each candidate at each recursive step and backtracking once the combination is complete or invalid, we explore every possibility.

3. **Skipping duplicates**: By checking `if(i && i > idx && nums[i] == nums[i-1]) continue;`, the algorithm skips a candidate if it is the same as the previous one, except for the first occurrence.

4. **Use of helper function**: The function `bt` is a helper function that takes care of the recursive exploration of combinations. The main function `combinationSum2` prepares the inputs and initiates the backtracking process.

### Complexity Analysis

#### Time Complexity:
- **Sorting the candidates**: The sorting step takes `O(n log n)` time, where `n` is the number of elements in the `cand` vector.
- **Backtracking exploration**: In the worst case, the algorithm explores all possible combinations of the numbers in the candidates list. For each combination, we perform a constant amount of work. The time complexity of the backtracking process depends on the number of combinations and the depth of recursion, which in the worst case can be exponential.
  - **Time Complexity**: `O(2^n)`, where `n` is the number of elements in the candidates list. This is because, at each recursive level, we either include or exclude each candidate, resulting in a binary tree of size `2^n`.

#### Space Complexity:
- **Auxiliary Space for Recursion**: The space complexity is determined by the depth of the recursion stack, which can be up to `O(n)` in the worst case (when every element is included in the combination).
- **Space for Storing Results**: The space required to store the valid combinations in `ans` depends on the number of combinations generated and their size. In the worst case, the number of combinations can be exponential, so the space complexity is also affected by this.
  - **Space Complexity**: `O(n + 2^n)` where `n` is the number of elements in the candidates list. The `n` comes from the recursion stack depth, and `2^n` comes from the possible combinations stored in the result.

### Conclusion

The solution to the **Combination Sum II** problem is efficiently handled using **backtracking**. By sorting the candidate list and skipping duplicate candidates during the backtracking process, the algorithm ensures that all unique combinations are considered. The solution is elegant and works well for smaller input sizes, though its time complexity is exponential, as it explores all possible combinations of candidates. Sorting the list and skipping duplicates significantly reduces the number of redundant calculations, making this a highly optimized approach for this problem.
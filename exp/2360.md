### Problem Statement

The task is to find the longest cycle in a directed graph, where each node has at most one outgoing edge. Given an array `edges`, each element at index `i` denotes the index of the next node connected by a directed edge from `i`. If there’s no outgoing edge from a node, it’s represented by `-1`. The goal is to identify the length of the longest cycle in the graph, if any. If no cycle exists, return `-1`.

### Approach

This solution uses Depth-First Search (DFS) and a visitation tracking technique to identify cycles. By traversing nodes and marking visited nodes, we keep track of each node’s traversal path using a temporary list. If we encounter a node that’s already in the current traversal path, we have identified a cycle, and we calculate its length.

1. **Initialization:**
   - We initialize a result variable `ans` to store the maximum cycle length found.
   - The `longestCycle` function initializes a visitation array `vis` with zeros, representing unvisited nodes.
   
2. **DFS Traversal and Cycle Detection:**
   - For each unvisited node, we start a DFS traversal to detect any cycles.
   - During traversal, we maintain a temporary list `store` to track the current path from the starting node.
   - If we revisit a node already in `store`, we have detected a cycle. The cycle length is calculated based on the distance between the first and last occurrences of this node in `store`.
   
3. **Updating the Longest Cycle Length:**
   - For each cycle detected, we update `ans` with the longest cycle length.
   - After all nodes are processed, we return `ans`, which will be `-1` if no cycle was found.

### Code Breakdown (Step by Step)

#### Step 1: Initialization and DFS Setup

```cpp
int ans = -1;
int longestCycle(vector<int>& edges) {
    int n = edges.size();
    vector<int> vis(n, 0);        
    for(int i = 0; i < n; i++) {
        if(vis[i]) continue;
        vector<int> store;
        dfs(i, vis, edges, store);
    }
    return ans; 
}
```

- `ans` is initialized to `-1`, indicating no cycle has been found yet.
- `vis` array is used to mark nodes that have been visited.
- A loop iterates over all nodes; if a node hasn’t been visited, we initiate a DFS from that node.

#### Step 2: DFS Traversal and Cycle Detection

```cpp
void dfs(int cur, vector<int> &vis, vector<int> &grid, vector<int> &store) {
    if(cur == -1) return;

    if(vis[cur]) {
        int pt = -1;
        for(int i = 0; i < store.size(); i++) {
            if(store[i] == cur) {
                pt = i;
                break;
            }
        }
        if(pt == -1) return;
        ans = max(ans, (int)store.size() - pt);
    } else {
        vis[cur] = true;            
        store.push_back(cur);
        dfs(grid[cur], vis, grid, store);
    }
}
```

- The `dfs` function takes the current node `cur` and checks if it has been visited.
- If `cur` is `-1`, there’s no outgoing edge, so we return.
- If `cur` has already been visited in this traversal (`store`), we have detected a cycle.
- The length of the cycle is calculated based on the index where the cycle started in `store`.
- If no cycle is detected, we continue the DFS by marking `cur` as visited, adding it to `store`, and calling `dfs` on the next node in the path.

### Complexity

#### Time Complexity
- **DFS Traversal:** The algorithm processes each node once, resulting in \(O(n)\) time complexity, where `n` is the number of nodes.
  
#### Space Complexity
- **Auxiliary Space:** We use an auxiliary vector `store` for each DFS call, leading to \(O(n)\) space complexity.

### Conclusion

This solution effectively identifies the longest cycle in a graph where each node has at most one outgoing edge. Using DFS and tracking visited nodes enables efficient cycle detection, while maintaining a list of nodes in the current path allows accurate cycle length calculation. The algorithm returns the longest cycle length or `-1` if no cycle exists. This approach is efficient for handling directed graphs with at most one outgoing edge per node.
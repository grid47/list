### ğŸ’¡ **Largest Rectangle in Histogram** â€“ Let's Solve It Together!

The **Largest Rectangle in Histogram** problem is a classic challenge in coding interviews. The goal is to find the area of the largest rectangle that can be formed within a histogram, where each bar in the histogram has a specific height. The trick is to efficiently compute the largest rectangular area using the heights of the bars.

### ğŸ“ **Problem Statement**

Given an array of integers where each integer represents the height of a bar in the histogram, your task is to compute the **maximum area** of a rectangle that can be formed using contiguous bars. The rectangleâ€™s area is determined by the height of the shortest bar in the range and the width of the range.

### ğŸ” **Approach**

To solve this problem efficiently, we can use a **stack-based approach**. This method allows us to find the **nearest smaller bar** to the left and right of each bar in the histogram. The stack helps us compute the maximum area for each bar in **linear time**.

Hereâ€™s a breakdown of the approach:

1. **Finding Nearest Smaller Bars:**
   For each bar, we need to calculate the nearest smaller bar to the left and the nearest smaller bar to the right. This defines the range within which the current bar can form the largest rectangle.

2. **Using a Stack to Track Indices:**
   We use a stack to store the indices of bars as we traverse the histogram. The stack helps us maintain the order of bars and efficiently find the nearest smaller bars.

3. **Calculating Maximum Area:**
   For each bar, the maximum rectangle area that can be formed is determined by the height of the bar and the width defined by the nearest smaller bars on the left and right.

### ğŸ§‘â€ğŸ’» **Step-by-Step Code Breakdown**

#### Step 1: Finding the Nearest Smaller Bar to the Left

```cpp
stack<int> stk;
int n = h.size();
vector<int> left(n, 0), right(n, 0);
for(int i = 0; i < h.size(); i++) {
    if(stk.empty()) {
        left[i] = -1;
        stk.push(i);
    } else {
        while(!stk.empty() && h[i] <= h[stk.top()])
            stk.pop();
        if(stk.empty())
            left[i] = -1;
        else left[i] = stk.top();
        stk.push(i);
    }
}
```

- **Explanation:**  
  We traverse the histogram from left to right, using a stack to track the indices of the bars.
  - For each bar, if itâ€™s taller than the bar at the index at the top of the stack, we pop elements from the stack until we find a smaller bar. 
  - The nearest smaller bar to the left of the current bar is the top element of the stack, and we store that index in the `left` array.
  - If no smaller bar is found, we assign `-1` to indicate thereâ€™s no smaller bar to the left.

#### Step 2: Finding the Nearest Smaller Bar to the Right

```cpp
while(!stk.empty()) stk.pop();
for(int i = h.size() - 1; i >= 0; i--) {
    if(stk.empty()) {
        right[i] = n;
        stk.push(i);
    } else {
        while(!stk.empty() && h[i] <= h[stk.top()])
            stk.pop();
        if(stk.empty())
            right[i] = n;
        else right[i] = stk.top();
        stk.push(i);
}
```

- **Explanation:**  
  After processing the left boundaries, we reset the stack and traverse the histogram from right to left to find the nearest smaller bar on the right.
  - Similar to the left traversal, if a bar is shorter than or equal to the bar at the index at the top of the stack, we pop elements off the stack.
  - We store the nearest smaller bar to the right of the current bar in the `right` array.
  - If no smaller bar is found, we assign `n` (the size of the histogram) to indicate that thereâ€™s no smaller bar to the right.

#### Step 3: Calculating the Maximum Rectangle Area

```cpp
int res = 0;
for(int i = 0; i < n; i++)
    res = max(res, h[i] * (right[i] - left[i] - 1));

return res;
```

- **Explanation:**  
  Once weâ€™ve computed the `left` and `right` arrays, we can calculate the maximum area for each bar.
  - The area for each bar is computed as:
    - `height * width`, where:
      - `height` is the height of the current bar (`h[i]`).
      - `width` is the distance between the left and right boundaries, which is calculated as `right[i] - left[i] - 1`.
  - We iterate over the histogram, compute the area for each bar, and track the maximum area found.

### â±ï¸ **Time and Space Complexity**

- **Time Complexity:**  
  - **Left and Right Boundary Calculation:** Both the left and right boundary calculations require iterating over the histogram, and for each bar, we perform constant-time stack operations (push and pop). Therefore, the time complexity for this step is **O(n)**, where `n` is the number of bars in the histogram.
  - **Area Calculation:** After finding the left and right boundaries, we perform a single pass over the histogram to calculate the area for each bar, which also takes **O(n)** time.
  - The overall time complexity of the algorithm is **O(n)**.

- **Space Complexity:**  
  - We use two arrays (`left` and `right`) of size `n` to store the boundaries, and a stack that can hold up to `n` indices. Thus, the space complexity is **O(n)**.

### ğŸ’¡ **Why This Approach Works**

This approach is efficient because it **calculates the nearest smaller bars** for each bar in the histogram using a stack, which ensures the algorithm runs in **linear time** (`O(n)`). By leveraging the stack, we avoid the brute-force approach of checking all possible rectangles, which would take **O(nÂ²)** time. This makes the algorithm scalable and efficient for large histograms.

### ğŸ **Conclusion**

The stack-based approach to finding the largest rectangle in a histogram is **time-efficient** and **space-efficient**. By using a stack to track the indices and find the nearest smaller bars, we can compute the maximum area in **linear time**. This solution is ideal for handling large input sizes and is well-suited for real-world applications involving histogram-based problems.

---

#### ğŸŒŸ **Final Thoughts**: Keep Coding, Keep Growing!

Each problem you solve is a step closer to mastering algorithms and data structures. The more you practice, the sharper your problem-solving skills become. Keep pushing forward, and remember, the journey to becoming a top-notch coder is all about **consistent practice and learning**. Keep going! ğŸŒ±ğŸ’ª

Happy coding, and remember: **Efficiency is the key to scaling your solutions!** âœ¨
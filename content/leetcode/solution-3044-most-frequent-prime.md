
+++
authors = ["grid47"]
title = "Leetcode 3044: Most Frequent Prime"
date = "2024-01-07"
lastmod = "2024-11-06"
description = "In-depth solution and explanation for Leetcode 3044: Most Frequent Prime in C++. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis."
tags = ["Array","Hash Table","Math","Matrix","Counting","Enumeration","Number Theory"]
categories = [
    "Medium"
]
series = ["Leetcode"]
img_src = ""
youtube = "vyLo_FMR3IU"
youtube_upload_date="2024-02-18"
youtube_thumbnail="https://i.ytimg.com/vi_webp/vyLo_FMR3IU/maxresdefault.webp"
comments = true
+++



---
You are given a matrix of integers, where each cell contains a digit from 1 to 9. Starting from any cell in the matrix, you can move in one of eight possible directions (east, south-east, south, south-west, west, north-west, north, and north-east) and create numbers by appending the digits along the path. For each valid path, numbers greater than 10 are generated. The task is to find the most frequent prime number greater than 10 among all the numbers generated by traversing the matrix. If there are multiple such prime numbers, return the largest one. If no prime number exists, return -1.
<!--more-->
{{< dots >}}
### Input Representations üì•
- **Input:** You are given a 2D matrix 'mat' of size m x n, where 1 <= m, n <= 6, and each element in mat is between 1 and 9 (inclusive).
- **Example:** `mat = [[2, 3, 4], [5, 6, 7], [8, 9, 1]]`
- **Constraints:**
	- 1 <= m, n <= 6
	- 1 <= mat[i][j] <= 9

{{< dots >}}
### Output Specifications üì§
- **Output:** Return the most frequent prime number greater than 10 formed by traversing the matrix. If no such prime exists, return -1.
- **Example:** `For mat = [[2, 3, 4], [5, 6, 7], [8, 9, 1]], the output is 23.`
- **Constraints:**

{{< dots >}}
### Core Logic üîç
**Goal:** Traverse the matrix from each cell, generate numbers by moving in any of the 8 directions, and identify the most frequent prime number greater than 10.

- 1. Define directions for traversal (east, south-east, south, etc.).
- 2. For each cell, generate numbers by moving in the defined directions.
- 3. Check if the generated number is a prime number greater than 10.
- 4. Keep track of the frequency of prime numbers.
- 5. Return the most frequent prime number greater than 10. If there are multiple such numbers, return the largest one. If none exists, return -1.
{{< dots >}}
### Problem Assumptions ‚úÖ
- You can move in one of eight possible directions from any cell.
- Numbers are formed by traversing through consecutive cells in a chosen direction.
{{< dots >}}
## Examples üß©
- **Input:** `For the input matrix mat = [[2, 3, 4], [5, 6, 7], [8, 9, 1]]`  \
  **Explanation:** Start from each cell and move in all 8 possible directions. The numbers greater than 10 are generated. Among these, the prime number 23 appears the most frequently, so the output is 23.

{{< dots >}}
## Approach üöÄ
The problem can be solved by generating all the numbers formed by traversing the matrix in all 8 directions, checking which numbers are prime and greater than 10, and then finding the most frequent prime.

### Initial Thoughts üí≠
- We need to check every direction from each cell and generate numbers.
- Prime numbers can be checked using a sieve of Eratosthenes.
- The number of cells and directions are small, so the problem can be approached using brute force.
{{< dots >}}
### Edge Cases üåê
- The matrix will always have at least one element.
- The maximum size of the matrix is 6x6.
- If no prime numbers greater than 10 are generated, return -1.
- The matrix elements are between 1 and 9, and the matrix dimensions are at most 6x6.
{{< dots >}}
## Code üíª
```cpp
int dx[8] = {1, 1, 1, -1, -1, -1, 0, 0};
int dy[8] = {1, 0, -1, 1, 0, -1, 1, -1};
void make() {
    sieve[1] = 1;
    for (int i = 2; i < 1000001; i++) {
        if (!sieve[i]) for (int j = 2*i; j < 1000001; j += i) sieve[j] = 1;
    }
} 
int mostFrequentPrime(vector<vector<int>>& mat) {
    if (sieve[1] == 0) make();
    map<int, int> freq;
    for (int i = 0; i < mat.size(); i++) {
        for (int j = 0; j < mat[i].size(); j++) {
            for (int k = 0; k < 8; k++) {
                int a = i, b = j;
                int cur = 0;
                while (a >= 0 && b >= 0 && a < mat.size() && b < mat[i].size()) {
                    cur *= 10;
                    cur += mat[a][b];
                    if(cur>10 && sieve[cur] == 0) freq[cur]++;
                    a += dx[k]; b += dy[k];
                }
            }
        }
    }
    int mx = -1;
    int ans = -1;
    for (auto i : freq) {
        if(i.second >= mx) {
            ans = i.first;
            mx = i.second;
        }
    }
    return ans;
}
```

This function computes the most frequent prime number formed by traversing an input matrix `mat` in all 8 possible directions, using a sieve approach to check for primes.

{{< dots >}}
### Step-by-Step Breakdown üõ†Ô∏è
1. **Variable Initialization**
	```cpp
	int dx[8] = {1, 1, 1, -1, -1, -1, 0, 0};
	```
	Declares an array `dx` to represent the directional movements in the x-axis for the 8 possible directions.

2. **Variable Initialization**
	```cpp
	int dy[8] = {1, 0, -1, 1, 0, -1, 1, -1};
	```
	Declares an array `dy` to represent the directional movements in the y-axis for the 8 possible directions.

3. **Function Definition**
	```cpp
	void make() {
	```
	Defines the `make` function to initialize the sieve array to mark non-prime numbers.

4. **Assignment**
	```cpp
	    sieve[1] = 1;
	```
	Marks the number `1` as non-prime in the sieve array.

5. **Loop**
	```cpp
	    for (int i = 2; i < 1000001; i++) {
	```
	Starts a loop to iterate through numbers from `2` to `1000000` to apply the sieve of Eratosthenes.

6. **Condition Check**
	```cpp
	        if (!sieve[i]) for (int j = 2*i; j < 1000001; j += i) sieve[j] = 1;
	```
	Checks if the current number `i` is prime. If it is, marks all multiples of `i` as non-prime.

7. **Function Definition**
	```cpp
	int mostFrequentPrime(vector<vector<int>>& mat) {
	```
	Defines the `mostFrequentPrime` function, which identifies the most frequent prime formed by traversing an input matrix `mat`.

8. **Condition Check**
	```cpp
	    if (sieve[1] == 0) make();
	```
	Checks if the sieve is initialized, and if not, calls the `make` function to initialize it.

9. **Variable Initialization**
	```cpp
	    map<int, int> freq;
	```
	Declares a map `freq` to store the frequency of prime numbers found during matrix traversal.

10. **Outer Loop**
	```cpp
	    for (int i = 0; i < mat.size(); i++) {
	```
	Starts the outer loop to iterate over each row of the matrix `mat`.

11. **Inner Loop**
	```cpp
	        for (int j = 0; j < mat[i].size(); j++) {
	```
	Starts the inner loop to iterate over each element in the current row `mat[i]`.

12. **Direction Loop**
	```cpp
	            for (int k = 0; k < 8; k++) {
	```
	Starts a loop to iterate over all 8 possible directions for traversing the matrix.

13. **Variable Initialization**
	```cpp
	                int a = i, b = j;
	```
	Initializes the variables `a` and `b` to represent the current position in the matrix.

14. **Variable Initialization**
	```cpp
	                int cur = 0;
	```
	Initializes a variable `cur` to 0, which will hold the current number formed by traversing in a specific direction.

15. **While Loop**
	```cpp
	                while (a >= 0 && b >= 0 && a < mat.size() && b < mat[i].size()) {
	```
	Starts a `while` loop to traverse the matrix in a specific direction as long as the indices `a` and `b` are within bounds.

16. **Number Construction**
	```cpp
	                    cur *= 10;
	```
	Multiplies the current number `cur` by 10 to shift its digits and prepare to add the next digit.

17. **Number Construction**
	```cpp
	                    cur += mat[a][b];
	```
	Adds the current matrix element `mat[a][b]` to the number `cur`.

18. **Prime Check**
	```cpp
	                    if(cur > 10 && sieve[cur] == 0) freq[cur]++;
	```
	Checks if the number `cur` is greater than 10 and a prime (using the sieve), and increments its frequency in the `freq` map.

19. **Move to Next Cell**
	```cpp
	                    a += dx[k]; b += dy[k];
	```
	Moves to the next cell in the matrix according to the current direction specified by `dx[k]` and `dy[k]`.

20. **Variable Initialization**
	```cpp
	    int mx = -1;
	```
	Initializes a variable `mx` to store the maximum frequency of a prime number.

21. **Variable Initialization**
	```cpp
	    int ans = -1;
	```
	Initializes a variable `ans` to store the prime number with the maximum frequency.

22. **Loop**
	```cpp
	    for (auto i : freq) {
	```
	Starts a loop to iterate over the frequency map `freq`.

23. **Condition Check**
	```cpp
	        if(i.second >= mx) {
	```
	Checks if the current frequency `i.second` is greater than or equal to the maximum frequency `mx`.

24. **Update Variables**
	```cpp
	            ans = i.first;
	```
	Updates the variable `ans` to the current prime number with the maximum frequency.

25. **Update Variables**
	```cpp
	            mx = i.second;
	```
	Updates the variable `mx` to the current frequency of the prime number.

26. **Return Statement**
	```cpp
	    return ans;
	```
	Returns the prime number with the maximum frequency.

{{< dots >}}
## Complexity Analysis üìä
### Time Complexity ‚è≥
- **Best Case:** O(m * n)
- **Average Case:** O(m * n * d)
- **Worst Case:** O(m * n * d)

The time complexity is O(m * n * d), where m and n are the dimensions of the matrix, and d is the number of directions (8 in this case).

### Space Complexity üíæ
- **Best Case:** O(p)
- **Worst Case:** O(p)

The space complexity is O(p), where p is the number of prime numbers greater than 10 found in the matrix.

**Happy Coding! üéâ**


[`Link to LeetCode Lab`](https://leetcode.com/problems/most-frequent-prime/description/)

---
{{< youtube vyLo_FMR3IU >}}
| [LeetCode Solutions Library](https://grid47.xyz/leetcode/) / [DSA Sheets](https://grid47.xyz/sheets/) / [Course Catalog](https://grid47.xyz/courses/) |
| --- |


+++
authors = ["grid47"]
title = "Leetcode 386: Lexicographical Numbers"
date = "2024-09-29"
lastmod = "2024-11-06"
description = "In-depth solution and explanation for Leetcode 386: Lexicographical Numbers in C++. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis."
tags = ["Depth-First Search","Trie"]
categories = [
    "Medium"
]
series = ["Leetcode"]
img_src = "https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/386.webp"
youtube = "n4YGTbFfU-w"
youtube_upload_date="2021-02-27"
youtube_thumbnail="https://i.ytimg.com/vi/n4YGTbFfU-w/maxresdefault.jpg"
+++


{{< rmtimg 
    src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/386.webp" 
    alt="A glowing series of numbers arranged in lexicographical order, highlighting their progression."
    caption="Solution to LeetCode 386: Lexicographical Numbers Problem"
    width="900px"
    borderRadius="8px"
    align="center" 
    captionColor="#555"
>}}
---
**Code:**

{{< highlight cpp >}}
class Solution {
public:
    int num;
    vector<int> ans;
    vector<int> lexicalOrder(int n) {
        num = n;
        d(1);
        return ans;
    }
    void d(int x) {
        if(x > num) return;
        ans.push_back(x);
        d(x * 10);
        if((x % 10) < 9) d(x + 1);
    }
};
{{< /highlight >}}
---

### üöÄ Problem Statement

We're tasked with generating a list of numbers in **lexicographical order** (like dictionary order) from `1` to `n`. For example, if `n = 13`, the output should be:

```
[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]
```

The goal is to generate this sequence **efficiently**, without sorting the list, ensuring that we maintain the lexicographical order. The solution needs to handle large values of `n` (up to \(10^9\)) without running into performance issues.

---

### üß† Approach

The key to solving this problem lies in **depth-first search (DFS)**, which allows us to generate the sequence directly in lexicographical order. Here‚Äôs how we break it down:

1. **Lexicographical Order**:
   - Lexicographical order works similarly to how words are ordered in a dictionary. For instance, `1, 10, 11, 12` comes before `2, 3, 4,...`‚Äîwhich is the structure we're aiming to replicate.
   - This order is like traversing a tree, where from any number `x`, the next possible numbers are generated by appending digits. For example, from `1` you get `10, 100, 101,...`.

2. **DFS Approach**:
   - The goal is to explore each number starting from `1`, and build deeper numbers (like `10, 100, 1000, ...`) by appending zeros.
   - After exploring deeper branches, the algorithm proceeds to the next number at the same level (like from `1` to `2`).

3. **Recursive Backtracking**:
   - We use a recursive function `d(int x)` that explores one branch at a time.
   - Starting from `x = 1`, the function will try to form numbers by multiplying by 10 (to explore deeper branches like `10, 100, 1000,...`), and adding 1 to `x` to explore the next number.

---

### üî® Step-by-Step Code Breakdown

Let‚Äôs go through the code and see how it works:

#### 1. **Class Declaration**
```cpp
class Solution {
public:
    int num;
    vector<int> ans;
```
- We define the `Solution` class with two members:
  - `num`: stores the value of `n`, the upper limit for generating the lexicographical order.
  - `ans`: a vector that holds the final list of numbers in lexicographical order.

#### 2. **lexicalOrder Function**
```cpp
vector<int> lexicalOrder(int n) {
    num = n;
    d(1);
    return ans;
}
```
- The `lexicalOrder` function is the main entry point. It initializes `num` with `n` and starts the recursive function `d(1)` from the number `1`.
- Once all the numbers are generated, it returns the vector `ans` containing them in the correct order.

#### 3. **Recursive DFS Function**
```cpp
void d(int x) {
    if(x > num) return;
    ans.push_back(x);
    d(x * 10);
    if((x % 10) < 9) d(x + 1);
}
```
- The recursive function `d(int x)` generates the numbers:
  - **Base Case**: If `x` exceeds `num`, it returns without doing anything.
  - **Add to Result**: It adds the current number `x` to the result vector `ans`.
  - **DFS Deeper**: First, it calls `d(x * 10)` to explore numbers formed by appending zeros (e.g., `1 ‚Üí 10, 100, 1000, ...`).
  - **Move to Next**: Then, if `x % 10` is less than 9, it calls `d(x + 1)` to move to the next number in the sequence.

#### 4. **Explaining the Recursive Calls**
- Let's go through an example with `n = 13`:
  - Start with `d(1)`. `1` is added to `ans`, then `d(10)` is called.
    - From `d(10)`, `10` is added, then `d(100)` is called, but `100 > 13`, so we return.
    - Then `d(11)` is called, `11` is added, and `d(110)` is called (returns without adding anything).
    - Then `d(12)` is called, followed by `d(120)` (returns).
    - Finally, `d(13)` is called and added to the result.
  - After reaching `13`, the function proceeds to `d(2)` and repeats similarly for numbers `2, 3, 4,...`.

---

### üìä Complexity Analysis

#### Time Complexity:
- **Time Complexity**: **O(n)**, where `n` is the input value.
  - We visit each number from `1` to `n` exactly once. Each number is added to the result vector, and the recursive calls only visit each number once.

#### Space Complexity:
- **Space Complexity**: **O(n)**.
  - The output vector `ans` stores all the numbers in lexicographical order, requiring space proportional to `n`.
  - The recursive stack depth is minimal (about `log n`), so the space complexity is mainly driven by the result storage.

---

### üèÅ Conclusion

This solution efficiently generates numbers in **lexicographical order** using **depth-first search (DFS)**. Here‚Äôs a quick recap:

- **Efficient Traversal**: The DFS approach directly constructs numbers in lexicographical order without sorting.
- **Scalable and Optimized**: It handles values of `n` up to \(10^9\) efficiently with **O(n)** time complexity.
- **Clean and Elegant**: This approach offers a clean recursive solution that efficiently handles the lexicographical generation without unnecessary computations.

üéâ Congratulations! You‚Äôve learned how to generate numbers in lexicographical order with a smooth, efficient algorithm!

[`Link to LeetCode Lab`](https://leetcode.com/problems/lexicographical-numbers/description/)

---
{{< youtube n4YGTbFfU-w >}}
| [LeetCode Solutions Library](https://grid47.xyz/leetcode/) / [DSA Sheets](https://grid47.xyz/sheets/) / [Course Catalog](https://grid47.xyz/courses/) |
| --- |

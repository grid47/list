
+++
authors = ["grid47"]
title = "Leetcode 38: Count and Say"
date = "2024-11-03"
lastmod = "2024-11-06"
description = "In-depth solution and explanation for Leetcode 38: Count and Say in C++. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis."
tags = ["String"]
categories = [
    "Medium"
]
series = ["Leetcode"]
img_src = "https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/38.webp"
youtube = "4PFCdoSOsiA"
youtube_upload_date="2023-12-25"
youtube_thumbnail="https://i.ytimg.com/vi_webp/4PFCdoSOsiA/maxresdefault.webp"
comments = true
+++


{{< rmtimg 
    src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/38.webp" 
    alt="A series of glowing numbers transforming into words, forming a pattern of calm repetition."
    caption="Solution to LeetCode 38: Count and Say Problem"
    width="900px"
    borderRadius="8px"
    align="center" 
    captionColor="#555"
>}}
---
The Count-and-Say sequence starts with '1'. Each subsequent term is generated by describing the previous term in terms of the count of consecutive digits. Given a positive integer n, return the nth term of the Count-and-Say sequence.
<!--more-->
{{< dots >}}
### Input Representations ğŸ“¥
- **Input:** A positive integer n representing the term of the Count-and-Say sequence to be returned.
- **Example:** `Input: n = 4`
- **Constraints:**
	- 1 <= n <= 30

{{< dots >}}
### Output Specifications ğŸ“¤
- **Output:** Return the nth term of the Count-and-Say sequence.
- **Example:** `Output: "1211"`
- **Constraints:**
	- Return a string representing the nth term.

{{< dots >}}
### Core Logic ğŸ”
**Goal:** The goal is to iteratively generate the nth term by describing the previous term using run-length encoding.

- Start with '1'.
- For each subsequent term, describe the previous term using run-length encoding.
- For each group of consecutive digits in the previous term, note the count followed by the digit.
{{< dots >}}
### Problem Assumptions âœ…
- n is always a positive integer.
- The Count-and-Say sequence starts with '1'.
{{< dots >}}
## Examples ğŸ§©
- **Input:** `Input: n = 4`  \
  **Explanation:** The 4th term in the Count-and-Say sequence is '1211', which is generated by describing the 3rd term '21' as 'one 2, one 1'.

- **Input:** `Input: n = 2`  \
  **Explanation:** The 2nd term in the Count-and-Say sequence is '11', generated by describing the first term '1' as 'one 1'.

{{< dots >}}
## Approach ğŸš€
Start from the first term of the sequence and iteratively generate the next terms using run-length encoding to describe the previous term.

### Initial Thoughts ğŸ’­
- The sequence can be generated iteratively by processing one term at a time.
- A simple way to describe each term is by counting consecutive characters and then concatenating the count and the character.
{{< dots >}}
### Edge Cases ğŸŒ
- N/A, since n is always at least 1.
- The constraints (n <= 30) ensure that large inputs will not be problematic.
- Consider how the sequence behaves with the smallest input n = 1, which simply returns '1'.
- n will always be within the range [1, 30].
{{< dots >}}
## Code ğŸ’»
```cpp
string countAndSay(int n) {
    if (n == 1) return "1";

    string tmp = countAndSay(n-1);
    string ans = "";

    for(int i = 0; i < tmp.size(); ) {

        char ch = tmp[i];
        int cnt = 0;

        while(tmp[i] == ch && i < tmp.size()) {
            cnt++;
            i++;
        }

        ans.push_back(cnt+'0');
        ans.push_back(tmp[i-1]);
    }

    return ans;
}
```

This code implements the `countAndSay` function, which generates the nth term of the count-and-say sequence.

{{< dots >}}
### Step-by-Step Breakdown ğŸ› ï¸
1. **Function Declaration**
	```cpp
	string countAndSay(int n) {
	```
	This line declares a function named `countAndSay` that takes an integer `n` as input and returns a string representing the nth term of the count-and-say sequence.

2. **Base Case**
	```cpp
	    if (n == 1) return "1";
	```
	This line handles the base case where `n` is 1. The first term of the sequence is simply "1", so the function returns it.

3. **Recursive Call**
	```cpp
	    string tmp = countAndSay(n-1);
	```
	This line recursively calls the `countAndSay` function to get the (n-1)th term of the sequence and stores it in the `tmp` string.

4. **String Initialization**
	```cpp
	    string ans = "";
	```
	This line initializes an empty string `ans` to store the nth term of the sequence.

5. **Loop Iteration**
	```cpp
	    for(int i = 0; i < tmp.size(); ) {
	```
	This line starts a `for` loop to iterate over the characters of the `tmp` string.

6. **Variable Initialization**
	```cpp
	        char ch = tmp[i];
	        int cnt = 0;
	```
	These lines initialize two variables: `ch` to store the current character being processed and `cnt` to count the occurrences of that character.

7. **Loop Iteration and Condition**
	```cpp
	        while(tmp[i] == ch && i < tmp.size()) {
	```
	This `while` loop continues as long as the current character `tmp[i]` is the same as the previous character `ch` and the index `i` is within the bounds of the `tmp` string.

8. **Counter Increment**
	```cpp
	            cnt++;
	```
	This line increments the `cnt` variable to count the occurrences of the current character.

9. **Index Increment**
	```cpp
	            i++;
	```
	This line increments the `i` index to move to the next character in the `tmp` string.

10. **String Manipulation**
	```cpp
	        ans.push_back(cnt+'0');
	        ans.push_back(tmp[i-1]);
	```
	These lines append the count of the current character (`cnt`) and the character itself (`tmp[i-1]`) to the `ans` string. The `cnt+'0'` converts the integer count to a character representing the digit.

11. **Return**
	```cpp
	    return ans;
	```
	After processing all characters in the `tmp` string, the function returns the `ans` string, which represents the nth term of the count-and-say sequence.

{{< dots >}}
## Complexity Analysis ğŸ“Š
### Time Complexity â³
- **Best Case:** O(n)
- **Average Case:** O(n^2)
- **Worst Case:** O(n^2)

The time complexity is O(n^2) in the worst case since the number of digits in each term grows approximately exponentially.

### Space Complexity ğŸ’¾
- **Best Case:** O(n)
- **Worst Case:** O(n^2)

Space complexity is O(n) for storing the current term, with additional space needed to store previous terms.

**Happy Coding! ğŸ‰**


[`Link to LeetCode Lab`](https://leetcode.com/problems/count-and-say/description/)

---
{{< youtube 4PFCdoSOsiA >}}
| [LeetCode Solutions Library](https://grid47.xyz/leetcode/) / [DSA Sheets](https://grid47.xyz/sheets/) / [Course Catalog](https://grid47.xyz/courses/) |
| --- |

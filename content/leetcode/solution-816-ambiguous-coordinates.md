
+++
authors = ["grid47"]
title = "Leetcode 816: Ambiguous Coordinates"
date = "2024-08-17"
lastmod = "2024-11-06"
description = "In-depth solution and explanation for Leetcode 816: Ambiguous Coordinates in C++. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis."
tags = ["String","Backtracking","Enumeration"]
categories = [
    "Medium"
]
series = ["Leetcode"]
img_src = "https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/816.webp"
youtube = ""
youtube_upload_date=""
youtube_thumbnail=""
+++


{{< rmtimg 
    src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/816.webp" 
    alt="A set of coordinates with ambiguity highlighted, glowing softly as each coordinate is clarified."
    caption="Solution to LeetCode 816: Ambiguous Coordinates Problem"
    width="900px"
    borderRadius="8px"
    align="center" 
    captionColor="#555"
>}}
---
**Code:**

{{< highlight cpp >}}
class Solution {
public:
    vector<string> ambiguousCoordinates(string S) {
        int n = S.size();
        vector<string> res;
        for (int i = 1; i < n - 2; ++i) {
            vector<string> A = f(S.substr(1, i)), B = f(S.substr(i + 1, n - 2 - i));
            for (auto & a : A) for (auto & b : B) res.push_back("(" + a + ", " + b + ")");
        }
        return res;
    }
    vector<string> f(string S) {
        int n = S.size();
        if (n == 0 || (n > 1 && S[0] == '0' && S[n - 1] == '0')) return {};
        if (n > 1 && S[0] == '0') return {"0." + S.substr(1)};
        if (n == 1 || S[n - 1] == '0') return {S};
        vector<string> res = {S};
        for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + '.' + S.substr(i));
        return res;
    }
};
{{< /highlight >}}
---

### Problem Statement

The problem requires generating possible coordinates from a given string `S` that represents a single pair of integers enclosed in parentheses, such as "(123)" or "(0123)". The task is to split the string into two parts and then insert decimal points appropriately within each part to generate valid coordinates. The output should contain all possible coordinate combinations that can be derived from the input string.

### Approach

The approach for solving this problem is broken down into the following steps:

1. **String Parsing and Validation**:
   - Remove the parentheses from the input string to get the number substring.
   - Split the remaining substring at different positions to create two parts: one representing the x-coordinate and the other representing the y-coordinate.

2. **Generating Valid Coordinates**:
   - For each part, create possible decimal representations:
     - If a number part has leading zeros or ends with zero, apply specific conditions to avoid invalid representations (e.g., "012" should not be split, and "30" should not be made into "3.0").
     - Generate all valid numbers by inserting decimal points in allowable positions.

3. **Combining Coordinates**:
   - After generating all possible decimal placements for both x and y coordinates, combine each possible x-coordinate with each possible y-coordinate to form valid coordinate pairs.
   
4. **Output**:
   - Return the list of all valid coordinates in the required format.

### Code Breakdown (Step by Step)

```cpp
vector<string> ambiguousCoordinates(string S) {
    int n = S.size();
    vector<string> res;

    for (int i = 1; i < n - 2; ++i) {
        vector<string> A = f(S.substr(1, i));
        vector<string> B = f(S.substr(i + 1, n - 2 - i));

        for (auto &a : A) {
            for (auto &b : B) {
                res.push_back("(" + a + ", " + b + ")");
            }
        }
    }
    return res;
}
```

- `ambiguousCoordinates` starts by iterating over possible split points within the number substring.
- For each split, the function `f` is called on both the left and right segments.
- The resulting coordinates from `f` are combined to form coordinate pairs.

```cpp
vector<string> f(string S) {
    int n = S.size();

    if (n == 0 || (n > 1 && S[0] == '0' && S[n - 1] == '0')) return {};
    if (n > 1 && S[0] == '0') return {"0." + S.substr(1)};
    if (n == 1 || S[n - 1] == '0') return {S};

    vector<string> res = {S};
    for (int i = 1; i < n; ++i) res.push_back(S.substr(0, i) + '.' + S.substr(i));
    return res;
}
```

- `f` generates all valid decimal placements for a given string `S`.
- It checks specific conditions to filter out invalid formats:
  - If `S` has a leading zero and ends with zero, no valid decimal placement exists.
  - If `S` starts with zero, only one decimal point placement after the first digit is allowed (e.g., `012` â†’ `0.12`).
  - If `S` ends with zero, the original string is returned without any decimal placement.
- For valid strings, possible decimal placements are generated by splitting the string at different positions.

### Complexity

#### Time Complexity
- **O(N^3)**, where `N` is the length of the string. This complexity arises from iterating over possible splits and generating combinations of coordinates.

#### Space Complexity
- **O(N^2)** due to the storage requirements for holding intermediate strings and results.

### Conclusion

This solution effectively generates all valid coordinates from the input string by handling decimal placements through logical validation checks. The use of helper functions and string manipulation ensures that invalid formats are excluded, and all possible combinations are captured accurately. The solution efficiently addresses all edge cases related to leading and trailing zeros, resulting in a comprehensive list of coordinate pairs that adhere to the given problem constraints.

[`Link to LeetCode Lab`](https://leetcode.com/problems/ambiguous-coordinates/description/)

---

| [LeetCode Solutions Library](https://grid47.xyz/leetcode/) / [DSA Sheets](https://grid47.xyz/sheets/) / [Course Catalog](https://grid47.xyz/courses/) |
| --- |

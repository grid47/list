
+++
authors = ["grid47"]
title = "Leetcode 866: Prime Palindrome"
date = "2024-08-12"
lastmod = "2024-11-06"
description = "In-depth solution and explanation for Leetcode 866: Prime Palindrome in C++. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis."
tags = ["Math","Number Theory"]
categories = [
    "Medium"
]
series = ["Leetcode"]
img_src = ""
youtube = "MZSbndVpxH8"
youtube_upload_date="2019-11-14"
youtube_thumbnail="https://i.ytimg.com/vi_webp/MZSbndVpxH8/maxresdefault.webp"
comments = true
+++



---
Given an integer `n`, find the smallest integer that is both a prime number and a palindrome, and is greater than or equal to `n`. A prime number is an integer greater than 1 with no divisors other than 1 and itself. A palindrome is a number that reads the same forwards and backwards.
<!--more-->
{{< dots >}}
### Input Representations 📥
- **Input:** The input is a single integer `n`.
- **Example:** `Input: n = 15`
- **Constraints:**
	- 1 <= n <= 10^8

{{< dots >}}
### Output Specifications 📤
- **Output:** Return the smallest integer that is both a prime and a palindrome, and is greater than or equal to `n`.
- **Example:** `Output: 17`
- **Constraints:**
	- The output will always exist within the range [2, 2 * 10^8].

{{< dots >}}
### Core Logic 🔍
**Goal:** Find the smallest prime palindrome greater than or equal to the given integer `n`.

- Iterate over integers starting from `n`.
- Check if the current number is a palindrome.
- If it is a palindrome, check if it is a prime number.
- If both conditions are satisfied, return the number.
{{< dots >}}
### Problem Assumptions ✅
- The input `n` is a valid positive integer.
- The answer always exists within the given range.
{{< dots >}}
## Examples 🧩
- **Input:** `Input: n = 15, Output: 17`  \
  **Explanation:** The smallest palindrome greater than or equal to 15 is 17, and 17 is also a prime number.

- **Input:** `Input: n = 22, Output: 101`  \
  **Explanation:** The smallest palindrome greater than or equal to 22 that is also prime is 101.

{{< dots >}}
## Approach 🚀
The problem is solved by combining palindrome generation with primality testing for numbers starting from the input value.

### Initial Thoughts 💭
- Palindromes can be generated by mirroring a number's digits.
- Primality testing can be optimized by only checking divisors up to the square root.
- Special cases include small values like 1 and 2.
- Start generating palindromes greater than or equal to `n` and test them for primality.
{{< dots >}}
### Edge Cases 🌐
- Not applicable since `n` is always provided.
- Input `n` close to 10^8, requiring efficient palindrome and prime checks.
- Input `n = 1`, where the output should be 2.
- Input `n = 8`, where the output is the special palindrome prime 11.
- Ensure the function does not generate unnecessary numbers or exceed time limits.
{{< dots >}}
## Code 💻
```cpp
int primePalindrome(int n) {
    if(8 <= n && n <= 11) return 11;
    for(int x = 1; x < 100000; x++) {
        string s = to_string(x), r(s.rbegin(), s.rend());
        int y = stoi(s + r.substr(1));
        if(y >= n && isPrime(y)) return y;
    }
    return -1;
}

bool isPrime(int num) {
    if(num < 2 || num %2 == 0) return num == 2;
    for(int i = 3; i * i <= num; i += 2) {
        if(num%i == 0) return false;
    }
    return true;
}
```

The code implements a solution to find the smallest prime palindrome greater than or equal to the given number n. It also contains a helper function to check if a number is prime.

{{< dots >}}
### Step-by-Step Breakdown 🛠️
1. **Function Definition**
	```cpp
	int primePalindrome(int n) {
	```
	The function definition of `primePalindrome` that takes an integer n as input and returns an integer.

2. **Condition Check**
	```cpp
	    if(8 <= n && n <= 11) return 11;
	```
	A base case for small numbers between 8 and 11. It returns 11 directly since 11 is the smallest prime palindrome in that range.

3. **Loop**
	```cpp
	    for(int x = 1; x < 100000; x++) {
	```
	A loop iterates over integers starting from 1 to 100,000, generating potential candidates for prime palindromes.

4. **String Operations**
	```cpp
	        string s = to_string(x), r(s.rbegin(), s.rend());
	```
	Converts the integer x to a string and generates its reverse by using the `rbegin()` and `rend()` iterators.

5. **String Concatenation**
	```cpp
	        int y = stoi(s + r.substr(1));
	```
	Concatenates the string `s` and the substring of `r` (excluding its first character) to form a potential palindrome number y.

6. **Prime Check**
	```cpp
	        if(y >= n && isPrime(y)) return y;
	```
	Checks if the number y is greater than or equal to n and if it is prime, in which case it is returned as the result.

7. **Loop End**
	```cpp
	    }
	```
	End of the loop iterating over potential palindrome numbers.

8. **Return Statement**
	```cpp
	    return -1;
	```
	If no prime palindrome is found in the loop, the function returns -1 to indicate failure.

9. **Function End**
	```cpp
	}
	```
	End of the `primePalindrome` function.

10. **Function Definition**
	```cpp
	bool isPrime(int num) {
	```
	The definition of the helper function `isPrime`, which checks if a number is prime.

11. **Prime Condition Check**
	```cpp
	    if(num < 2 || num %2 == 0) return num == 2;
	```
	Checks if the number is less than 2 or even. If so, it only returns true for the number 2.

12. **Loop For Prime**
	```cpp
	    for(int i = 3; i * i <= num; i += 2) {
	```
	A loop iterating from 3 to the square root of `num`, checking if `num` is divisible by any odd number.

13. **Prime Check Return False**
	```cpp
	        if(num%i == 0) return false;
	```
	If `num` is divisible by `i`, then it is not prime and the function returns false.

14. **Prime Check Return True**
	```cpp
	    }
	```
	End of the loop checking for prime factors.

15. **Function End**
	```cpp
	    return true;
	```
	If no factors are found, the function returns true, indicating that `num` is prime.

16. **Function End**
	```cpp
	}
	```
	End of the `isPrime` function.

{{< dots >}}
## Complexity Analysis 📊
### Time Complexity ⏳
- **Best Case:** O(sqrt(N)), where N is the smallest valid output.
- **Average Case:** O(M * sqrt(N)), where M is the number of candidates generated.
- **Worst Case:** O(M * sqrt(N)), when `n` is large and close to 10^8.

Palindrome generation is efficient, but primality testing contributes the most to complexity.

### Space Complexity 💾
- **Best Case:** O(1), when considering only constant space for variables.
- **Worst Case:** O(log(N)), where N is the palindrome being checked.

Space usage is minimal as palindrome generation and primality testing use iterative methods.

**Happy Coding! 🎉**


[`Link to LeetCode Lab`](https://leetcode.com/problems/prime-palindrome/description/)

---
{{< youtube MZSbndVpxH8 >}}
| [LeetCode Solutions Library](https://grid47.xyz/leetcode/) / [DSA Sheets](https://grid47.xyz/sheets/) / [Course Catalog](https://grid47.xyz/courses/) |
| --- |

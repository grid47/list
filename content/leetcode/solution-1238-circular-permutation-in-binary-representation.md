
+++
authors = ["grid47"]
title = "Leetcode 1238: Circular Permutation in Binary Representation"
date = "2024-07-06"
lastmod = "2024-11-06"
description = "In-depth solution and explanation for Leetcode 1238: Circular Permutation in Binary Representation in C++. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis."
tags = ["Math","Backtracking","Bit Manipulation"]
categories = [
    "Medium"
]
series = ["Leetcode"]
img_src = ""
youtube = ""
youtube_upload_date=""
youtube_thumbnail=""
+++



---
**Code:**

{{< highlight cpp >}}
class Solution {
public:
    vector<int> circularPermutation(int n, int start) {
        vector<int> res;
        for(int i = 0; i < 1 << n; i++)
            res.push_back(start ^ i ^ i >> 1);
        return res;
    }
};
{{< /highlight >}}
---


### Problem Statement
The task is to generate a circular permutation of numbers represented in binary. Given an integer \( n \), the function needs to produce an array of \( 2^n \) integers, representing the values of all \( n \)-bit binary numbers in a circular format, starting from a specified integer `start`. The challenge lies in ensuring that the generated numbers form a valid Gray code sequence, where two consecutive numbers differ by only one bit.

### Approach
The approach leverages the properties of Gray codes to generate the circular permutation. The key idea behind the Gray code is that for any integer \( i \), the corresponding Gray code value can be calculated using the formula:

\[ \text{Gray}(i) = i \oplus (i >> 1) \]

Where \( \oplus \) represents the bitwise XOR operation. In this case, the sequence is further adjusted to start from the specified integer `start` by applying another XOR operation with `start`. The complete sequence can be generated by iterating through all integers from \( 0 \) to \( 2^n - 1 \).

### Code Breakdown (Step by Step)

```cpp
class Solution {
public:
    vector<int> circularPermutation(int n, int start) {
        vector<int> res;
```
- **Lines 1-3**: We define the `Solution` class and declare the public method `circularPermutation`, which takes two integers \( n \) and `start` as parameters. We also initialize an empty vector `res` to hold the results.

```cpp
        for(int i = 0; i < 1 << n; i++)
            res.push_back(start ^ i ^ i >> 1);
```
- **Lines 4-5**: Here, we use a for loop that iterates from \( 0 \) to \( 2^n - 1 \) (calculated as \( 1 << n \), which is a bitwise left shift of 1 by \( n \) positions).
    - For each integer \( i \) in this range, we calculate the corresponding Gray code value by performing the following operations:
        1. `i >> 1`: This shifts the bits of \( i \) to the right by one position.
        2. `start ^ i`: This XORs `start` with \( i \).
        3. The final result `start ^ i ^ (i >> 1)` is pushed into the `res` vector.

### Summary of Operations
The formula utilized in the loop effectively constructs the desired circular permutation:
- The first part `i` represents each number in the range.
- The right shift operation ensures we are aligning the bits correctly for the Gray code transformation.
- The XOR operation with `start` ensures the sequence starts from the specified integer.

```cpp
        return res;
    }
};
```
- **Lines 6-7**: After completing the loop and populating the `res` vector with the circular permutation values, we return this vector.

### Complexity
1. **Time Complexity**: The time complexity of this solution is \( O(2^n) \), which arises from the need to generate all \( 2^n \) numbers in the circular permutation.
2. **Space Complexity**: The space complexity is also \( O(2^n) \) due to the storage required for the resulting vector containing all the permutations.

### Conclusion
The `circularPermutation` function provides an efficient and elegant solution to generate a circular permutation of numbers in Gray code format. By utilizing bitwise operations and the properties of XOR, the function achieves its goal with minimal computational overhead and in a straightforward manner. This makes the solution not only effective but also easy to understand and implement for similar problems involving binary representations and permutations. The algorithm's efficiency in generating the results ensures it can handle relatively larger values of \( n \) within reasonable limits, making it a valuable technique in combinatorial generation tasks.

[`Link to LeetCode Lab`](https://leetcode.com/problems/circular-permutation-in-binary-representation/description/)

---

| [LeetCode Solutions Library](https://grid47.xyz/leetcode/) / [DSA Sheets](https://grid47.xyz/sheets/) / [Course Catalog](https://grid47.xyz/courses/) |
| --- |

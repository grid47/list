<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Depth-First Search on grid47</title>
    <link>http://localhost:1313/tags/depth-first-search/</link>
    <description>Recent content in Depth-First Search on grid47</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>www.grid47.com - All rights reserved</copyright>
    <lastBuildDate>Wed, 06 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/depth-first-search/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 100: Same Tree</title>
      <link>http://localhost:1313/leetcode/solution-100-same-tree/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-100-same-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3051s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/100.webp&#34; &#xA;           alt=&#34;Two trees glowing in harmony, showing perfect symmetry and balance.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 100: Same Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given two binary trees. Your task is to check if these two trees are the same. Two binary trees are considered the same if they are structurally identical and the nodes have the same value at each corresponding position.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 94: Binary Tree Inorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-94-binary-tree-inorder-traversal/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-94-binary-tree-inorder-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4441s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/94.webp&#34; &#xA;           alt=&#34;A glowing tree with nodes softly illuminating as the inorder traversal progresses.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 94: Binary Tree Inorder Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the values of its nodes as they appear in an inorder traversal. Inorder traversal visits nodes in the left subtree, the root, and then the right subtree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 98: Validate Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-98-validate-binary-search-tree/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-98-validate-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4469s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/98.webp&#34; &#xA;           alt=&#34;A glowing tree with balanced nodes, radiating a sense of order and validation.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 98: Validate Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to determine whether the tree is a valid binary search tree (BST). A binary search tree is valid if for every node in the tree, the value of all nodes in its left subtree are less than its own value, and the value of all nodes in its right subtree are greater than its own value.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 99: Recover Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-99-recover-binary-search-tree/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-99-recover-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4473s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/99.webp&#34; &#xA;           alt=&#34;A tree softly rearranging its nodes, finding its balance and order.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 99: Recover Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary search tree (BST), but two nodes in the tree were swapped by mistake. Your task is to recover the tree by swapping the two nodes back, without changing the structure of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 104: Maximum Depth of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-104-maximum-depth-of-binary-tree/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-104-maximum-depth-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3078s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/104.webp&#34; &#xA;           alt=&#34;A deep, glowing tree with rays of light expanding downwards to symbolize depth.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 104: Maximum Depth of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to return the maximum depth of the tree. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 110: Balanced Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-110-balanced-binary-tree/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-110-balanced-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3103s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/110.webp&#34; &#xA;           alt=&#34;A tree where branches gently balance on either side, with glowing nodes symbolizing equilibrium.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 110: Balanced Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a binary tree, determine if it is height-balanced. A binary tree is considered height-balanced if for every node, the height of the left and right subtrees differs by no more than one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 111: Minimum Depth of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-111-minimum-depth-of-binary-tree/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-111-minimum-depth-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3106s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/111.webp&#34; &#xA;           alt=&#34;A deep tree with soft, glowing light reaching the minimal depth, highlighting the shortest path.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 111: Minimum Depth of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a binary tree, find its minimum depth. The minimum depth is defined as the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf node is a node that does not have any children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 113: Path Sum II</title>
      <link>http://localhost:1313/leetcode/solution-113-path-sum-ii/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-113-path-sum-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3116s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/113.webp&#34; &#xA;           alt=&#34;A radiant path of numbers, showing multiple possible paths with gentle branches leading to different sums.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 113: Path Sum II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree and an integer targetSum, return all paths from the root to the leaf nodes where the sum of the node values along the path equals the targetSum. A root-to-leaf path is defined as any path that starts from the root and ends at a leaf node. A leaf node is a node that does not have any children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 114: Flatten Binary Tree to Linked List</title>
      <link>http://localhost:1313/leetcode/solution-114-flatten-binary-tree-to-linked-list/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-114-flatten-binary-tree-to-linked-list/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3122s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/114.webp&#34; &#xA;           alt=&#34;A soft tree smoothly transforming into a linear, glowing list of nodes, symbolizing a flattened structure.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 114: Flatten Binary Tree to Linked List Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, flatten the tree into a &amp;rsquo;linked list&amp;rsquo; where each node&amp;rsquo;s right pointer points to the next node in pre-order traversal, and the left pointer of all nodes is null. The &amp;rsquo;linked list&amp;rsquo; should maintain the same order as a pre-order traversal of the binary tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 116: Populating Next Right Pointers in Each Node</title>
      <link>http://localhost:1313/leetcode/solution-116-populating-next-right-pointers-in-each-node/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-116-populating-next-right-pointers-in-each-node/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3130s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/116.webp&#34; &#xA;           alt=&#34;A glowing grid of nodes, with gentle arrows connecting them, showing the next right pointer linkages.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 116: Populating Next Right Pointers in Each Node Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a perfect binary tree where every parent node has two children and all leaves are at the same level. Your task is to populate the &amp;rsquo;next&amp;rsquo; pointer of each node to point to its next right node. If no such node exists, set the &amp;rsquo;next&amp;rsquo; pointer to NULL. Initially, all &amp;rsquo;next&amp;rsquo; pointers are set to NULL.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 130: Surrounded Regions</title>
      <link>http://localhost:1313/leetcode/solution-130-surrounded-regions/</link>
      <pubDate>Fri, 25 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-130-surrounded-regions/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3182s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/130.webp&#34; &#xA;           alt=&#34;A grid of cells gently surrounded by a calming border of light, with certain areas being &amp;#39;captured.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 130: Surrounded Regions Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an m x n matrix board containing letters &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;. Capture all regions that are surrounded by &amp;lsquo;X&amp;rsquo;. A region is captured if it is surrounded by &amp;lsquo;X&amp;rsquo; cells and cannot reach the edges of the board.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 133: Clone Graph</title>
      <link>http://localhost:1313/leetcode/solution-133-clone-graph/</link>
      <pubDate>Thu, 24 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-133-clone-graph/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3197s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/133.webp&#34; &#xA;           alt=&#34;A graph with nodes gently duplicating and glowing, forming an identical copy with soft edges.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 133: Clone Graph Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a reference to a node in a connected, undirected graph. Each node in the graph contains a value (integer) and a list of its neighbors. Your task is to return a deep copy of the entire graph starting from the given node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 144: Binary Tree Preorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-144-binary-tree-preorder-traversal/</link>
      <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-144-binary-tree-preorder-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3257s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/144.webp&#34; &#xA;           alt=&#34;A tree with nodes glowing sequentially from root to leaf, following a smooth, glowing path.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 144: Binary Tree Preorder Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. The task is to return the preorder traversal of the tree. Preorder traversal means visiting the root node first, followed by the left subtree, and then the right subtree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 199: Binary Tree Right Side View</title>
      <link>http://localhost:1313/leetcode/solution-199-binary-tree-right-side-view/</link>
      <pubDate>Fri, 18 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-199-binary-tree-right-side-view/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3533s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/199.webp&#34; &#xA;           alt=&#34;A glowing tree viewed from the right side, with the rightmost nodes gently illuminating.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 199: Binary Tree Right Side View Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Imagine yourself standing on the right side of the tree, and return the values of the nodes you can see when viewed from the right, ordered from top to bottom.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 200: Number of Islands</title>
      <link>http://localhost:1313/leetcode/solution-200-number-of-islands/</link>
      <pubDate>Fri, 18 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-200-number-of-islands/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3542s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/200.webp&#34; &#xA;           alt=&#34;A map of glowing islands floating gently, with the number of islands appearing as a soft count.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 200: Number of Islands Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a 2D grid representing a map, where &amp;lsquo;1&amp;rsquo; represents land and &amp;lsquo;0&amp;rsquo; represents water. Your task is to count how many islands are formed by connecting adjacent lands horizontally or vertically. An island is a collection of &amp;lsquo;1&amp;rsquo;s connected either horizontally or vertically.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 207: Course Schedule</title>
      <link>http://localhost:1313/leetcode/solution-207-course-schedule/</link>
      <pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-207-course-schedule/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3584s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/207.webp&#34; &#xA;           alt=&#34;A calming flowchart with courses linking together, showing dependencies in a gentle, glowing path.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 207: Course Schedule Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a set of courses and a list of prerequisites. Each prerequisite is a pair of courses where the second course must be taken before the first one. Determine if it is possible to complete all courses based on these prerequisites. If there are cycles in the dependencies, it would be impossible to finish all courses.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 210: Course Schedule II</title>
      <link>http://localhost:1313/leetcode/solution-210-course-schedule-ii/</link>
      <pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-210-course-schedule-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3600s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/210.webp&#34; &#xA;           alt=&#34;A series of tasks gently forming a schedule, with dependencies softly highlighted as the courses unfold.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 210: Course Schedule II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a set of courses with prerequisites, and you need to find a valid order to take them, or return an empty array if no valid order exists.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 211: Design Add and Search Words Data Structure</title>
      <link>http://localhost:1313/leetcode/solution-211-design-add-and-search-words-data-structure/</link>
      <pubDate>Wed, 16 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-211-design-add-and-search-words-data-structure/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3607s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/211.webp&#34; &#xA;           alt=&#34;A series of glowing words arranged in a structure, showing efficient searching and adding through soft pathways.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 211: Design Add and Search Words Data Structure Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are tasked with creating a data structure that allows adding words and checking if a word matches any previously added word, with support for the wildcard &amp;lsquo;.&amp;rsquo; character.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 226: Invert Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-226-invert-binary-tree/</link>
      <pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-226-invert-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3691s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/226.webp&#34; &#xA;           alt=&#34;A tree slowly flipping upside down, with nodes glowing as they invert.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 226: Invert Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, invert the tree by swapping the left and right subtrees of every node, and return its root.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 230: Kth Smallest Element in a BST</title>
      <link>http://localhost:1313/leetcode/solution-230-kth-smallest-element-in-a-bst/</link>
      <pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-230-kth-smallest-element-in-a-bst/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3715s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/230.webp&#34; &#xA;           alt=&#34;A binary search tree with nodes softly glowing, showing the kth smallest element highlighted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 230: Kth Smallest Element in a BST Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary search tree and an integer k, your task is to return the kth smallest value in the tree (1-indexed).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 235: Lowest Common Ancestor of a Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-235-lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Mon, 14 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-235-lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3743s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/235.webp&#34; &#xA;           alt=&#34;Two paths glowing brightly as they meet at the lowest common ancestor in a binary search tree.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 235: Lowest Common Ancestor of a Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a Binary Search Tree (BST), find the lowest common ancestor (LCA) of two given nodes. The lowest common ancestor is the deepest node that is an ancestor of both nodes. An ancestor of a node is a node itself or any node in its path up to the root.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 236: Lowest Common Ancestor of a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-236-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Mon, 14 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-236-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3749s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/236.webp&#34; &#xA;           alt=&#34;Similar to the previous idea, with paths gently intersecting to show the common ancestor in a non-search tree.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 236: Lowest Common Ancestor of a Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes. The lowest common ancestor is defined as the lowest node that is an ancestor of both nodes p and q. A node can be a descendant of itself.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 310: Minimum Height Trees</title>
      <link>http://localhost:1313/leetcode/solution-310-minimum-height-trees/</link>
      <pubDate>Mon, 07 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-310-minimum-height-trees/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4093s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/310.webp&#34; &#xA;           alt=&#34;A series of tree structures, with each one growing taller or shorter as the minimum height tree is highlighted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 310: Minimum Height Trees Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a tree with &amp;rsquo;n&amp;rsquo; nodes labeled from 0 to n-1, represented by &amp;rsquo;n-1&amp;rsquo; edges. Your task is to find all roots that minimize the height of the tree. The height of a tree is defined as the number of edges in the longest downward path from the root to any leaf.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 341: Flatten Nested List Iterator</title>
      <link>http://localhost:1313/leetcode/solution-341-flatten-nested-list-iterator/</link>
      <pubDate>Thu, 03 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-341-flatten-nested-list-iterator/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4123s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/341.webp&#34; &#xA;           alt=&#34;A nested list unfolding and flattening into a 1D array, with each item softly glowing as it appears.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 341: Flatten Nested List Iterator Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a nested list of integers nestedList, where each element can either be an integer or a sublist containing integers or other sublists. Implement an iterator to flatten this nested list.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 365: Water and Jug Problem</title>
      <link>http://localhost:1313/leetcode/solution-365-water-and-jug-problem/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-365-water-and-jug-problem/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4133s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/365.webp&#34; &#xA;           alt=&#34;A set of water jugs being filled and emptied, with the optimal solution softly glowing as it reaches the target amount.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 365: Water and Jug Problem Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given two jugs with capacities x and y liters, and an infinite supply of water. You need to determine whether you can measure exactly target liters of water using the following operations: fill, empty, and pour water between the jugs.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 385: Mini Parser</title>
      <link>http://localhost:1313/leetcode/solution-385-mini-parser/</link>
      <pubDate>Sun, 29 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-385-mini-parser/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4147s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/385.webp&#34; &#xA;           alt=&#34;A series of nested lists being parsed, with each level gently unfolding and being highlighted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 385: Mini Parser Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a string s representing a serialized nested list, implement a parser to deserialize it and return the deserialized NestedInteger.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 386: Lexicographical Numbers</title>
      <link>http://localhost:1313/leetcode/solution-386-lexicographical-numbers/</link>
      <pubDate>Sun, 29 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-386-lexicographical-numbers/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4148s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/386.webp&#34; &#xA;           alt=&#34;A glowing series of numbers arranged in lexicographical order, highlighting their progression.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 386: Lexicographical Numbers Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given an integer n, return all the numbers in the range [1, n] sorted in lexicographical order. The solution must run in O(n) time and use O(1) extra space.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 388: Longest Absolute File Path</title>
      <link>http://localhost:1313/leetcode/solution-388-longest-absolute-file-path/</link>
      <pubDate>Sun, 29 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-388-longest-absolute-file-path/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4150s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/388.webp&#34; &#xA;           alt=&#34;A file path glowing as it grows, showing the longest path as it is traced step by step.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 388: Longest Absolute File Path Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;In a file system where both directories and files are stored, we are given a string representation of the system. The string includes the directory structure, with tab characters (&amp;rsquo;\t&amp;rsquo;) representing subdirectories and newline characters (&amp;rsquo;\n&amp;rsquo;) representing file and directory boundaries. Each directory and file has a unique absolute path. Compute the length of the longest absolute path to a file. If no file exists, return 0.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 399: Evaluate Division</title>
      <link>http://localhost:1313/leetcode/solution-399-evaluate-division/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-399-evaluate-division/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4160s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/399.webp&#34; &#xA;           alt=&#34;A set of equations forming a division problem, with the answer softly glowing as it is calculated.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 399: Evaluate Division Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a list of equations and their corresponding values, where each equation represents a division between two variables. Your task is to determine the result of several queries asking for the division result of two given variables.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 417: Pacific Atlantic Water Flow</title>
      <link>http://localhost:1313/leetcode/solution-417-pacific-atlantic-water-flow/</link>
      <pubDate>Thu, 26 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-417-pacific-atlantic-water-flow/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4167s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/417.webp&#34; &#xA;           alt=&#34;A map with water flowing from both Pacific and Atlantic oceans, gently meeting at highlighted points.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 417: Pacific Atlantic Water Flow Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an m x n grid representing an island, where each cell contains an integer representing the height above sea level. The island borders both the Pacific and Atlantic Oceans. The Pacific Ocean touches the left and top edges of the grid, and the Atlantic Ocean touches the right and bottom edges. Water can flow from one cell to an adjacent cell if the adjacent cell&amp;rsquo;s height is less than or equal to the current cell&amp;rsquo;s height. The task is to find all the cells where water can flow to both oceans.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 419: Battleships in a Board</title>
      <link>http://localhost:1313/leetcode/solution-419-battleships-in-a-board/</link>
      <pubDate>Thu, 26 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-419-battleships-in-a-board/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4169s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/419.webp&#34; &#xA;           alt=&#34;A board game where ships glow softly as they are placed on the grid, each ship highlighted as it is positioned.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 419: Battleships in a Board Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a grid representing a battleship field, where &amp;lsquo;X&amp;rsquo; marks the location of a part of a battleship and &amp;lsquo;.&amp;rsquo; represents an empty sea cell. A battleship is either placed horizontally or vertically on the grid, with no adjacent battleships (there must be at least one empty cell between any two battleships). Your task is to count the number of distinct battleships on the grid.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 437: Path Sum III</title>
      <link>http://localhost:1313/leetcode/solution-437-path-sum-iii/</link>
      <pubDate>Tue, 24 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-437-path-sum-iii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4178s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/437.webp&#34; &#xA;           alt=&#34;A tree with nodes lighting up, showing the path sum from a root node to the leaves, highlighting valid paths.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 437: Path Sum III Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree and an integer targetSum. Your task is to count the total number of paths in the tree where the sum of node values along the path equals targetSum. The path does not need to start or end at the root or a leaf, but it must go downwards (from parent to child nodes).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 449: Serialize and Deserialize BST</title>
      <link>http://localhost:1313/leetcode/solution-449-serialize-and-deserialize-bst/</link>
      <pubDate>Mon, 23 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-449-serialize-and-deserialize-bst/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4183s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/449.webp&#34; &#xA;           alt=&#34;A binary search tree being serialized and deserialized, with each node softly glowing during the transformation.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 449: Serialize and Deserialize BST Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Design an algorithm to serialize and deserialize a binary search tree (BST). Serialization is converting the tree to a string format, while deserialization reconstructs the tree from this string. The goal is to ensure that the BST can be serialized to a compact string and can be accurately deserialized back into the original tree structure.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 501: Find Mode in Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-501-find-mode-in-binary-search-tree/</link>
      <pubDate>Tue, 17 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-501-find-mode-in-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4208s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/501.webp&#34; &#xA;           alt=&#34;A glowing tree with nodes lighting up to highlight the mode, with the mode’s value softly radiating.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 501: Find Mode in Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary search tree (BST) with possible duplicates, return the mode(s) (i.e., the most frequently occurring element) in the tree. If there are multiple modes, return them in any order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 508: Most Frequent Subtree Sum</title>
      <link>http://localhost:1313/leetcode/solution-508-most-frequent-subtree-sum/</link>
      <pubDate>Tue, 17 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-508-most-frequent-subtree-sum/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4209s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/508.webp&#34; &#xA;           alt=&#34;A tree with sums at each subtree, and the most frequent subtree sum glowing brightly as it is discovered.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 508: Most Frequent Subtree Sum Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the most frequent subtree sum. A subtree sum is the sum of all the node values in the subtree rooted at any node, including the node itself. If there is a tie, return all the subtree sums with the highest frequency.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 513: Find Bottom Left Tree Value</title>
      <link>http://localhost:1313/leetcode/solution-513-find-bottom-left-tree-value/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-513-find-bottom-left-tree-value/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4211s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/513.webp&#34; &#xA;           alt=&#34;A tree with a glowing bottom-left node, showing the value of the deepest leftmost node in the binary tree.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 513: Find Bottom Left Tree Value Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the leftmost value in the last row of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 515: Find Largest Value in Each Tree Row</title>
      <link>http://localhost:1313/leetcode/solution-515-find-largest-value-in-each-tree-row/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-515-find-largest-value-in-each-tree-row/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4212s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/515.webp&#34; &#xA;           alt=&#34;A tree with rows of values, each row highlighted with the largest value softly glowing.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 515: Find Largest Value in Each Tree Row Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 529: Minesweeper</title>
      <link>http://localhost:1313/leetcode/solution-529-minesweeper/</link>
      <pubDate>Sun, 15 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-529-minesweeper/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4222s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/529.webp&#34; &#xA;           alt=&#34;A glowing grid with mines and safe spots, where the player’s moves are highlighted to avoid mines.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 529: Minesweeper Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are playing the game Minesweeper. Given an m x n grid, you must reveal the square corresponding to the next click and update the grid according to Minesweeper&amp;rsquo;s rules. The grid can contain mines (&amp;lsquo;M&amp;rsquo;), empty squares (&amp;lsquo;E&amp;rsquo;), or revealed squares with adjacent mine counts.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 530: Minimum Absolute Difference in BST</title>
      <link>http://localhost:1313/leetcode/solution-530-minimum-absolute-difference-in-bst/</link>
      <pubDate>Sun, 15 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-530-minimum-absolute-difference-in-bst/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4224s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/530.webp&#34; &#xA;           alt=&#34;A binary search tree where nodes light up showing the minimum absolute difference between node values.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 530: Minimum Absolute Difference in BST Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 538: Convert BST to Greater Tree</title>
      <link>http://localhost:1313/leetcode/solution-538-convert-bst-to-greater-tree/</link>
      <pubDate>Sat, 14 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-538-convert-bst-to-greater-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4228s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/538.webp&#34; &#xA;           alt=&#34;A binary search tree where each node is gradually updated to a greater tree, with each transformation softly highlighted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 538: Convert BST to Greater Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a Binary Search Tree (BST), convert it into a Greater Tree where every node’s value is replaced by the sum of all greater node values in the BST plus its original value.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 543: Diameter of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-543-diameter-of-binary-tree/</link>
      <pubDate>Fri, 13 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-543-diameter-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4233s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/543.webp&#34; &#xA;           alt=&#34;A binary tree where the longest path between two nodes is highlighted, glowing softly to show the tree&amp;#39;s diameter.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 543: Diameter of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes, which may or may not pass through the root.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 547: Number of Provinces</title>
      <link>http://localhost:1313/leetcode/solution-547-number-of-provinces/</link>
      <pubDate>Fri, 13 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-547-number-of-provinces/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4234s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/547.webp&#34; &#xA;           alt=&#34;A map of regions where provinces are counted and highlighted, each province glowing softly.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 547: Number of Provinces Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a matrix where each element indicates if two cities are directly connected. Your task is to determine the number of provinces formed by the cities. A province is a group of directly or indirectly connected cities.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 565: Array Nesting</title>
      <link>http://localhost:1313/leetcode/solution-565-array-nesting/</link>
      <pubDate>Wed, 11 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-565-array-nesting/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4240s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/565.webp&#34; &#xA;           alt=&#34;An array where elements are nested, each valid nesting glowing softly as it is processed.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 565: Array Nesting Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an array nums, a permutation of numbers from [0, n-1], and for each index k, you need to build a set s[k] by repeatedly selecting elements based on the rule nums[k] -&amp;gt; nums[nums[k]] -&amp;gt; nums[nums[nums[k]]], stopping when a duplicate is found. Return the longest length of any such set s[k].&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 572: Subtree of Another Tree</title>
      <link>http://localhost:1313/leetcode/solution-572-subtree-of-another-tree/</link>
      <pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-572-subtree-of-another-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4244s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/572.webp&#34; &#xA;           alt=&#34;A tree being checked for its subtree, with the subtree softly glowing as it is found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 572: Subtree of Another Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the roots of two binary trees, root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree consists of a node in the tree and all of this node&amp;rsquo;s descendants.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 589: N-ary Tree Preorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-589-n-ary-tree-preorder-traversal/</link>
      <pubDate>Mon, 09 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-589-n-ary-tree-preorder-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4249s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/589.webp&#34; &#xA;           alt=&#34;An N-ary tree where each node is visited in preorder, with each visit softly glowing as the nodes are explored.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 589: N-ary Tree Preorder Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of an n-ary tree, return the preorder traversal of its nodes&amp;rsquo; values. In one step, the node is visited first, followed by its children from left to right. The input is serialized in a level order format where each group of children is separated by a null value.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 606: Construct String from Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-606-construct-string-from-binary-tree/</link>
      <pubDate>Sat, 07 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-606-construct-string-from-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4254s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/606.webp&#34; &#xA;           alt=&#34;A binary tree where a string is being constructed by traversing the tree, with each character softly glowing.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 606: Construct String from Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root node of a binary tree, generate a string representation of the tree following specific formatting rules based on a preorder traversal.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 617: Merge Two Binary Trees</title>
      <link>http://localhost:1313/leetcode/solution-617-merge-two-binary-trees/</link>
      <pubDate>Fri, 06 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-617-merge-two-binary-trees/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4257s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/617.webp&#34; &#xA;           alt=&#34;Two binary trees merging together, with each node softly glowing as they combine.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 617: Merge Two Binary Trees Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given two binary trees, merge them into a new binary tree where overlapping nodes are summed, and non-overlapping nodes are retained as they are.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 623: Add One Row to Tree</title>
      <link>http://localhost:1313/leetcode/solution-623-add-one-row-to-tree/</link>
      <pubDate>Thu, 05 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-623-add-one-row-to-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4259s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/623.webp&#34; &#xA;           alt=&#34;A binary tree where a new row is being added, with the new row glowing as it is inserted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 623: Add One Row to Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree, and two integers val and depth. You need to add a row of nodes with value val at the given depth depth. The root node is considered to be at depth 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 652: Find Duplicate Subtrees</title>
      <link>http://localhost:1313/leetcode/solution-652-find-duplicate-subtrees/</link>
      <pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-652-find-duplicate-subtrees/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4274s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/652.webp&#34; &#xA;           alt=&#34;A binary tree where duplicate subtrees are identified, and each duplicate subtree softly glows as it’s found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 652: Find Duplicate Subtrees Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return all duplicate subtrees. For each duplicate subtree, return the root node of any one of them. Two trees are considered duplicates if they have the same structure and node values.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 655: Print Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-655-print-binary-tree/</link>
      <pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-655-print-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4277s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/655.webp&#34; &#xA;           alt=&#34;A binary tree where nodes are printed visually, with the structure softly glowing as it is printed.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 655: Print Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, construct a matrix representation of the tree using specific formatting rules to place each node in the appropriate position in the matrix.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 662: Maximum Width of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-662-maximum-width-of-binary-tree/</link>
      <pubDate>Sun, 01 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-662-maximum-width-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4291s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/662.webp&#34; &#xA;           alt=&#34;A binary tree where the maximum width is highlighted, with the width softly glowing as it’s measured.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 662: Maximum Width of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Determine the maximum width of the tree, which is defined as the maximum width among all levels. The width of a level is the distance between the leftmost and rightmost non-null nodes, including null nodes in between that would be present in a complete binary tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 669: Trim a Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-669-trim-a-binary-search-tree/</link>
      <pubDate>Sun, 01 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-669-trim-a-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4282s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/669.webp&#34; &#xA;           alt=&#34;A binary search tree where the tree is trimmed to fit a given range, with each trimmed node softly glowing.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 669: Trim a Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary search tree (BST) and two integer values &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt;. Trim the tree such that all its elements lie within the inclusive range &lt;code&gt;[low, high]&lt;/code&gt;. The tree&amp;rsquo;s relative structure should remain unchanged, and the root may change depending on the given bounds.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 672: Bulb Switcher II</title>
      <link>http://localhost:1313/leetcode/solution-672-bulb-switcher-ii/</link>
      <pubDate>Sat, 31 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-672-bulb-switcher-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4285s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/672.webp&#34; &#xA;           alt=&#34;A set of bulbs where switches are turned on and off, with each change softly glowing.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 672: Bulb Switcher II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are in a room with &lt;code&gt;n&lt;/code&gt; bulbs, all initially turned on. There are four buttons on the wall, each with a different functionality: flip all bulbs, flip even-numbered bulbs, flip odd-numbered bulbs, and flip bulbs with labels &lt;code&gt;j = 3k + 1&lt;/code&gt;. You need to make exactly &lt;code&gt;presses&lt;/code&gt; presses. For each press, you can choose any button. Return the number of distinct possible configurations of the bulbs after performing all the presses.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 676: Implement Magic Dictionary</title>
      <link>http://localhost:1313/leetcode/solution-676-implement-magic-dictionary/</link>
      <pubDate>Sat, 31 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-676-implement-magic-dictionary/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4287s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/676.webp&#34; &#xA;           alt=&#34;A glowing dictionary where each word is stored and retrieved, with each word softly glowing as it’s found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 676: Implement Magic Dictionary Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Design a data structure that supports searching for words that can be matched by changing exactly one character.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 684: Redundant Connection</title>
      <link>http://localhost:1313/leetcode/solution-684-redundant-connection/</link>
      <pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-684-redundant-connection/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4290s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/684.webp&#34; &#xA;           alt=&#34;A graph where redundant connections are detected and softly glowing to indicate the loop.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 684: Redundant Connection Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a graph that started as a tree with n nodes. One additional edge has been added, creating a cycle. Your task is to find and return the redundant edge that, when removed, would turn the graph back into a tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 687: Longest Univalue Path</title>
      <link>http://localhost:1313/leetcode/solution-687-longest-univalue-path/</link>
      <pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-687-longest-univalue-path/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4292s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/687.webp&#34; &#xA;           alt=&#34;A tree where the longest univalue path is traced and softly glowing as it’s found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 687: Longest Univalue Path Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. The task is to find the length of the longest path in the tree where all the nodes in the path have the same value. The path can be anywhere in the tree, not necessarily passing through the root. The path length is determined by the number of edges between the nodes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 695: Max Area of Island</title>
      <link>http://localhost:1313/leetcode/solution-695-max-area-of-island/</link>
      <pubDate>Thu, 29 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-695-max-area-of-island/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4296s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/695.webp&#34; &#xA;           alt=&#34;A map of islands where the maximum area is calculated and softly glowing as the largest island is found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 695: Max Area of Island Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a binary matrix of size m x n, where 1 represents land and 0 represents water. An island is a group of 1&amp;rsquo;s connected horizontally or vertically. Return the area of the largest island. If there are no islands, return 0.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 721: Accounts Merge</title>
      <link>http://localhost:1313/leetcode/solution-721-accounts-merge/</link>
      <pubDate>Mon, 26 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-721-accounts-merge/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4311s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/721.webp&#34; &#xA;           alt=&#34;A set of accounts where identical accounts are merged, with each merge softly glowing as it’s processed.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 721: Accounts Merge Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a list of accounts, where each account consists of a name and a list of emails. Merge accounts that share common emails, and return the merged accounts in the format: name followed by sorted emails.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 733: Flood Fill</title>
      <link>http://localhost:1313/leetcode/solution-733-flood-fill/</link>
      <pubDate>Sun, 25 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-733-flood-fill/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4318s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/733.webp&#34; &#xA;           alt=&#34;A grid where the flood fill algorithm is applied, with the flooded area glowing softly as it spreads.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 733: Flood Fill Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an m x n grid representing an image, where each element in the grid corresponds to a pixel value. Additionally, you&amp;rsquo;re provided with three integers: sr (starting row), sc (starting column), and color. Your task is to perform a flood fill operation on the image starting at the pixel located at (sr, sc).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 743: Network Delay Time</title>
      <link>http://localhost:1313/leetcode/solution-743-network-delay-time/</link>
      <pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-743-network-delay-time/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4324s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/743.webp&#34; &#xA;           alt=&#34;A network of nodes where the delay time is calculated, with the shortest delay glowing softly as it’s found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 743: Network Delay Time Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a network of &lt;code&gt;n&lt;/code&gt; nodes and a list of directed edges with travel times. You need to send a signal from a given node &lt;code&gt;k&lt;/code&gt;. Return the minimum time it takes for all nodes to receive the signal, or return &lt;code&gt;-1&lt;/code&gt; if it is impossible.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 756: Pyramid Transition Matrix</title>
      <link>http://localhost:1313/leetcode/solution-756-pyramid-transition-matrix/</link>
      <pubDate>Fri, 23 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-756-pyramid-transition-matrix/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4330s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/756.webp&#34; &#xA;           alt=&#34;A pyramid structure where transitions occur, with the valid transitions glowing softly as they are made.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 756: Pyramid Transition Matrix Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are building a pyramid by stacking blocks, each represented by a color denoted by a letter. Each row above the bottom consists of one less block, centered on the row beneath. Only specific triangular patterns of blocks are allowed. A triangular pattern consists of three blocks: two at the bottom and one on top. Given the bottom row and allowed patterns, determine if it&amp;rsquo;s possible to construct the pyramid.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 785: Is Graph Bipartite?</title>
      <link>http://localhost:1313/leetcode/solution-785-is-graph-bipartite/</link>
      <pubDate>Tue, 20 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-785-is-graph-bipartite/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4343s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/785.webp&#34; &#xA;           alt=&#34;A graph where bipartiteness is checked, with the two sets glowing softly as they are separated.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 785: Is Graph Bipartite? Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an undirected graph where each node is labeled between 0 and n - 1. The graph is represented as a 2D array, where graph[u] contains the nodes that are adjacent to node u. A graph is bipartite if its nodes can be divided into two sets such that every edge connects a node from one set to a node in the other set. Your task is to return true if the graph is bipartite, otherwise return false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 787: Cheapest Flights Within K Stops</title>
      <link>http://localhost:1313/leetcode/solution-787-cheapest-flights-within-k-stops/</link>
      <pubDate>Tue, 20 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-787-cheapest-flights-within-k-stops/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4345s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/787.webp&#34; &#xA;           alt=&#34;A map where the cheapest flight path is calculated, glowing softly as the optimal path is found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 787: Cheapest Flights Within K Stops Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a number of cities and a list of flights between them. Each flight has a price and connects two cities. You need to find the cheapest route from a given source city to a destination city with at most a certain number of stops. If no such route exists, return -1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 797: All Paths From Source to Target</title>
      <link>http://localhost:1313/leetcode/solution-797-all-paths-from-source-to-target/</link>
      <pubDate>Mon, 19 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-797-all-paths-from-source-to-target/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4354s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/797.webp&#34; &#xA;           alt=&#34;A graph where all paths are traced from source to target, with each path softly glowing as it is found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 797: All Paths From Source to Target Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a directed acyclic graph (DAG) with &lt;code&gt;n&lt;/code&gt; nodes, labeled from 0 to n-1. Find all possible paths from node 0 to node n-1 and return these paths in any order. The graph is represented such that each node has a list of other nodes that can be visited directly from it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 802: Find Eventual Safe States</title>
      <link>http://localhost:1313/leetcode/solution-802-find-eventual-safe-states/</link>
      <pubDate>Sun, 18 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-802-find-eventual-safe-states/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4357s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/802.webp&#34; &#xA;           alt=&#34;A graph with nodes marked as safe, glowing softly as they are identified.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 802: Find Eventual Safe States Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a directed graph where each node represents a point, and edges represent possible transitions between nodes. A node is considered terminal if it has no outgoing edges. A node is deemed safe if every path starting from it leads either to a terminal node or another safe node. Your task is to identify all the safe nodes in the graph and return them in ascending order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 814: Binary Tree Pruning</title>
      <link>http://localhost:1313/leetcode/solution-814-binary-tree-pruning/</link>
      <pubDate>Sat, 17 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-814-binary-tree-pruning/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4361s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/814.webp&#34; &#xA;           alt=&#34;A binary tree where branches are pruned, with the pruned branches glowing softly as they are removed.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 814: Binary Tree Pruning Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to remove all subtrees in the tree that do not contain at least one node with the value 1. A subtree is defined as the node and all its descendants. Return the modified tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 841: Keys and Rooms</title>
      <link>http://localhost:1313/leetcode/solution-841-keys-and-rooms/</link>
      <pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-841-keys-and-rooms/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are in a building with multiple rooms, each containing a set of keys to unlock other rooms. Initially, only the first room (room 0) is unlocked. You are tasked with determining whether you can visit all the rooms, starting from room 0. To enter a locked room, you must have its corresponding key, which can only be obtained by visiting other rooms.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 851: Loud and Rich</title>
      <link>http://localhost:1313/leetcode/solution-851-loud-and-rich/</link>
      <pubDate>Tue, 13 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-851-loud-and-rich/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a group of &lt;code&gt;n&lt;/code&gt; people, each with a unique amount of money and quietness. An array &lt;code&gt;richer&lt;/code&gt; specifies the relationships between people where &lt;code&gt;richer[i] = [ai, bi]&lt;/code&gt; indicates that person &lt;code&gt;ai&lt;/code&gt; has more money than person &lt;code&gt;bi&lt;/code&gt;. You are also given an array &lt;code&gt;quiet&lt;/code&gt; where &lt;code&gt;quiet[i]&lt;/code&gt; represents the quietness of person &lt;code&gt;i&lt;/code&gt;. Your task is to return an array &lt;code&gt;answer&lt;/code&gt; where &lt;code&gt;answer[x]&lt;/code&gt; is the person &lt;code&gt;y&lt;/code&gt; who has the least quietness among all people who have equal or more money than person &lt;code&gt;x&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 863: All Nodes Distance K in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-863-all-nodes-distance-k-in-binary-tree/</link>
      <pubDate>Mon, 12 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-863-all-nodes-distance-k-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a binary tree, a target node within the tree, and a non-negative integer k, determine all the nodes that are exactly k edges away from the target node. Return these node values as a list in any order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 865: Smallest Subtree with all the Deepest Nodes</title>
      <link>http://localhost:1313/leetcode/solution-865-smallest-subtree-with-all-the-deepest-nodes/</link>
      <pubDate>Mon, 12 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-865-smallest-subtree-with-all-the-deepest-nodes/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the smallest subtree that contains all the nodes with the maximum depth in the tree. A node is considered the deepest if it has the greatest distance to the root among all nodes. The subtree of a node consists of the node itself and all its descendants.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 872: Leaf-Similar Trees</title>
      <link>http://localhost:1313/leetcode/solution-872-leaf-similar-trees/</link>
      <pubDate>Sun, 11 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-872-leaf-similar-trees/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given two binary trees, determine if their leaf value sequences are identical. A binary tree&amp;rsquo;s leaf value sequence is the sequence of values of its leaves, from left to right, following the in-order traversal. Two trees are considered leaf-similar if the leaf values in both trees appear in the same order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 886: Possible Bipartition</title>
      <link>http://localhost:1313/leetcode/solution-886-possible-bipartition/</link>
      <pubDate>Sat, 10 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-886-possible-bipartition/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a group of n people, labeled from 1 to n. Each person may dislike other people, and they should not be placed in the same group. Your task is to determine if it is possible to split the group of people into two subgroups, such that no one in the same group dislikes each other. Each pair of dislikes is represented by an array of two people who cannot be in the same group. Return true if such a split is possible, otherwise return false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 934: Shortest Bridge</title>
      <link>http://localhost:1313/leetcode/solution-934-shortest-bridge/</link>
      <pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-934-shortest-bridge/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an n x n binary matrix where 1 represents land and 0 represents water. There are exactly two islands in the grid, and you need to connect them by flipping the smallest number of 0&amp;rsquo;s to 1&amp;rsquo;s. An island is a group of 1&amp;rsquo;s that are connected horizontally or vertically. Your task is to find the minimum number of flips required to connect the two islands.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 938: Range Sum of BST</title>
      <link>http://localhost:1313/leetcode/solution-938-range-sum-of-bst/</link>
      <pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-938-range-sum-of-bst/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary search tree and two integers, low and high, return the sum of values of all nodes whose values are within the inclusive range [low, high]. You can assume that all nodes in the tree have distinct values.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 947: Most Stones Removed with Same Row or Column</title>
      <link>http://localhost:1313/leetcode/solution-947-most-stones-removed-with-same-row-or-column/</link>
      <pubDate>Sun, 04 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-947-most-stones-removed-with-same-row-or-column/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a set of stones placed on a 2D plane at various integer coordinate points. A stone can be removed if it shares the same row or column as another stone that has not been removed yet. Your task is to determine the maximum number of stones that can be removed from the plane by performing valid operations.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 951: Flip Equivalent Binary Trees</title>
      <link>http://localhost:1313/leetcode/solution-951-flip-equivalent-binary-trees/</link>
      <pubDate>Sat, 03 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-951-flip-equivalent-binary-trees/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the roots of two binary trees. A flip operation consists of choosing any node and swapping its left and right child subtrees. A tree X is flip equivalent to tree Y if and only if we can make tree X equal to tree Y by performing some flip operations on X. Your task is to determine if the two trees are flip equivalent.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 959: Regions Cut By Slashes</title>
      <link>http://localhost:1313/leetcode/solution-959-regions-cut-by-slashes/</link>
      <pubDate>Sat, 03 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-959-regions-cut-by-slashes/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an n x n grid where each cell contains one of the following characters: &amp;lsquo;/&amp;rsquo;, &amp;lsquo;&#39;, or &amp;rsquo; &amp;lsquo;. These characters divide the grid into different regions. Your task is to determine how many distinct regions the grid is divided into.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 971: Flip Binary Tree To Match Preorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-971-flip-binary-tree-to-match-preorder-traversal/</link>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-971-flip-binary-tree-to-match-preorder-traversal/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree with n nodes, where each node has a unique value from 1 to n. You are also given a sequence of n integers, voyage, representing the desired pre-order traversal of the tree. A node in the tree can be flipped by swapping its left and right children. Your task is to find the smallest set of nodes to flip such that the pre-order traversal matches voyage. If it is impossible to achieve this traversal, return [-1].&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 979: Distribute Coins in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-979-distribute-coins-in-binary-tree/</link>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-979-distribute-coins-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree with &lt;code&gt;n&lt;/code&gt; nodes, where each node contains &lt;code&gt;node.val&lt;/code&gt; coins. There are exactly &lt;code&gt;n&lt;/code&gt; coins in total across the tree. In one move, you can transfer a coin between two adjacent nodes (parent to child or child to parent). Return the minimum number of moves required to ensure that every node has exactly one coin.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 988: Smallest String Starting From Leaf</title>
      <link>http://localhost:1313/leetcode/solution-988-smallest-string-starting-from-leaf/</link>
      <pubDate>Wed, 31 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-988-smallest-string-starting-from-leaf/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree, where each node contains a value between 0 and 25, corresponding to letters from &amp;lsquo;a&amp;rsquo; to &amp;lsquo;z&amp;rsquo;. Your task is to find the lexicographically smallest string that can be formed by traversing from a leaf node to the root node, using the values in each node as letters.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1020: Number of Enclaves</title>
      <link>http://localhost:1313/leetcode/solution-1020-number-of-enclaves/</link>
      <pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1020-number-of-enclaves/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a grid of size m x n where each cell is either land (1) or sea (0). Your task is to determine the number of land cells that are completely enclosed by sea cells. A land cell is considered enclosed if it cannot reach the boundary of the grid via other land cells.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1026: Maximum Difference Between Node and Ancestor</title>
      <link>http://localhost:1313/leetcode/solution-1026-maximum-difference-between-node-and-ancestor/</link>
      <pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1026-maximum-difference-between-node-and-ancestor/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to find the maximum absolute difference between the values of two nodes, where one node is an ancestor of the other. Specifically, you need to find the largest value of |a.val - b.val|, where node a is an ancestor of node b.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1034: Coloring A Border</title>
      <link>http://localhost:1313/leetcode/solution-1034-coloring-a-border/</link>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1034-coloring-a-border/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an m x n grid of integers where each value represents the color of a cell. You are also given three integers: &lt;code&gt;row&lt;/code&gt;, &lt;code&gt;col&lt;/code&gt;, and &lt;code&gt;color&lt;/code&gt;. The task is to change the color of the border of the connected component containing the cell at &lt;code&gt;grid[row][col]&lt;/code&gt;. A connected component is defined as a group of adjacent cells that have the same color. A border cell is a cell that is either adjacent to a different color cell or is on the boundary of the grid. You should return the updated grid where the border of the connected component is colored with the specified color.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1038: Binary Search Tree to Greater Sum Tree</title>
      <link>http://localhost:1313/leetcode/solution-1038-binary-search-tree-to-greater-sum-tree/</link>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1038-binary-search-tree-to-greater-sum-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a Binary Search Tree (BST), convert it into a Greater Tree where each node&amp;rsquo;s value is updated to the sum of its original value and all the values greater than it in the BST. The transformation should preserve the BST structure.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1042: Flower Planting With No Adjacent</title>
      <link>http://localhost:1313/leetcode/solution-1042-flower-planting-with-no-adjacent/</link>
      <pubDate>Thu, 25 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1042-flower-planting-with-no-adjacent/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given n gardens labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi and garden yi. Each garden needs to be assigned one of 4 types of flowers. You need to ensure that for any two gardens connected by a path, they have different types of flowers. Your task is to return any valid flower assignment for all gardens such that no two adjacent gardens share the same flower type.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1080: Insufficient Nodes in Root to Leaf Paths</title>
      <link>http://localhost:1313/leetcode/solution-1080-insufficient-nodes-in-root-to-leaf-paths/</link>
      <pubDate>Mon, 22 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1080-insufficient-nodes-in-root-to-leaf-paths/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree and an integer limit. Your task is to delete all nodes in the tree that are considered insufficient. A node is insufficient if every root-to-leaf path passing through that node has a sum strictly less than the given limit. A leaf is defined as a node with no children. Return the root of the resulting binary tree after the deletions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1110: Delete Nodes And Return Forest</title>
      <link>http://localhost:1313/leetcode/solution-1110-delete-nodes-and-return-forest/</link>
      <pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1110-delete-nodes-and-return-forest/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, and a list of values to delete, your task is to remove the nodes with the given values. The resulting tree will become a forest, where each tree is a disjoint set of nodes. Return the roots of the trees in the remaining forest.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1123: Lowest Common Ancestor of Deepest Leaves</title>
      <link>http://localhost:1313/leetcode/solution-1123-lowest-common-ancestor-of-deepest-leaves/</link>
      <pubDate>Wed, 17 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1123-lowest-common-ancestor-of-deepest-leaves/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, your task is to return the lowest common ancestor (LCA) of its deepest leaf nodes. The LCA of a set of nodes is the deepest node that is an ancestor of all the nodes in the set. A leaf node is one that does not have any children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1145: Binary Tree Coloring Game</title>
      <link>http://localhost:1313/leetcode/solution-1145-binary-tree-coloring-game/</link>
      <pubDate>Mon, 15 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1145-binary-tree-coloring-game/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Two players play a turn-based game on a binary tree. We are given the root of the tree and the number of nodes, &lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is odd, and each node has a distinct value from 1 to &lt;code&gt;n&lt;/code&gt;. Player 1 selects a value &lt;code&gt;x&lt;/code&gt; and colors the corresponding node red, while Player 2 selects a value &lt;code&gt;y&lt;/code&gt; (where &lt;code&gt;y&lt;/code&gt; ≠ &lt;code&gt;x&lt;/code&gt;) and colors the corresponding node blue. Players take turns coloring neighboring nodes. The game ends when both players pass their turns, and the winner is the player who colored more nodes. Your task is to determine if Player 2 can guarantee a win by choosing a value &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1161: Maximum Level Sum of a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1161-maximum-level-sum-of-a-binary-tree/</link>
      <pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1161-maximum-level-sum-of-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, find the smallest level x (1-indexed) such that the sum of the values of nodes at level x is maximal. Each level of the tree corresponds to the distance from the root, with the root being level 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1202: Smallest String With Swaps</title>
      <link>http://localhost:1313/leetcode/solution-1202-smallest-string-with-swaps/</link>
      <pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1202-smallest-string-with-swaps/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a string s and an array of pairs of indices pairs where each pair pairs[i] = [a, b] represents two indices in the string. You can swap the characters at any of these index pairs any number of times. Your task is to return the lexicographically smallest string that can be obtained after performing the swaps.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1233: Remove Sub-Folders from the Filesystem</title>
      <link>http://localhost:1313/leetcode/solution-1233-remove-sub-folders-from-the-filesystem/</link>
      <pubDate>Sat, 06 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1233-remove-sub-folders-from-the-filesystem/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a list of folder paths, where each path represents a folder in the file system. The task is to remove all sub-folders from the list, keeping only the main folders.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1254: Number of Closed Islands</title>
      <link>http://localhost:1313/leetcode/solution-1254-number-of-closed-islands/</link>
      <pubDate>Thu, 04 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1254-number-of-closed-islands/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 2D grid with 0s (land) and 1s (water). An island is a group of 0s connected 4-directionally, and a closed island is a group of 0s completely surrounded by 1s. Your task is to count how many closed islands are present in the grid.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1261: Find Elements in a Contaminated Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1261-find-elements-in-a-contaminated-binary-tree/</link>
      <pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1261-find-elements-in-a-contaminated-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a contaminated binary tree, recover it and implement a class to search for specific values in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1267: Count Servers that Communicate</title>
      <link>http://localhost:1313/leetcode/solution-1267-count-servers-that-communicate/</link>
      <pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1267-count-servers-that-communicate/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 2D grid where each cell is either 1 (indicating a server) or 0 (no server). Two servers are said to communicate if they are in the same row or column. The task is to find the number of servers that can communicate with at least one other server.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1302: Deepest Leaves Sum</title>
      <link>http://localhost:1313/leetcode/solution-1302-deepest-leaves-sum/</link>
      <pubDate>Sat, 29 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1302-deepest-leaves-sum/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the sum of values of its deepest leaves. The deepest leaves are the nodes found at the lowest level of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1305: All Elements in Two Binary Search Trees</title>
      <link>http://localhost:1313/leetcode/solution-1305-all-elements-in-two-binary-search-trees/</link>
      <pubDate>Sat, 29 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1305-all-elements-in-two-binary-search-trees/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given two binary search trees, root1 and root2, return a list containing all the integers from both trees, sorted in ascending order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1306: Jump Game III</title>
      <link>http://localhost:1313/leetcode/solution-1306-jump-game-iii/</link>
      <pubDate>Sat, 29 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1306-jump-game-iii/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an array of non-negative integers arr and a starting index start. You can jump forward or backward from any index based on the values at the index. Your task is to determine whether you can reach an index with a value of 0.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1315: Sum of Nodes with Even-Valued Grandparent</title>
      <link>http://localhost:1313/leetcode/solution-1315-sum-of-nodes-with-even-valued-grandparent/</link>
      <pubDate>Fri, 28 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1315-sum-of-nodes-with-even-valued-grandparent/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the sum of the values of the nodes that have an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0. A grandparent is defined as the parent of a node’s parent, if it exists.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1319: Number of Operations to Make Network Connected</title>
      <link>http://localhost:1313/leetcode/solution-1319-number-of-operations-to-make-network-connected/</link>
      <pubDate>Fri, 28 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1319-number-of-operations-to-make-network-connected/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a network of computers, each labeled from 0 to n-1, and a list of direct connections between these computers. The network is initially connected in some way, but some computers are not directly connected. You can remove cables from existing direct connections and reconnect them between disconnected computers to minimize the number of operations required to make the entire network fully connected. The task is to determine the minimum number of operations needed. If it&amp;rsquo;s not possible to connect all the computers, return -1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1325: Delete Leaves With a Given Value</title>
      <link>http://localhost:1313/leetcode/solution-1325-delete-leaves-with-a-given-value/</link>
      <pubDate>Thu, 27 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1325-delete-leaves-with-a-given-value/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree and an integer target. Your task is to remove all leaf nodes that have the value equal to the target. Once you remove a leaf node with the target value, if its parent node becomes a leaf node and has the same value, it should also be removed. This process should continue until no more leaf nodes with the target value are present.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1339: Maximum Product of Splitted Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1339-maximum-product-of-splitted-binary-tree/</link>
      <pubDate>Wed, 26 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1339-maximum-product-of-splitted-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, you need to split the tree into two subtrees by removing one edge. The goal is to maximize the product of the sums of these two subtrees. Return the maximum product of the sums of the two subtrees, modulo 10^9 + 7.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1361: Validate Binary Tree Nodes</title>
      <link>http://localhost:1313/leetcode/solution-1361-validate-binary-tree-nodes/</link>
      <pubDate>Sun, 23 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1361-validate-binary-tree-nodes/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given &lt;code&gt;n&lt;/code&gt; nodes in a binary tree, numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;. Each node &lt;code&gt;i&lt;/code&gt; has two children: &lt;code&gt;leftChild[i]&lt;/code&gt; and &lt;code&gt;rightChild[i]&lt;/code&gt;. If a node has no left child, its value will be &lt;code&gt;-1&lt;/code&gt;. Similarly, if a node has no right child, its value will also be &lt;code&gt;-1&lt;/code&gt;. Your task is to return &lt;code&gt;true&lt;/code&gt; if and only if these nodes form exactly one valid binary tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1367: Linked List in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1367-linked-list-in-binary-tree/</link>
      <pubDate>Sun, 23 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1367-linked-list-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree and a linked list. Determine if there exists a downward path in the binary tree that matches all elements of the linked list starting from its head node. A downward path means starting from any node in the binary tree and following child nodes downwards.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1372: Longest ZigZag Path in a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1372-longest-zigzag-path-in-a-binary-tree/</link>
      <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1372-longest-zigzag-path-in-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, find the length of the longest ZigZag path in the tree. A ZigZag path is one where you move left and right alternately, starting from any node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1376: Time Needed to Inform All Employees</title>
      <link>http://localhost:1313/leetcode/solution-1376-time-needed-to-inform-all-employees/</link>
      <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1376-time-needed-to-inform-all-employees/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;A company has &lt;code&gt;n&lt;/code&gt; employees with a unique ID for each employee from 0 to n-1. The head of the company is the one with &lt;code&gt;headID&lt;/code&gt;. Each employee has one direct manager. The head will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news. Each employee needs &lt;code&gt;informTime[i]&lt;/code&gt; minutes to inform their direct subordinates. Return the total time required to inform all employees.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1379: Find a Corresponding Node of a Binary Tree in a Clone of That Tree</title>
      <link>http://localhost:1313/leetcode/solution-1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/</link>
      <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given two binary trees: an original tree and a cloned tree. The cloned tree is a copy of the original tree, and you are given a reference to a node in the original tree. Your task is to return the reference to the corresponding node in the cloned tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1382: Balance a Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-1382-balance-a-binary-search-tree/</link>
      <pubDate>Fri, 21 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1382-balance-a-binary-search-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary search tree (BST), return a balanced BST containing the same node values. A balanced BST is one where the depth of the left and right subtrees of every node never differ by more than 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1391: Check if There is a Valid Path in a Grid</title>
      <link>http://localhost:1313/leetcode/solution-1391-check-if-there-is-a-valid-path-in-a-grid/</link>
      <pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1391-check-if-there-is-a-valid-path-in-a-grid/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an m x n grid where each cell represents a street. The streets have different connections between neighboring cells. Starting from the top-left corner of the grid, you need to find if there exists a valid path to the bottom-right corner, following the direction of the streets.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1443: Minimum Time to Collect All Apples in a Tree</title>
      <link>http://localhost:1313/leetcode/solution-1443-minimum-time-to-collect-all-apples-in-a-tree/</link>
      <pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1443-minimum-time-to-collect-all-apples-in-a-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an undirected tree with &lt;code&gt;n&lt;/code&gt; vertices numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;. Some vertices in this tree contain apples. Each edge in the tree requires &lt;code&gt;1 second&lt;/code&gt; to traverse. Starting at vertex &lt;code&gt;0&lt;/code&gt;, determine the minimum time required to collect all apples and return to vertex &lt;code&gt;0&lt;/code&gt;. The tree structure is described by the array &lt;code&gt;edges&lt;/code&gt;, where &lt;code&gt;edges[i] = [ai, bi]&lt;/code&gt; indicates an edge between vertices &lt;code&gt;ai&lt;/code&gt; and &lt;code&gt;bi&lt;/code&gt;. Additionally, the array &lt;code&gt;hasApple&lt;/code&gt; specifies whether a vertex contains an apple (&lt;code&gt;true&lt;/code&gt;) or not (&lt;code&gt;false&lt;/code&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1448: Count Good Nodes in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1448-count-good-nodes-in-binary-tree/</link>
      <pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1448-count-good-nodes-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, a node is considered &amp;lsquo;good&amp;rsquo; if in the path from the root to that node, there are no nodes with a value greater than the node itself. Return the total number of good nodes in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1457: Pseudo-Palindromic Paths in a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1457-pseudo-palindromic-paths-in-a-binary-tree/</link>
      <pubDate>Fri, 14 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1457-pseudo-palindromic-paths-in-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree where each node contains a digit from 1 to 9. A path from the root to a leaf node is considered pseudo-palindromic if at least one permutation of the node values in the path can form a palindrome. Your task is to return the number of pseudo-palindromic paths in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1462: Course Schedule IV</title>
      <link>http://localhost:1313/leetcode/solution-1462-course-schedule-iv/</link>
      <pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1462-course-schedule-iv/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a set of courses numbered from 0 to numCourses - 1 and a list of prerequisites. Each prerequisite is a pair [ai, bi], indicating that you must complete course ai before course bi. For a series of queries, where each query asks whether a specific course is a prerequisite for another, you are tasked with determining whether each query is true or false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1466: Reorder Routes to Make All Paths Lead to the City Zero</title>
      <link>http://localhost:1313/leetcode/solution-1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero/</link>
      <pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given n cities and n - 1 roads, forming a tree structure. The roads have been directed, and some roads may need to be reoriented to ensure all cities can reach the capital city (city 0). Your task is to determine the minimum number of road reorientations required to make it possible for each city to reach city 0.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1519: Number of Nodes in the Sub-Tree With the Same Label</title>
      <link>http://localhost:1313/leetcode/solution-1519-number-of-nodes-in-the-sub-tree-with-the-same-label/</link>
      <pubDate>Sat, 08 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1519-number-of-nodes-in-the-sub-tree-with-the-same-label/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a tree with &lt;code&gt;n&lt;/code&gt; nodes, where each node has a label, and your task is to find the number of nodes in the subtree rooted at each node that have the same label as that node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1530: Number of Good Leaf Nodes Pairs</title>
      <link>http://localhost:1313/leetcode/solution-1530-number-of-good-leaf-nodes-pairs/</link>
      <pubDate>Fri, 07 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1530-number-of-good-leaf-nodes-pairs/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes is considered good if the shortest path between them is less than or equal to the given distance. The task is to return the number of such good leaf node pairs in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1559: Detect Cycles in 2D Grid</title>
      <link>http://localhost:1313/leetcode/solution-1559-detect-cycles-in-2d-grid/</link>
      <pubDate>Tue, 04 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1559-detect-cycles-in-2d-grid/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a 2D grid of characters, find if there exists a cycle where the same character repeats in the grid. A cycle is defined as a path where a character appears 4 or more times, forming a loop that starts and ends at the same cell. The cycle must consist of adjacent cells, and you are not allowed to revisit the previous cell.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1600: Throne Inheritance</title>
      <link>http://localhost:1313/leetcode/solution-1600-throne-inheritance/</link>
      <pubDate>Fri, 31 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1600-throne-inheritance/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;In a kingdom, there is a well-defined hierarchy of inheritance, starting with the king. The inheritance order depends on the family&amp;rsquo;s birth and death events. Implement a class to keep track of the order, excluding the dead members.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1625: Lexicographically Smallest String After Applying Operations</title>
      <link>http://localhost:1313/leetcode/solution-1625-lexicographically-smallest-string-after-applying-operations/</link>
      <pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1625-lexicographically-smallest-string-after-applying-operations/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a string s of even length consisting of digits from 0 to 9, and two integers a and b, return the lexicographically smallest string that can be obtained by applying two operations any number of times: adding a to all odd indices of s (with wrapping) and rotating s to the right by b positions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1631: Path With Minimum Effort</title>
      <link>http://localhost:1313/leetcode/solution-1631-path-with-minimum-effort/</link>
      <pubDate>Mon, 27 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1631-path-with-minimum-effort/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are a hiker navigating a terrain represented by a 2D grid of heights. Your goal is to find the path from the top-left corner to the bottom-right corner that minimizes the maximum height difference between any two consecutive cells.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1722: Minimize Hamming Distance After Swap Operations</title>
      <link>http://localhost:1313/leetcode/solution-1722-minimize-hamming-distance-after-swap-operations/</link>
      <pubDate>Sat, 18 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1722-minimize-hamming-distance-after-swap-operations/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given two integer arrays, &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt;, both of length &lt;code&gt;n&lt;/code&gt;, and an array &lt;code&gt;allowedSwaps&lt;/code&gt; containing pairs of indices where swapping is allowed. You can perform multiple swaps between the specified pairs to minimize the Hamming distance between &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt;. The Hamming distance is the number of indices where the elements of &lt;code&gt;source&lt;/code&gt; and &lt;code&gt;target&lt;/code&gt; differ.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1743: Restore the Array From Adjacent Pairs</title>
      <link>http://localhost:1313/leetcode/solution-1743-restore-the-array-from-adjacent-pairs/</link>
      <pubDate>Thu, 16 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1743-restore-the-array-from-adjacent-pairs/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an integer array &lt;code&gt;nums&lt;/code&gt; with unique elements, but you have forgotten it. However, you do remember every pair of adjacent elements in &lt;code&gt;nums&lt;/code&gt;. You are given a 2D integer array &lt;code&gt;adjacentPairs&lt;/code&gt; where each &lt;code&gt;adjacentPairs[i] = [ui, vi]&lt;/code&gt; indicates that the elements &lt;code&gt;ui&lt;/code&gt; and &lt;code&gt;vi&lt;/code&gt; are adjacent in &lt;code&gt;nums&lt;/code&gt;. Your task is to reconstruct the original array &lt;code&gt;nums&lt;/code&gt; using these adjacent pairs. There could be multiple valid solutions, so return any one of them.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1905: Count Sub Islands</title>
      <link>http://localhost:1313/leetcode/solution-1905-count-sub-islands/</link>
      <pubDate>Tue, 30 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1905-count-sub-islands/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given two m x n binary matrices, grid1 and grid2, where each cell can either be 0 (representing water) or 1 (representing land). An island is a group of connected 1&amp;rsquo;s, connected either horizontally or vertically. An island in grid2 is considered a sub-island if there is a corresponding island in grid1 that contains all the cells of the island in grid2. Your task is to determine the number of sub-islands in grid2.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1971: Find if Path Exists in Graph</title>
      <link>http://localhost:1313/leetcode/solution-1971-find-if-path-exists-in-graph/</link>
      <pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1971-find-if-path-exists-in-graph/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a graph with &lt;code&gt;n&lt;/code&gt; vertices labeled from 0 to &lt;code&gt;n-1&lt;/code&gt; (inclusive) and edges connecting pairs of vertices. Your task is to determine if there exists a valid path from a given source vertex to a destination vertex. The graph is undirected, and each pair of vertices is connected by at most one edge. The vertices are connected by edges as given in the input.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1992: Find All Groups of Farmland</title>
      <link>http://localhost:1313/leetcode/solution-1992-find-all-groups-of-farmland/</link>
      <pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1992-find-all-groups-of-farmland/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an m x n binary matrix representing a piece of land, where &amp;lsquo;1&amp;rsquo; denotes farmland and &amp;lsquo;0&amp;rsquo; denotes forest. Your task is to identify the coordinates of each rectangular group of contiguous farmland (1&amp;rsquo;s), where each group of farmland is isolated and not adjacent to another group. Return a list of 4-length arrays, where each array represents the top-left and bottom-right coordinates of a rectangular farmland group.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1993: Operations on Tree</title>
      <link>http://localhost:1313/leetcode/solution-1993-operations-on-tree/</link>
      <pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1993-operations-on-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a tree with &lt;code&gt;n&lt;/code&gt; nodes numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n - 1&lt;/code&gt; represented by a &lt;code&gt;parent&lt;/code&gt; array. You need to implement the &lt;code&gt;LockingTree&lt;/code&gt; class with methods for locking, unlocking, and upgrading nodes in the tree based on certain conditions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2049: Count Nodes With the Highest Score</title>
      <link>http://localhost:1313/leetcode/solution-2049-count-nodes-with-the-highest-score/</link>
      <pubDate>Tue, 16 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2049-count-nodes-with-the-highest-score/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree with n nodes, where each node is labeled from 0 to n-1. The tree is represented by a 0-indexed array &lt;code&gt;parents&lt;/code&gt;, where &lt;code&gt;parents[i]&lt;/code&gt; indicates the parent of node &lt;code&gt;i&lt;/code&gt;. The root node has no parent, so &lt;code&gt;parents[0] == -1&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Each node has a score, calculated as follows:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;If the node and the edges connected to it are removed, the tree splits into one or more non-empty subtrees.&lt;/li&gt;&#xA;&lt;li&gt;The score of a node is the product of the sizes of all resulting subtrees.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Return the number of nodes with the highest score in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2096: Step-By-Step Directions From a Binary Tree Node to Another</title>
      <link>http://localhost:1313/leetcode/solution-2096-step-by-step-directions-from-a-binary-tree-node-to-another/</link>
      <pubDate>Thu, 11 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2096-step-by-step-directions-from-a-binary-tree-node-to-another/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree where each node has a unique value between 1 and n. You are also given a start node and a destination node, each represented by their values. Your task is to find the shortest path from the start node to the destination node in terms of directions. The directions should be represented by a string using the characters &amp;lsquo;L&amp;rsquo;, &amp;lsquo;R&amp;rsquo;, and &amp;lsquo;U&amp;rsquo;, where &amp;lsquo;L&amp;rsquo; means left child, &amp;lsquo;R&amp;rsquo; means right child, and &amp;lsquo;U&amp;rsquo; means moving to the parent node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2101: Detonate the Maximum Bombs</title>
      <link>http://localhost:1313/leetcode/solution-2101-detonate-the-maximum-bombs/</link>
      <pubDate>Wed, 10 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2101-detonate-the-maximum-bombs/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a list of bombs represented by a 2D array &amp;lsquo;bombs&amp;rsquo; where each bomb is described by three integers: [xi, yi, ri]. xi and yi denote the X and Y coordinates of the bomb, while ri is its blast radius. Your task is to find the maximum number of bombs that can be detonated by initiating a detonation of one bomb.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2192: All Ancestors of a Node in a Directed Acyclic Graph</title>
      <link>http://localhost:1313/leetcode/solution-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/</link>
      <pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a directed acyclic graph (DAG) with &lt;code&gt;n&lt;/code&gt; nodes, numbered from 0 to &lt;code&gt;n-1&lt;/code&gt;. Along with this, you are given a list of directed edges where each edge &lt;code&gt;[fromi, toi]&lt;/code&gt; indicates a directed edge from node &lt;code&gt;fromi&lt;/code&gt; to node &lt;code&gt;toi&lt;/code&gt;. For each node in the graph, you need to determine the list of all its ancestors. A node &lt;code&gt;u&lt;/code&gt; is an ancestor of node &lt;code&gt;v&lt;/code&gt; if there is a path from &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt; through one or more directed edges. Return a list &lt;code&gt;answer&lt;/code&gt; where &lt;code&gt;answer[i]&lt;/code&gt; contains the sorted list of ancestors of the &lt;code&gt;i&lt;/code&gt;-th node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2265: Count Nodes Equal to Average of Subtree</title>
      <link>http://localhost:1313/leetcode/solution-2265-count-nodes-equal-to-average-of-subtree/</link>
      <pubDate>Mon, 25 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2265-count-nodes-equal-to-average-of-subtree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to return the number of nodes where the value of the node is equal to the average of the values in its entire subtree (including the node itself). The average of a set of values is the sum of the values divided by the number of values, rounded down to the nearest integer.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2316: Count Unreachable Pairs of Nodes in an Undirected Graph</title>
      <link>http://localhost:1313/leetcode/solution-2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/</link>
      <pubDate>Wed, 20 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an undirected graph with n nodes and a list of edges connecting the nodes. The goal is to find the number of pairs of distinct nodes that are unreachable from each other.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2331: Evaluate Boolean Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-2331-evaluate-boolean-binary-tree/</link>
      <pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2331-evaluate-boolean-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a full binary tree. The leaf nodes hold boolean values: 0 (False) and 1 (True). The non-leaf nodes hold values 2 (OR) or 3 (AND). Your task is to evaluate the tree according to the logical operations and return the final boolean result of the root node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2359: Find Closest Node to Given Two Nodes</title>
      <link>http://localhost:1313/leetcode/solution-2359-find-closest-node-to-given-two-nodes/</link>
      <pubDate>Sat, 16 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2359-find-closest-node-to-given-two-nodes/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a directed graph with n nodes, where each node can have at most one outgoing edge. You are provided with an array &lt;code&gt;edges&lt;/code&gt; representing the graph, where &lt;code&gt;edges[i]&lt;/code&gt; indicates a directed edge from node &lt;code&gt;i&lt;/code&gt; to node &lt;code&gt;edges[i]&lt;/code&gt; (or -1 if there is no outgoing edge). You are also given two nodes &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt;. The task is to return the node that is reachable from both &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt;, such that the maximum of the distances from &lt;code&gt;node1&lt;/code&gt; and &lt;code&gt;node2&lt;/code&gt; to that node is minimized. If there are multiple such nodes, return the smallest index, or return &lt;code&gt;-1&lt;/code&gt; if no such node exists.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2368: Reachable Nodes With Restrictions</title>
      <link>http://localhost:1313/leetcode/solution-2368-reachable-nodes-with-restrictions/</link>
      <pubDate>Fri, 15 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2368-reachable-nodes-with-restrictions/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a tree with n nodes and n - 1 edges, where nodes are labeled from 0 to n - 1. Additionally, a list of restricted nodes is provided. Your goal is to determine the maximum number of nodes that can be visited starting from node 0, without passing through any restricted node. Node 0 itself is not restricted.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2385: Amount of Time for Binary Tree to Be Infected</title>
      <link>http://localhost:1313/leetcode/solution-2385-amount-of-time-for-binary-tree-to-be-infected/</link>
      <pubDate>Wed, 13 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2385-amount-of-time-for-binary-tree-to-be-infected/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree where each node has a unique value, and an integer start representing the initial infected node. At minute 0, the infection begins at the node with value start. Each minute, an adjacent uninfected node becomes infected. Your task is to return the total number of minutes it takes for the entire tree to become infected.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2415: Reverse Odd Levels of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-2415-reverse-odd-levels-of-binary-tree/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2415-reverse-odd-levels-of-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a perfect binary tree, reverse the values of the nodes at each odd level of the tree. The level of a node is defined as the number of edges along the path from the root to the node. A perfect binary tree is one where all nodes have two children and all leaves are on the same level.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2467: Most Profitable Path in a Tree</title>
      <link>http://localhost:1313/leetcode/solution-2467-most-profitable-path-in-a-tree/</link>
      <pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2467-most-profitable-path-in-a-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;In a tree with n nodes labeled from 0 to n - 1, each node has a gate with a price to open. Alice starts at node 0 and Bob starts at node bob. Alice moves towards a leaf node, and Bob moves towards node 0. At every node, both Alice and Bob either pay the price to open the gate, or they receive a reward. If they reach a node simultaneously, they share the price/reward equally. Return the maximum net income Alice can achieve if she travels towards the optimal leaf node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2476: Closest Nodes Queries in a Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-2476-closest-nodes-queries-in-a-binary-search-tree/</link>
      <pubDate>Mon, 04 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2476-closest-nodes-queries-in-a-binary-search-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary search tree (BST) and an array of queries. For each query, find the largest value smaller than or equal to the query value and the smallest value greater than or equal to the query value in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2477: Minimum Fuel Cost to Report to the Capital</title>
      <link>http://localhost:1313/leetcode/solution-2477-minimum-fuel-cost-to-report-to-the-capital/</link>
      <pubDate>Mon, 04 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2477-minimum-fuel-cost-to-report-to-the-capital/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;A country network consists of n cities connected by n-1 bidirectional roads. The capital city is city 0, and each city has one representative with a car having a fixed number of seats. Calculate the minimum amount of fuel required for all representatives to reach the capital city.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2492: Minimum Score of a Path Between Two Cities</title>
      <link>http://localhost:1313/leetcode/solution-2492-minimum-score-of-a-path-between-two-cities/</link>
      <pubDate>Sat, 02 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2492-minimum-score-of-a-path-between-two-cities/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a set of cities, each connected by bidirectional roads. Each road has a distance, and the score of a path between two cities is defined as the minimum distance of any road on that path. The task is to find the minimum score of a path between city 1 and city n. You are allowed to visit the cities multiple times, and the roads may be repeated.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2556: Disconnect Path in a Binary Matrix by at Most One Flip</title>
      <link>http://localhost:1313/leetcode/solution-2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip/</link>
      <pubDate>Sun, 25 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary matrix &lt;code&gt;grid&lt;/code&gt; where you can move from any cell &lt;code&gt;(row, col)&lt;/code&gt; to adjacent cells &lt;code&gt;(row + 1, col)&lt;/code&gt; or &lt;code&gt;(row, col + 1)&lt;/code&gt; only if they have the value 1. The grid is disconnected if there is no path from the top-left corner &lt;code&gt;(0, 0)&lt;/code&gt; to the bottom-right corner &lt;code&gt;(m - 1, n - 1)&lt;/code&gt;. You are allowed to flip at most one cell (changing a 1 to 0 or vice versa), but you cannot flip the cells &lt;code&gt;(0, 0)&lt;/code&gt; or &lt;code&gt;(m - 1, n - 1)&lt;/code&gt;. Return true if it is possible to disconnect the grid by flipping at most one cell, otherwise return false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2596: Check Knight Tour Configuration</title>
      <link>http://localhost:1313/leetcode/solution-2596-check-knight-tour-configuration/</link>
      <pubDate>Wed, 21 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2596-check-knight-tour-configuration/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given an &lt;code&gt;n x n&lt;/code&gt; chessboard, the knight starts at the top-left corner and visits every cell exactly once. The knight&amp;rsquo;s movements are represented by a grid where &lt;code&gt;grid[row][col]&lt;/code&gt; indicates the order of the knight&amp;rsquo;s visit to that cell. Determine if this sequence of moves is valid, i.e., the knight moves according to its legal movement pattern.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2641: Cousins in Binary Tree II</title>
      <link>http://localhost:1313/leetcode/solution-2641-cousins-in-binary-tree-ii/</link>
      <pubDate>Fri, 16 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2641-cousins-in-binary-tree-ii/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins&amp;rsquo; values. Two nodes are cousins if they have the same depth but different parents. The depth of a node is the number of edges from the root to the node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2658: Maximum Number of Fish in a Grid</title>
      <link>http://localhost:1313/leetcode/solution-2658-maximum-number-of-fish-in-a-grid/</link>
      <pubDate>Thu, 15 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2658-maximum-number-of-fish-in-a-grid/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 2D matrix &lt;code&gt;grid&lt;/code&gt; of size m x n, where each cell can either be a land cell (represented by 0) or a water cell (represented by a positive integer indicating the number of fish present in that cell). A fisher can start at any water cell and perform two operations any number of times: catch all the fish in the current cell or move to an adjacent water cell. Your task is to determine the maximum number of fish the fisher can catch if they start at the optimal water cell.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2685: Count the Number of Complete Components</title>
      <link>http://localhost:1313/leetcode/solution-2685-count-the-number-of-complete-components/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2685-count-the-number-of-complete-components/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a graph with &lt;code&gt;n&lt;/code&gt; vertices, numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;. The graph contains undirected edges described in a 2D array &lt;code&gt;edges&lt;/code&gt;, where each element &lt;code&gt;edges[i] = [ai, bi]&lt;/code&gt; indicates that there is an undirected edge between vertices &lt;code&gt;ai&lt;/code&gt; and &lt;code&gt;bi&lt;/code&gt;. A connected component is a subgraph in which there is a path between any two vertices, and no vertex is connected to vertices outside of the subgraph. A connected component is said to be complete if there is an edge between every pair of vertices in that component. Your task is to return the number of complete connected components in the graph.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

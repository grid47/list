<!DOCTYPE html>
<html lang="en-us"><head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Graph | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Graph">
  <meta name="twitter:description" content="Blog by grid47">

	<meta property="og:url" content="https://www.grid47.xyz/tags/graph/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Graph">
  <meta property="og:description" content="Blog by grid47">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="https://www.grid47.xyz/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="https://www.grid47.xyz/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="https://www.grid47.xyz//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/courses/">Course</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
    <div class="main-content">
        
        <section class="recent-posts">            
            <div class="section-title">                
                <h2><span>All Posts</span></h2>                
            </div>            
            <div class="row listrecent">
                
                
<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="https://www.grid47.xyz/leetcode/solution-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="https://www.grid47.xyz/leetcode/solution-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/">Leetcode 2192: All Ancestors of a Node in a Directed Acyclic Graph</a></h2>
            <h4 class="card-text"><hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode613s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> getAncestors(<span style="color:#0b0;font-weight:bold">int</span> n, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> edges) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span>set<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> dag(n);
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> grid(n), sol(n);
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> inward(n, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: edges) {
</span></span><span style="display:flex;"><span>            grid[it[<span style="color:#666">0</span>]].push_back(it[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>            inward[it[<span style="color:#666">1</span>]]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        queue<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> q;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(inward[i] <span style="color:#666">==</span> <span style="color:#666">0</span>) q.push(i);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#0b0;font-weight:bold">int</span> tmp <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>                q.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: grid[tmp]) {
</span></span><span style="display:flex;"><span>                    inward[it]<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>                    dag[it].insert(tmp);
</span></span><span style="display:flex;"><span>                    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">x</span>: dag[tmp])
</span></span><span style="display:flex;"><span>                        dag[it].insert(x);
</span></span><span style="display:flex;"><span>                    <span style="color:#a2f;font-weight:bold">if</span>(inward[it] <span style="color:#666">==</span> <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>                        q.push(it);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: dag[i]) {
</span></span><span style="display:flex;"><span>                sol[i].push_back(it);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> sol;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given a Directed Acyclic Graph (DAG) with <code>n</code> nodes and a list of directed edges, the task is to find all the ancestors of each node in the graph. An ancestor of a node is any node that has a direct or indirect path to the node. The solution should return a list of sets where each set contains the ancestors of the node at the corresponding index.</p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Apr 1, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="https://www.grid47.xyz/leetcode/solution-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="https://www.grid47.xyz/leetcode/solution-2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="https://www.grid47.xyz/leetcode/solution-2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/">Leetcode 2316: Count Unreachable Pairs of Nodes in an Undirected Graph</a></h2>
            <h4 class="card-text"><hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode682s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">typedef</span> <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> ll;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> countPairs(<span style="color:#0b0;font-weight:bold">int</span> n, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> es) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> g(n, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#a0a000">e</span>: es){
</span></span><span style="display:flex;"><span>            g[e[<span style="color:#666">0</span>]].push_back(e[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>            g[e[<span style="color:#666">1</span>]].push_back(e[<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">bool</span><span style="color:#666">&gt;</span> vis(n, <span style="color:#a2f">false</span>);
</span></span><span style="display:flex;"><span>        ll res <span style="color:#666">=</span> (ll) n <span style="color:#666">*</span> (n <span style="color:#666">-</span> <span style="color:#666">1</span>) <span style="color:#666">/</span><span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            ll ret <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>vis[i])
</span></span><span style="display:flex;"><span>      ret <span style="color:#666">=</span> dfs(i, g, vis);
</span></span><span style="display:flex;"><span>      res <span style="color:#666">-=</span> (ret <span style="color:#666">*</span> (ret <span style="color:#666">-</span><span style="color:#666">1</span>)<span style="color:#666">/</span><span style="color:#666">2</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ll <span style="color:#00a000">dfs</span>(<span style="color:#0b0;font-weight:bold">int</span> i, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> <span style="color:#666">&amp;</span>g, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">bool</span><span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>vis) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(vis[i]) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        vis[i] <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>        ll res <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">v</span> : g[i]) {
</span></span><span style="display:flex;"><span>            res <span style="color:#666">+=</span> dfs(v, g, vis);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem requires finding the number of pairs of nodes in a graph that are not connected by an edge. We are given an undirected graph with <code>n</code> nodes and <code>m</code> edges, and we need to determine the number of pairs of nodes that are not connected either directly or indirectly through other nodes (i.e., not part of the same connected component).</p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Mar 20, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="https://www.grid47.xyz/leetcode/solution-2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="https://www.grid47.xyz/leetcode/solution-2359-find-closest-node-to-given-two-nodes/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="https://www.grid47.xyz/leetcode/solution-2359-find-closest-node-to-given-two-nodes/">Leetcode 2359: Find Closest Node to Given Two Nodes</a></h2>
            <h4 class="card-text"><hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode708s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> dfs(<span style="color:#0b0;font-weight:bold">int</span> node, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>edge, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>vis, <span style="color:#0b0;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>        vis[node] <span style="color:#666">=</span> x;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(edge[node] <span style="color:#666">!=</span> <span style="color:#666">-</span><span style="color:#666">1</span> <span style="color:#666">&amp;&amp;</span> vis[edge[node]] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>            dfs(edge[node], edge, vis, x <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">closestMeetingNode</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> edges, <span style="color:#0b0;font-weight:bold">int</span> node1, <span style="color:#0b0;font-weight:bold">int</span> node2) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> edges.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dist1(n, <span style="color:#666">-</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        dfs(node1, edges, dist1, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dist2(n, <span style="color:#666">-</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        dfs(node2, edges, dist2, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> dist, ans <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>, sol <span style="color:#666">=</span> INT_MAX;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(dist1[i] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span> <span style="color:#666">||</span> dist2[i] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>                dist <span style="color:#666">=</span> max(dist1[i], dist2[i]);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(dist <span style="color:#666">&lt;</span> sol) {
</span></span><span style="display:flex;"><span>                sol <span style="color:#666">=</span> dist;
</span></span><span style="display:flex;"><span>                ans <span style="color:#666">=</span> i;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given a directed graph where each node points to exactly one other node or to no node at all, you are given two starting nodes. The task is to find the &ldquo;closest meeting node&rdquo; — the node that can be reached by both starting nodes such that the maximum distance traveled by either node is minimized. If there are multiple such nodes, the smallest index should be returned.</p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Mar 16, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="https://www.grid47.xyz/leetcode/solution-2359-find-closest-node-to-given-two-nodes/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="https://www.grid47.xyz/leetcode/solution-2368-reachable-nodes-with-restrictions/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="https://www.grid47.xyz/leetcode/solution-2368-reachable-nodes-with-restrictions/">Leetcode 2368: Reachable Nodes With Restrictions</a></h2>
            <h4 class="card-text"><hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode714s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> ans;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> solve(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> gph, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">bool</span><span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>vis, <span style="color:#0b0;font-weight:bold">int</span> i) {
</span></span><span style="display:flex;"><span>        vis[i] <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">n</span>: gph[i]) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>vis[n]) {
</span></span><span style="display:flex;"><span>                ans<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>                vis[n] <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>                solve(gph, vis, n);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">reachableNodes</span>(<span style="color:#0b0;font-weight:bold">int</span> n, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> edges, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> <span style="color:#a2f;font-weight:bold">restricted</span>) {
</span></span><span style="display:flex;"><span>        ans <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> gph(n);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">e</span>: edges) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> u <span style="color:#666">=</span> e[<span style="color:#666">0</span>], v <span style="color:#666">=</span> e[<span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>            gph[u].push_back(v);
</span></span><span style="display:flex;"><span>            gph[v].push_back(u);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">bool</span><span style="color:#666">&gt;</span> vis(n, <span style="color:#a2f">false</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">i</span>: <span style="color:#a2f;font-weight:bold">restricted</span>) vis[i] <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        solve(gph, vis, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem asks to count the number of nodes that are reachable from a starting node, with certain restricted nodes that cannot be visited. The graph is represented as an undirected graph with <code>n</code> nodes and <code>edges</code> that connect pairs of nodes. Additionally, a list of restricted nodes is given, and these nodes are considered inaccessible in the graph traversal. Your task is to implement a function that returns the number of reachable nodes, excluding the restricted nodes.</p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Mar 15, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="https://www.grid47.xyz/leetcode/solution-2368-reachable-nodes-with-restrictions/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="https://www.grid47.xyz/leetcode/solution-2374-node-with-highest-edge-score/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="https://www.grid47.xyz/leetcode/solution-2374-node-with-highest-edge-score/">Leetcode 2374: Node With Highest Edge Score</a></h2>
            <h4 class="card-text"><hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode719s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> edgeScore(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> edges) {
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span><span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> edges.size();
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> mx <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>, idx <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            mp[edges[i]] <span style="color:#666">+=</span> i;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(mp[edges[i]] <span style="color:#666">&gt;</span> mx) {
</span></span><span style="display:flex;"><span>                idx <span style="color:#666">=</span> edges[i];
</span></span><span style="display:flex;"><span>                mx <span style="color:#666">=</span> mp[edges[i]];
</span></span><span style="display:flex;"><span>            } <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#00a000">if</span>(mp[edges[i]] <span style="color:#666">==</span> mx) {
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(edges[i] <span style="color:#666">&lt;</span> idx)
</span></span><span style="display:flex;"><span>                    idx <span style="color:#666">=</span> edges[i];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> idx;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>In this problem, we are given an array <code>edges</code> of size <code>n</code>, where <code>edges[i]</code> represents a directed edge from node <code>i</code> to node <code>edges[i]</code>. Our task is to find the node with the largest sum of indices of nodes that point to it. If multiple nodes have the same sum, we return the node with the smallest index.</p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Mar 14, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="https://www.grid47.xyz/leetcode/solution-2374-node-with-highest-edge-score/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="https://www.grid47.xyz/leetcode/solution-2467-most-profitable-path-in-a-tree/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="https://www.grid47.xyz/leetcode/solution-2467-most-profitable-path-in-a-tree/">Leetcode 2467: Most Profitable Path in a Tree</a></h2>
            <h4 class="card-text"><hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode779s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> adj;
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> par, dis;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(<span style="color:#0b0;font-weight:bold">int</span> u, <span style="color:#0b0;font-weight:bold">int</span> p <span style="color:#666">=</span> <span style="color:#666">0</span>, <span style="color:#0b0;font-weight:bold">int</span> d <span style="color:#666">=</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>        dis[u] <span style="color:#666">=</span> d;
</span></span><span style="display:flex;"><span>        par[u] <span style="color:#666">=</span> p;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">v</span> : adj[u]) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> (v <span style="color:#666">==</span> p) <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>            dfs(v, u, d <span style="color:#666">+</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>     
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">dfs2</span>(<span style="color:#0b0;font-weight:bold">int</span> u,vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span>amount,<span style="color:#0b0;font-weight:bold">int</span> p<span style="color:#666">=</span> <span style="color:#666">0</span>){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> ret <span style="color:#666">=</span> amount[u];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> mxc <span style="color:#666">=</span> <span style="color:#666">-</span>INT_MAX;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">v</span>:adj[u]){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(v<span style="color:#666">!=</span>p){
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                mxc<span style="color:#666">=</span> max(mxc,dfs2(v,amount,u));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">//if the node is leaf we just return its amount
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(mxc<span style="color:#666">==-</span>INT_MAX)<span style="color:#a2f;font-weight:bold">return</span> ret;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">return</span> ret<span style="color:#666">+</span>mxc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">mostProfitablePath</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> edges, <span style="color:#0b0;font-weight:bold">int</span> bob, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> amount) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> amount.size();
</span></span><span style="display:flex;"><span>        adj.resize(n,vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span>());
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span><span style="color:#666">&amp;</span><span style="color:#a0a000">e</span>:edges){
</span></span><span style="display:flex;"><span>            adj[e[<span style="color:#666">0</span>]].push_back(e[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>            adj[e[<span style="color:#666">1</span>]].push_back(e[<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        par.resize(n);
</span></span><span style="display:flex;"><span>        dis.resize(n);
</span></span><span style="display:flex;"><span>        dfs(<span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> cur <span style="color:#666">=</span> bob;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> bob_dis <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#080;font-style:italic">//update the path of from Bob to 0
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">while</span>(cur<span style="color:#666">!=</span><span style="color:#666">0</span>){
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(dis[cur]<span style="color:#666">&gt;</span>bob_dis){
</span></span><span style="display:flex;"><span>                amount[cur] <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>            }<span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">if</span>(dis[cur]<span style="color:#666">==</span>bob_dis){
</span></span><span style="display:flex;"><span>                amount[cur]<span style="color:#666">/=</span><span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            cur <span style="color:#666">=</span> par[cur];
</span></span><span style="display:flex;"><span>            bob_dis<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> dfs2(<span style="color:#666">0</span>,amount);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem is to find the most profitable path in a tree graph where each node has an associated profit (or loss). You are given a tree represented by an undirected graph, and you need to compute the path that maximizes the total profit, taking into account that one of the participants, Bob, will affect the profit on his path.</p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Mar 5, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="https://www.grid47.xyz/leetcode/solution-2467-most-profitable-path-in-a-tree/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


            </div>
        </section>
<div class="bottompagination">
  <div class="pointerup"><i class="fa fa-caret-up"></i></div>
  <div class="navigation" role="navigation">
    
      <div class="pagination">
        
          <a class="ml-1 mr-1" href="/tags/graph/page/6/">&laquo; Prev</a>
          <a class="ml-1 mr-1" href="/tags/graph/page/6/">6</a>
        

        <span class="ml-1 mr-1">7</span>

        
          <a class="ml-1 mr-1" href="/tags/graph/page/8/">8</a>
          <a class="ml-1 mr-1" href="/tags/graph/page/8/">Next &raquo;</a>
        
      </div>
    
  </div>
</div></div>


            </div>
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
			<div class="d-md-flex align-items-center justify-content-center h-100">
				<h2 class="d-md-block d-none align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
			</div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
			
			<a class="mt-1 mb-1" href="/tags/array">array</a>
			
			<a class="mt-1 mb-1" href="/tags/backtracking">backtracking</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-indexed-tree">binary indexed tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search">binary search</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search-tree">binary search tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-tree">binary tree</a>
			
			<a class="mt-1 mb-1" href="/tags/bit-manipulation">bit manipulation</a>
			
			<a class="mt-1 mb-1" href="/tags/bitmask">bitmask</a>
			
			<a class="mt-1 mb-1" href="/tags/brainteaser">brainteaser</a>
			
			<a class="mt-1 mb-1" href="/tags/breadth-first-search">breadth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/bucket-sort">bucket sort</a>
			
			<a class="mt-1 mb-1" href="/tags/combinatorics">combinatorics</a>
			
			<a class="mt-1 mb-1" href="/tags/concurrency">concurrency</a>
			
			<a class="mt-1 mb-1" href="/tags/counting">counting</a>
			
			<a class="mt-1 mb-1" href="/tags/counting-sort">counting sort</a>
			
			<a class="mt-1 mb-1" href="/tags/data-stream">data stream</a>
			
			<a class="mt-1 mb-1" href="/tags/database">database</a>
			
			<a class="mt-1 mb-1" href="/tags/depth-first-search">depth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/design">design</a>
			
			<a class="mt-1 mb-1" href="/tags/divide-and-conquer">divide and conquer</a>
			
			<a class="mt-1 mb-1" href="/tags/doubly-linked-list">doubly-linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/dynamic-programming">dynamic programming</a>
			
			<a class="mt-1 mb-1" href="/tags/enumeration">enumeration</a>
			
			<a class="mt-1 mb-1" href="/tags/game-theory">game theory</a>
			
			<a class="mt-1 mb-1" href="/tags/geometry">geometry</a>
			
			<a class="mt-1 mb-1" href="/tags/graph">graph</a>
			
			<a class="mt-1 mb-1" href="/tags/greedy">greedy</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-function">hash function</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-table">hash table</a>
			
			<a class="mt-1 mb-1" href="/tags/heap-priority-queue">heap (priority queue)</a>
			
			<a class="mt-1 mb-1" href="/tags/interactive">interactive</a>
			
			<a class="mt-1 mb-1" href="/tags/iterator">iterator</a>
			
			<a class="mt-1 mb-1" href="/tags/linked-list">linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/math">math</a>
			
			<a class="mt-1 mb-1" href="/tags/matrix">matrix</a>
			
			<a class="mt-1 mb-1" href="/tags/memoization">memoization</a>
			
			<a class="mt-1 mb-1" href="/tags/minimum-spanning-tree">minimum spanning tree</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-queue">monotonic queue</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-stack">monotonic stack</a>
			
			<a class="mt-1 mb-1" href="/tags/number-theory">number theory</a>
			
			<a class="mt-1 mb-1" href="/tags/ordered-set">ordered set</a>
			
			<a class="mt-1 mb-1" href="/tags/prefix-sum">prefix sum</a>
			
			<a class="mt-1 mb-1" href="/tags/probability-and-statistics">probability and statistics</a>
			
			<a class="mt-1 mb-1" href="/tags/queue">queue</a>
			
			<a class="mt-1 mb-1" href="/tags/quickselect">quickselect</a>
			
			<a class="mt-1 mb-1" href="/tags/radix-sort">radix sort</a>
			
			<a class="mt-1 mb-1" href="/tags/randomized">randomized</a>
			
			<a class="mt-1 mb-1" href="/tags/recursion">recursion</a>
			
			<a class="mt-1 mb-1" href="/tags/reservoir-sampling">reservoir sampling</a>
			
			<a class="mt-1 mb-1" href="/tags/rolling-hash">rolling hash</a>
			
			<a class="mt-1 mb-1" href="/tags/segment-tree">segment tree</a>
			
			<a class="mt-1 mb-1" href="/tags/shortest-path">shortest path</a>
			
			<a class="mt-1 mb-1" href="/tags/simulation">simulation</a>
			
			<a class="mt-1 mb-1" href="/tags/sliding-window">sliding window</a>
			
			<a class="mt-1 mb-1" href="/tags/sorting">sorting</a>
			
			<a class="mt-1 mb-1" href="/tags/stack">stack</a>
			
			<a class="mt-1 mb-1" href="/tags/string">string</a>
			
			<a class="mt-1 mb-1" href="/tags/string-matching">string matching</a>
			
			<a class="mt-1 mb-1" href="/tags/topological-sort">topological sort</a>
			
			<a class="mt-1 mb-1" href="/tags/tree">tree</a>
			
			<a class="mt-1 mb-1" href="/tags/trie">trie</a>
			
			<a class="mt-1 mb-1" href="/tags/two-pointers">two pointers</a>
			
			<a class="mt-1 mb-1" href="/tags/union-find">union find</a>
			
		</div>
	</div>
</div>

<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="https://www.grid47.xyz/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

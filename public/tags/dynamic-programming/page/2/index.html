<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Dynamic Programming | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Dynamic Programming">
  <meta name="twitter:description" content="Blog by grid47">

	<meta property="og:url" content="http://localhost:1313/tags/dynamic-programming/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Dynamic Programming">
  <meta property="og:description" content="Blog by grid47">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
        

	
	
	<link rel="stylesheet" href="/css/leetcode.css" integrity="" crossorigin="anonymous" media="screen">



</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/courses/">Course</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
    <div class="main-content">
        
        <section class="recent-posts">            
            <div class="section-title">                
                <h2><span>All Posts</span></h2>                
            </div>            
            <div class="row listrecent">
                
                
<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-63-unique-paths-ii/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-63-unique-paths-ii/">Leetcode 63: Unique Paths II</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1221s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/63.webp" 
           alt="A more intricate, glowing path system with a few obstacles, showing varied routes to the goal." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 63: Unique Paths II Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given the head of a singly linked list and two integers <code>left</code> and <code>right</code> where <code>left &lt;= right</code>, reverse the nodes of the linked list starting at position <code>left</code> and ending at position <code>right</code>. Return the modified linked list. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The function receives the head of a singly linked list and two integers `left` and `right` representing the positions in the list to reverse.</div>
                        <div class=""> <b>Example:</b> Input: head = [7,9,11,5,2], left = 3, right = 5</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the list is n.</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= n &lt;= 500</div>
                            
                                <div style="margin-left: 20px;"> • -500 &lt;= Node.val &lt;= 500</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= left &lt;= right &lt;= n</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return the head of the modified singly linked list after reversing the specified section.</div>
                        <div class=""> <b>Example:</b> Output: [7,9,2,5,11]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output list retains all nodes from the original list.</div>
                            
                                <div style="margin-left: 20px;"> • The reversed portion is accurately modified while the rest remains untouched.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Reverse the nodes of a singly linked list between positions `left` and `right` in a single traversal.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Create a dummy node pointing to the head of the list.</div>
                            
                                <div style="margin-left: 20px;"> • Traverse to the node immediately before position `left`.</div>
                            
                                <div style="margin-left: 20px;"> • Perform in-place node re-linking to reverse the sublist between `left` and `right`.</div>
                            
                                <div style="margin-left: 20px;"> • Reconnect the reversed sublist to the remaining parts of the list.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Ensure proper handling of edge cases and valid inputs.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Handle lists with a single node or where `left == right`.</div>
                            
                                <div style="margin-left: 20px;"> • Ensure the function operates within O(1) space complexity apart from the input list.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input list is non-circular and contains valid node values.</div>
                            
                                <div style="margin-left: 20px;"> • `left` and `right` are always within valid bounds.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: head = [3,6,1,8,5], left = 2, right = 4</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> Reverse the sublist from position 2 to 4. Resulting list is [3,8,1,6,5].</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: head = [10], left = 1, right = 1</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> Since the list contains a single node and `left == right`, the list remains [10].</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> Reverse a sublist in the linked list using in-place re-linking. Maintain pointers to manage the reversed sublist and the unaffected portions efficiently.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Reversing a sublist can be done by adjusting the next pointers of the nodes within the range.</div>
                            
                                <div style="margin-left: 20px;"> • A dummy node helps handle edge cases cleanly, such as reversing from the head of the list.</div>
                            
                            
                                <div style="margin-left: 20px;"> • Minimize traversal by reversing the sublist in-place.</div>
                            
                                <div style="margin-left: 20px;"> • Optimize space usage to O(1) by not using additional data structures.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Initialize a dummy node pointing to the head of the list.</div>
                            
                                <div style="margin-left: 20px;"> • Use a pointer to traverse to the node just before the reversal starts.</div>
                            
                                <div style="margin-left: 20px;"> • Iteratively reverse the next pointers of nodes in the specified range.</div>
                            
                                <div style="margin-left: 20px;"> • Reconnect the reversed sublist to the preceding and succeeding parts of the list.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Input list is NULL.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • List has 500 nodes and requires reversing a large sublist.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Input values at the boundary of valid ranges, e.g., `left = 1`, `right = n`.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure nodes outside the reversal range remain unmodified.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Edge Case Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Dummy Node Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Pointer Assignment</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Pointer Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Loop Iteration, Pointer Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Pointer Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Pointer Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Loop Iteration, Pointer Manipulation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Pointer Manipulation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Pointer Manipulation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Pointer Manipulation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Pointer Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Return</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ListNode<span style="color:#666">*</span> <span style="color:#00a000">reverseBetween</span>(ListNode<span style="color:#666">*</span> head, <span style="color:#0b0;font-weight:bold">int</span> left, <span style="color:#0b0;font-weight:bold">int</span> right) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#666">!</span>head) <span style="color:#a2f;font-weight:bold">return</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> dummy <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> ListNode(<span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>    dummy<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> head;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> prev <span style="color:#666">=</span> dummy;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> left <span style="color:#666">-</span> <span style="color:#666">1</span>; <span style="color:#666">++</span>i) {
</span></span><span style="display:flex;"><span>        prev <span style="color:#666">=</span> prev<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> curr <span style="color:#666">=</span> prev<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> next <span style="color:#666">=</span> curr<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> right <span style="color:#666">-</span> left; <span style="color:#666">++</span>i) {
</span></span><span style="display:flex;"><span>        curr<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> next<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        next<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prev<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        prev<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> next;
</span></span><span style="display:flex;"><span>        next <span style="color:#666">=</span> curr<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> dummy<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ListNode<span style="color:#666">*</span> <span style="color:#00a000">reverseBetween</span>(ListNode<span style="color:#666">*</span> head, <span style="color:#0b0;font-weight:bold">int</span> left, <span style="color:#0b0;font-weight:bold">int</span> right) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declares a function `reverseBetween` that takes a linked list `head`, a starting position `left`, and an ending position `right` as input and returns the modified linked list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Edge Case Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (<span style="color:#666">!</span>head) <span style="color:#a2f;font-weight:bold">return</span> head;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the input linked list is empty. If so, returns the head directly. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Dummy Node Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> dummy <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> ListNode(<span style="color:#666">0</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Creates a dummy node to simplify the reversal process, especially when reversing from the beginning of the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Pointer Assignment</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dummy<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> head;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Sets the `next` pointer of the dummy node to the head of the original linked list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Pointer Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> prev <span style="color:#666">=</span> dummy;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes a `prev` pointer to the dummy node, which will be used to track the node before the reversal range. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Loop Iteration, Pointer Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> left <span style="color:#666">-</span> <span style="color:#666">1</span>; <span style="color:#666">++</span>i) {
</span></span><span style="display:flex;"><span>        prev <span style="color:#666">=</span> prev<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Iterates `left - 1` times to move the `prev` pointer to the node just before the start of the reversal range. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Pointer Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> curr <span style="color:#666">=</span> prev<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes a `curr` pointer to the first node in the reversal range. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Pointer Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> next <span style="color:#666">=</span> curr<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes a `next` pointer to the node after `curr`, which will be used to temporarily store the next node during the reversal process. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Loop Iteration, Pointer Manipulation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> right <span style="color:#666">-</span> left; <span style="color:#666">++</span>i) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Iterates `right - left` times to reverse the nodes in the specified range. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Pointer Manipulation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        curr<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> next<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Sets the `next` pointer of the current node `curr` to the node after the next node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Pointer Manipulation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        next<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prev<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Sets the `next` pointer of the next node `next` to the node that `prev` currently points to, effectively reversing the link. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Pointer Manipulation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        prev<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Sets the `next` pointer of the `prev` node to the current `next` node, linking it to the reversed portion. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Pointer Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        next <span style="color:#666">=</span> curr<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `next` pointer to the next node to be reversed in the next iteration. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Return</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> dummy<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the head of the modified linked list, which is the `next` pointer of the dummy node. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The entire list may need to be traversed in the worst case, where `right = n`.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(1)</div> 
                        <div class=""> <b>Description:</b> The solution uses constant space for pointers and variables.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/unique-paths-ii/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 31, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-63-unique-paths-ii/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-64-minimum-path-sum/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-64-minimum-path-sum/">Leetcode 64: Minimum Path Sum</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1225s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/64.webp" 
           alt="A glowing, winding path that minimizes distance, with bright, guiding arrows showing the best route." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 64: Minimum Path Sum Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given the root of a binary tree, return the values of its nodes as they appear in an inorder traversal. Inorder traversal visits nodes in the left subtree, the root, and then the right subtree. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input is the root of a binary tree where each node has a value and pointers to left and right child nodes.</div>
                        <div class=""> <b>Example:</b> Input: root = [5,3,8,1,4,null,10]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the tree is in the range [0, 100].</div>
                            
                                <div style="margin-left: 20px;"> • -100 &lt;= Node.val &lt;= 100</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return a list of integers representing the inorder traversal of the binary tree.</div>
                        <div class=""> <b>Example:</b> Output: [1,3,4,5,8,10]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output list must contain the values of all nodes visited in correct inorder sequence.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Perform an inorder traversal of the binary tree and return the node values in the correct order.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Traverse the left subtree recursively.</div>
                            
                                <div style="margin-left: 20px;"> • Visit the root node and append its value to the result list.</div>
                            
                                <div style="margin-left: 20px;"> • Traverse the right subtree recursively.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Ensure that the traversal correctly handles binary trees with various structures.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Handle null nodes gracefully.</div>
                            
                                <div style="margin-left: 20px;"> • Ensure the solution works for trees with all node values at the boundaries of the valid range.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input tree is binary (each node has at most two children).</div>
                            
                                <div style="margin-left: 20px;"> • The input tree structure is well-formed, with nodes correctly linked.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: root = [2,1,3]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The inorder traversal visits nodes in the order: left (1), root (2), right (3). Output: [1,2,3].</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: root = [10,null,15,null,20]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The inorder traversal visits nodes in the order: root (10), right child (15), right subtree (20). Output: [10,15,20].</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: root = []</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> An empty tree has no nodes to traverse. Output: [].</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: root = [7]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> A single-node tree has only the root to traverse. Output: [7].</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> Perform an inorder traversal of the binary tree using both recursive and iterative methods.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Inorder traversal visits nodes in the order: left subtree, root, right subtree.</div>
                            
                                <div style="margin-left: 20px;"> • A recursive implementation is straightforward but can be replaced with an iterative stack-based approach for better control over recursion depth.</div>
                            
                            
                                <div style="margin-left: 20px;"> • Iterative traversal avoids the function call stack and provides explicit stack management.</div>
                            
                                <div style="margin-left: 20px;"> • Both methods result in the same output but vary in implementation style and use of memory.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Initialize an empty list to store the result and a stack to manage traversal states.</div>
                            
                                <div style="margin-left: 20px;"> • Push nodes onto the stack while traversing to the leftmost node.</div>
                            
                                <div style="margin-left: 20px;"> • Pop nodes from the stack, append their value to the result, and traverse their right child.</div>
                            
                                <div style="margin-left: 20px;"> • Repeat until all nodes are visited.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • An empty tree (root = null) should return an empty list.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • A tree with maximum nodes (100) with a balanced or unbalanced structure.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • All node values are the same, e.g., root = [5,5,5].</div>
                            
                                <div style="margin-left: 20px;"> • All nodes are arranged in a single line (left-skewed or right-skewed tree).</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure no extra nodes are added or skipped during traversal.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Result Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Stack Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Loop Iteration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Nested Loop Iteration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Stack Push</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Pointer Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Stack Pop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Stack Pop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Result Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Pointer Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Return</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> inorderTraversal(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> nodes;
</span></span><span style="display:flex;"><span>    stack<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> todo;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> (root <span style="color:#666">||</span> <span style="color:#666">!</span>todo.empty()) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span> (root) {
</span></span><span style="display:flex;"><span>            todo.push(root);
</span></span><span style="display:flex;"><span>            root <span style="color:#666">=</span> root <span style="color:#666">-&gt;</span> left;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        root <span style="color:#666">=</span> todo.top();
</span></span><span style="display:flex;"><span>        todo.pop();
</span></span><span style="display:flex;"><span>        nodes.push_back(root <span style="color:#666">-&gt;</span> val);
</span></span><span style="display:flex;"><span>        root <span style="color:#666">=</span> root <span style="color:#666">-&gt;</span> right;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> nodes;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> inorderTraversal(TreeNode<span style="color:#666">*</span> root) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declares a function `inorderTraversal` that takes the root node of a binary tree as input and returns a vector containing the inorder traversal of the tree. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Result Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> nodes;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes an empty vector `nodes` to store the inorder traversal result. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Stack Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    stack<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> todo;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes an empty stack `todo` to keep track of nodes to be visited. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Loop Iteration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> (root <span style="color:#666">||</span> <span style="color:#666">!</span>todo.empty()) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Iterates until both the `root` node and the `todo` stack are empty. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Nested Loop Iteration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span> (root) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> While the current `root` node is not null, we keep pushing it onto the stack and moving to its left child. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Stack Push</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            todo.push(root);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pushes the current `root` node onto the stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Pointer Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            root <span style="color:#666">=</span> root <span style="color:#666">-&gt;</span> left;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `root` pointer to its left child. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Stack Pop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        root <span style="color:#666">=</span> todo.top();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pops the top node from the stack and assigns it to the `root`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Stack Pop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        todo.pop();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Removes the top node from the stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Result Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        nodes.push_back(root <span style="color:#666">-&gt;</span> val);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Adds the value of the current `root` node to the `nodes` vector. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Pointer Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        root <span style="color:#666">=</span> root <span style="color:#666">-&gt;</span> right;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `root` pointer to its right child. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Return</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> nodes;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the `nodes` vector containing the inorder traversal of the tree. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> Each node is visited exactly once during the traversal.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> In the worst case, the stack stores all nodes (e.g., in a completely skewed tree).</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/minimum-path-sum/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 31, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-64-minimum-path-sum/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-70-climbing-stairs/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-70-climbing-stairs/">Leetcode 70: Climbing Stairs</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1257s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/70.webp" 
           alt="A glowing staircase with each step symbolizing progress, slowly leading upwards." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 70: Climbing Stairs Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given the root of a binary tree, your task is to return the level order traversal of its nodes&rsquo; values. This means you should traverse the tree level by level, from left to right at each level. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> You are given the root of a binary tree, where each node has a value and pointers to its left and right children.</div>
                        <div class=""> <b>Example:</b> root = [5,3,8,1,4,null,9]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the tree is in the range [0, 2000].</div>
                            
                                <div style="margin-left: 20px;"> • -1000 &lt;= Node.val &lt;= 1000</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be a 2D array where each element represents a level in the binary tree. Each level is a list of node values at that level, traversed from left to right.</div>
                        <div class=""> <b>Example:</b> Output: [[5], [3, 8], [1, 4, 9]]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be an array of arrays where each inner array contains the values of the nodes at that level.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to perform a level order traversal of the binary tree using a queue to process nodes level by level.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Start by checking if the root is null. If it is, return an empty list.</div>
                            
                                <div style="margin-left: 20px;"> • Initialize a queue with the root node.</div>
                            
                                <div style="margin-left: 20px;"> • While the queue is not empty, process each node at the current level.</div>
                            
                                <div style="margin-left: 20px;"> • For each level, create a list of node values and add the left and right children of each node to the queue.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Ensure the solution can handle a tree with up to 2000 nodes efficiently.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The tree can have between 0 and 2000 nodes.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input is always a valid binary tree.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = [3,9,20,null,null,15,7]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The binary tree has the following structure:

       3
      / \
     9  20
        /  \
       15   7

The level order traversal is: [[3], [9, 20], [15, 7]]</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = [1]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The binary tree consists of just one node, which is the root node. The level order traversal is: [[1]]</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = []</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> An empty tree has no nodes, so the level order traversal is: []</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The problem can be solved using a breadth-first search (BFS) approach where we explore the tree level by level, ensuring nodes at each level are processed from left to right.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Level order traversal can be efficiently implemented using a queue.</div>
                            
                            
                                <div style="margin-left: 20px;"> • By using a queue, we can ensure that we process nodes level by level, which is the key to solving this problem.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Check if the root is null, return an empty list if it is.</div>
                            
                                <div style="margin-left: 20px;"> • Initialize a queue and add the root node to it.</div>
                            
                                <div style="margin-left: 20px;"> • While the queue is not empty, process each level by iterating over the nodes in the queue.</div>
                            
                                <div style="margin-left: 20px;"> • For each node in the current level, add its value to the result list and enqueue its left and right children if they exist.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the tree is empty (i.e., the root is null), return an empty list.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • For large trees with up to 2000 nodes, ensure the solution handles the input efficiently.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If a node has only one child (either left or right), make sure it is properly handled during the level order traversal.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The tree must be processed within the provided constraints (2000 nodes).</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Base Case</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Queue Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Push Root to Queue</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Main BFS Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Level Size</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Result Vector</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Level Nodes Processing</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Queue Front</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Add Node Value</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Queue Pop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Left Child Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Right Child Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Push Level to Result</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Return Result</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> levelOrder(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> ans;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    queue<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span><span style="display:flex;"><span>    q.push(root);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#666">*</span> tmp <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>            res.push_back(tmp<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(tmp<span style="color:#666">-&gt;</span>left) q.push(tmp<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(tmp<span style="color:#666">-&gt;</span>right) q.push(tmp<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ans.push_back(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> levelOrder(TreeNode<span style="color:#666">*</span> root) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Define the function &#39;levelOrder&#39; which takes the root of the tree and returns a 2D vector of integers, representing the tree&#39;s level-order traversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize an empty 2D vector &#39;ans&#39; to store the values of each level of the tree. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Base Case</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the tree is empty (root is NULL), return the empty result vector. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Queue Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    queue<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Create a queue to assist in performing a breadth-first search (BFS). The queue will hold nodes at each level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Push Root to Queue</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    q.push(root);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Push the root node to the queue to begin the level-order traversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Main BFS Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> While the queue is not empty, continue processing the nodes level by level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Level Size</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Store the current size of the queue, which represents the number of nodes at the current level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Result Vector</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize a temporary vector &#39;res&#39; to hold the node values for the current level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Level Nodes Processing</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Process each node at the current level by looping through the queue until all nodes at this level are visited. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Queue Front</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            TreeNode<span style="color:#666">*</span> tmp <span style="color:#666">=</span> q.front();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Get the front node from the queue, which is the current node to be processed. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Add Node Value</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            res.push_back(tmp<span style="color:#666">-&gt;</span>val);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Add the value of the current node to the &#39;res&#39; vector. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Queue Pop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            q.pop();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pop the processed node from the queue. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Left Child Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(tmp<span style="color:#666">-&gt;</span>left) q.push(tmp<span style="color:#666">-&gt;</span>left);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current node has a left child, push it onto the queue for the next level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Right Child Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(tmp<span style="color:#666">-&gt;</span>right) q.push(tmp<span style="color:#666">-&gt;</span>right);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current node has a right child, push it onto the queue for the next level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Push Level to Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ans.push_back(res);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> After processing all nodes at the current level, add the &#39;res&#39; vector to the final result vector &#39;ans&#39;. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Return Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Return the final 2D vector &#39;ans&#39; which contains the level-order traversal of the tree. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> In all cases, we must visit each node in the tree once, so the time complexity is O(n), where n is the number of nodes in the tree.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> In the worst case, the queue may hold all the nodes at the last level of the tree, resulting in a space complexity of O(n). In the best case, when the tree is perfectly balanced, the space complexity could be reduced to O(log n).</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/climbing-stairs/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 31, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-70-climbing-stairs/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-72-edit-distance/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-72-edit-distance/">Leetcode 72: Edit Distance</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1267s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/72.webp" 
           alt="Two strings gently transforming into one another, symbolizing subtle edits." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 72: Edit Distance Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given the root of a binary tree. Your task is to return the maximum depth of the tree. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> You are given the root node of a binary tree, where each node contains a value, and pointers to its left and right children.</div>
                        <div class=""> <b>Example:</b> root = [5,3,8,2,4,7,9]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the tree is in the range [0, 10^4].</div>
                            
                                <div style="margin-left: 20px;"> • -100 &lt;= Node.val &lt;= 100</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> You should return an integer representing the maximum depth of the binary tree.</div>
                        <div class=""> <b>Example:</b> Output: 3</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be a single integer representing the depth of the tree.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to find the maximum depth of the binary tree by recursively calculating the depth of the left and right subtrees, and returning the larger of the two depths plus one.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Base Case: If the root is NULL, return 0.</div>
                            
                                <div style="margin-left: 20px;"> • Recursively find the maximum depth of the left subtree.</div>
                            
                                <div style="margin-left: 20px;"> • Recursively find the maximum depth of the right subtree.</div>
                            
                                <div style="margin-left: 20px;"> • Return the larger of the two depths plus one to account for the current node.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The solution should be able to handle trees with up to 10,000 nodes efficiently.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The tree can contain up to 10,000 nodes.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input will always represent a valid binary tree.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = [3,9,20,null,null,15,7]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The binary tree has the following structure:

       3
      / \
     9  20
        /  \
       15   7

The longest path is from root (3) to leaf nodes (15 or 7), which has a depth of 3.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = [1,null,2]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The binary tree consists of the root node (1) and its right child (2), forming a path of depth 2.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = []</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> An empty tree has no nodes, so the maximum depth is 0.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The problem can be solved using a recursive approach to traverse the tree and calculate the depth of each subtree.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • The problem can be solved using recursion by finding the depth of the left and right subtrees at each node.</div>
                            
                            
                                <div style="margin-left: 20px;"> • By utilizing recursion, we can efficiently calculate the maximum depth of the tree by always comparing the depths of the left and right subtrees.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Check if the root is null. If so, return 0.</div>
                            
                                <div style="margin-left: 20px;"> • Recursively calculate the maximum depth of the left subtree.</div>
                            
                                <div style="margin-left: 20px;"> • Recursively calculate the maximum depth of the right subtree.</div>
                            
                                <div style="margin-left: 20px;"> • Return the larger of the two depths, plus one to account for the current node.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the tree is empty, return 0.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • For large trees with up to 10,000 nodes, ensure the solution handles the input efficiently.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the tree is heavily unbalanced (e.g., all nodes are on one side), the depth should be calculated correctly based on the longest path.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The tree can contain up to 10,000 nodes, so the algorithm should be efficient in terms of time complexity.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Base Case Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Recursive Call</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">maxDepth</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">1</span> <span style="color:#666">+</span> max(maxDepth(root<span style="color:#666">-&gt;</span>left), maxDepth(root<span style="color:#666">-&gt;</span>right));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">maxDepth</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Define the function &#39;maxDepth&#39; which takes the root of a binary tree and returns the maximum depth of the tree. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Base Case Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Check if the current node is null. If it is, return a depth of 0, representing the base case of the recursion. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">1</span> <span style="color:#666">+</span> max(maxDepth(root<span style="color:#666">-&gt;</span>left), maxDepth(root<span style="color:#666">-&gt;</span>right));
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calculate the maximum depth of the left and right subtrees, add 1 to account for the current node, and return the result. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> In the worst case, we need to visit each node in the tree, so the time complexity is O(n), where n is the number of nodes.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(h)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(h) in the worst case, where h is the height of the tree. In the best case, the tree is perfectly balanced, and the space complexity is O(1).</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/edit-distance/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 30, 2024 - 4 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-72-edit-distance/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-91-decode-ways/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-91-decode-ways/">Leetcode 91: Decode Ways</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1383s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/91.webp" 
           alt="A glowing key unlocking multiple pathways, symbolizing decoding and transformation." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 91: Decode Ways Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given a linked list where each node contains a value, a next pointer, and a random pointer (which can point to any node in the list or be null), create a deep copy of the list. The deep copy should consist of exactly n new nodes where each node has its value set to the value of its corresponding original node, and the next and random pointers of the new nodes should represent the same list state as the original. None of the pointers in the new list should point to nodes in the original list. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> A linked list of nodes, each containing two pointers: a next pointer and a random pointer, which can point to any node or be null.</div>
                        <div class=""> <b>Example:</b> head = [[5,null],[10,0],[15,4],[20,2],[25,1]]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= n &lt;= 1000</div>
                            
                                <div style="margin-left: 20px;"> • -10^4 &lt;= Node.val &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • Node.random is null or points to some node in the linked list.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return the head of the deep copied linked list, where the copied list has the same values, next pointers, and random pointers as the original list.</div>
                        <div class=""> <b>Example:</b> Output: [[5,null],[10,0],[15,4],[20,2],[25,1]]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The copied list should have no shared nodes with the original list.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Create a deep copy of the linked list by ensuring that both the next and random pointers of the new nodes represent the same list structure as the original list.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Iterate through the original list and create new nodes for each node in the original list.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Set the next pointer of each new node to match the corresponding next pointer in the original list.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Set the random pointer of each new node to match the corresponding random pointer in the original list.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Use a map or hash table to store mappings between the original nodes and their corresponding new nodes to handle random pointers efficiently.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The constraints ensure that the solution can handle linked lists with up to 1000 nodes while maintaining the correct structure for random pointers.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= n &lt;= 1000</div>
                            
                                <div style="margin-left: 20px;"> • -10^4 &lt;= Node.val &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • Node.random is null or points to some node in the linked list.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input list contains nodes with valid random pointers that either point to a valid node or are null.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> head = [[5,null],[10,0],[15,4],[20,2],[25,1]]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The original list contains five nodes with random pointers. The deep copy should have the same structure, where the next and random pointers of the new nodes match the original list.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> head = [[1,1],[2,1]]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> This example contains a two-node list where both nodes have random pointers pointing to each other. The deep copy should replicate the same structure.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> To solve this problem, we will create a deep copy of the list by iterating through the original list and using a map to maintain references to the new nodes.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • We need to handle the random pointers, which require mapping original nodes to new nodes to ensure the correct structure.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We will use a hash map to store the relationship between the original nodes and the copied nodes, allowing us to efficiently update the random pointers.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Initialize a hash map to store the mapping of original nodes to new nodes.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Traverse the original list and create new nodes, saving the new node in the map.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Set the next and random pointers for each new node using the map.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the input list is empty (null head), return null.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution should handle lists with up to 1000 nodes efficiently.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If a node&#39;s random pointer is null, the corresponding new node&#39;s random pointer should also be null.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution should maintain a linear time complexity and constant space for the mapping.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Variable Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Function Definition (copyRandomList)</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Clear Map</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Recursive Call (copyRandomList)</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Helper Function Definition (copy)</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Base Case (null)</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Check if Node is Already Copied</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Node Creation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Store Copy in Map</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Recursive Copy (Next Pointer)</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Recursive Copy (Random Pointer)</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 End Function (copy)</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>map<span style="color:#666">&lt;</span>Node<span style="color:#666">*</span>, Node<span style="color:#666">*&gt;</span> mp;
</span></span><span style="display:flex;"><span>Node<span style="color:#666">*</span> <span style="color:#00a000">copyRandomList</span>(Node<span style="color:#666">*</span> head) {
</span></span><span style="display:flex;"><span>    mp.clear();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> copy(head);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Node<span style="color:#666">*</span> <span style="color:#00a000">copy</span>(Node<span style="color:#666">*</span> head) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>head) <span style="color:#a2f;font-weight:bold">return</span> head;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(mp.count(head)) <span style="color:#a2f;font-weight:bold">return</span> mp[head];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    Node<span style="color:#666">*</span> node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> Node(head<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    mp[head] <span style="color:#666">=</span> node;
</span></span><span style="display:flex;"><span>    node<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> copy(head<span style="color:#666">-&gt;</span>next);
</span></span><span style="display:flex;"><span>    node<span style="color:#666">-&gt;</span>random <span style="color:#666">=</span> copy(head<span style="color:#666">-&gt;</span>random);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Variable Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>map<span style="color:#666">&lt;</span>Node<span style="color:#666">*</span>, Node<span style="color:#666">*&gt;</span> mp;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> A map `mp` is declared to store the mapping between the original node and the newly copied node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Function Definition (copyRandomList)</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Node<span style="color:#666">*</span> <span style="color:#00a000">copyRandomList</span>(Node<span style="color:#666">*</span> head) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This is the definition of the `copyRandomList` function, which will clone the entire list starting from the given head node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Clear Map</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    mp.clear();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The map `mp` is cleared to ensure that no previous data remains before starting the copy process. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Recursive Call (copyRandomList)</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">copy</span>(head);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The `copyRandomList` function calls the helper function `copy`, passing the head node to begin the cloning process. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Helper Function Definition (copy)</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Node<span style="color:#666">*</span> <span style="color:#00a000">copy</span>(Node<span style="color:#666">*</span> head) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This is the definition of the helper function `copy`, which handles the actual node cloning process for each individual node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Base Case (null)</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>head) <span style="color:#a2f;font-weight:bold">return</span> head;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the input `head` is null, return null. This is the base case of the recursion. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Check if Node is Already Copied</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(mp.count(head)) <span style="color:#a2f;font-weight:bold">return</span> mp[head];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the node has already been copied (i.e., it exists in the map `mp`), return the corresponding copied node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Node Creation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    Node<span style="color:#666">*</span> node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> Node(head<span style="color:#666">-&gt;</span>val);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> A new node is created with the same value as the original node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Store Copy in Map</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    mp[head] <span style="color:#666">=</span> node;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The newly created node is stored in the map `mp`, with the original node as the key. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Recursive Copy (Next Pointer)</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    node<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> copy(head<span style="color:#666">-&gt;</span>next);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively copy the `next` pointer of the current node by calling `copy` on the next node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Recursive Copy (Random Pointer)</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    node<span style="color:#666">-&gt;</span>random <span style="color:#666">=</span> copy(head<span style="color:#666">-&gt;</span>random);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively copy the `random` pointer of the current node by calling `copy` on the random node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : End Function (copy)</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> node;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Return the newly created and fully cloned node. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n) as we need to traverse the entire linked list once.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n) due to the map used to store the original-to-new node mapping.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/decode-ways/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 28, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-91-decode-ways/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-95-unique-binary-search-trees-ii/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-95-unique-binary-search-trees-ii/">Leetcode 95: Unique Binary Search Trees II</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1406s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/95.webp" 
           alt="A sequence of elegant trees gently forming in various, unique shapes." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 95: Unique Binary Search Trees II Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given the head of a singly linked list. The goal is to reorder the list such that the nodes are arranged as follows: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → &hellip;, without modifying the values of the nodes. Only the structure of the list can be changed. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of a singly linked list with integer values. The linked list is given by its head node.</div>
                        <div class=""> <b>Example:</b> Input: head = [10, 20, 30, 40]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the list is in the range [1, 5 * 10^4].</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= Node.val &lt;= 1000</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be the reordered linked list where nodes are arranged as L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...</div>
                        <div class=""> <b>Example:</b> Output: [10, 40, 20, 30]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be a singly linked list with the nodes rearranged as described.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to reorder the linked list as per the given structure without modifying the node values.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Find the middle of the list using the slow and fast pointer approach.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Reverse the second half of the list.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Merge the first half and the reversed second half by alternating nodes from each half.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The solution must operate within the given constraints and reorder the list in linear time.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The list must be reordered in O(n) time and O(1) extra space.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input list is non-empty and contains valid integers.</div>
                            
                                <div style="margin-left: 20px;"> • The list is not cyclic.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: head = [10, 20, 30, 40]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this example, the list is reordered as [10, 40, 20, 30], where the first node is followed by the last node, then the second node, followed by the second last node, and so on.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The solution involves three main steps: finding the middle of the list, reversing the second half, and merging the two halves.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • The problem requires rearranging nodes without modifying their values.</div>
                            
                            
                                <div style="margin-left: 20px;"> • A two-pointer approach can help find the middle of the list. After that, reversing the second half allows us to merge both halves in the required order.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Use two pointers (slow and fast) to find the middle of the list.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Reverse the second half of the list starting from the node after the middle.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Merge the two halves by alternately linking nodes from each half.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the input list contains only one node, the list remains unchanged.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The algorithm should efficiently handle lists with up to 50,000 nodes.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • The list may contain nodes with varying values, but the algorithm should not modify their values, only their positions.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution must use linear time and constant space.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Pointer Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Find Middle</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Move Slow Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Move Fast Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Middle Node</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Break First Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Pointer Initialization for Reversal</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Reverse Second Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Save Next Node</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Reverse Link</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Update Previous Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Move Mid Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Pointer Initialization for Merging</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Merge Two Halves</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Save Next Node in First Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="17"> 17 Connect First Half to Second Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="18"> 18 Save Next Node in Second Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="19"> 19 Connect Second Half to First Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="20"> 20 Move to Next Nodes</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="21"> 21 Move to Next Nodes</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">reorderList</span>(ListNode<span style="color:#666">*</span> head) {
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> fast <span style="color:#666">=</span> head, <span style="color:#666">*</span>slow <span style="color:#666">=</span> head;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(fast<span style="color:#666">-&gt;</span>next <span style="color:#666">&amp;&amp;</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>        slow <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        fast <span style="color:#666">=</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> mid <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    slow<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> next, <span style="color:#666">*</span>prev <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(mid) {
</span></span><span style="display:flex;"><span>        next <span style="color:#666">=</span> mid<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        mid<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prev;
</span></span><span style="display:flex;"><span>        prev <span style="color:#666">=</span> mid;
</span></span><span style="display:flex;"><span>        mid <span style="color:#666">=</span> next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> l1 <span style="color:#666">=</span> head, <span style="color:#666">*</span>l2 <span style="color:#666">=</span> prev;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(l1 <span style="color:#666">&amp;&amp;</span> l2) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> tmp1 <span style="color:#666">=</span> l1<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        l1<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> l2;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> tmp2 <span style="color:#666">=</span> l2<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        l2<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> tmp1;
</span></span><span style="display:flex;"><span>        l1 <span style="color:#666">=</span> tmp1;
</span></span><span style="display:flex;"><span>        l2 <span style="color:#666">=</span> tmp2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">reorderList</span>(ListNode<span style="color:#666">*</span> head) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This defines the `reorderList` function, which reorders the nodes of a linked list in a specific pattern by modifying the list in-place. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Pointer Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> fast <span style="color:#666">=</span> head, <span style="color:#666">*</span>slow <span style="color:#666">=</span> head;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Two pointers, `fast` and `slow`, are initialized at the head of the list. `fast` moves two steps at a time, and `slow` moves one step at a time. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Find Middle</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(fast<span style="color:#666">-&gt;</span>next <span style="color:#666">&amp;&amp;</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This loop runs until the `fast` pointer reaches the end of the list. It helps in finding the middle of the linked list using the slow and fast pointer technique. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Move Slow Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        slow <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The `slow` pointer moves one step at a time toward the middle of the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Move Fast Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        fast <span style="color:#666">=</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The `fast` pointer moves two steps at a time, so when it reaches the end, the `slow` pointer will be at the middle of the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Middle Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> mid <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> After finding the middle of the list, the `mid` pointer is initialized to the node right after the `slow` pointer. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Break First Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    slow<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Breaks the list into two halves by setting `slow-&gt;next` to `NULL`, thus isolating the first half of the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Pointer Initialization for Reversal</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> next, <span style="color:#666">*</span>prev <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Two pointers, `prev` and `next`, are initialized. `prev` is used for reversing the second half of the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Reverse Second Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(mid) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This loop reverses the second half of the list by iterating over the nodes starting from `mid`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Save Next Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        next <span style="color:#666">=</span> mid<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Saves the next node in the `next` pointer to avoid losing the reference during the reversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Reverse Link</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        mid<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prev;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Reverses the `mid` node&#39;s `next` pointer to point to the previous node, effectively reversing the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Update Previous Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        prev <span style="color:#666">=</span> mid;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `prev` pointer one step forward to the current node (`mid`), preparing it for the next iteration. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Move Mid Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        mid <span style="color:#666">=</span> next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `mid` pointer to the next node in the original list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Pointer Initialization for Merging</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> l1 <span style="color:#666">=</span> head, <span style="color:#666">*</span>l2 <span style="color:#666">=</span> prev;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes two pointers, `l1` pointing to the head of the first half, and `l2` pointing to the head of the reversed second half. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Merge Two Halves</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(l1 <span style="color:#666">&amp;&amp;</span> l2) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This loop merges the two halves by alternating nodes from `l1` and `l2`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Save Next Node in First Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> tmp1 <span style="color:#666">=</span> l1<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Saves the next node of `l1` in `tmp1` to prevent losing the reference during the merge. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>17 : Connect First Half to Second Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l1<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> l2;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Connects the current node of the first half (`l1`) to the current node of the second half (`l2`). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>18 : Save Next Node in Second Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> tmp2 <span style="color:#666">=</span> l2<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Saves the next node of `l2` in `tmp2` to ensure the merge can continue. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>19 : Connect Second Half to First Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l2<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> tmp1;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Connects the current node of the second half (`l2`) to the next node of the first half (`tmp1`). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>20 : Move to Next Nodes</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l1 <span style="color:#666">=</span> tmp1;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `l1` pointer to the next node in the first half. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>21 : Move to Next Nodes</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l2 <span style="color:#666">=</span> tmp2;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `l2` pointer to the next node in the second half. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n), when the list is reordered by following the standard procedure.</div>
                        <div class=""> <b>Average Case:</b> O(n), the list will always require a full traversal for reordering.</div>
                        <div class=""> <b>Worst Case:</b> O(n), the solution works in linear time in all cases.</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n) because we traverse the list multiple times, but each traversal is linear.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1), the space complexity remains constant.</div>
                        <div class=""> <b>Worst Case:</b> O(1), since only a few pointers are used.</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(1) because no extra space is used apart from a few pointers.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 28, 2024 - 7 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-95-unique-binary-search-trees-ii/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


            </div>
        </section>
<div class="bottompagination">
  <div class="pointerup"><i class="fa fa-caret-up"></i></div>
  <div class="navigation" role="navigation">
    
      <div class="pagination">
        
          <a class="ml-1 mr-1" href="/tags/dynamic-programming/">&laquo; Prev</a>
          <a class="ml-1 mr-1" href="/tags/dynamic-programming/">1</a>
        

        <span class="ml-1 mr-1">2</span>

        
          <a class="ml-1 mr-1" href="/tags/dynamic-programming/page/3/">3</a>
          <a class="ml-1 mr-1" href="/tags/dynamic-programming/page/3/">Next &raquo;</a>
        
      </div>
    
  </div>
</div></div>


            </div>
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
			<div class="d-md-flex align-items-center justify-content-center h-100">
				<h2 class="d-md-block d-none align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
			</div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
			
			<a class="mt-1 mb-1" href="/tags/array">array</a>
			
			<a class="mt-1 mb-1" href="/tags/backtracking">backtracking</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-indexed-tree">binary indexed tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search">binary search</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search-tree">binary search tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-tree">binary tree</a>
			
			<a class="mt-1 mb-1" href="/tags/bit-manipulation">bit manipulation</a>
			
			<a class="mt-1 mb-1" href="/tags/bitmask">bitmask</a>
			
			<a class="mt-1 mb-1" href="/tags/brainteaser">brainteaser</a>
			
			<a class="mt-1 mb-1" href="/tags/breadth-first-search">breadth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/bucket-sort">bucket sort</a>
			
			<a class="mt-1 mb-1" href="/tags/combinatorics">combinatorics</a>
			
			<a class="mt-1 mb-1" href="/tags/concurrency">concurrency</a>
			
			<a class="mt-1 mb-1" href="/tags/counting">counting</a>
			
			<a class="mt-1 mb-1" href="/tags/counting-sort">counting sort</a>
			
			<a class="mt-1 mb-1" href="/tags/data-stream">data stream</a>
			
			<a class="mt-1 mb-1" href="/tags/depth-first-search">depth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/design">design</a>
			
			<a class="mt-1 mb-1" href="/tags/divide-and-conquer">divide and conquer</a>
			
			<a class="mt-1 mb-1" href="/tags/doubly-linked-list">doubly-linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/dynamic-programming">dynamic programming</a>
			
			<a class="mt-1 mb-1" href="/tags/enumeration">enumeration</a>
			
			<a class="mt-1 mb-1" href="/tags/game-theory">game theory</a>
			
			<a class="mt-1 mb-1" href="/tags/geometry">geometry</a>
			
			<a class="mt-1 mb-1" href="/tags/graph">graph</a>
			
			<a class="mt-1 mb-1" href="/tags/greedy">greedy</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-function">hash function</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-table">hash table</a>
			
			<a class="mt-1 mb-1" href="/tags/heap-priority-queue">heap (priority queue)</a>
			
			<a class="mt-1 mb-1" href="/tags/interactive">interactive</a>
			
			<a class="mt-1 mb-1" href="/tags/iterator">iterator</a>
			
			<a class="mt-1 mb-1" href="/tags/linked-list">linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/math">math</a>
			
			<a class="mt-1 mb-1" href="/tags/matrix">matrix</a>
			
			<a class="mt-1 mb-1" href="/tags/memoization">memoization</a>
			
			<a class="mt-1 mb-1" href="/tags/minimum-spanning-tree">minimum spanning tree</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-queue">monotonic queue</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-stack">monotonic stack</a>
			
			<a class="mt-1 mb-1" href="/tags/number-theory">number theory</a>
			
			<a class="mt-1 mb-1" href="/tags/ordered-set">ordered set</a>
			
			<a class="mt-1 mb-1" href="/tags/prefix-sum">prefix sum</a>
			
			<a class="mt-1 mb-1" href="/tags/probability-and-statistics">probability and statistics</a>
			
			<a class="mt-1 mb-1" href="/tags/queue">queue</a>
			
			<a class="mt-1 mb-1" href="/tags/quickselect">quickselect</a>
			
			<a class="mt-1 mb-1" href="/tags/radix-sort">radix sort</a>
			
			<a class="mt-1 mb-1" href="/tags/randomized">randomized</a>
			
			<a class="mt-1 mb-1" href="/tags/recursion">recursion</a>
			
			<a class="mt-1 mb-1" href="/tags/reservoir-sampling">reservoir sampling</a>
			
			<a class="mt-1 mb-1" href="/tags/rolling-hash">rolling hash</a>
			
			<a class="mt-1 mb-1" href="/tags/segment-tree">segment tree</a>
			
			<a class="mt-1 mb-1" href="/tags/shortest-path">shortest path</a>
			
			<a class="mt-1 mb-1" href="/tags/simulation">simulation</a>
			
			<a class="mt-1 mb-1" href="/tags/sliding-window">sliding window</a>
			
			<a class="mt-1 mb-1" href="/tags/sorting">sorting</a>
			
			<a class="mt-1 mb-1" href="/tags/stack">stack</a>
			
			<a class="mt-1 mb-1" href="/tags/string">string</a>
			
			<a class="mt-1 mb-1" href="/tags/string-matching">string matching</a>
			
			<a class="mt-1 mb-1" href="/tags/topological-sort">topological sort</a>
			
			<a class="mt-1 mb-1" href="/tags/tree">tree</a>
			
			<a class="mt-1 mb-1" href="/tags/trie">trie</a>
			
			<a class="mt-1 mb-1" href="/tags/two-pointers">two pointers</a>
			
			<a class="mt-1 mb-1" href="/tags/union-find">union find</a>
			
		</div>
	</div>
</div>

<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

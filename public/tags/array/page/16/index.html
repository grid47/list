<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Array | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Array">
  <meta name="twitter:description" content="Blog by grid47">

	<meta property="og:url" content="http://localhost:1313/tags/array/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Array">
  <meta property="og:description" content="Blog by grid47">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
        

	
	
	<link rel="stylesheet" href="/css/leetcode.css" integrity="" crossorigin="anonymous" media="screen">



</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/courses/">Course</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
    <div class="main-content">
        
        <section class="recent-posts">            
            <div class="section-title">                
                <h2><span>All Posts</span></h2>                
            </div>            
            <div class="row listrecent">
                
                
<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-455-assign-cookies/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-455-assign-cookies/">Leetcode 455: Assign Cookies</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1147s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/455.webp" 
           alt="A series of cookies and children with glowing indicators of the best cookie assignment." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 455: Assign Cookies Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given an integer array nums and an array of queries, each of which is in the form [value, index], you need to apply each query by adding value to nums[index] and return the sum of even numbers in the updated nums array after each query. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> You are given an array nums of integers and an array of queries, where each query consists of a value to be added to nums at a specific index.</div>
                        <div class=""> <b>Example:</b> nums = [5, 7, 9, 10], queries = [[2, 0], [-5, 1], [4, 0], [6, 3]]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= nums.length &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • -10^4 &lt;= nums[i] &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= queries.length &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • -10^4 &lt;= value &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= index &lt; nums.length</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> For each query, return the sum of even numbers in nums after the query has been applied.</div>
                        <div class=""> <b>Example:</b> Output: [12, 7, 12, 14]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be an array of integers representing the sum of even numbers after each query.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to modify the nums array with each query and compute the sum of even values in the updated array.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Initialize a sum variable to hold the sum of even numbers in nums.</div>
                            
                                <div style="margin-left: 20px;"> • Iterate over each query and modify the appropriate value in nums.</div>
                            
                                <div style="margin-left: 20px;"> • After modifying nums, update the sum of even numbers based on the updated value.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The problem must be solved efficiently given the constraints on the array and queries sizes.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • nums.length and queries.length can be as large as 10^4, so the solution must be efficient.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • Each query modifies nums at a specific index, and the sum of even values is updated immediately after each modification.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> nums = [5, 7, 9, 10], queries = [[2, 0], [-5, 1], [4, 0], [6, 3]]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this example, we modify nums in place for each query and compute the sum of even values after each query.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> We can keep track of the sum of even values in nums and update it after each query, adjusting for the even/odd status of the modified value.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • We need to efficiently update the sum of even values after each query without recalculating from scratch.</div>
                            
                            
                                <div style="margin-left: 20px;"> • By adjusting the sum based on whether the modified value is even or odd, we can avoid unnecessary recalculations.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Calculate the initial sum of even numbers in the array.</div>
                            
                                <div style="margin-left: 20px;"> • For each query, update the value in nums and adjust the sum of even numbers accordingly.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle cases where nums has only one element.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Consider large arrays and large values for nums and queries.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle cases where the modified number becomes even or odd due to the addition.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure the solution is efficient enough to handle the maximum constraints.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Initialize Result Vector</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Initialize Sum of Even Elements</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Lambda for Even Sum</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Iterate Over Queries</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Remove Even Value from Sum</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Apply Query</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Add Even Value to Sum</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Store the Sum After Query</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Return Result</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> sumEvenAfterQueries(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> A, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> qs) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res <span style="color:#666">=</span> {};
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> accumulate(begin(A), end(A), <span style="color:#666">0</span>, [](<span style="color:#0b0;font-weight:bold">int</span> s, <span style="color:#0b0;font-weight:bold">int</span> a) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> s <span style="color:#666">+</span> (a <span style="color:#666">%</span> <span style="color:#666">2</span> <span style="color:#666">==</span> <span style="color:#666">0</span><span style="color:#666">?</span> <span style="color:#a0a000">a</span> : <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">q</span>: qs) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(A[q[<span style="color:#666">1</span>]] <span style="color:#666">%</span><span style="color:#666">2</span> <span style="color:#666">==</span> <span style="color:#666">0</span>) sum<span style="color:#666">-=</span>A[q[<span style="color:#666">1</span>]];
</span></span><span style="display:flex;"><span>        A[q[<span style="color:#666">1</span>]] <span style="color:#666">+=</span> q[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(A[q[<span style="color:#666">1</span>]]<span style="color:#666">%</span><span style="color:#666">2</span> <span style="color:#666">==</span> <span style="color:#666">0</span>) sum<span style="color:#666">+=</span>A[q[<span style="color:#666">1</span>]];
</span></span><span style="display:flex;"><span>        res.push_back(sum);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> sumEvenAfterQueries(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> A, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> qs) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the function `sumEvenAfterQueries`, which takes an array `A` and a list of queries `qs`, returning a vector of integers with the sum of even elements after each query. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Initialize Result Vector</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res <span style="color:#666">=</span> {};
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes an empty vector `res` that will store the results after each query, representing the sum of even elements in the array. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Initialize Sum of Even Elements</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> accumulate(begin(A), end(A), <span style="color:#666">0</span>, [](<span style="color:#0b0;font-weight:bold">int</span> s, <span style="color:#0b0;font-weight:bold">int</span> a) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calculates the initial sum of all even elements in the array `A` using the `accumulate` function and a lambda to check if an element is even. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Lambda for Even Sum</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> s <span style="color:#666">+</span> (a <span style="color:#666">%</span> <span style="color:#666">2</span> <span style="color:#666">==</span> <span style="color:#666">0</span><span style="color:#666">?</span> <span style="color:#a0a000">a</span> : <span style="color:#666">0</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This lambda function adds the element `a` to the sum `s` if `a` is even (`a % 2 == 0`), otherwise it adds 0. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Iterate Over Queries</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">q</span>: qs) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Begins a loop to iterate over the list of queries `qs`. Each query contains an update to the array `A`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Remove Even Value from Sum</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(A[q[<span style="color:#666">1</span>]] <span style="color:#666">%</span><span style="color:#666">2</span> <span style="color:#666">==</span> <span style="color:#666">0</span>) sum<span style="color:#666">-=</span>A[q[<span style="color:#666">1</span>]];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the element at the index specified by `q[1]` is even, it is subtracted from the sum of even numbers before applying the query. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Apply Query</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        A[q[<span style="color:#666">1</span>]] <span style="color:#666">+=</span> q[<span style="color:#666">0</span>];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates the element in the array `A` at the index `q[1]` by adding the value `q[0]` from the current query. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Add Even Value to Sum</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(A[q[<span style="color:#666">1</span>]]<span style="color:#666">%</span><span style="color:#666">2</span> <span style="color:#666">==</span> <span style="color:#666">0</span>) sum<span style="color:#666">+=</span>A[q[<span style="color:#666">1</span>]];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> After updating the element, if the element at index `q[1]` is even, it is added back to the sum of even numbers. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Store the Sum After Query</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        res.push_back(sum);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> After processing the query, the current sum of even numbers is added to the result vector `res`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Return Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the result vector `res`, which contains the sum of even elements after each query. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1) for each query if the update does not affect the even/odd status.</div>
                        <div class=""> <b>Average Case:</b> O(1) for each query as we only adjust the sum.</div>
                        <div class=""> <b>Worst Case:</b> O(n) if we recalculate the sum of even numbers after each query (though this is avoidable).</div> 
                        <div class=""> <b>Description:</b> Each query is processed in constant time if we manage the sum of even numbers efficiently.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n) for storing the nums array.</div>
                        <div class=""> <b>Worst Case:</b> O(n) for storing the nums array.</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n) where n is the size of the nums array.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/assign-cookies/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Sep 22, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-455-assign-cookies/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-456-132-pattern/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-456-132-pattern/">Leetcode 456: 132 Pattern</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1148s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/456.webp" 
           alt="A sequence of numbers where the 132 pattern lights up, showing the correct order and placement of elements." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 456: 132 Pattern Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given the root of a binary tree, where each node contains a value between 0 and 25, corresponding to letters from &lsquo;a&rsquo; to &lsquo;z&rsquo;. Your task is to find the lexicographically smallest string that can be formed by traversing from a leaf node to the root node, using the values in each node as letters. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of the root of a binary tree, where each node has an integer value in the range [0, 25].</div>
                        <div class=""> <b>Example:</b> root = [0, 1, 2, 3, 4, 3, 4]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the tree is between 1 and 8500.</div>
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= Node.val &lt;= 25.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be the lexicographically smallest string that starts from a leaf node and ends at the root.</div>
                        <div class=""> <b>Example:</b> Output: &#34;dbd&#34;</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The string must be constructed by following the path from a leaf node to the root.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to traverse the binary tree from each leaf node to the root, constructing strings and determining the lexicographically smallest one.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Traverse the tree recursively from root to leaf nodes.</div>
                            
                                <div style="margin-left: 20px;"> • At each leaf node, generate the corresponding string by adding the character of the node to the string.</div>
                            
                                <div style="margin-left: 20px;"> • Compare the generated string with the current smallest string and update accordingly.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The solution must handle the constraints efficiently given the possible size of the binary tree.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The number of nodes is between 1 and 8500, so a recursive solution with backtracking will be efficient enough.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The tree is a binary tree with no cycles.</div>
                            
                                <div style="margin-left: 20px;"> • The tree contains at least one node (i.e., the root is not null).</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = [0, 1, 2, 3, 4, 3, 4]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this example, the binary tree has leaf nodes with values corresponding to &#39;d&#39;, &#39;b&#39;, and &#39;d&#39;. The lexicographically smallest string is formed by starting from the leaf &#39;d&#39; and traversing back to the root, resulting in &#39;dbd&#39;.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The approach involves recursively traversing the tree and constructing strings from leaf nodes to the root while keeping track of the lexicographically smallest string.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • We need to traverse each path from a leaf to the root and compare the strings lexicographically.</div>
                            
                            
                                <div style="margin-left: 20px;"> • Using recursion allows us to easily explore all paths from leaf to root and compare the strings efficiently.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Initialize a variable to store the lexicographically smallest string.</div>
                            
                                <div style="margin-left: 20px;"> • Use a recursive function to explore each node and append its value as a character to the string.</div>
                            
                                <div style="margin-left: 20px;"> • At each leaf node, compare the constructed string with the current smallest string and update if necessary.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle the case where the tree has only one node.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure the solution handles the maximum number of nodes efficiently.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Consider trees with values representing letters near the boundaries of the alphabet, such as &#39;a&#39; (0) or &#39;z&#39; (25).</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure the algorithm runs efficiently for a large number of nodes and is optimized for recursion.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Return Result</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Helper Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Base Case</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Leaf Node Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Update Answer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Recursive Call for Left Child</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Recursive Call for Right Child</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string ans <span style="color:#666">=</span> <span style="color:#b44">&#34;~&#34;</span>;
</span></span><span style="display:flex;"><span>string <span style="color:#00a000">smallestFromLeaf</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    recur(root, <span style="color:#b44">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">recur</span>(TreeNode<span style="color:#666">*</span> node, string s) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>node) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>node<span style="color:#666">-&gt;</span>left <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>node<span style="color:#666">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>        ans <span style="color:#666">=</span> min(ans, <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout <span style="color:#666">&lt;&lt;</span> node<span style="color:#666">-&gt;</span>val<span style="color:#666">&lt;&lt;</span><span style="color:#b44">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    recur(node<span style="color:#666">-&gt;</span>left,  <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);
</span></span><span style="display:flex;"><span>    recur(node<span style="color:#666">-&gt;</span>right, <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string ans <span style="color:#666">=</span> <span style="color:#b44">&#34;~&#34;</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes the variable `ans` to `~`, which will be used to store the smallest string found from a leaf to the root during the traversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string <span style="color:#00a000">smallestFromLeaf</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the function `smallestFromLeaf`, which takes the root node of a binary tree and returns the lexicographically smallest string from a leaf node to the root. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    recur(root, <span style="color:#b44">&#34;&#34;</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calls the helper function `recur` to start the recursive traversal of the tree. The empty string `&#34;&#34;` is passed as the initial path. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Return Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the variable `ans`, which contains the lexicographically smallest string from a leaf node to the root after the recursion completes. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Helper Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">recur</span>(TreeNode<span style="color:#666">*</span> node, string s) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the helper function `recur`, which performs the recursive traversal of the binary tree, building the string path from the leaf to the root. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Base Case</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>node) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current node is null, which is the base case for recursion. If the node is null, the function returns without doing anything. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Leaf Node Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>node<span style="color:#666">-&gt;</span>left <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>node<span style="color:#666">-&gt;</span>right) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current node is a leaf node (both left and right children are null). If it&#39;s a leaf, the function proceeds to check and update the answer. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Update Answer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ans <span style="color:#666">=</span> min(ans, <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates the `ans` variable with the lexicographically smaller string between the current `ans` and the string formed by adding the current node&#39;s value (converted to a character) to the path `s`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Recursive Call for Left Child</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    recur(node<span style="color:#666">-&gt;</span>left,  <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls the `recur` function for the left child of the current node, passing the current node&#39;s value (converted to a character) prepended to the string path `s`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Recursive Call for Right Child</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    recur(node<span style="color:#666">-&gt;</span>right, <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);  
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls the `recur` function for the right child of the current node, prepending the current node&#39;s value (converted to a character) to the string path `s`. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n) where n is the number of nodes, as each node is visited once.</div>
                        <div class=""> <b>Average Case:</b> O(n) where n is the number of nodes, as each node contributes to a string comparison.</div>
                        <div class=""> <b>Worst Case:</b> O(n) where n is the number of nodes, since we visit each node in the tree once.</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n), where n is the number of nodes in the tree, due to the tree traversal.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1) if the tree is very shallow or balanced.</div>
                        <div class=""> <b>Worst Case:</b> O(h) where h is the height of the tree, due to recursion stack space.</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(h), where h is the height of the tree, due to recursion.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/132-pattern/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Sep 22, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-456-132-pattern/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-457-circular-array-loop/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-457-circular-array-loop/">Leetcode 457: Circular Array Loop</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1149s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/457.webp" 
           alt="A glowing circular array where elements move in a loop, with each cycle softly illuminated as it repeats." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 457: Circular Array Loop Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given a list of equations where each equation represents a relationship between two variables in the form &lsquo;xi==yi&rsquo; or &lsquo;xi!=yi&rsquo;. Determine if it&rsquo;s possible to assign integer values to variables such that all equations are satisfied. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of an array of strings, where each string is an equation of the form &#39;xi==yi&#39; or &#39;xi!=yi&#39;.</div>
                        <div class=""> <b>Example:</b> equations = [&#34;a==b&#34;, &#34;b!=a&#34;]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= equations.length &lt;= 500</div>
                            
                                <div style="margin-left: 20px;"> • equations[i].length == 4</div>
                            
                                <div style="margin-left: 20px;"> • equations[i][0] is a lowercase letter.</div>
                            
                                <div style="margin-left: 20px;"> • equations[i][1] is either &#39;=&#39; or &#39;!&#39;</div>
                            
                                <div style="margin-left: 20px;"> • equations[i][2] is &#39;=&#39;</div>
                            
                                <div style="margin-left: 20px;"> • equations[i][3] is a lowercase letter.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be a boolean value: &#39;true&#39; if the equations can be satisfied by assigning values to the variables, &#39;false&#39; otherwise.</div>
                        <div class=""> <b>Example:</b> Output: true</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output is true if all equations can be satisfied with consistent assignments of values to variables.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to check if it&#39;s possible to assign integer values to variables such that all the equations are satisfied. This can be done by using a union-find data structure to group variables that are equal and check if any &#39;!=&#39; equations violate these groups.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Initialize a union-find data structure to represent groups of variables that are equal.</div>
                            
                                <div style="margin-left: 20px;"> • Process each equation: if it&#39;s an equality (&#39;==&#39;), union the two variables; if it&#39;s an inequality (&#39;!=&#39;), check if the two variables are in the same group, which would indicate a contradiction.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The solution needs to be efficient given the constraints.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= equations.length &lt;= 500</div>
                            
                                <div style="margin-left: 20px;"> • Each equation is of length 4.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input list will contain only valid equations in the form of &#39;xi==yi&#39; or &#39;xi!=yi&#39;.</div>
                            
                                <div style="margin-left: 20px;"> • The variables are represented by lowercase letters (&#39;a&#39; to &#39;z&#39;).</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> equations = [&#34;a==b&#34;, &#34;b!=a&#34;]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this example, we are given the equations &#39;a==b&#39; and &#39;b!=a&#39;. If we assume a = 1 and b = 1, the first equation is satisfied, but the second equation is violated because a cannot be equal to b and not equal to b at the same time.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> To solve this problem, we can use a union-find (disjoint-set) data structure to manage the groups of variables that must be equal. We process all equality equations first and then check each inequality equation to ensure no contradictions.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • The problem requires us to check both equality and inequality relationships, which can be efficiently handled using the union-find data structure.</div>
                            
                            
                                <div style="margin-left: 20px;"> • The union-find approach will allow us to group variables and detect contradictions efficiently. If two variables that must be different are in the same group, it&#39;s impossible to satisfy the equations.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Step 1: Initialize a union-find data structure for the 26 lowercase variables.</div>
                            
                                <div style="margin-left: 20px;"> • Step 2: Process all &#39;==&#39; equations by uniting the respective variables.</div>
                            
                                <div style="margin-left: 20px;"> • Step 3: Process all &#39;!=&#39; equations and check if any variables that should be different belong to the same group.</div>
                            
                                <div style="margin-left: 20px;"> • Step 4: If a contradiction is found, return false; otherwise, return true.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle cases where the input array is empty.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure that the solution efficiently handles the maximum number of equations (500).</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Check for edge cases with only one equation, such as &#39;a==a&#39; or &#39;a!=a&#39;.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution must handle up to 500 equations efficiently.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Union-Find Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Equality Processing Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Character Indexing</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Character Indexing</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Equality Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Union Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Inequality Processing Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Character Indexing</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Character Indexing</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Inequality Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Find Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Return False</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Return True</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">equationsPossible</span>(vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&amp;</span> eqn) {
</span></span><span style="display:flex;"><span>    UF<span style="color:#666">*</span> uf <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> UF(<span style="color:#666">26</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> eqn.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> a <span style="color:#666">=</span> eqn[i][<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> b <span style="color:#666">=</span> eqn[i][<span style="color:#666">3</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(eqn[i][<span style="color:#666">1</span>] <span style="color:#666">==</span> <span style="color:#b44">&#39;=&#39;</span>)
</span></span><span style="display:flex;"><span>            uf<span style="color:#666">-&gt;</span>uni(a, b);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> eqn.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> a <span style="color:#666">=</span> eqn[i][<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> b <span style="color:#666">=</span> eqn[i][<span style="color:#666">3</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(eqn[i][<span style="color:#666">1</span>] <span style="color:#666">==</span> <span style="color:#b44">&#39;!&#39;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(uf<span style="color:#666">-&gt;</span>find(a) <span style="color:#666">==</span> uf<span style="color:#666">-&gt;</span>find(b))
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>    }        
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">equationsPossible</span>(vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&amp;</span> eqn) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the `equationsPossible` function that takes a vector of strings, `eqn`, where each string represents an equation (either equality or inequality) between two characters. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Union-Find Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    UF<span style="color:#666">*</span> uf <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> UF(<span style="color:#666">26</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes a union-find (disjoint-set) data structure `uf` with 26 elements, one for each letter of the alphabet. The union-find structure will help manage connected components for equality relations. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Equality Processing Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> eqn.size(); i<span style="color:#666">++</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts a loop to process each equation in the input `eqn` vector. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Character Indexing</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> a <span style="color:#666">=</span> eqn[i][<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Converts the first character of the equation (left side) into an integer index between 0 and 25, representing the letter in the alphabet. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Character Indexing</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> b <span style="color:#666">=</span> eqn[i][<span style="color:#666">3</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Converts the second character of the equation (right side) into an integer index between 0 and 25. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Equality Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(eqn[i][<span style="color:#666">1</span>] <span style="color:#666">==</span> <span style="color:#b44">&#39;=&#39;</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current equation is an equality (`=`). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Union Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            uf<span style="color:#666">-&gt;</span>uni(a, b);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the equation is an equality, it performs a union operation on the two characters (`a` and `b`), indicating that they belong to the same group. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Inequality Processing Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> eqn.size(); i<span style="color:#666">++</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts another loop to process the inequality equations. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Character Indexing</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> a <span style="color:#666">=</span> eqn[i][<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Converts the first character of the inequality equation into an integer index between 0 and 25. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Character Indexing</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> b <span style="color:#666">=</span> eqn[i][<span style="color:#666">3</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Converts the second character of the inequality equation into an integer index between 0 and 25. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Inequality Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(eqn[i][<span style="color:#666">1</span>] <span style="color:#666">==</span> <span style="color:#b44">&#39;!&#39;</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current equation is an inequality (`!=`). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Find Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(uf<span style="color:#666">-&gt;</span>find(a) <span style="color:#666">==</span> uf<span style="color:#666">-&gt;</span>find(b))
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the equation is an inequality, it checks if the two characters are connected in the union-find structure. If they are connected (i.e., they belong to the same group), the inequality is violated. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Return False</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the inequality is violated (the characters are in the same group), the function returns `false` indicating that the equations are not possible. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Return True</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If all equations have been processed and no contradictions were found, the function returns `true`, indicating that the set of equations is possible. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n), where n is the number of equations, if all equations are satisfied with no contradictions.</div>
                        <div class=""> <b>Average Case:</b> O(n), since each equation requires a constant time union/find operation.</div>
                        <div class=""> <b>Worst Case:</b> O(n), as each union/find operation is nearly constant time with path compression and union by rank.</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n) due to the use of union-find, where n is the number of equations.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(26), regardless of input size, as the space required is constant.</div>
                        <div class=""> <b>Worst Case:</b> O(26), as we need to store the union-find structure for 26 variables.</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(26), which is constant, since we only need to store the union-find structure for the 26 variables.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/circular-array-loop/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Sep 22, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-457-circular-array-loop/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-474-ones-and-zeroes/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-474-ones-and-zeroes/">Leetcode 474: Ones and Zeroes</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1154s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/474.webp" 
           alt="A sequence of ones and zeroes gently forming various combinations, with each valid combination glowing softly." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 474: Ones and Zeroes Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given the head of a singly linked list. For each node in the list, find the value of the next node that has a strictly larger value than the current node. If no such node exists, return 0 for that node. Return the result as an array where the value at index i represents the next greater node for the i-th node. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> You are given a singly linked list where each node contains a value.</div>
                        <div class=""> <b>Example:</b> head = [1, 3, 2, 4]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the list is n.</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= n &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= Node.val &lt;= 10^9</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return an integer array answer, where answer[i] is the value of the next greater node for the i-th node (1-indexed). If no such node exists, set answer[i] = 0.</div>
                        <div class=""> <b>Example:</b> Output: [3, 4, 4, 0]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The array returned should have the same length as the number of nodes in the linked list.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to find the next greater node for each node in the linked list. This involves tracking the nodes where a larger value appears next and updating the corresponding result.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Traverse the linked list while maintaining a stack to store the indices of nodes.</div>
                            
                                <div style="margin-left: 20px;"> • 2. For each node, compare its value with the value at the index stored at the top of the stack.</div>
                            
                                <div style="margin-left: 20px;"> • 3. If the current node has a larger value, pop the index from the stack and update the result for that index.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Push the current node index onto the stack for future comparisons.</div>
                            
                                <div style="margin-left: 20px;"> • 5. After processing all nodes, the remaining indices in the stack will correspond to nodes that do not have a larger next node, so set their results to 0.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Ensure that the solution handles large inputs and avoids unnecessary computations.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the linked list should be between 1 and 10^4.</div>
                            
                                <div style="margin-left: 20px;"> • Node values are integers between 1 and 10^9.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input linked list is valid, and the list is not empty.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: head = [1, 3, 2, 4]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this list, the next greater node for 1 is 3, for 3 is 4, for 2 is 4, and for 4, there is no greater node, so it returns 0. Therefore, the output is [3, 4, 4, 0].</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: head = [2, 1, 5]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> Here, the next greater node for 2 is 5, for 1 is 5, and for 5, there is no next greater node, so it returns 0. The output is [5, 5, 0].</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The solution uses a stack to keep track of the nodes while iterating through the list. This helps efficiently find the next greater node for each element.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • A stack is useful to store indices of nodes while checking for the next greater node.</div>
                            
                            
                                <div style="margin-left: 20px;"> • The stack ensures that we only look at each node once, making the algorithm more efficient.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Initialize an empty stack and an empty result array.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Traverse the linked list. For each node:</div>
                            
                                <div style="margin-left: 20px;"> •    a. If the current node has a value larger than the node at the top of the stack, pop the stack and update the result.</div>
                            
                                <div style="margin-left: 20px;"> •    b. Push the index of the current node onto the stack.</div>
                            
                                <div style="margin-left: 20px;"> • 3. After processing all nodes, assign 0 to the remaining indices in the stack since they do not have a next greater node.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the input linked list is empty, the output should be an empty array.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • For large lists (e.g., when n is close to 10^4), the solution should still run efficiently within time limits.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle cases where all nodes have the same value, in which case the output should be an array of zeros.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure that the solution works for cases with values at the boundary of constraints (e.g., very large node values).</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 For Loop Setup</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 While Loop Start</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Update Result</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Pop from Stack</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Push Index to Stack</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Store Node Value</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 For Loop for Remaining Indices</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Return Result</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> nextLargerNodes(ListNode<span style="color:#666">*</span> head) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> stk, res;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(ListNode<span style="color:#666">*</span> node <span style="color:#666">=</span> head; node <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>; node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>stk.empty() <span style="color:#666">&amp;&amp;</span> res[stk.back()] <span style="color:#666">&lt;</span> node<span style="color:#666">-&gt;</span>val) {
</span></span><span style="display:flex;"><span>            res[stk.back()] <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>            stk.pop_back();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        stk.push_back(res.size());
</span></span><span style="display:flex;"><span>        res.push_back(node<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">i</span> : stk) res[i] <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> nextLargerNodes(ListNode<span style="color:#666">*</span> head) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the function `nextLargerNodes`, which accepts a pointer to the head of a linked list and returns a vector of integers. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> stk, res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes two vectors: `stk` to hold indices of elements and `res` to store the final result. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : For Loop Setup</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(ListNode<span style="color:#666">*</span> node <span style="color:#666">=</span> head; node <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>; node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>next) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Begins a loop that iterates over each node in the linked list from `head` to the end. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : While Loop Start</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>stk.empty() <span style="color:#666">&amp;&amp;</span> res[stk.back()] <span style="color:#666">&lt;</span> node<span style="color:#666">-&gt;</span>val) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Enters a while loop to check if there is a larger node value for the indices stored in `stk`. If the current node&#39;s value is greater, it updates the corresponding position in `res`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Update Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            res[stk.back()] <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>val;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates the result array `res` at the index stored in `stk` with the current node&#39;s value. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Pop from Stack</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            stk.pop_back();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Removes the top index from the stack `stk` since its next larger value has been found. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Push Index to Stack</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        stk.push_back(res.size());
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pushes the index of the current node into the stack `stk` to track the position of the node for future comparisons. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Store Node Value</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        res.push_back(node<span style="color:#666">-&gt;</span>val);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Adds the current node&#39;s value to the `res` vector. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : For Loop for Remaining Indices</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">i</span> : stk) res[i] <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Iterates through the remaining indices in `stk`, setting their corresponding values in `res` to 0, as no larger value was found for those nodes. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Return Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the final result vector `res`, which contains the next larger value for each node in the linked list. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n) since we iterate through each node exactly once.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n) due to the stack and result array storing information for each node in the list.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/ones-and-zeroes/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Sep 20, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-474-ones-and-zeroes/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-475-heaters/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-475-heaters/">Leetcode 475: Heaters</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1155s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/475.webp" 
           alt="A grid where heaters light up and warm nearby houses, with each heater softly illuminating its effect." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 475: Heaters Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given a grid of size m x n where each cell is either land (1) or sea (0). Your task is to determine the number of land cells that are completely enclosed by sea cells. A land cell is considered enclosed if it cannot reach the boundary of the grid via other land cells. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of an m x n grid, where grid[i][j] is either 1 (land) or 0 (sea).</div>
                        <div class=""> <b>Example:</b> grid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= m, n &lt;= 500</div>
                            
                                <div style="margin-left: 20px;"> • grid[i][j] is either 0 or 1</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return the number of land cells that are completely enclosed by sea cells, i.e., they cannot reach the boundary of the grid.</div>
                        <div class=""> <b>Example:</b> Output: 3</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The returned number should be an integer representing the count of enclosed land cells.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> To determine which land cells are enclosed, we need to find and mark all the land cells connected to the boundary of the grid, and then count the remaining land cells.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Traverse the boundary of the grid and mark all land cells connected to it using depth-first search (DFS).</div>
                            
                                <div style="margin-left: 20px;"> • 2. After marking the reachable land cells, the remaining unmarked land cells are enclosed.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Count and return the number of enclosed land cells.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Make sure the algorithm works efficiently within the grid size constraints and correctly identifies enclosed land cells.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The grid can be as large as 500 x 500, so the solution should handle grids of this size.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input grid is valid and contains only 0s and 1s.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: grid = [[0, 0, 0, 0], [1, 0, 1, 0], [0, 1, 1, 0], [0, 0, 0, 0]]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this case, the 1s in positions (1, 0), (1, 2), and (2, 1) are enclosed by 0s. The land cell at position (2, 2) is not enclosed because it is connected to the boundary. Thus, the output is 3.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: grid = [[0, 1, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 0, 0]]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this case, all the 1s are either connected to the boundary or can reach the boundary through other land cells. Therefore, no land cells are enclosed, and the output is 0.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The approach uses depth-first search (DFS) to mark all land cells connected to the boundary, then counts the remaining unmarked land cells.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Boundary cells can directly or indirectly reach the edge, so any land cell connected to the boundary is not enclosed.</div>
                            
                            
                                <div style="margin-left: 20px;"> • The problem requires marking the land cells that are connected to the boundary using DFS and then counting the unmarked ones.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Loop through the boundary of the grid and perform a DFS for each land cell (1).</div>
                            
                                <div style="margin-left: 20px;"> • 2. For each DFS, mark the connected land cells by changing their value to a different number (e.g., 2).</div>
                            
                                <div style="margin-left: 20px;"> • 3. After the boundary DFS traversal, loop through the grid again and count the land cells that are still 1 (i.e., they are enclosed).</div>
                            
                                <div style="margin-left: 20px;"> • 4. Return the count of these enclosed land cells.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the grid is empty or contains no land cells, the output should be 0.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • For large grids (e.g., 500 x 500), the algorithm should still run within time limits.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle cases where all cells are sea cells (0) or all cells are land cells (1).</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure the solution handles the maximum grid size efficiently.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Grid Dimensions</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Outer Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Inner Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Boundary Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Condition for DFS</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 DFS Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Count Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Count Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Count Inner Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Count Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Return Count</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Helper Function Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 DFS Base Case</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Exit DFS</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Mark Visited Cell</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="17"> 17 DFS Recursive Calls</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="18"> 18 DFS Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="19"> 19 DFS Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="20"> 20 DFS Recursive Call</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">numEnclaves</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> grid.size(), n <span style="color:#666">=</span> grid[<span style="color:#666">0</span>].size();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> m; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> n; j<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">==</span> <span style="color:#666">0</span> <span style="color:#666">||</span> j <span style="color:#666">==</span> <span style="color:#666">0</span> <span style="color:#666">||</span> i <span style="color:#666">==</span> m <span style="color:#666">-</span> <span style="color:#666">1</span> <span style="color:#666">||</span> j <span style="color:#666">==</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(grid[i][j] <span style="color:#666">==</span> <span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>                dfs(grid, i, j);
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> cnt <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> m; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> n; j<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(grid[i][j] <span style="color:#666">==</span> <span style="color:#666">1</span>) cnt<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> cnt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> grid, <span style="color:#0b0;font-weight:bold">int</span> i, <span style="color:#0b0;font-weight:bold">int</span> j) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> j <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> i <span style="color:#666">==</span> grid.size() <span style="color:#666">||</span> j <span style="color:#666">==</span> grid[<span style="color:#666">0</span>].size() <span style="color:#666">||</span> grid[i][j] <span style="color:#666">!=</span> <span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    grid[i][j] <span style="color:#666">=</span> <span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>    dfs(grid, i <span style="color:#666">+</span> <span style="color:#666">1</span>, j);
</span></span><span style="display:flex;"><span>    dfs(grid, i, j <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>    dfs(grid, i <span style="color:#666">-</span> <span style="color:#666">1</span>, j);
</span></span><span style="display:flex;"><span>    dfs(grid, i, j <span style="color:#666">-</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">numEnclaves</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> grid) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the function `numEnclaves`, which takes a 2D grid as input and returns the number of enclaves (connected regions of 1&#39;s that are not connected to the boundary). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Grid Dimensions</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> grid.size(), n <span style="color:#666">=</span> grid[<span style="color:#666">0</span>].size();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Stores the number of rows `m` and columns `n` in the grid, which are used to iterate over the grid. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Outer Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> m; i<span style="color:#666">++</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts the first loop to iterate through each row of the grid. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Inner Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> n; j<span style="color:#666">++</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts the inner loop to iterate through each column of the current row. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Boundary Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">==</span> <span style="color:#666">0</span> <span style="color:#666">||</span> j <span style="color:#666">==</span> <span style="color:#666">0</span> <span style="color:#666">||</span> i <span style="color:#666">==</span> m <span style="color:#666">-</span> <span style="color:#666">1</span> <span style="color:#666">||</span> j <span style="color:#666">==</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current cell is on the boundary of the grid (first row, first column, last row, or last column). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Condition for DFS</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(grid[i][j] <span style="color:#666">==</span> <span style="color:#666">1</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current boundary cell contains a 1 (representing land), it calls the `dfs` function to mark all connected land cells. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : DFS Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>                dfs(grid, i, j);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calls the helper function `dfs` to mark all connected 1&#39;s from the current cell as visited (by setting them to 2). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Count Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> cnt <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes a counter `cnt` to store the number of remaining land cells that are not connected to the boundary. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Count Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> m; i<span style="color:#666">++</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts a loop to iterate through each row again to count the remaining land cells. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Count Inner Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> n; j<span style="color:#666">++</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts an inner loop to iterate through each column of the current row. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Count Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(grid[i][j] <span style="color:#666">==</span> <span style="color:#666">1</span>) cnt<span style="color:#666">++</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Increments the counter `cnt` whenever a land cell (1) is found that is not connected to the boundary. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Return Count</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> cnt;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the final count of the enclaves (land cells not connected to the boundary). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Helper Function Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> grid, <span style="color:#0b0;font-weight:bold">int</span> i, <span style="color:#0b0;font-weight:bold">int</span> j) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the helper function `dfs` that uses Depth-First Search to mark connected land cells starting from position `(i, j)`. It modifies the grid to mark visited cells. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : DFS Base Case</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> j <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> i <span style="color:#666">==</span> grid.size() <span style="color:#666">||</span> j <span style="color:#666">==</span> grid[<span style="color:#666">0</span>].size() <span style="color:#666">||</span> grid[i][j] <span style="color:#666">!=</span> <span style="color:#666">1</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks for out-of-bounds conditions or if the current cell is not land (value is not 1). If any of these conditions are true, the function exits. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Exit DFS</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Exits the DFS function if the cell is invalid or already visited. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Mark Visited Cell</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    grid[i][j] <span style="color:#666">=</span> <span style="color:#666">2</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Marks the current cell as visited by setting its value to 2. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>17 : DFS Recursive Calls</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dfs(grid, i <span style="color:#666">+</span> <span style="color:#666">1</span>, j);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls `dfs` on the cell below the current cell. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>18 : DFS Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dfs(grid, i, j <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls `dfs` on the cell to the right of the current cell. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>19 : DFS Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dfs(grid, i <span style="color:#666">-</span> <span style="color:#666">1</span>, j);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls `dfs` on the cell above the current cell. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>20 : DFS Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dfs(grid, i, j <span style="color:#666">-</span> <span style="color:#666">1</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls `dfs` on the cell to the left of the current cell. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(m * n)</div>
                        <div class=""> <b>Average Case:</b> O(m * n)</div>
                        <div class=""> <b>Worst Case:</b> O(m * n)</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(m * n) because we are iterating over every cell in the grid, performing a DFS traversal for each boundary land cell.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(m * n)</div>
                        <div class=""> <b>Worst Case:</b> O(m * n)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(m * n) due to the recursion stack used by DFS.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/heaters/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Sep 20, 2024 - 7 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-475-heaters/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-477-total-hamming-distance/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-477-total-hamming-distance/">Leetcode 477: Total Hamming Distance</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1156s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/477.webp" 
           alt="A sequence of binary strings where the total Hamming distance is calculated, with each distance step gently highlighted" 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 477: Total Hamming Distance Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given a set of video clips from a sporting event that lasts a specified duration in seconds. The clips may overlap and have varying lengths. The goal is to determine the minimum number of clips required to cover the entire event. If it&rsquo;s impossible to cover the entire event, return -1. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of an array of clips, where each clip is represented by a pair of integers [start, end] indicating the start and end times of the clip. Additionally, a single integer, time, specifies the duration of the event to be covered.</div>
                        <div class=""> <b>Example:</b> clips = [[0, 3], [4, 7], [2, 5], [6, 8], [5, 9]], time = 9</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= clips.length &lt;= 100</div>
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= starti &lt;= endi &lt;= 100</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= time &lt;= 100</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be a single integer representing the minimum number of clips needed to cover the entire event. If it&#39;s impossible to cover the event, return -1.</div>
                        <div class=""> <b>Example:</b> Output: 3</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the clips cannot cover the entire event, return -1.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The task is to determine the smallest number of clips that can be used to cover the entire duration of the sporting event. This is a greedy problem where we need to select the clips that maximize the coverage of the event, ensuring we cover the entire time range from 0 to time.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Sort the clips based on their start times.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Use a greedy approach to select clips, always choosing the one that extends the coverage the most without skipping any part of the event.</div>
                            
                                <div style="margin-left: 20px;"> • 3. If at any point the selected clips cannot extend the coverage, return -1.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Otherwise, return the number of clips selected.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Ensure the solution works for the given input size constraints.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The solution should handle up to 100 clips, with start and end times between 0 and 100 seconds.</div>
                            
                                <div style="margin-left: 20px;"> • The event duration is between 1 and 100 seconds.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The clips array will be non-empty and the event duration will be positive.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: clips = [[0, 3], [4, 7], [2, 5], [6, 8], [5, 9]], time = 9</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this case, we can take the clips [0, 3], [2, 5], and [5, 9], which cover the entire event from 0 to 9. So, the output is 3.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: clips = [[0, 1], [1, 2]], time = 5</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this case, it is impossible to cover the event duration from 0 to 5 using just the clips [0, 1] and [1, 2], so the output is -1.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The approach uses a greedy strategy where we attempt to cover the event by iteratively selecting the clip that extends the current coverage the furthest.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Sorting the clips by start time allows us to systematically check which clips to select for covering the event.</div>
                            
                            
                                <div style="margin-left: 20px;"> • By always picking the clip that extends the coverage the most, we can minimize the number of clips needed.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Sort the clips by their start times.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Initialize variables to track the current end time of the covered event and the number of clips selected.</div>
                            
                                <div style="margin-left: 20px;"> • 3. For each clip, check if it extends the current coverage. If it does, update the coverage and increment the count of clips.</div>
                            
                                <div style="margin-left: 20px;"> • 4. If at any point we cannot extend the coverage, return -1.</div>
                            
                                <div style="margin-left: 20px;"> • 5. Return the number of clips selected once the entire event is covered.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If there are no clips, return -1 unless the event duration is 0.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution must efficiently handle inputs with up to 100 clips.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If a clip exactly matches the time, it should be counted as one clip.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure that the solution handles cases where no set of clips can cover the entire event.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Sorting</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Looping</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Looping</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Max Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Condition Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Return Statement</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">videoStitching</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> clips, <span style="color:#0b0;font-weight:bold">int</span> time) {
</span></span><span style="display:flex;"><span>    sort(clips.begin(), clips.end());
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>, st <span style="color:#666">=</span> <span style="color:#666">0</span>, end <span style="color:#666">=</span> <span style="color:#666">0</span>; st <span style="color:#666">&lt;</span> time; st<span style="color:#666">=</span>end, <span style="color:#666">++</span>res){
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(; i <span style="color:#666">&lt;</span> clips.size() <span style="color:#666">&amp;&amp;</span> clips[i][<span style="color:#666">0</span>] <span style="color:#666">&lt;=</span> st; <span style="color:#666">++</span>i)
</span></span><span style="display:flex;"><span>            end <span style="color:#666">=</span> max(end, clips[i][<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(st <span style="color:#666">==</span> end) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">videoStitching</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> clips, <span style="color:#0b0;font-weight:bold">int</span> time) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Define the function `videoStitching`, which takes a list of clips and a target time interval to cover. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Sorting</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    sort(clips.begin(), clips.end());
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Sort the clips by their start times to make it easier to find overlapping intervals and select the optimal clips. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize the result variable `res` to 0, which will store the number of clips used to cover the time interval. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Looping</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>, st <span style="color:#666">=</span> <span style="color:#666">0</span>, end <span style="color:#666">=</span> <span style="color:#666">0</span>; st <span style="color:#666">&lt;</span> time; st<span style="color:#666">=</span>end, <span style="color:#666">++</span>res){
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Start a loop where `i` is the index for iterating through the clips, `st` is the start of the current covered interval, and `end` is the end of the last selected clip. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Looping</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(; i <span style="color:#666">&lt;</span> clips.size() <span style="color:#666">&amp;&amp;</span> clips[i][<span style="color:#666">0</span>] <span style="color:#666">&lt;=</span> st; <span style="color:#666">++</span>i)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Loop through the clips and find the clip whose start time is less than or equal to the current start time (`st`). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Max Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            end <span style="color:#666">=</span> max(end, clips[i][<span style="color:#666">1</span>]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Update the `end` time by taking the maximum of the current `end` and the end time of the current clip, which extends the covered interval. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Condition Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(st <span style="color:#666">==</span> end) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current start time `st` is the same as the end time `end`, it means no clip can extend the coverage. Return -1 to indicate it&#39;s impossible to cover the entire time interval. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Return Statement</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Return the number of clips used to cover the time interval. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n log n)</div>
                        <div class=""> <b>Average Case:</b> O(n log n)</div>
                        <div class=""> <b>Worst Case:</b> O(n log n)</div> 
                        <div class=""> <b>Description:</b> The time complexity is dominated by the sorting step, which takes O(n log n), where n is the number of clips.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n) due to the space required for sorting the clips.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/total-hamming-distance/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Sep 20, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-477-total-hamming-distance/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


            </div>
        </section>
<div class="bottompagination">
  <div class="pointerup"><i class="fa fa-caret-up"></i></div>
  <div class="navigation" role="navigation">
    
      <div class="pagination">
        
          <a class="ml-1 mr-1" href="/tags/array/page/15/">&laquo; Prev</a>
          <a class="ml-1 mr-1" href="/tags/array/page/15/">15</a>
        

        <span class="ml-1 mr-1">16</span>

        
          <a class="ml-1 mr-1" href="/tags/array/page/17/">17</a>
          <a class="ml-1 mr-1" href="/tags/array/page/17/">Next &raquo;</a>
        
      </div>
    
  </div>
</div></div>


            </div>
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
			<div class="d-md-flex align-items-center justify-content-center h-100">
				<h2 class="d-md-block d-none align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
			</div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
			
			<a class="mt-1 mb-1" href="/tags/array">array</a>
			
			<a class="mt-1 mb-1" href="/tags/backtracking">backtracking</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-indexed-tree">binary indexed tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search">binary search</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search-tree">binary search tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-tree">binary tree</a>
			
			<a class="mt-1 mb-1" href="/tags/bit-manipulation">bit manipulation</a>
			
			<a class="mt-1 mb-1" href="/tags/bitmask">bitmask</a>
			
			<a class="mt-1 mb-1" href="/tags/brainteaser">brainteaser</a>
			
			<a class="mt-1 mb-1" href="/tags/breadth-first-search">breadth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/bucket-sort">bucket sort</a>
			
			<a class="mt-1 mb-1" href="/tags/combinatorics">combinatorics</a>
			
			<a class="mt-1 mb-1" href="/tags/concurrency">concurrency</a>
			
			<a class="mt-1 mb-1" href="/tags/counting">counting</a>
			
			<a class="mt-1 mb-1" href="/tags/counting-sort">counting sort</a>
			
			<a class="mt-1 mb-1" href="/tags/data-stream">data stream</a>
			
			<a class="mt-1 mb-1" href="/tags/depth-first-search">depth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/design">design</a>
			
			<a class="mt-1 mb-1" href="/tags/divide-and-conquer">divide and conquer</a>
			
			<a class="mt-1 mb-1" href="/tags/doubly-linked-list">doubly-linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/dynamic-programming">dynamic programming</a>
			
			<a class="mt-1 mb-1" href="/tags/enumeration">enumeration</a>
			
			<a class="mt-1 mb-1" href="/tags/game-theory">game theory</a>
			
			<a class="mt-1 mb-1" href="/tags/geometry">geometry</a>
			
			<a class="mt-1 mb-1" href="/tags/graph">graph</a>
			
			<a class="mt-1 mb-1" href="/tags/greedy">greedy</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-function">hash function</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-table">hash table</a>
			
			<a class="mt-1 mb-1" href="/tags/heap-priority-queue">heap (priority queue)</a>
			
			<a class="mt-1 mb-1" href="/tags/interactive">interactive</a>
			
			<a class="mt-1 mb-1" href="/tags/iterator">iterator</a>
			
			<a class="mt-1 mb-1" href="/tags/linked-list">linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/math">math</a>
			
			<a class="mt-1 mb-1" href="/tags/matrix">matrix</a>
			
			<a class="mt-1 mb-1" href="/tags/memoization">memoization</a>
			
			<a class="mt-1 mb-1" href="/tags/minimum-spanning-tree">minimum spanning tree</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-queue">monotonic queue</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-stack">monotonic stack</a>
			
			<a class="mt-1 mb-1" href="/tags/number-theory">number theory</a>
			
			<a class="mt-1 mb-1" href="/tags/ordered-set">ordered set</a>
			
			<a class="mt-1 mb-1" href="/tags/prefix-sum">prefix sum</a>
			
			<a class="mt-1 mb-1" href="/tags/probability-and-statistics">probability and statistics</a>
			
			<a class="mt-1 mb-1" href="/tags/queue">queue</a>
			
			<a class="mt-1 mb-1" href="/tags/quickselect">quickselect</a>
			
			<a class="mt-1 mb-1" href="/tags/radix-sort">radix sort</a>
			
			<a class="mt-1 mb-1" href="/tags/randomized">randomized</a>
			
			<a class="mt-1 mb-1" href="/tags/recursion">recursion</a>
			
			<a class="mt-1 mb-1" href="/tags/reservoir-sampling">reservoir sampling</a>
			
			<a class="mt-1 mb-1" href="/tags/rolling-hash">rolling hash</a>
			
			<a class="mt-1 mb-1" href="/tags/segment-tree">segment tree</a>
			
			<a class="mt-1 mb-1" href="/tags/shortest-path">shortest path</a>
			
			<a class="mt-1 mb-1" href="/tags/simulation">simulation</a>
			
			<a class="mt-1 mb-1" href="/tags/sliding-window">sliding window</a>
			
			<a class="mt-1 mb-1" href="/tags/sorting">sorting</a>
			
			<a class="mt-1 mb-1" href="/tags/stack">stack</a>
			
			<a class="mt-1 mb-1" href="/tags/string">string</a>
			
			<a class="mt-1 mb-1" href="/tags/string-matching">string matching</a>
			
			<a class="mt-1 mb-1" href="/tags/topological-sort">topological sort</a>
			
			<a class="mt-1 mb-1" href="/tags/tree">tree</a>
			
			<a class="mt-1 mb-1" href="/tags/trie">trie</a>
			
			<a class="mt-1 mb-1" href="/tags/two-pointers">two pointers</a>
			
			<a class="mt-1 mb-1" href="/tags/union-find">union find</a>
			
		</div>
	</div>
</div>

<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

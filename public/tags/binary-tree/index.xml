<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Binary Tree on grid47</title>
    <link>http://localhost:1313/tags/binary-tree/</link>
    <description>Recent content in Binary Tree on grid47</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>www.grid47.com - All rights reserved</copyright>
    <lastBuildDate>Wed, 06 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/binary-tree/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 100: Same Tree</title>
      <link>http://localhost:1313/leetcode/solution-100-same-tree/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-100-same-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3051s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/100.webp&#34; &#xA;           alt=&#34;Two trees glowing in harmony, showing perfect symmetry and balance.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 100: Same Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given two binary trees. Your task is to check if these two trees are the same. Two binary trees are considered the same if they are structurally identical and the nodes have the same value at each corresponding position.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 94: Binary Tree Inorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-94-binary-tree-inorder-traversal/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-94-binary-tree-inorder-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4441s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/94.webp&#34; &#xA;           alt=&#34;A glowing tree with nodes softly illuminating as the inorder traversal progresses.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 94: Binary Tree Inorder Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the values of its nodes as they appear in an inorder traversal. Inorder traversal visits nodes in the left subtree, the root, and then the right subtree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 95: Unique Binary Search Trees II</title>
      <link>http://localhost:1313/leetcode/solution-95-unique-binary-search-trees-ii/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-95-unique-binary-search-trees-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4448s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/95.webp&#34; &#xA;           alt=&#34;A sequence of elegant trees gently forming in various, unique shapes.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 95: Unique Binary Search Trees II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given an integer n, return all structurally unique binary search trees (BSTs) that can be constructed using the integers from 1 to n. Each tree should be a unique arrangement of nodes where each node contains a unique value from the set {1, 2, &amp;hellip;, n}.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 98: Validate Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-98-validate-binary-search-tree/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-98-validate-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4469s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/98.webp&#34; &#xA;           alt=&#34;A glowing tree with balanced nodes, radiating a sense of order and validation.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 98: Validate Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to determine whether the tree is a valid binary search tree (BST). A binary search tree is valid if for every node in the tree, the value of all nodes in its left subtree are less than its own value, and the value of all nodes in its right subtree are greater than its own value.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 99: Recover Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-99-recover-binary-search-tree/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-99-recover-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4473s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/99.webp&#34; &#xA;           alt=&#34;A tree softly rearranging its nodes, finding its balance and order.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 99: Recover Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary search tree (BST), but two nodes in the tree were swapped by mistake. Your task is to recover the tree by swapping the two nodes back, without changing the structure of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 102: Binary Tree Level Order Traversal</title>
      <link>http://localhost:1313/leetcode/solution-102-binary-tree-level-order-traversal/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-102-binary-tree-level-order-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3064s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/102.webp&#34; &#xA;           alt=&#34;A tree with soft, glowing rings representing each level, expanding outward.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 102: Binary Tree Level Order Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, your task is to return the level order traversal of its nodes&amp;rsquo; values. This means you should traverse the tree level by level, from left to right at each level.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 103: Binary Tree Zigzag Level Order Traversal</title>
      <link>http://localhost:1313/leetcode/solution-103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3071s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/103.webp&#34; &#xA;           alt=&#34;A glowing zigzag path moving through tree levels, creating a calming, fluid motion.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 103: Binary Tree Zigzag Level Order Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, your task is to return the zigzag level order traversal of its nodes&amp;rsquo; values. This means you need to traverse the tree level by level, alternating between left to right and right to left on each level.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 104: Maximum Depth of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-104-maximum-depth-of-binary-tree/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-104-maximum-depth-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3078s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/104.webp&#34; &#xA;           alt=&#34;A deep, glowing tree with rays of light expanding downwards to symbolize depth.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 104: Maximum Depth of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to return the maximum depth of the tree. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 105: Construct Binary Tree from Preorder and Inorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-105-construct-binary-tree-from-preorder-and-inorder-traversal/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-105-construct-binary-tree-from-preorder-and-inorder-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3085s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/105.webp&#34; &#xA;           alt=&#34;A tree gently forming from two intertwining paths of glowing nodes, one representing preorder, the other inorder.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 105: Construct Binary Tree from Preorder and Inorder Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given two integer arrays, &lt;code&gt;preorder&lt;/code&gt; and &lt;code&gt;inorder&lt;/code&gt;, representing the preorder and inorder traversals of a binary tree, your task is to reconstruct and return the binary tree. The values in the arrays are unique, and the preorder traversal provides the sequence in which nodes are visited before their children, while the inorder traversal provides the order in which nodes are visited between their children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 107: Binary Tree Level Order Traversal II</title>
      <link>http://localhost:1313/leetcode/solution-107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-107-binary-tree-level-order-traversal-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3091s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/107.webp&#34; &#xA;           alt=&#34;A tree with soft concentric circles, each level glowing and expanding outward from the center.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 107: Binary Tree Level Order Traversal II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. This means that for each level, starting from the leaf level and moving towards the root, you should collect the node values from left to right.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 109: Convert Sorted List to Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-109-convert-sorted-list-to-binary-search-tree/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-109-convert-sorted-list-to-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3099s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/109.webp&#34; &#xA;           alt=&#34;A flowing list of sorted numbers seamlessly transforming into a calm, glowing binary search tree.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 109: Convert Sorted List to Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the head of a singly linked list where elements are sorted in ascending order, convert it into a height-balanced binary search tree. A height-balanced binary search tree is one where the depth of the two subtrees of every node never differs by more than 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 110: Balanced Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-110-balanced-binary-tree/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-110-balanced-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3103s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/110.webp&#34; &#xA;           alt=&#34;A tree where branches gently balance on either side, with glowing nodes symbolizing equilibrium.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 110: Balanced Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a binary tree, determine if it is height-balanced. A binary tree is considered height-balanced if for every node, the height of the left and right subtrees differs by no more than one.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 111: Minimum Depth of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-111-minimum-depth-of-binary-tree/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-111-minimum-depth-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3106s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/111.webp&#34; &#xA;           alt=&#34;A deep tree with soft, glowing light reaching the minimal depth, highlighting the shortest path.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 111: Minimum Depth of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a binary tree, find its minimum depth. The minimum depth is defined as the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf node is a node that does not have any children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 113: Path Sum II</title>
      <link>http://localhost:1313/leetcode/solution-113-path-sum-ii/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-113-path-sum-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3116s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/113.webp&#34; &#xA;           alt=&#34;A radiant path of numbers, showing multiple possible paths with gentle branches leading to different sums.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 113: Path Sum II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree and an integer targetSum, return all paths from the root to the leaf nodes where the sum of the node values along the path equals the targetSum. A root-to-leaf path is defined as any path that starts from the root and ends at a leaf node. A leaf node is a node that does not have any children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 114: Flatten Binary Tree to Linked List</title>
      <link>http://localhost:1313/leetcode/solution-114-flatten-binary-tree-to-linked-list/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-114-flatten-binary-tree-to-linked-list/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3122s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/114.webp&#34; &#xA;           alt=&#34;A soft tree smoothly transforming into a linear, glowing list of nodes, symbolizing a flattened structure.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 114: Flatten Binary Tree to Linked List Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, flatten the tree into a &amp;rsquo;linked list&amp;rsquo; where each node&amp;rsquo;s right pointer points to the next node in pre-order traversal, and the left pointer of all nodes is null. The &amp;rsquo;linked list&amp;rsquo; should maintain the same order as a pre-order traversal of the binary tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 116: Populating Next Right Pointers in Each Node</title>
      <link>http://localhost:1313/leetcode/solution-116-populating-next-right-pointers-in-each-node/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-116-populating-next-right-pointers-in-each-node/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3130s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/116.webp&#34; &#xA;           alt=&#34;A glowing grid of nodes, with gentle arrows connecting them, showing the next right pointer linkages.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 116: Populating Next Right Pointers in Each Node Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a perfect binary tree where every parent node has two children and all leaves are at the same level. Your task is to populate the &amp;rsquo;next&amp;rsquo; pointer of each node to point to its next right node. If no such node exists, set the &amp;rsquo;next&amp;rsquo; pointer to NULL. Initially, all &amp;rsquo;next&amp;rsquo; pointers are set to NULL.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 144: Binary Tree Preorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-144-binary-tree-preorder-traversal/</link>
      <pubDate>Wed, 23 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-144-binary-tree-preorder-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3257s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/144.webp&#34; &#xA;           alt=&#34;A tree with nodes glowing sequentially from root to leaf, following a smooth, glowing path.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 144: Binary Tree Preorder Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. The task is to return the preorder traversal of the tree. Preorder traversal means visiting the root node first, followed by the left subtree, and then the right subtree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 199: Binary Tree Right Side View</title>
      <link>http://localhost:1313/leetcode/solution-199-binary-tree-right-side-view/</link>
      <pubDate>Fri, 18 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-199-binary-tree-right-side-view/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3533s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/199.webp&#34; &#xA;           alt=&#34;A glowing tree viewed from the right side, with the rightmost nodes gently illuminating.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 199: Binary Tree Right Side View Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Imagine yourself standing on the right side of the tree, and return the values of the nodes you can see when viewed from the right, ordered from top to bottom.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 226: Invert Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-226-invert-binary-tree/</link>
      <pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-226-invert-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3691s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/226.webp&#34; &#xA;           alt=&#34;A tree slowly flipping upside down, with nodes glowing as they invert.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 226: Invert Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, invert the tree by swapping the left and right subtrees of every node, and return its root.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 230: Kth Smallest Element in a BST</title>
      <link>http://localhost:1313/leetcode/solution-230-kth-smallest-element-in-a-bst/</link>
      <pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-230-kth-smallest-element-in-a-bst/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3715s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/230.webp&#34; &#xA;           alt=&#34;A binary search tree with nodes softly glowing, showing the kth smallest element highlighted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 230: Kth Smallest Element in a BST Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary search tree and an integer k, your task is to return the kth smallest value in the tree (1-indexed).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 235: Lowest Common Ancestor of a Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-235-lowest-common-ancestor-of-a-binary-search-tree/</link>
      <pubDate>Mon, 14 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-235-lowest-common-ancestor-of-a-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3743s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/235.webp&#34; &#xA;           alt=&#34;Two paths glowing brightly as they meet at the lowest common ancestor in a binary search tree.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 235: Lowest Common Ancestor of a Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a Binary Search Tree (BST), find the lowest common ancestor (LCA) of two given nodes. The lowest common ancestor is the deepest node that is an ancestor of both nodes. An ancestor of a node is a node itself or any node in its path up to the root.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 236: Lowest Common Ancestor of a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-236-lowest-common-ancestor-of-a-binary-tree/</link>
      <pubDate>Mon, 14 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-236-lowest-common-ancestor-of-a-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3749s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/236.webp&#34; &#xA;           alt=&#34;Similar to the previous idea, with paths gently intersecting to show the common ancestor in a non-search tree.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 236: Lowest Common Ancestor of a Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a binary tree, find the lowest common ancestor (LCA) of two given nodes. The lowest common ancestor is defined as the lowest node that is an ancestor of both nodes p and q. A node can be a descendant of itself.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 437: Path Sum III</title>
      <link>http://localhost:1313/leetcode/solution-437-path-sum-iii/</link>
      <pubDate>Tue, 24 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-437-path-sum-iii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4178s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/437.webp&#34; &#xA;           alt=&#34;A tree with nodes lighting up, showing the path sum from a root node to the leaves, highlighting valid paths.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 437: Path Sum III Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree and an integer targetSum. Your task is to count the total number of paths in the tree where the sum of node values along the path equals targetSum. The path does not need to start or end at the root or a leaf, but it must go downwards (from parent to child nodes).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 449: Serialize and Deserialize BST</title>
      <link>http://localhost:1313/leetcode/solution-449-serialize-and-deserialize-bst/</link>
      <pubDate>Mon, 23 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-449-serialize-and-deserialize-bst/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4183s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/449.webp&#34; &#xA;           alt=&#34;A binary search tree being serialized and deserialized, with each node softly glowing during the transformation.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 449: Serialize and Deserialize BST Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Design an algorithm to serialize and deserialize a binary search tree (BST). Serialization is converting the tree to a string format, while deserialization reconstructs the tree from this string. The goal is to ensure that the BST can be serialized to a compact string and can be accurately deserialized back into the original tree structure.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 501: Find Mode in Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-501-find-mode-in-binary-search-tree/</link>
      <pubDate>Tue, 17 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-501-find-mode-in-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4208s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/501.webp&#34; &#xA;           alt=&#34;A glowing tree with nodes lighting up to highlight the mode, with the mode’s value softly radiating.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 501: Find Mode in Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary search tree (BST) with possible duplicates, return the mode(s) (i.e., the most frequently occurring element) in the tree. If there are multiple modes, return them in any order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 508: Most Frequent Subtree Sum</title>
      <link>http://localhost:1313/leetcode/solution-508-most-frequent-subtree-sum/</link>
      <pubDate>Tue, 17 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-508-most-frequent-subtree-sum/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4209s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/508.webp&#34; &#xA;           alt=&#34;A tree with sums at each subtree, and the most frequent subtree sum glowing brightly as it is discovered.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 508: Most Frequent Subtree Sum Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the most frequent subtree sum. A subtree sum is the sum of all the node values in the subtree rooted at any node, including the node itself. If there is a tie, return all the subtree sums with the highest frequency.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 513: Find Bottom Left Tree Value</title>
      <link>http://localhost:1313/leetcode/solution-513-find-bottom-left-tree-value/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-513-find-bottom-left-tree-value/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4211s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/513.webp&#34; &#xA;           alt=&#34;A tree with a glowing bottom-left node, showing the value of the deepest leftmost node in the binary tree.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 513: Find Bottom Left Tree Value Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the leftmost value in the last row of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 515: Find Largest Value in Each Tree Row</title>
      <link>http://localhost:1313/leetcode/solution-515-find-largest-value-in-each-tree-row/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-515-find-largest-value-in-each-tree-row/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4212s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/515.webp&#34; &#xA;           alt=&#34;A tree with rows of values, each row highlighted with the largest value softly glowing.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 515: Find Largest Value in Each Tree Row Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 530: Minimum Absolute Difference in BST</title>
      <link>http://localhost:1313/leetcode/solution-530-minimum-absolute-difference-in-bst/</link>
      <pubDate>Sun, 15 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-530-minimum-absolute-difference-in-bst/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4224s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/530.webp&#34; &#xA;           alt=&#34;A binary search tree where nodes light up showing the minimum absolute difference between node values.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 530: Minimum Absolute Difference in BST Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 538: Convert BST to Greater Tree</title>
      <link>http://localhost:1313/leetcode/solution-538-convert-bst-to-greater-tree/</link>
      <pubDate>Sat, 14 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-538-convert-bst-to-greater-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4228s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/538.webp&#34; &#xA;           alt=&#34;A binary search tree where each node is gradually updated to a greater tree, with each transformation softly highlighted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 538: Convert BST to Greater Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a Binary Search Tree (BST), convert it into a Greater Tree where every node’s value is replaced by the sum of all greater node values in the BST plus its original value.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 543: Diameter of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-543-diameter-of-binary-tree/</link>
      <pubDate>Fri, 13 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-543-diameter-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4233s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/543.webp&#34; &#xA;           alt=&#34;A binary tree where the longest path between two nodes is highlighted, glowing softly to show the tree&amp;#39;s diameter.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 543: Diameter of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes, which may or may not pass through the root.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 572: Subtree of Another Tree</title>
      <link>http://localhost:1313/leetcode/solution-572-subtree-of-another-tree/</link>
      <pubDate>Tue, 10 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-572-subtree-of-another-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4244s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/572.webp&#34; &#xA;           alt=&#34;A tree being checked for its subtree, with the subtree softly glowing as it is found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 572: Subtree of Another Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the roots of two binary trees, root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise. A subtree of a binary tree consists of a node in the tree and all of this node&amp;rsquo;s descendants.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 606: Construct String from Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-606-construct-string-from-binary-tree/</link>
      <pubDate>Sat, 07 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-606-construct-string-from-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4254s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/606.webp&#34; &#xA;           alt=&#34;A binary tree where a string is being constructed by traversing the tree, with each character softly glowing.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 606: Construct String from Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root node of a binary tree, generate a string representation of the tree following specific formatting rules based on a preorder traversal.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 617: Merge Two Binary Trees</title>
      <link>http://localhost:1313/leetcode/solution-617-merge-two-binary-trees/</link>
      <pubDate>Fri, 06 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-617-merge-two-binary-trees/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4257s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/617.webp&#34; &#xA;           alt=&#34;Two binary trees merging together, with each node softly glowing as they combine.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 617: Merge Two Binary Trees Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given two binary trees, merge them into a new binary tree where overlapping nodes are summed, and non-overlapping nodes are retained as they are.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 623: Add One Row to Tree</title>
      <link>http://localhost:1313/leetcode/solution-623-add-one-row-to-tree/</link>
      <pubDate>Thu, 05 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-623-add-one-row-to-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4259s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/623.webp&#34; &#xA;           alt=&#34;A binary tree where a new row is being added, with the new row glowing as it is inserted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 623: Add One Row to Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree, and two integers val and depth. You need to add a row of nodes with value val at the given depth depth. The root node is considered to be at depth 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 652: Find Duplicate Subtrees</title>
      <link>http://localhost:1313/leetcode/solution-652-find-duplicate-subtrees/</link>
      <pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-652-find-duplicate-subtrees/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4274s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/652.webp&#34; &#xA;           alt=&#34;A binary tree where duplicate subtrees are identified, and each duplicate subtree softly glows as it’s found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 652: Find Duplicate Subtrees Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return all duplicate subtrees. For each duplicate subtree, return the root node of any one of them. Two trees are considered duplicates if they have the same structure and node values.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 654: Maximum Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-654-maximum-binary-tree/</link>
      <pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-654-maximum-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4275s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/654.webp&#34; &#xA;           alt=&#34;A binary tree where the maximum value node is highlighted, glowing softly as it’s determined.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 654: Maximum Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given an integer array nums with no duplicates, construct a maximum binary tree by recursively selecting the largest number as the root, and building the left and right subtrees from the elements before and after the largest number.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 655: Print Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-655-print-binary-tree/</link>
      <pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-655-print-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4277s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/655.webp&#34; &#xA;           alt=&#34;A binary tree where nodes are printed visually, with the structure softly glowing as it is printed.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 655: Print Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, construct a matrix representation of the tree using specific formatting rules to place each node in the appropriate position in the matrix.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 662: Maximum Width of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-662-maximum-width-of-binary-tree/</link>
      <pubDate>Sun, 01 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-662-maximum-width-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4291s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/662.webp&#34; &#xA;           alt=&#34;A binary tree where the maximum width is highlighted, with the width softly glowing as it’s measured.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 662: Maximum Width of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Determine the maximum width of the tree, which is defined as the maximum width among all levels. The width of a level is the distance between the leftmost and rightmost non-null nodes, including null nodes in between that would be present in a complete binary tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 669: Trim a Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-669-trim-a-binary-search-tree/</link>
      <pubDate>Sun, 01 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-669-trim-a-binary-search-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4282s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/669.webp&#34; &#xA;           alt=&#34;A binary search tree where the tree is trimmed to fit a given range, with each trimmed node softly glowing.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 669: Trim a Binary Search Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary search tree (BST) and two integer values &lt;code&gt;low&lt;/code&gt; and &lt;code&gt;high&lt;/code&gt;. Trim the tree such that all its elements lie within the inclusive range &lt;code&gt;[low, high]&lt;/code&gt;. The tree&amp;rsquo;s relative structure should remain unchanged, and the root may change depending on the given bounds.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 687: Longest Univalue Path</title>
      <link>http://localhost:1313/leetcode/solution-687-longest-univalue-path/</link>
      <pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-687-longest-univalue-path/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4292s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/687.webp&#34; &#xA;           alt=&#34;A tree where the longest univalue path is traced and softly glowing as it’s found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 687: Longest Univalue Path Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. The task is to find the length of the longest path in the tree where all the nodes in the path have the same value. The path can be anywhere in the tree, not necessarily passing through the root. The path length is determined by the number of edges between the nodes.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 703: Kth Largest Element in a Stream</title>
      <link>http://localhost:1313/leetcode/solution-703-kth-largest-element-in-a-stream/</link>
      <pubDate>Wed, 28 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-703-kth-largest-element-in-a-stream/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4300s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/703.webp&#34; &#xA;           alt=&#34;A stream of numbers where the kth largest element is identified, glowing brightly as it’s found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 703: Kth Largest Element in a Stream Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are tasked with implementing a class that helps track the kth highest score in a dynamic list of test scores. Each time a new score is submitted, you need to return the kth highest score in the list.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 814: Binary Tree Pruning</title>
      <link>http://localhost:1313/leetcode/solution-814-binary-tree-pruning/</link>
      <pubDate>Sat, 17 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-814-binary-tree-pruning/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4361s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/814.webp&#34; &#xA;           alt=&#34;A binary tree where branches are pruned, with the pruned branches glowing softly as they are removed.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 814: Binary Tree Pruning Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to remove all subtrees in the tree that do not contain at least one node with the value 1. A subtree is defined as the node and all its descendants. Return the modified tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 863: All Nodes Distance K in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-863-all-nodes-distance-k-in-binary-tree/</link>
      <pubDate>Mon, 12 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-863-all-nodes-distance-k-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a binary tree, a target node within the tree, and a non-negative integer k, determine all the nodes that are exactly k edges away from the target node. Return these node values as a list in any order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 865: Smallest Subtree with all the Deepest Nodes</title>
      <link>http://localhost:1313/leetcode/solution-865-smallest-subtree-with-all-the-deepest-nodes/</link>
      <pubDate>Mon, 12 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-865-smallest-subtree-with-all-the-deepest-nodes/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the smallest subtree that contains all the nodes with the maximum depth in the tree. A node is considered the deepest if it has the greatest distance to the root among all nodes. The subtree of a node consists of the node itself and all its descendants.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 872: Leaf-Similar Trees</title>
      <link>http://localhost:1313/leetcode/solution-872-leaf-similar-trees/</link>
      <pubDate>Sun, 11 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-872-leaf-similar-trees/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given two binary trees, determine if their leaf value sequences are identical. A binary tree&amp;rsquo;s leaf value sequence is the sequence of values of its leaves, from left to right, following the in-order traversal. Two trees are considered leaf-similar if the leaf values in both trees appear in the same order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 889: Construct Binary Tree from Preorder and Postorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-889-construct-binary-tree-from-preorder-and-postorder-traversal/</link>
      <pubDate>Sat, 10 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-889-construct-binary-tree-from-preorder-and-postorder-traversal/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given two integer arrays representing the preorder and postorder traversals of a binary tree. Your task is to reconstruct the binary tree from these two traversals and return the root node of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 894: All Possible Full Binary Trees</title>
      <link>http://localhost:1313/leetcode/solution-894-all-possible-full-binary-trees/</link>
      <pubDate>Fri, 09 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-894-all-possible-full-binary-trees/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given an integer n, return all possible full binary trees with exactly n nodes. Each node of the tree must have the value 0. A full binary tree is defined as a binary tree where each node has either 0 or 2 children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 919: Complete Binary Tree Inserter</title>
      <link>http://localhost:1313/leetcode/solution-919-complete-binary-tree-inserter/</link>
      <pubDate>Wed, 07 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-919-complete-binary-tree-inserter/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a complete binary tree. A complete binary tree is one where every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Your task is to design a data structure that supports inserting new nodes while maintaining the completeness of the binary tree. Implement the CBTInserter class that supports two operations: inserting a new node and returning the root of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 938: Range Sum of BST</title>
      <link>http://localhost:1313/leetcode/solution-938-range-sum-of-bst/</link>
      <pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-938-range-sum-of-bst/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary search tree and two integers, low and high, return the sum of values of all nodes whose values are within the inclusive range [low, high]. You can assume that all nodes in the tree have distinct values.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 951: Flip Equivalent Binary Trees</title>
      <link>http://localhost:1313/leetcode/solution-951-flip-equivalent-binary-trees/</link>
      <pubDate>Sat, 03 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-951-flip-equivalent-binary-trees/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the roots of two binary trees. A flip operation consists of choosing any node and swapping its left and right child subtrees. A tree X is flip equivalent to tree Y if and only if we can make tree X equal to tree Y by performing some flip operations on X. Your task is to determine if the two trees are flip equivalent.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 958: Check Completeness of a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-958-check-completeness-of-a-binary-tree/</link>
      <pubDate>Sat, 03 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-958-check-completeness-of-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Determine if the tree is a complete binary tree. A complete binary tree is defined as follows: every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 971: Flip Binary Tree To Match Preorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-971-flip-binary-tree-to-match-preorder-traversal/</link>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-971-flip-binary-tree-to-match-preorder-traversal/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree with n nodes, where each node has a unique value from 1 to n. You are also given a sequence of n integers, voyage, representing the desired pre-order traversal of the tree. A node in the tree can be flipped by swapping its left and right children. Your task is to find the smallest set of nodes to flip such that the pre-order traversal matches voyage. If it is impossible to achieve this traversal, return [-1].&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 979: Distribute Coins in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-979-distribute-coins-in-binary-tree/</link>
      <pubDate>Thu, 01 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-979-distribute-coins-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree with &lt;code&gt;n&lt;/code&gt; nodes, where each node contains &lt;code&gt;node.val&lt;/code&gt; coins. There are exactly &lt;code&gt;n&lt;/code&gt; coins in total across the tree. In one move, you can transfer a coin between two adjacent nodes (parent to child or child to parent). Return the minimum number of moves required to ensure that every node has exactly one coin.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 988: Smallest String Starting From Leaf</title>
      <link>http://localhost:1313/leetcode/solution-988-smallest-string-starting-from-leaf/</link>
      <pubDate>Wed, 31 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-988-smallest-string-starting-from-leaf/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree, where each node contains a value between 0 and 25, corresponding to letters from &amp;lsquo;a&amp;rsquo; to &amp;lsquo;z&amp;rsquo;. Your task is to find the lexicographically smallest string that can be formed by traversing from a leaf node to the root node, using the values in each node as letters.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 998: Maximum Binary Tree II</title>
      <link>http://localhost:1313/leetcode/solution-998-maximum-binary-tree-ii/</link>
      <pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-998-maximum-binary-tree-ii/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a maximum binary tree and an integer val. The task is to insert val into the tree by constructing a new maximum binary tree with a list that contains val appended to the original list used to construct the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1008: Construct Binary Search Tree from Preorder Traversal</title>
      <link>http://localhost:1313/leetcode/solution-1008-construct-binary-search-tree-from-preorder-traversal/</link>
      <pubDate>Mon, 29 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1008-construct-binary-search-tree-from-preorder-traversal/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an array representing the preorder traversal of a binary search tree (BST). Your task is to construct the BST from this preorder traversal and return the root of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1026: Maximum Difference Between Node and Ancestor</title>
      <link>http://localhost:1313/leetcode/solution-1026-maximum-difference-between-node-and-ancestor/</link>
      <pubDate>Sat, 27 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1026-maximum-difference-between-node-and-ancestor/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to find the maximum absolute difference between the values of two nodes, where one node is an ancestor of the other. Specifically, you need to find the largest value of |a.val - b.val|, where node a is an ancestor of node b.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1038: Binary Search Tree to Greater Sum Tree</title>
      <link>http://localhost:1313/leetcode/solution-1038-binary-search-tree-to-greater-sum-tree/</link>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1038-binary-search-tree-to-greater-sum-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a Binary Search Tree (BST), convert it into a Greater Tree where each node&amp;rsquo;s value is updated to the sum of its original value and all the values greater than it in the BST. The transformation should preserve the BST structure.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1080: Insufficient Nodes in Root to Leaf Paths</title>
      <link>http://localhost:1313/leetcode/solution-1080-insufficient-nodes-in-root-to-leaf-paths/</link>
      <pubDate>Mon, 22 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1080-insufficient-nodes-in-root-to-leaf-paths/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree and an integer limit. Your task is to delete all nodes in the tree that are considered insufficient. A node is insufficient if every root-to-leaf path passing through that node has a sum strictly less than the given limit. A leaf is defined as a node with no children. Return the root of the resulting binary tree after the deletions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1104: Path In Zigzag Labelled Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1104-path-in-zigzag-labelled-binary-tree/</link>
      <pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1104-path-in-zigzag-labelled-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a label representing a node in an infinite binary tree. In this binary tree, each level alternates between left-to-right and right-to-left labeling. Your task is to return the path from the root of the tree to the node with the given label, following the zigzag pattern.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1110: Delete Nodes And Return Forest</title>
      <link>http://localhost:1313/leetcode/solution-1110-delete-nodes-and-return-forest/</link>
      <pubDate>Fri, 19 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1110-delete-nodes-and-return-forest/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, and a list of values to delete, your task is to remove the nodes with the given values. The resulting tree will become a forest, where each tree is a disjoint set of nodes. Return the roots of the trees in the remaining forest.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1123: Lowest Common Ancestor of Deepest Leaves</title>
      <link>http://localhost:1313/leetcode/solution-1123-lowest-common-ancestor-of-deepest-leaves/</link>
      <pubDate>Wed, 17 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1123-lowest-common-ancestor-of-deepest-leaves/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, your task is to return the lowest common ancestor (LCA) of its deepest leaf nodes. The LCA of a set of nodes is the deepest node that is an ancestor of all the nodes in the set. A leaf node is one that does not have any children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1145: Binary Tree Coloring Game</title>
      <link>http://localhost:1313/leetcode/solution-1145-binary-tree-coloring-game/</link>
      <pubDate>Mon, 15 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1145-binary-tree-coloring-game/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Two players play a turn-based game on a binary tree. We are given the root of the tree and the number of nodes, &lt;code&gt;n&lt;/code&gt;, where &lt;code&gt;n&lt;/code&gt; is odd, and each node has a distinct value from 1 to &lt;code&gt;n&lt;/code&gt;. Player 1 selects a value &lt;code&gt;x&lt;/code&gt; and colors the corresponding node red, while Player 2 selects a value &lt;code&gt;y&lt;/code&gt; (where &lt;code&gt;y&lt;/code&gt; ≠ &lt;code&gt;x&lt;/code&gt;) and colors the corresponding node blue. Players take turns coloring neighboring nodes. The game ends when both players pass their turns, and the winner is the player who colored more nodes. Your task is to determine if Player 2 can guarantee a win by choosing a value &lt;code&gt;y&lt;/code&gt;.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1161: Maximum Level Sum of a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1161-maximum-level-sum-of-a-binary-tree/</link>
      <pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1161-maximum-level-sum-of-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, find the smallest level x (1-indexed) such that the sum of the values of nodes at level x is maximal. Each level of the tree corresponds to the distance from the root, with the root being level 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1261: Find Elements in a Contaminated Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1261-find-elements-in-a-contaminated-binary-tree/</link>
      <pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1261-find-elements-in-a-contaminated-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a contaminated binary tree, recover it and implement a class to search for specific values in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1302: Deepest Leaves Sum</title>
      <link>http://localhost:1313/leetcode/solution-1302-deepest-leaves-sum/</link>
      <pubDate>Sat, 29 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1302-deepest-leaves-sum/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the sum of values of its deepest leaves. The deepest leaves are the nodes found at the lowest level of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1305: All Elements in Two Binary Search Trees</title>
      <link>http://localhost:1313/leetcode/solution-1305-all-elements-in-two-binary-search-trees/</link>
      <pubDate>Sat, 29 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1305-all-elements-in-two-binary-search-trees/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given two binary search trees, root1 and root2, return a list containing all the integers from both trees, sorted in ascending order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1315: Sum of Nodes with Even-Valued Grandparent</title>
      <link>http://localhost:1313/leetcode/solution-1315-sum-of-nodes-with-even-valued-grandparent/</link>
      <pubDate>Fri, 28 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1315-sum-of-nodes-with-even-valued-grandparent/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the sum of the values of the nodes that have an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0. A grandparent is defined as the parent of a node’s parent, if it exists.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1325: Delete Leaves With a Given Value</title>
      <link>http://localhost:1313/leetcode/solution-1325-delete-leaves-with-a-given-value/</link>
      <pubDate>Thu, 27 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1325-delete-leaves-with-a-given-value/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree and an integer target. Your task is to remove all leaf nodes that have the value equal to the target. Once you remove a leaf node with the target value, if its parent node becomes a leaf node and has the same value, it should also be removed. This process should continue until no more leaf nodes with the target value are present.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1339: Maximum Product of Splitted Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1339-maximum-product-of-splitted-binary-tree/</link>
      <pubDate>Wed, 26 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1339-maximum-product-of-splitted-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, you need to split the tree into two subtrees by removing one edge. The goal is to maximize the product of the sums of these two subtrees. Return the maximum product of the sums of the two subtrees, modulo 10^9 + 7.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1361: Validate Binary Tree Nodes</title>
      <link>http://localhost:1313/leetcode/solution-1361-validate-binary-tree-nodes/</link>
      <pubDate>Sun, 23 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1361-validate-binary-tree-nodes/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given &lt;code&gt;n&lt;/code&gt; nodes in a binary tree, numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;. Each node &lt;code&gt;i&lt;/code&gt; has two children: &lt;code&gt;leftChild[i]&lt;/code&gt; and &lt;code&gt;rightChild[i]&lt;/code&gt;. If a node has no left child, its value will be &lt;code&gt;-1&lt;/code&gt;. Similarly, if a node has no right child, its value will also be &lt;code&gt;-1&lt;/code&gt;. Your task is to return &lt;code&gt;true&lt;/code&gt; if and only if these nodes form exactly one valid binary tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1367: Linked List in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1367-linked-list-in-binary-tree/</link>
      <pubDate>Sun, 23 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1367-linked-list-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree and a linked list. Determine if there exists a downward path in the binary tree that matches all elements of the linked list starting from its head node. A downward path means starting from any node in the binary tree and following child nodes downwards.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1372: Longest ZigZag Path in a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1372-longest-zigzag-path-in-a-binary-tree/</link>
      <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1372-longest-zigzag-path-in-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, find the length of the longest ZigZag path in the tree. A ZigZag path is one where you move left and right alternately, starting from any node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1379: Find a Corresponding Node of a Binary Tree in a Clone of That Tree</title>
      <link>http://localhost:1313/leetcode/solution-1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/</link>
      <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given two binary trees: an original tree and a cloned tree. The cloned tree is a copy of the original tree, and you are given a reference to a node in the original tree. Your task is to return the reference to the corresponding node in the cloned tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1382: Balance a Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-1382-balance-a-binary-search-tree/</link>
      <pubDate>Fri, 21 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1382-balance-a-binary-search-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary search tree (BST), return a balanced BST containing the same node values. A balanced BST is one where the depth of the left and right subtrees of every node never differ by more than 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1448: Count Good Nodes in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1448-count-good-nodes-in-binary-tree/</link>
      <pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1448-count-good-nodes-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, a node is considered &amp;lsquo;good&amp;rsquo; if in the path from the root to that node, there are no nodes with a value greater than the node itself. Return the total number of good nodes in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1457: Pseudo-Palindromic Paths in a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1457-pseudo-palindromic-paths-in-a-binary-tree/</link>
      <pubDate>Fri, 14 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1457-pseudo-palindromic-paths-in-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree where each node contains a digit from 1 to 9. A path from the root to a leaf node is considered pseudo-palindromic if at least one permutation of the node values in the path can form a palindrome. Your task is to return the number of pseudo-palindromic paths in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1530: Number of Good Leaf Nodes Pairs</title>
      <link>http://localhost:1313/leetcode/solution-1530-number-of-good-leaf-nodes-pairs/</link>
      <pubDate>Fri, 07 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1530-number-of-good-leaf-nodes-pairs/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree and an integer distance. A pair of two different leaf nodes is considered good if the shortest path between them is less than or equal to the given distance. The task is to return the number of such good leaf node pairs in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1609: Even Odd Tree</title>
      <link>http://localhost:1313/leetcode/solution-1609-even-odd-tree/</link>
      <pubDate>Thu, 30 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1609-even-odd-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;A binary tree is called Even-Odd if the values in each level of the tree follow certain rules. For every even-indexed level, all nodes must contain odd integers in strictly increasing order. For every odd-indexed level, all nodes must contain even integers in strictly decreasing order. Given the root of a binary tree, return true if the tree is Even-Odd, otherwise return false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2049: Count Nodes With the Highest Score</title>
      <link>http://localhost:1313/leetcode/solution-2049-count-nodes-with-the-highest-score/</link>
      <pubDate>Tue, 16 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2049-count-nodes-with-the-highest-score/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree with n nodes, where each node is labeled from 0 to n-1. The tree is represented by a 0-indexed array &lt;code&gt;parents&lt;/code&gt;, where &lt;code&gt;parents[i]&lt;/code&gt; indicates the parent of node &lt;code&gt;i&lt;/code&gt;. The root node has no parent, so &lt;code&gt;parents[0] == -1&lt;/code&gt;.&lt;/p&gt;&#xA;&lt;p&gt;Each node has a score, calculated as follows:&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;If the node and the edges connected to it are removed, the tree splits into one or more non-empty subtrees.&lt;/li&gt;&#xA;&lt;li&gt;The score of a node is the product of the sizes of all resulting subtrees.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;Return the number of nodes with the highest score in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2096: Step-By-Step Directions From a Binary Tree Node to Another</title>
      <link>http://localhost:1313/leetcode/solution-2096-step-by-step-directions-from-a-binary-tree-node-to-another/</link>
      <pubDate>Thu, 11 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2096-step-by-step-directions-from-a-binary-tree-node-to-another/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree where each node has a unique value between 1 and n. You are also given a start node and a destination node, each represented by their values. Your task is to find the shortest path from the start node to the destination node in terms of directions. The directions should be represented by a string using the characters &amp;lsquo;L&amp;rsquo;, &amp;lsquo;R&amp;rsquo;, and &amp;lsquo;U&amp;rsquo;, where &amp;lsquo;L&amp;rsquo; means left child, &amp;lsquo;R&amp;rsquo; means right child, and &amp;lsquo;U&amp;rsquo; means moving to the parent node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2196: Create Binary Tree From Descriptions</title>
      <link>http://localhost:1313/leetcode/solution-2196-create-binary-tree-from-descriptions/</link>
      <pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2196-create-binary-tree-from-descriptions/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a list of triplets representing the structure of a binary tree. Each triplet &lt;code&gt;[parent, child, isLeft]&lt;/code&gt; indicates that &lt;code&gt;parent&lt;/code&gt; is the parent of &lt;code&gt;child&lt;/code&gt;, and if &lt;code&gt;isLeft&lt;/code&gt; is 1, &lt;code&gt;child&lt;/code&gt; is the left child of &lt;code&gt;parent&lt;/code&gt;, otherwise, it&amp;rsquo;s the right child. Your task is to reconstruct the binary tree and return the root node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2236: Root Equals Sum of Children</title>
      <link>http://localhost:1313/leetcode/solution-2236-root-equals-sum-of-children/</link>
      <pubDate>Thu, 28 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2236-root-equals-sum-of-children/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree with three nodes: the root, its left child, and its right child. Determine whether the value of the root node is equal to the sum of the values of its two children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2265: Count Nodes Equal to Average of Subtree</title>
      <link>http://localhost:1313/leetcode/solution-2265-count-nodes-equal-to-average-of-subtree/</link>
      <pubDate>Mon, 25 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2265-count-nodes-equal-to-average-of-subtree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to return the number of nodes where the value of the node is equal to the average of the values in its entire subtree (including the node itself). The average of a set of values is the sum of the values divided by the number of values, rounded down to the nearest integer.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2331: Evaluate Boolean Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-2331-evaluate-boolean-binary-tree/</link>
      <pubDate>Mon, 18 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2331-evaluate-boolean-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a full binary tree. The leaf nodes hold boolean values: 0 (False) and 1 (True). The non-leaf nodes hold values 2 (OR) or 3 (AND). Your task is to evaluate the tree according to the logical operations and return the final boolean result of the root node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2385: Amount of Time for Binary Tree to Be Infected</title>
      <link>http://localhost:1313/leetcode/solution-2385-amount-of-time-for-binary-tree-to-be-infected/</link>
      <pubDate>Wed, 13 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2385-amount-of-time-for-binary-tree-to-be-infected/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree where each node has a unique value, and an integer start representing the initial infected node. At minute 0, the infection begins at the node with value start. Each minute, an adjacent uninfected node becomes infected. Your task is to return the total number of minutes it takes for the entire tree to become infected.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2415: Reverse Odd Levels of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-2415-reverse-odd-levels-of-binary-tree/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2415-reverse-odd-levels-of-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a perfect binary tree, reverse the values of the nodes at each odd level of the tree. The level of a node is defined as the number of edges along the path from the root to the node. A perfect binary tree is one where all nodes have two children and all leaves are on the same level.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2471: Minimum Number of Operations to Sort a Binary Tree by Level</title>
      <link>http://localhost:1313/leetcode/solution-2471-minimum-number-of-operations-to-sort-a-binary-tree-by-level/</link>
      <pubDate>Mon, 04 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2471-minimum-number-of-operations-to-sort-a-binary-tree-by-level/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in strictly increasing order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2476: Closest Nodes Queries in a Binary Search Tree</title>
      <link>http://localhost:1313/leetcode/solution-2476-closest-nodes-queries-in-a-binary-search-tree/</link>
      <pubDate>Mon, 04 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2476-closest-nodes-queries-in-a-binary-search-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary search tree (BST) and an array of queries. For each query, find the largest value smaller than or equal to the query value and the smallest value greater than or equal to the query value in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2583: Kth Largest Sum in a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-2583-kth-largest-sum-in-a-binary-tree/</link>
      <pubDate>Thu, 22 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2583-kth-largest-sum-in-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 0-indexed array of strings &lt;code&gt;words&lt;/code&gt; and two integers &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;. A string is considered a vowel string if it starts and ends with a vowel character (vowels are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, &amp;lsquo;u&amp;rsquo;). Your task is to return the number of vowel strings in the array &lt;code&gt;words&lt;/code&gt; where the indices fall within the range [left, right].&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2641: Cousins in Binary Tree II</title>
      <link>http://localhost:1313/leetcode/solution-2641-cousins-in-binary-tree-ii/</link>
      <pubDate>Fri, 16 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2641-cousins-in-binary-tree-ii/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins&amp;rsquo; values. Two nodes are cousins if they have the same depth but different parents. The depth of a node is the number of edges from the root to the node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2673: Make Costs of Paths Equal in a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-2673-make-costs-of-paths-equal-in-a-binary-tree/</link>
      <pubDate>Tue, 13 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2673-make-costs-of-paths-equal-in-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a perfect binary tree with &lt;code&gt;n&lt;/code&gt; nodes, where each node has a cost associated with it. The tree is numbered from 1 to n, with node 1 as the root. For each node &lt;code&gt;i&lt;/code&gt;, its left child is &lt;code&gt;2*i&lt;/code&gt; and its right child is &lt;code&gt;2*i + 1&lt;/code&gt;. You are allowed to increment the cost of any node by 1 any number of times. Your task is to return the minimum number of increments required to make the total cost of the path from the root to each leaf node equal.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

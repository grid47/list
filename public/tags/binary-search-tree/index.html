<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Binary Search Tree | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Binary Search Tree">
  <meta name="twitter:description" content="Blog by grid47">

	<meta property="og:url" content="http://localhost:1313/tags/binary-search-tree/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Binary Search Tree">
  <meta property="og:description" content="Blog by grid47">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
        

	
	
	<link rel="stylesheet" href="/css/leetcode.css" integrity="" crossorigin="anonymous" media="screen">



</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/courses/">Course</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
    <div class="main-content">
        
        <section class="recent-posts">            
            <div class="section-title">                
                <h2><span>All Posts</span></h2>                
            </div>            
            <div class="row listrecent">
                
                
<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-95-unique-binary-search-trees-ii/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-95-unique-binary-search-trees-ii/">Leetcode 95: Unique Binary Search Trees II</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1406s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/95.webp" 
           alt="A sequence of elegant trees gently forming in various, unique shapes." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 95: Unique Binary Search Trees II Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given the head of a singly linked list. The goal is to reorder the list such that the nodes are arranged as follows: L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → &hellip;, without modifying the values of the nodes. Only the structure of the list can be changed. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of a singly linked list with integer values. The linked list is given by its head node.</div>
                        <div class=""> <b>Example:</b> Input: head = [10, 20, 30, 40]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the list is in the range [1, 5 * 10^4].</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= Node.val &lt;= 1000</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be the reordered linked list where nodes are arranged as L0 → Ln → L1 → Ln-1 → L2 → Ln-2 → ...</div>
                        <div class=""> <b>Example:</b> Output: [10, 40, 20, 30]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be a singly linked list with the nodes rearranged as described.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to reorder the linked list as per the given structure without modifying the node values.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Find the middle of the list using the slow and fast pointer approach.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Reverse the second half of the list.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Merge the first half and the reversed second half by alternating nodes from each half.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The solution must operate within the given constraints and reorder the list in linear time.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The list must be reordered in O(n) time and O(1) extra space.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input list is non-empty and contains valid integers.</div>
                            
                                <div style="margin-left: 20px;"> • The list is not cyclic.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: head = [10, 20, 30, 40]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this example, the list is reordered as [10, 40, 20, 30], where the first node is followed by the last node, then the second node, followed by the second last node, and so on.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The solution involves three main steps: finding the middle of the list, reversing the second half, and merging the two halves.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • The problem requires rearranging nodes without modifying their values.</div>
                            
                            
                                <div style="margin-left: 20px;"> • A two-pointer approach can help find the middle of the list. After that, reversing the second half allows us to merge both halves in the required order.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Use two pointers (slow and fast) to find the middle of the list.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Reverse the second half of the list starting from the node after the middle.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Merge the two halves by alternately linking nodes from each half.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the input list contains only one node, the list remains unchanged.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The algorithm should efficiently handle lists with up to 50,000 nodes.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • The list may contain nodes with varying values, but the algorithm should not modify their values, only their positions.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution must use linear time and constant space.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Pointer Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Find Middle</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Move Slow Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Move Fast Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Middle Node</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Break First Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Pointer Initialization for Reversal</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Reverse Second Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Save Next Node</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Reverse Link</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Update Previous Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Move Mid Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Pointer Initialization for Merging</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Merge Two Halves</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Save Next Node in First Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="17"> 17 Connect First Half to Second Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="18"> 18 Save Next Node in Second Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="19"> 19 Connect Second Half to First Half</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="20"> 20 Move to Next Nodes</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="21"> 21 Move to Next Nodes</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">reorderList</span>(ListNode<span style="color:#666">*</span> head) {
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> fast <span style="color:#666">=</span> head, <span style="color:#666">*</span>slow <span style="color:#666">=</span> head;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(fast<span style="color:#666">-&gt;</span>next <span style="color:#666">&amp;&amp;</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>        slow <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        fast <span style="color:#666">=</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> mid <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    slow<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> next, <span style="color:#666">*</span>prev <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(mid) {
</span></span><span style="display:flex;"><span>        next <span style="color:#666">=</span> mid<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        mid<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prev;
</span></span><span style="display:flex;"><span>        prev <span style="color:#666">=</span> mid;
</span></span><span style="display:flex;"><span>        mid <span style="color:#666">=</span> next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> l1 <span style="color:#666">=</span> head, <span style="color:#666">*</span>l2 <span style="color:#666">=</span> prev;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(l1 <span style="color:#666">&amp;&amp;</span> l2) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> tmp1 <span style="color:#666">=</span> l1<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        l1<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> l2;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> tmp2 <span style="color:#666">=</span> l2<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        l2<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> tmp1;
</span></span><span style="display:flex;"><span>        l1 <span style="color:#666">=</span> tmp1;
</span></span><span style="display:flex;"><span>        l2 <span style="color:#666">=</span> tmp2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">reorderList</span>(ListNode<span style="color:#666">*</span> head) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This defines the `reorderList` function, which reorders the nodes of a linked list in a specific pattern by modifying the list in-place. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Pointer Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> fast <span style="color:#666">=</span> head, <span style="color:#666">*</span>slow <span style="color:#666">=</span> head;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Two pointers, `fast` and `slow`, are initialized at the head of the list. `fast` moves two steps at a time, and `slow` moves one step at a time. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Find Middle</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(fast<span style="color:#666">-&gt;</span>next <span style="color:#666">&amp;&amp;</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This loop runs until the `fast` pointer reaches the end of the list. It helps in finding the middle of the linked list using the slow and fast pointer technique. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Move Slow Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        slow <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The `slow` pointer moves one step at a time toward the middle of the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Move Fast Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        fast <span style="color:#666">=</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The `fast` pointer moves two steps at a time, so when it reaches the end, the `slow` pointer will be at the middle of the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Middle Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> mid <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> After finding the middle of the list, the `mid` pointer is initialized to the node right after the `slow` pointer. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Break First Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    slow<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Breaks the list into two halves by setting `slow-&gt;next` to `NULL`, thus isolating the first half of the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Pointer Initialization for Reversal</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> next, <span style="color:#666">*</span>prev <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Two pointers, `prev` and `next`, are initialized. `prev` is used for reversing the second half of the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Reverse Second Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(mid) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This loop reverses the second half of the list by iterating over the nodes starting from `mid`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Save Next Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        next <span style="color:#666">=</span> mid<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Saves the next node in the `next` pointer to avoid losing the reference during the reversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Reverse Link</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        mid<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prev;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Reverses the `mid` node&#39;s `next` pointer to point to the previous node, effectively reversing the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Update Previous Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        prev <span style="color:#666">=</span> mid;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `prev` pointer one step forward to the current node (`mid`), preparing it for the next iteration. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Move Mid Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        mid <span style="color:#666">=</span> next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `mid` pointer to the next node in the original list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Pointer Initialization for Merging</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> l1 <span style="color:#666">=</span> head, <span style="color:#666">*</span>l2 <span style="color:#666">=</span> prev;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes two pointers, `l1` pointing to the head of the first half, and `l2` pointing to the head of the reversed second half. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Merge Two Halves</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(l1 <span style="color:#666">&amp;&amp;</span> l2) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This loop merges the two halves by alternating nodes from `l1` and `l2`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Save Next Node in First Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> tmp1 <span style="color:#666">=</span> l1<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Saves the next node of `l1` in `tmp1` to prevent losing the reference during the merge. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>17 : Connect First Half to Second Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l1<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> l2;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Connects the current node of the first half (`l1`) to the current node of the second half (`l2`). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>18 : Save Next Node in Second Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> tmp2 <span style="color:#666">=</span> l2<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Saves the next node of `l2` in `tmp2` to ensure the merge can continue. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>19 : Connect Second Half to First Half</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l2<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> tmp1;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Connects the current node of the second half (`l2`) to the next node of the first half (`tmp1`). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>20 : Move to Next Nodes</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l1 <span style="color:#666">=</span> tmp1;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `l1` pointer to the next node in the first half. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>21 : Move to Next Nodes</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l2 <span style="color:#666">=</span> tmp2;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `l2` pointer to the next node in the second half. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n), when the list is reordered by following the standard procedure.</div>
                        <div class=""> <b>Average Case:</b> O(n), the list will always require a full traversal for reordering.</div>
                        <div class=""> <b>Worst Case:</b> O(n), the solution works in linear time in all cases.</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n) because we traverse the list multiple times, but each traversal is linear.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1), the space complexity remains constant.</div>
                        <div class=""> <b>Worst Case:</b> O(1), since only a few pointers are used.</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(1) because no extra space is used apart from a few pointers.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 28, 2024 - 7 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-95-unique-binary-search-trees-ii/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-98-validate-binary-search-tree/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-98-validate-binary-search-tree/">Leetcode 98: Validate Binary Search Tree</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1427s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/98.webp" 
           alt="A glowing tree with balanced nodes, radiating a sense of order and validation." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 98: Validate Binary Search Tree Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given an array of strings tokens that represents an arithmetic expression in Reverse Polish Notation (RPN). Your task is to evaluate the expression and return the result as an integer. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of an array of strings, where each string is either an operand (integer) or an operator (&#43;, -, *, /).</div>
                        <div class=""> <b>Example:</b> tokens = [&#34;3&#34;, &#34;4&#34;, &#34;-&#34;, &#34;5&#34;, &#34;*&#34;]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= tokens.length &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • tokens[i] is either an operator (&#43;, -, *, /) or an integer between [-200, 200].</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be an integer representing the result of evaluating the RPN expression.</div>
                        <div class=""> <b>Example:</b> Result = -35</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The answer can be represented as a 32-bit integer.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Evaluate the Reverse Polish Notation expression by using a stack to process operands and operators.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Initialize an empty stack.</div>
                            
                                <div style="margin-left: 20px;"> • Iterate through the tokens array:</div>
                            
                                <div style="margin-left: 20px;"> •   - If the token is an integer, push it onto the stack.</div>
                            
                                <div style="margin-left: 20px;"> •   - If the token is an operator (&#43;, -, *, /), pop the top two elements from the stack, apply the operator, and push the result back onto the stack.</div>
                            
                                <div style="margin-left: 20px;"> • At the end of the iteration, the stack will contain only one element, which is the result of the expression.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The expression will always be valid and can be evaluated.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= tokens.length &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • tokens[i] is an operator (&#43;, -, *, /) or an integer between [-200, 200].</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The expression will always be valid and contain no division by zero.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> tokens = [&#34;3&#34;, &#34;4&#34;, &#34;-&#34;, &#34;5&#34;, &#34;*&#34;]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> First, 3 - 4 = -1, then -1 * 5 = -35. So the result is -35.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> tokens = [&#34;2&#34;, &#34;3&#34;, &#34;*&#34;, &#34;4&#34;, &#34;&#43;&#34;]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> First, 2 * 3 = 6, then 6 &#43; 4 = 10. So the result is 10.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> We can solve this problem using a stack to handle the Reverse Polish Notation (RPN) expression evaluation.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Using a stack is ideal for processing Reverse Polish Notation expressions, as operators act on the most recent operands.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We need to iterate through the tokens, handling both operands and operators, and update the stack as we go.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Initialize an empty stack.</div>
                            
                                <div style="margin-left: 20px;"> • For each token in the tokens array, check if it&#39;s an operand (integer) or an operator (&#43;, -, *, /).</div>
                            
                                <div style="margin-left: 20px;"> • If it&#39;s an operand, push it onto the stack.</div>
                            
                                <div style="margin-left: 20px;"> • If it&#39;s an operator, pop two operands from the stack, perform the operation, and push the result back onto the stack.</div>
                            
                                <div style="margin-left: 20px;"> • At the end, the stack will contain the final result.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • There will always be at least one token in the input.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution must handle large inputs efficiently, up to 10^4 tokens.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle negative numbers and division truncation towards zero correctly.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution should be efficient in terms of time and space complexity.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Variable Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Loop Iteration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Conditional Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Conditional Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Conditional Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Conditional Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Stack Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Else Block</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Stack Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Stack Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Arithmetic Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Arithmetic Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Arithmetic Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Arithmetic Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="17"> 17 Return Value</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">evalRPN</span>(vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&amp;</span> tokens) {
</span></span><span style="display:flex;"><span>    stack<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> stk;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> tokens.size();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">!=</span> <span style="color:#b44">&#34;+&#34;</span> <span style="color:#666">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>           tokens[i] <span style="color:#666">!=</span> <span style="color:#b44">&#34;-&#34;</span> <span style="color:#666">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>           tokens[i] <span style="color:#666">!=</span> <span style="color:#b44">&#34;*&#34;</span> <span style="color:#666">&amp;&amp;</span>
</span></span><span style="display:flex;"><span>           tokens[i] <span style="color:#666">!=</span> <span style="color:#b44">&#34;/&#34;</span>) {
</span></span><span style="display:flex;"><span>            stk.push(stoi(tokens[i]));
</span></span><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> stk.top(); stk.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> y <span style="color:#666">=</span> stk.top(); stk.pop();
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">==</span> <span style="color:#b44">&#34;*&#34;</span>){ stk.push(y <span style="color:#666">*</span> x); }
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">==</span> <span style="color:#b44">&#34;/&#34;</span>){ stk.push(y <span style="color:#666">/</span> x); }
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">==</span> <span style="color:#b44">&#34;+&#34;</span>){ stk.push(y <span style="color:#666">+</span> x); }
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">==</span> <span style="color:#b44">&#34;-&#34;</span>){ stk.push(y <span style="color:#666">-</span> x); }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> stk.top();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">evalRPN</span>(vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&amp;</span> tokens) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the function `evalRPN` that takes a vector of strings as input (tokens in Reverse Polish Notation) and returns the result of evaluating the expression. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Variable Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    stack<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> stk;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declares a stack `stk` to store intermediate values while processing the RPN expression. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> tokens.size();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes `n` to the size of the tokens vector, which represents the number of elements in the RPN expression. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Loop Iteration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts a loop to iterate through each token in the RPN expression. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Conditional Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">!=</span> <span style="color:#b44">&#34;+&#34;</span> <span style="color:#666">&amp;&amp;</span>
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current token is not an operator (i.e., `&#43;`, `-`, `*`, or `/`). If it is not an operator, the token is assumed to be a number. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Conditional Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>           tokens[i] <span style="color:#666">!=</span> <span style="color:#b44">&#34;-&#34;</span> <span style="color:#666">&amp;&amp;</span>
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Continues the check for other operators to ensure the current token is not one of the arithmetic operators. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Conditional Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>           tokens[i] <span style="color:#666">!=</span> <span style="color:#b44">&#34;*&#34;</span> <span style="color:#666">&amp;&amp;</span>
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Further checks if the current token is not the multiplication operator. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Conditional Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>           tokens[i] <span style="color:#666">!=</span> <span style="color:#b44">&#34;/&#34;</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the token is not the division operator. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Stack Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            stk.push(stoi(tokens[i]));
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the token is a number (not an operator), it is converted to an integer using `stoi` and pushed onto the stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Else Block</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the token is an operator, the algorithm proceeds to perform the corresponding arithmetic operation. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Stack Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> stk.top(); stk.pop();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pops the top value from the stack and assigns it to `x`. This represents the second operand for the operation. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Stack Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> y <span style="color:#666">=</span> stk.top(); stk.pop();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pops the next value from the stack and assigns it to `y`. This represents the first operand for the operation. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Arithmetic Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">==</span> <span style="color:#b44">&#34;*&#34;</span>){ stk.push(y <span style="color:#666">*</span> x); }
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Performs multiplication if the current token is the `*` operator. The result is pushed onto the stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Arithmetic Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">==</span> <span style="color:#b44">&#34;/&#34;</span>){ stk.push(y <span style="color:#666">/</span> x); }
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Performs division if the current token is the `/` operator. The result is pushed onto the stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Arithmetic Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">==</span> <span style="color:#b44">&#34;+&#34;</span>){ stk.push(y <span style="color:#666">+</span> x); }
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Performs addition if the current token is the `&#43;` operator. The result is pushed onto the stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Arithmetic Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(tokens[i] <span style="color:#666">==</span> <span style="color:#b44">&#34;-&#34;</span>){ stk.push(y <span style="color:#666">-</span> x); }
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Performs subtraction if the current token is the `-` operator. The result is pushed onto the stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>17 : Return Value</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> stk.top();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the final result, which is the last remaining value on the stack after processing all the tokens. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> We process each token in the input once, so the time complexity is linear in the number of tokens.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n) in the worst case due to the stack used for processing the tokens.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/validate-binary-search-tree/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 28, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-98-validate-binary-search-tree/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-99-recover-binary-search-tree/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-99-recover-binary-search-tree/">Leetcode 99: Recover Binary Search Tree</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1433s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/99.webp" 
           alt="A tree softly rearranging its nodes, finding its balance and order." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 99: Recover Binary Search Tree Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given an integer array nums. Find the subarray that has the largest product, and return the product. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input is an integer array nums where each element is an integer between -10 and 10.</div>
                        <div class=""> <b>Example:</b> nums = [1, 2, -1, 4]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= nums.length &lt;= 2 * 10^4</div>
                            
                                <div style="margin-left: 20px;"> • -10 &lt;= nums[i] &lt;= 10</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be an integer representing the largest product of any subarray.</div>
                        <div class=""> <b>Example:</b> 8</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The product of any subarray will fit within a 32-bit integer.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> To find the maximum product of a subarray, we can track the maximum and minimum products up to the current index.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Initialize two variables, mx and mn, to store the maximum and minimum products so far.</div>
                            
                                <div style="margin-left: 20px;"> • Initialize a result variable to store the maximum product encountered.</div>
                            
                                <div style="margin-left: 20px;"> • Iterate through the array, updating mx, mn, and result at each step by considering the current number and its product with the previous mx and mn.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The input array will always have at least one element.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= nums.length &lt;= 2 * 10^4</div>
                            
                                <div style="margin-left: 20px;"> • -10 &lt;= nums[i] &lt;= 10</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input array is not empty.</div>
                            
                                <div style="margin-left: 20px;"> • The product of any subarray will fit within a 32-bit integer.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> nums = [1, 2, -1, 4]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The subarray [1, 2, -1, 4] has the largest product, which is 8.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> nums = [-1, 0, -3, 4]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The subarray [4] has the largest product, which is 4.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> To solve this problem, we will iterate through the array while keeping track of the maximum and minimum products at each step.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • When we multiply a negative number by a negative number, it could result in a large positive product.</div>
                            
                            
                                <div style="margin-left: 20px;"> • By keeping track of both the maximum and minimum products at each index, we can handle the case of negative numbers efficiently.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Initialize two variables mx and mn to 1.</div>
                            
                                <div style="margin-left: 20px;"> • Iterate through the array nums.</div>
                            
                                <div style="margin-left: 20px;"> • For each element, update mx and mn by considering the current number, the product of the current number with mx, and the product of the current number with mn.</div>
                            
                                <div style="margin-left: 20px;"> • Update the result at each step to ensure it holds the largest product encountered so far.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The input will never be empty.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution must handle large inputs efficiently, up to 2 * 10^4 elements.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle negative numbers and zeros correctly.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The product of any subarray must fit in a 32-bit integer.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Variable Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Loop Iteration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Conditional Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Dynamic Programming</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Dynamic Programming</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Result Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 End of Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Return Value</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">maxProduct</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> mx <span style="color:#666">=</span> <span style="color:#666">1</span>, mn <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> INT_MIN;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> nums.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(nums[i] <span style="color:#666">&lt;</span> <span style="color:#666">0</span>) swap(mx, mn);
</span></span><span style="display:flex;"><span>        mx <span style="color:#666">=</span> max(nums[i], mx <span style="color:#666">*</span> nums[i]);
</span></span><span style="display:flex;"><span>        mn <span style="color:#666">=</span> min(nums[i], mn <span style="color:#666">*</span> nums[i]);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        res <span style="color:#666">=</span> max(res, mx);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">maxProduct</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> nums) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the function `maxProduct`, which takes a vector of integers and returns the maximum product of any contiguous subarray. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> mx <span style="color:#666">=</span> <span style="color:#666">1</span>, mn <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes two variables `mx` and `mn` to 1, representing the maximum and minimum products ending at the current index. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Variable Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> INT_MIN;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declares `res` and initializes it to the minimum integer value (`INT_MIN`) to track the maximum product found during the loop. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Loop Iteration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> nums.size(); i<span style="color:#666">++</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts a loop to iterate through the elements of the `nums` vector. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Conditional Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(nums[i] <span style="color:#666">&lt;</span> <span style="color:#666">0</span>) swap(mx, mn);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current number is negative. If it is, it swaps `mx` and `mn`, as a negative number could flip the product&#39;s sign. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Dynamic Programming</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        mx <span style="color:#666">=</span> max(nums[i], mx <span style="color:#666">*</span> nums[i]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates `mx` to the maximum of the current number itself or the product of `mx` and the current number. This keeps track of the largest product of any subarray ending at the current index. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Dynamic Programming</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        mn <span style="color:#666">=</span> min(nums[i], mn <span style="color:#666">*</span> nums[i]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates `mn` to the minimum of the current number itself or the product of `mn` and the current number. This helps to track the smallest product, which can be important for handling negative numbers. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Result Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        res <span style="color:#666">=</span> max(res, mx);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates the result `res` by comparing it with the current `mx` to keep track of the maximum product encountered so far. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : End of Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    }
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Marks the end of the loop that processes each number in the input array. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Return Value</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the final value of `res`, which holds the maximum product of any subarray. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> We iterate through the array once, so the time complexity is linear in the number of elements.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(1)</div> 
                        <div class=""> <b>Description:</b> We use a constant amount of space, so the space complexity is O(1).</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/recover-binary-search-tree/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 28, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-99-recover-binary-search-tree/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-109-convert-sorted-list-to-binary-search-tree/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-109-convert-sorted-list-to-binary-search-tree/">Leetcode 109: Convert Sorted List to Binary Search Tree</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode58s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/109.webp" 
           alt="A flowing list of sorted numbers seamlessly transforming into a calm, glowing binary search tree." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 109: Convert Sorted List to Binary Search Tree Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are a burglar planning to rob houses along a street. Each house has an amount of money, but robbing two adjacent houses will trigger an alarm. Given an integer array <code>nums</code> representing the money stashed in each house, find the maximum amount you can rob without triggering the alarm. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of a list of integers where each integer represents the amount of money in each house.</div>
                        <div class=""> <b>Example:</b> nums = [5, 3, 4, 11]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= nums.length &lt;= 100</div>
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= nums[i] &lt;= 400</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output is the maximum amount of money that can be robbed without triggering the alarm by robbing adjacent houses.</div>
                        <div class=""> <b>Example:</b> Output = 16</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output is a single integer representing the maximum amount of money that can be robbed.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Maximize the total amount of money robbed while ensuring no two adjacent houses are robbed.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Step 1: Use dynamic programming to keep track of the maximum money robbed up to each house.</div>
                            
                                <div style="margin-left: 20px;"> • Step 2: For each house, calculate the maximum amount by either skipping the house or robbing it and adding its value to the previous non-adjacent house&#39;s value.</div>
                            
                                <div style="margin-left: 20px;"> • Step 3: Return the maximum value at the last house.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The problem constraints ensure that the input list contains valid house values and its length is manageable.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The length of the input list, `nums`, is between 1 and 100.</div>
                            
                                <div style="margin-left: 20px;"> • Each value in `nums` is between 0 and 400.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input array is non-empty.</div>
                            
                                <div style="margin-left: 20px;"> • The values in the input array are valid integers within the given range.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: nums = [5, 3, 4, 11]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The maximum money that can be robbed is 16 by robbing house 1 (5) and house 4 (11). The adjacent houses can&#39;t both be robbed, so we skip house 2 and 3.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: nums = [3, 2, 5, 10, 7]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The optimal choice is to rob house 1 (3), house 3 (5), and house 5 (7), yielding a total of 15.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> We can solve this problem using dynamic programming. The idea is to iterate through the houses and keep track of the maximum money we can rob up to each house without robbing two adjacent houses.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • This is a typical dynamic programming problem where we need to make decisions based on previous results.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We can define a dp array where dp[i] represents the maximum money we can rob up to the i-th house.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Step 1: Initialize an array `dp` where dp[i] will store the maximum amount of money that can be robbed from house 0 to house i.</div>
                            
                                <div style="margin-left: 20px;"> • Step 2: Set dp[0] = nums[0] and dp[1] = max(nums[0], nums[1]).</div>
                            
                                <div style="margin-left: 20px;"> • Step 3: For each subsequent house i, calculate dp[i] as max(dp[i-2] &#43; nums[i], dp[i-1]).</div>
                            
                                <div style="margin-left: 20px;"> • Step 4: Return dp[n-1], which will hold the maximum amount of money robbed.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • There are no empty inputs, as the problem guarantees at least one house.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The problem&#39;s constraints are small enough (up to 100 houses) that large inputs are not a concern.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the array contains only one house, we simply rob that house.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The input will always have at least one house.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Array Size</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Edge Case Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 DP Array Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Base Case Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Base Case Comparison</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Loop Through Houses</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 DP Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Return Result</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">rob</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> a) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> a.size();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(n <span style="color:#666">==</span> <span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> a[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dp(n,<span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>    dp[<span style="color:#666">0</span>] <span style="color:#666">=</span> a[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>    dp[<span style="color:#666">1</span>] <span style="color:#666">=</span> max(a[<span style="color:#666">0</span>], a[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">2</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>        dp[i] <span style="color:#666">=</span> max(dp[i<span style="color:#666">-</span><span style="color:#666">2</span>]<span style="color:#666">+</span>a[i], dp[i<span style="color:#666">-</span><span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> dp[n<span style="color:#666">-</span><span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">rob</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> a) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Define the function &#39;rob&#39; which accepts a vector of integers &#39;a&#39; representing the amount of money in each house, and returns the maximum amount that can be robbed. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Array Size</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> a.size();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Store the size of the input vector &#39;a&#39; in the variable &#39;n&#39;, which represents the number of houses. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Edge Case Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(n <span style="color:#666">==</span> <span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> a[<span style="color:#666">0</span>];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Check if there is only one house. If so, return the amount in that single house as there are no other houses to consider. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : DP Array Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dp(n,<span style="color:#666">0</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize a dynamic programming (DP) array &#39;dp&#39; of size &#39;n&#39; with all elements set to zero. This array will store the maximum amount that can be robbed up to each house. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Base Case Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dp[<span style="color:#666">0</span>] <span style="color:#666">=</span> a[<span style="color:#666">0</span>];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Set the base case: the maximum amount that can be robbed from just the first house is the amount in the first house itself. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Base Case Comparison</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dp[<span style="color:#666">1</span>] <span style="color:#666">=</span> max(a[<span style="color:#666">0</span>], a[<span style="color:#666">1</span>]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> For the second house, the maximum amount that can be robbed is the greater of the first and second house values. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Loop Through Houses</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">2</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Start a loop from the third house onward to compute the maximum amount that can be robbed by either including or excluding the current house. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : DP Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        dp[i] <span style="color:#666">=</span> max(dp[i<span style="color:#666">-</span><span style="color:#666">2</span>]<span style="color:#666">+</span>a[i], dp[i<span style="color:#666">-</span><span style="color:#666">1</span>]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Update the DP array by choosing the maximum between robbing the current house (dp[i-2] &#43; a[i]) or skipping the current house (dp[i-1]). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Return Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> dp[n<span style="color:#666">-</span><span style="color:#666">1</span>];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Return the maximum amount that can be robbed from all houses, which is stored in the last element of the DP array. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n), where n is the length of the input array `nums`. We process each house once.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n) due to the dynamic programming array used to store the maximum amounts for each house.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 27, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-109-convert-sorted-list-to-binary-search-tree/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-230-kth-smallest-element-in-a-bst/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-230-kth-smallest-element-in-a-bst/">Leetcode 230: Kth Smallest Element in a BST</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode673s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/230.webp" 
           alt="A binary search tree with nodes softly glowing, showing the kth smallest element highlighted." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 230: Kth Smallest Element in a BST Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given a set of coins of different denominations, determine how many distinct combinations of these coins sum up to the target amount. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> You are given an array `coins` containing different coin denominations and an integer `amount` representing the target sum.</div>
                        <div class=""> <b>Example:</b> amount = 8, coins = [3, 4, 5]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= coins.length &lt;= 300</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= coins[i] &lt;= 5000</div>
                            
                                <div style="margin-left: 20px;"> • All values in coins are unique</div>
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= amount &lt;= 5000</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be an integer representing the number of distinct combinations of coins that can sum up to the target amount.</div>
                        <div class=""> <b>Example:</b> 3</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be a non-negative integer.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> To calculate the number of distinct combinations that sum up to the target amount.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Use dynamic programming to calculate the number of ways to make each amount up to the target.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Initialize a DP array where dp[i] stores the number of ways to make amount i.</div>
                            
                                <div style="margin-left: 20px;"> • 3. For each coin, update the DP array by considering using that coin multiple times.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The constraints for the input and output of the problem.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= coins.length &lt;= 300</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= coins[i] &lt;= 5000</div>
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= amount &lt;= 5000</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The `coins` array contains unique values.</div>
                            
                                <div style="margin-left: 20px;"> • The `amount` is guaranteed to be within the specified range.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> amount = 8, coins = [3, 4, 5]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> There are three distinct ways to make up the amount 8 using the coins [3, 4, 5]: 5&#43;3, 4&#43;4, and 3&#43;3&#43;3.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> amount = 6, coins = [2, 5]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> There is only one way to make the amount 6: 2&#43;2&#43;2.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The solution uses dynamic programming to count the number of ways to make the target amount.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • The problem can be solved using dynamic programming as it is a variant of the coin change problem.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We need to maintain a DP table to track the number of ways to make each possible amount.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Initialize a DP array `dp` of size (amount &#43; 1) with all elements set to 0, except `dp[0]` which should be 1 (base case).</div>
                            
                                <div style="margin-left: 20px;"> • 2. Iterate over each coin and for each coin, update the DP table by adding `dp[amount - coin]` to `dp[amount]`.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the amount is 0, return 1 as there is one way to make the amount 0 (by not using any coins).</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The algorithm should handle cases where the amount is large (up to 5000) efficiently.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If no combination of coins can form the amount, return 0.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure the solution handles cases where the amount is 0 correctly.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Base Case</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Memoization Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Recursion</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Recursion with Coin Inclusion</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Memoization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Static Function</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Static Function</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Main Function</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Variable Assignment</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Sorting</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Memo Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Recursive Call</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> memo[<span style="color:#666">5001</span>][<span style="color:#666">301</span>];
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> nums;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">dp</span>(<span style="color:#0b0;font-weight:bold">int</span> amnt, <span style="color:#0b0;font-weight:bold">int</span> idx) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(idx <span style="color:#666">==</span> nums.size()) <span style="color:#a2f;font-weight:bold">return</span> amnt <span style="color:#666">==</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(memo[amnt][idx] <span style="color:#666">!=</span> <span style="color:#666">-</span><span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> memo[amnt][idx];
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// cout &lt;&lt; amnt &lt;&lt; &#34; &#34; &lt;&lt; idx &lt;&lt; &#34; &#34; &lt;&lt; nums[idx]&lt;&lt; &#34;\n&#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> dp(amnt, idx <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(amnt <span style="color:#666">&gt;=</span> nums[idx])
</span></span><span style="display:flex;"><span>    res <span style="color:#666">+=</span> dp(amnt <span style="color:#666">-</span> nums[idx], idx);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> memo[amnt][idx] <span style="color:#666">=</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">cmp</span>(<span style="color:#0b0;font-weight:bold">int</span> a, <span style="color:#0b0;font-weight:bold">int</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> b <span style="color:#666">&lt;</span> a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">change</span>(<span style="color:#0b0;font-weight:bold">int</span> amount, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> coins) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>nums <span style="color:#666">=</span> coins;
</span></span><span style="display:flex;"><span>    sort(nums.begin(), nums.end(), cmp);
</span></span><span style="display:flex;"><span>    memset(memo, <span style="color:#666">-</span><span style="color:#666">1</span>, <span style="color:#a2f;font-weight:bold">sizeof</span>(memo));
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> dp(amount, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> memo[<span style="color:#666">5001</span>][<span style="color:#666">301</span>];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This initializes a 2D array `memo` that will store the results of subproblems, where `memo[amnt][idx]` represents the number of ways to make the amount `amnt` from the first `idx` coins. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> nums;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This declares a vector `nums` to hold the coins available to make the desired amount. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">dp</span>(<span style="color:#0b0;font-weight:bold">int</span> amnt, <span style="color:#0b0;font-weight:bold">int</span> idx) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This is the recursive function `dp` which calculates the number of ways to make the amount `amnt` starting from coin index `idx`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Base Case</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(idx <span style="color:#666">==</span> nums.size()) <span style="color:#a2f;font-weight:bold">return</span> amnt <span style="color:#666">==</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If all coins have been considered (`idx` reaches the size of `nums`), return `1` if the remaining amount is zero, otherwise `0`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Memoization Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(memo[amnt][idx] <span style="color:#666">!=</span> <span style="color:#666">-</span><span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> memo[amnt][idx];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Check if the subproblem has already been computed by checking the `memo` table. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Recursion</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> dp(amnt, idx <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively call `dp` to calculate the number of ways to make the amount `amnt` without using the current coin (`idx &#43; 1`). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Recursion with Coin Inclusion</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(amnt <span style="color:#666">&gt;=</span> nums[idx]) res <span style="color:#666">+=</span> dp(amnt <span style="color:#666">-</span> nums[idx], idx);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current coin can be used (i.e., `amnt &gt;= nums[idx]`), recursively call `dp` including the current coin and subtract its value from `amnt`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Memoization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> memo[amnt][idx] <span style="color:#666">=</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Store the computed result in `memo[amnt][idx]` to avoid redundant calculations in future calls. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Static Function</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">static</span> <span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">cmp</span>(<span style="color:#0b0;font-weight:bold">int</span> a, <span style="color:#0b0;font-weight:bold">int</span> b) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This is a static comparator function used to sort the coins in descending order. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Static Function</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> b <span style="color:#666">&lt;</span> a;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The comparator function sorts coins in descending order to prioritize larger coins first. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Main Function</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">change</span>(<span style="color:#0b0;font-weight:bold">int</span> amount, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> coins) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This is the main function where the coin change problem is solved using the `dp` function. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Variable Assignment</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>nums <span style="color:#666">=</span> coins;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Assign the `coins` vector to the class member `nums`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Sorting</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    sort(nums.begin(), nums.end(), cmp);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Sort the coins in descending order using the `cmp` function. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Memo Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    memset(memo, <span style="color:#666">-</span><span style="color:#666">1</span>, <span style="color:#a2f;font-weight:bold">sizeof</span>(memo));
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize the `memo` table to `-1` to indicate that no subproblems have been solved yet. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">dp</span>(amount, <span style="color:#666">0</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Start the recursive `dp` function from the first coin (`idx = 0`) with the given `amount`. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n * amount)</div>
                        <div class=""> <b>Average Case:</b> O(n * amount)</div>
                        <div class=""> <b>Worst Case:</b> O(n * amount)</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n * amount), where n is the number of coins and amount is the target sum.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(amount)</div>
                        <div class=""> <b>Worst Case:</b> O(amount)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(amount) due to the DP array storing the number of combinations for each amount.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/kth-smallest-element-in-a-bst/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 15, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-230-kth-smallest-element-in-a-bst/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-235-lowest-common-ancestor-of-a-binary-search-tree/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-235-lowest-common-ancestor-of-a-binary-search-tree/">Leetcode 235: Lowest Common Ancestor of a Binary Search Tree</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode701s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/235.webp" 
           alt="Two paths glowing brightly as they meet at the lowest common ancestor in a binary search tree." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 235: Lowest Common Ancestor of a Binary Search Tree Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given a string s and a string array dictionary, return the longest string from the dictionary that can be formed by deleting some characters of s. If there are multiple valid words, return the longest word with the smallest lexicographical order. If no valid word exists, return an empty string. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of a string s and an array of strings dictionary.</div>
                        <div class=""> <b>Example:</b> s = &#39;xyzzabca&#39;, dictionary = [&#39;abc&#39;, &#39;xy&#39;, &#39;zz&#39;, &#39;xyz&#39;]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= s.length &lt;= 1000</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= dictionary.length &lt;= 1000</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= dictionary[i].length &lt;= 1000</div>
                            
                                <div style="margin-left: 20px;"> • s and dictionary[i] consist of lowercase English letters.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return the longest word in the dictionary that can be formed from the string s. If there are multiple such words, return the lexicographically smallest one. If no valid word can be formed, return an empty string.</div>
                        <div class=""> <b>Example:</b> &#39;abc&#39;, &#39;c&#39;</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be a string.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to check each word in the dictionary to see if it can be formed by deleting characters from s and then return the longest, lexicographically smallest one.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Iterate through each word in the dictionary.</div>
                            
                                <div style="margin-left: 20px;"> • 2. For each word, check if it can be formed by deleting some characters from s by maintaining a pointer for both strings.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Track the longest valid word found and update if a new word with a longer length or smaller lexicographical order is found.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Return the valid word or an empty string if no valid word is found.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The constraints on the input string s and the dictionary ensure that the solution must be efficient enough to handle large inputs.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= s.length &lt;= 1000</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= dictionary.length &lt;= 1000</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= dictionary[i].length &lt;= 1000</div>
                            
                                <div style="margin-left: 20px;"> • s and dictionary[i] consist of lowercase English letters.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input strings are valid and consist of lowercase English letters only.</div>
                            
                                <div style="margin-left: 20px;"> • We assume that all words in the dictionary are distinct.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> s = &#39;xyzzabca&#39;, dictionary = [&#39;abc&#39;, &#39;xy&#39;, &#39;zz&#39;, &#39;xyz&#39;]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The word &#39;abc&#39; can be formed from s by deleting &#39;x&#39;, &#39;y&#39;, &#39;z&#39;, and &#39;z&#39;. The other words cannot be formed.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> s = &#39;abc&#39;, dictionary = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> &#39;c&#39; is the longest valid word that can be formed from s.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> s = &#39;abcxyz&#39;, dictionary = [&#39;ax&#39;, &#39;bc&#39;, &#39;xyz&#39;]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> &#39;ax&#39; can be formed from s and is the longest, lexicographically smallest word.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The approach involves iterating over each word in the dictionary and checking if it can be formed from s by deleting characters. The key operation is maintaining a pointer for both the string and the word being checked.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • The task is a typical string matching problem where we are allowed to delete characters from s.</div>
                            
                            
                                <div style="margin-left: 20px;"> • The solution needs to efficiently check if a word can be formed from s and track the longest, lexicographically smallest result.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Sort the dictionary in lexicographical order to ensure we can always pick the smallest word first.</div>
                            
                                <div style="margin-left: 20px;"> • 2. For each word, check if it can be formed by traversing s and matching the characters of the word in sequence.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Track the longest word found, and if two words are of the same length, return the lexicographically smallest one.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle empty string s or an empty dictionary.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution should efficiently handle the case where s and the dictionary contain the maximum number of elements (1000).</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If no word can be formed, return an empty string.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution should run in O(n * m) time, where n is the length of s and m is the total length of all words in the dictionary.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Looping through Dictionary</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Matching Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Character Matching</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Subsequence Validity and Lexicographical Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Assign Longest Word</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Return Result</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string <span style="color:#00a000">findLongestWord</span>(string s, vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&amp;</span> d) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    string ans;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> d.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> pi <span style="color:#666">=</span> <span style="color:#666">0</span>, pj <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(; pi <span style="color:#666">&lt;</span> s.size() <span style="color:#666">&amp;&amp;</span> pj <span style="color:#666">&lt;</span> d[i].size(); pi<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            pj <span style="color:#666">+=</span> s[pi] <span style="color:#666">==</span> d[i][pj];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(pj <span style="color:#666">==</span> d[i].size() <span style="color:#666">&amp;&amp;</span> (ans.size() <span style="color:#666">&lt;</span> d[i].size() <span style="color:#666">||</span> (ans.size() <span style="color:#666">==</span> d[i].size() <span style="color:#666">&amp;&amp;</span> ans <span style="color:#666">&gt;</span> d[i])))
</span></span><span style="display:flex;"><span>            ans <span style="color:#666">=</span> d[i];
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string <span style="color:#00a000">findLongestWord</span>(string s, vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&amp;</span> d) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the function `findLongestWord` that takes a string `s` and a vector of strings `d`, and returns the longest word from `d` that can be formed by deleting some characters from `s`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    string ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes the variable `ans` to store the result, which will be the longest word found from the dictionary `d`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Looping through Dictionary</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> d.size(); i<span style="color:#666">++</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts a loop to iterate through each word in the dictionary `d`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> pi <span style="color:#666">=</span> <span style="color:#666">0</span>, pj <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes two variables `pi` and `pj`, which represent the current indices in the string `s` and the current word `d[i]` being checked, respectively. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Matching Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(; pi <span style="color:#666">&lt;</span> s.size() <span style="color:#666">&amp;&amp;</span> pj <span style="color:#666">&lt;</span> d[i].size(); pi<span style="color:#666">++</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Starts a loop to iterate through the string `s` and the current word `d[i]` simultaneously. It continues as long as both indices are within the bounds of `s` and `d[i]`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Character Matching</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            pj <span style="color:#666">+=</span> s[pi] <span style="color:#666">==</span> d[i][pj];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Increments the index `pj` if the characters `s[pi]` and `d[i][pj]` match. This helps in checking if `d[i]` is a subsequence of `s`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Subsequence Validity and Lexicographical Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(pj <span style="color:#666">==</span> d[i].size() <span style="color:#666">&amp;&amp;</span> (ans.size() <span style="color:#666">&lt;</span> d[i].size() <span style="color:#666">||</span> (ans.size() <span style="color:#666">==</span> d[i].size() <span style="color:#666">&amp;&amp;</span> ans <span style="color:#666">&gt;</span> d[i])))
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if `d[i]` is a subsequence of `s` (i.e., if `pj` equals the length of `d[i]`), and if it is, compares it with the current longest word `ans` to ensure that the longest and lexicographically largest word is selected. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Assign Longest Word</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            ans <span style="color:#666">=</span> d[i];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current word `d[i]` is a valid subsequence and is either longer or lexicographically larger than `ans`, it updates `ans` with `d[i]`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Return Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the longest word found from `d` that can be formed by deleting characters from `s`. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n * m), where n is the length of s and m is the total length of all dictionary words.</div>
                        <div class=""> <b>Average Case:</b> O(n * m)</div>
                        <div class=""> <b>Worst Case:</b> O(n * m)</div> 
                        <div class=""> <b>Description:</b> In the worst case, we check every word in the dictionary against the entire string s.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1), if no valid word is found.</div>
                        <div class=""> <b>Worst Case:</b> O(m), where m is the total length of all words in the dictionary.</div> 
                        <div class=""> <b>Description:</b> Space complexity is determined by the dictionary size and the string s, with no extra space used apart from variables for tracking results.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 14, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-235-lowest-common-ancestor-of-a-binary-search-tree/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


            </div>
        </section>
<div class="bottompagination">
  <div class="pointerup"><i class="fa fa-caret-up"></i></div>
  <div class="navigation" role="navigation">
    
      <div class="pagination">
        
          <span>&laquo; Prev</span>
        

        <span class="ml-1 mr-1">1</span>

        
          <a class="ml-1 mr-1" href="/tags/binary-search-tree/page/2/">2</a>
          <a class="ml-1 mr-1" href="/tags/binary-search-tree/page/2/">Next &raquo;</a>
        
      </div>
    
  </div>
</div></div>


            </div>
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
			<div class="d-md-flex align-items-center justify-content-center h-100">
				<h2 class="d-md-block d-none align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
			</div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
			
			<a class="mt-1 mb-1" href="/tags/array">array</a>
			
			<a class="mt-1 mb-1" href="/tags/backtracking">backtracking</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-indexed-tree">binary indexed tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search">binary search</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search-tree">binary search tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-tree">binary tree</a>
			
			<a class="mt-1 mb-1" href="/tags/bit-manipulation">bit manipulation</a>
			
			<a class="mt-1 mb-1" href="/tags/bitmask">bitmask</a>
			
			<a class="mt-1 mb-1" href="/tags/brainteaser">brainteaser</a>
			
			<a class="mt-1 mb-1" href="/tags/breadth-first-search">breadth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/bucket-sort">bucket sort</a>
			
			<a class="mt-1 mb-1" href="/tags/combinatorics">combinatorics</a>
			
			<a class="mt-1 mb-1" href="/tags/concurrency">concurrency</a>
			
			<a class="mt-1 mb-1" href="/tags/counting">counting</a>
			
			<a class="mt-1 mb-1" href="/tags/counting-sort">counting sort</a>
			
			<a class="mt-1 mb-1" href="/tags/data-stream">data stream</a>
			
			<a class="mt-1 mb-1" href="/tags/depth-first-search">depth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/design">design</a>
			
			<a class="mt-1 mb-1" href="/tags/divide-and-conquer">divide and conquer</a>
			
			<a class="mt-1 mb-1" href="/tags/doubly-linked-list">doubly-linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/dynamic-programming">dynamic programming</a>
			
			<a class="mt-1 mb-1" href="/tags/enumeration">enumeration</a>
			
			<a class="mt-1 mb-1" href="/tags/game-theory">game theory</a>
			
			<a class="mt-1 mb-1" href="/tags/geometry">geometry</a>
			
			<a class="mt-1 mb-1" href="/tags/graph">graph</a>
			
			<a class="mt-1 mb-1" href="/tags/greedy">greedy</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-function">hash function</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-table">hash table</a>
			
			<a class="mt-1 mb-1" href="/tags/heap-priority-queue">heap (priority queue)</a>
			
			<a class="mt-1 mb-1" href="/tags/interactive">interactive</a>
			
			<a class="mt-1 mb-1" href="/tags/iterator">iterator</a>
			
			<a class="mt-1 mb-1" href="/tags/linked-list">linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/math">math</a>
			
			<a class="mt-1 mb-1" href="/tags/matrix">matrix</a>
			
			<a class="mt-1 mb-1" href="/tags/memoization">memoization</a>
			
			<a class="mt-1 mb-1" href="/tags/minimum-spanning-tree">minimum spanning tree</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-queue">monotonic queue</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-stack">monotonic stack</a>
			
			<a class="mt-1 mb-1" href="/tags/number-theory">number theory</a>
			
			<a class="mt-1 mb-1" href="/tags/ordered-set">ordered set</a>
			
			<a class="mt-1 mb-1" href="/tags/prefix-sum">prefix sum</a>
			
			<a class="mt-1 mb-1" href="/tags/probability-and-statistics">probability and statistics</a>
			
			<a class="mt-1 mb-1" href="/tags/queue">queue</a>
			
			<a class="mt-1 mb-1" href="/tags/quickselect">quickselect</a>
			
			<a class="mt-1 mb-1" href="/tags/radix-sort">radix sort</a>
			
			<a class="mt-1 mb-1" href="/tags/randomized">randomized</a>
			
			<a class="mt-1 mb-1" href="/tags/recursion">recursion</a>
			
			<a class="mt-1 mb-1" href="/tags/reservoir-sampling">reservoir sampling</a>
			
			<a class="mt-1 mb-1" href="/tags/rolling-hash">rolling hash</a>
			
			<a class="mt-1 mb-1" href="/tags/segment-tree">segment tree</a>
			
			<a class="mt-1 mb-1" href="/tags/shortest-path">shortest path</a>
			
			<a class="mt-1 mb-1" href="/tags/simulation">simulation</a>
			
			<a class="mt-1 mb-1" href="/tags/sliding-window">sliding window</a>
			
			<a class="mt-1 mb-1" href="/tags/sorting">sorting</a>
			
			<a class="mt-1 mb-1" href="/tags/stack">stack</a>
			
			<a class="mt-1 mb-1" href="/tags/string">string</a>
			
			<a class="mt-1 mb-1" href="/tags/string-matching">string matching</a>
			
			<a class="mt-1 mb-1" href="/tags/topological-sort">topological sort</a>
			
			<a class="mt-1 mb-1" href="/tags/tree">tree</a>
			
			<a class="mt-1 mb-1" href="/tags/trie">trie</a>
			
			<a class="mt-1 mb-1" href="/tags/two-pointers">two pointers</a>
			
			<a class="mt-1 mb-1" href="/tags/union-find">union find</a>
			
		</div>
	</div>
</div>

<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

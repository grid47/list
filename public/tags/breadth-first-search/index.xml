<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Breadth-First Search on grid47</title>
    <link>http://localhost:1313/tags/breadth-first-search/</link>
    <description>Recent content in Breadth-First Search on grid47</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>www.grid47.com - All rights reserved</copyright>
    <lastBuildDate>Wed, 06 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/tags/breadth-first-search/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 100: Same Tree</title>
      <link>http://localhost:1313/leetcode/solution-100-same-tree/</link>
      <pubDate>Mon, 28 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-100-same-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3051s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/100.webp&#34; &#xA;           alt=&#34;Two trees glowing in harmony, showing perfect symmetry and balance.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 100: Same Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given two binary trees. Your task is to check if these two trees are the same. Two binary trees are considered the same if they are structurally identical and the nodes have the same value at each corresponding position.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 102: Binary Tree Level Order Traversal</title>
      <link>http://localhost:1313/leetcode/solution-102-binary-tree-level-order-traversal/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-102-binary-tree-level-order-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3064s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/102.webp&#34; &#xA;           alt=&#34;A tree with soft, glowing rings representing each level, expanding outward.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 102: Binary Tree Level Order Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, your task is to return the level order traversal of its nodes&amp;rsquo; values. This means you should traverse the tree level by level, from left to right at each level.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 103: Binary Tree Zigzag Level Order Traversal</title>
      <link>http://localhost:1313/leetcode/solution-103-binary-tree-zigzag-level-order-traversal/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-103-binary-tree-zigzag-level-order-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3071s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/103.webp&#34; &#xA;           alt=&#34;A glowing zigzag path moving through tree levels, creating a calming, fluid motion.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 103: Binary Tree Zigzag Level Order Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, your task is to return the zigzag level order traversal of its nodes&amp;rsquo; values. This means you need to traverse the tree level by level, alternating between left to right and right to left on each level.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 104: Maximum Depth of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-104-maximum-depth-of-binary-tree/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-104-maximum-depth-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3078s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/104.webp&#34; &#xA;           alt=&#34;A deep, glowing tree with rays of light expanding downwards to symbolize depth.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 104: Maximum Depth of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Your task is to return the maximum depth of the tree. The maximum depth is defined as the number of nodes along the longest path from the root node down to the farthest leaf node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 107: Binary Tree Level Order Traversal II</title>
      <link>http://localhost:1313/leetcode/solution-107-binary-tree-level-order-traversal-ii/</link>
      <pubDate>Sun, 27 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-107-binary-tree-level-order-traversal-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3091s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/107.webp&#34; &#xA;           alt=&#34;A tree with soft concentric circles, each level glowing and expanding outward from the center.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 107: Binary Tree Level Order Traversal II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the bottom-up level order traversal of its nodes&amp;rsquo; values. This means that for each level, starting from the leaf level and moving towards the root, you should collect the node values from left to right.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 111: Minimum Depth of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-111-minimum-depth-of-binary-tree/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-111-minimum-depth-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3106s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/111.webp&#34; &#xA;           alt=&#34;A deep tree with soft, glowing light reaching the minimal depth, highlighting the shortest path.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 111: Minimum Depth of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given a binary tree, find its minimum depth. The minimum depth is defined as the number of nodes along the shortest path from the root node down to the nearest leaf node. A leaf node is a node that does not have any children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 116: Populating Next Right Pointers in Each Node</title>
      <link>http://localhost:1313/leetcode/solution-116-populating-next-right-pointers-in-each-node/</link>
      <pubDate>Sat, 26 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-116-populating-next-right-pointers-in-each-node/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3130s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/116.webp&#34; &#xA;           alt=&#34;A glowing grid of nodes, with gentle arrows connecting them, showing the next right pointer linkages.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 116: Populating Next Right Pointers in Each Node Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a perfect binary tree where every parent node has two children and all leaves are at the same level. Your task is to populate the &amp;rsquo;next&amp;rsquo; pointer of each node to point to its next right node. If no such node exists, set the &amp;rsquo;next&amp;rsquo; pointer to NULL. Initially, all &amp;rsquo;next&amp;rsquo; pointers are set to NULL.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 130: Surrounded Regions</title>
      <link>http://localhost:1313/leetcode/solution-130-surrounded-regions/</link>
      <pubDate>Fri, 25 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-130-surrounded-regions/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3182s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/130.webp&#34; &#xA;           alt=&#34;A grid of cells gently surrounded by a calming border of light, with certain areas being &amp;#39;captured.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 130: Surrounded Regions Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an m x n matrix board containing letters &amp;lsquo;X&amp;rsquo; and &amp;lsquo;O&amp;rsquo;. Capture all regions that are surrounded by &amp;lsquo;X&amp;rsquo;. A region is captured if it is surrounded by &amp;lsquo;X&amp;rsquo; cells and cannot reach the edges of the board.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 133: Clone Graph</title>
      <link>http://localhost:1313/leetcode/solution-133-clone-graph/</link>
      <pubDate>Thu, 24 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-133-clone-graph/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3197s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/133.webp&#34; &#xA;           alt=&#34;A graph with nodes gently duplicating and glowing, forming an identical copy with soft edges.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 133: Clone Graph Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a reference to a node in a connected, undirected graph. Each node in the graph contains a value (integer) and a list of its neighbors. Your task is to return a deep copy of the entire graph starting from the given node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 199: Binary Tree Right Side View</title>
      <link>http://localhost:1313/leetcode/solution-199-binary-tree-right-side-view/</link>
      <pubDate>Fri, 18 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-199-binary-tree-right-side-view/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3533s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/199.webp&#34; &#xA;           alt=&#34;A glowing tree viewed from the right side, with the rightmost nodes gently illuminating.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 199: Binary Tree Right Side View Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Imagine yourself standing on the right side of the tree, and return the values of the nodes you can see when viewed from the right, ordered from top to bottom.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 200: Number of Islands</title>
      <link>http://localhost:1313/leetcode/solution-200-number-of-islands/</link>
      <pubDate>Fri, 18 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-200-number-of-islands/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3542s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/200.webp&#34; &#xA;           alt=&#34;A map of glowing islands floating gently, with the number of islands appearing as a soft count.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 200: Number of Islands Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a 2D grid representing a map, where &amp;lsquo;1&amp;rsquo; represents land and &amp;lsquo;0&amp;rsquo; represents water. Your task is to count how many islands are formed by connecting adjacent lands horizontally or vertically. An island is a collection of &amp;lsquo;1&amp;rsquo;s connected either horizontally or vertically.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 207: Course Schedule</title>
      <link>http://localhost:1313/leetcode/solution-207-course-schedule/</link>
      <pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-207-course-schedule/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3584s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/207.webp&#34; &#xA;           alt=&#34;A calming flowchart with courses linking together, showing dependencies in a gentle, glowing path.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 207: Course Schedule Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a set of courses and a list of prerequisites. Each prerequisite is a pair of courses where the second course must be taken before the first one. Determine if it is possible to complete all courses based on these prerequisites. If there are cycles in the dependencies, it would be impossible to finish all courses.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 210: Course Schedule II</title>
      <link>http://localhost:1313/leetcode/solution-210-course-schedule-ii/</link>
      <pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-210-course-schedule-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3600s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/210.webp&#34; &#xA;           alt=&#34;A series of tasks gently forming a schedule, with dependencies softly highlighted as the courses unfold.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 210: Course Schedule II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a set of courses with prerequisites, and you need to find a valid order to take them, or return an empty array if no valid order exists.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 226: Invert Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-226-invert-binary-tree/</link>
      <pubDate>Tue, 15 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-226-invert-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3691s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/226.webp&#34; &#xA;           alt=&#34;A tree slowly flipping upside down, with nodes glowing as they invert.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 226: Invert Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, invert the tree by swapping the left and right subtrees of every node, and return its root.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 279: Perfect Squares</title>
      <link>http://localhost:1313/leetcode/solution-279-perfect-squares/</link>
      <pubDate>Thu, 10 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-279-perfect-squares/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode3990s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/279.webp&#34; &#xA;           alt=&#34;A series of glowing squares being formed from numbers, each square glowing brighter as it becomes perfect.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 279: Perfect Squares Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given an integer n, return the least number of perfect square numbers that sum to n. A perfect square is a number that is the square of an integer. Your goal is to determine the minimum number of perfect squares that sum up to the given integer n.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 310: Minimum Height Trees</title>
      <link>http://localhost:1313/leetcode/solution-310-minimum-height-trees/</link>
      <pubDate>Mon, 07 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-310-minimum-height-trees/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4093s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/310.webp&#34; &#xA;           alt=&#34;A series of tree structures, with each one growing taller or shorter as the minimum height tree is highlighted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 310: Minimum Height Trees Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a tree with &amp;rsquo;n&amp;rsquo; nodes labeled from 0 to n-1, represented by &amp;rsquo;n-1&amp;rsquo; edges. Your task is to find all roots that minimize the height of the tree. The height of a tree is defined as the number of edges in the longest downward path from the root to any leaf.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 322: Coin Change</title>
      <link>http://localhost:1313/leetcode/solution-322-coin-change/</link>
      <pubDate>Sat, 05 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-322-coin-change/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4117s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/322.webp&#34; &#xA;           alt=&#34;A set of coins gradually transforming into the fewest possible number of coins needed to make the change, glowing softly.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 322: Coin Change Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a set of coins with different denominations and a target amount. Your task is to determine the fewest number of coins required to make the target amount. If it&amp;rsquo;s not possible, return -1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 365: Water and Jug Problem</title>
      <link>http://localhost:1313/leetcode/solution-365-water-and-jug-problem/</link>
      <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-365-water-and-jug-problem/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4133s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/365.webp&#34; &#xA;           alt=&#34;A set of water jugs being filled and emptied, with the optimal solution softly glowing as it reaches the target amount.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 365: Water and Jug Problem Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given two jugs with capacities x and y liters, and an infinite supply of water. You need to determine whether you can measure exactly target liters of water using the following operations: fill, empty, and pour water between the jugs.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 399: Evaluate Division</title>
      <link>http://localhost:1313/leetcode/solution-399-evaluate-division/</link>
      <pubDate>Sat, 28 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-399-evaluate-division/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4160s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/399.webp&#34; &#xA;           alt=&#34;A set of equations forming a division problem, with the answer softly glowing as it is calculated.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 399: Evaluate Division Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a list of equations and their corresponding values, where each equation represents a division between two variables. Your task is to determine the result of several queries asking for the division result of two given variables.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 417: Pacific Atlantic Water Flow</title>
      <link>http://localhost:1313/leetcode/solution-417-pacific-atlantic-water-flow/</link>
      <pubDate>Thu, 26 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-417-pacific-atlantic-water-flow/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4167s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/417.webp&#34; &#xA;           alt=&#34;A map with water flowing from both Pacific and Atlantic oceans, gently meeting at highlighted points.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 417: Pacific Atlantic Water Flow Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an m x n grid representing an island, where each cell contains an integer representing the height above sea level. The island borders both the Pacific and Atlantic Oceans. The Pacific Ocean touches the left and top edges of the grid, and the Atlantic Ocean touches the right and bottom edges. Water can flow from one cell to an adjacent cell if the adjacent cell&amp;rsquo;s height is less than or equal to the current cell&amp;rsquo;s height. The task is to find all the cells where water can flow to both oceans.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 429: N-ary Tree Level Order Traversal</title>
      <link>http://localhost:1313/leetcode/solution-429-n-ary-tree-level-order-traversal/</link>
      <pubDate>Wed, 25 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-429-n-ary-tree-level-order-traversal/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4174s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/429.webp&#34; &#xA;           alt=&#34;An N-ary tree with nodes being traversed in level order, with each level softly illuminated as it&amp;#39;s visited.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 429: N-ary Tree Level Order Traversal Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an n-ary tree where each node contains a value and a list of its children. Your task is to return the level order traversal of the tree&amp;rsquo;s nodes. Nodes are grouped by their level, with the root node at level 0. Each node’s children are separated by a null value in the level order serialization.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 433: Minimum Genetic Mutation</title>
      <link>http://localhost:1313/leetcode/solution-433-minimum-genetic-mutation/</link>
      <pubDate>Tue, 24 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-433-minimum-genetic-mutation/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4176s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/433.webp&#34; &#xA;           alt=&#34;A series of genes evolving through mutations, with each valid mutation softly glowing as it occurs.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 433: Minimum Genetic Mutation Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given two gene strings, &lt;code&gt;startGene&lt;/code&gt; and &lt;code&gt;endGene&lt;/code&gt;, both consisting of 8 characters. You also have a gene bank of valid gene strings that can be mutated into one another. A mutation is defined as changing one character at a time, and the mutated gene string must exist in the gene bank. Your task is to determine the minimum number of mutations needed to transform &lt;code&gt;startGene&lt;/code&gt; into &lt;code&gt;endGene&lt;/code&gt;. If transformation is impossible, return -1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 449: Serialize and Deserialize BST</title>
      <link>http://localhost:1313/leetcode/solution-449-serialize-and-deserialize-bst/</link>
      <pubDate>Mon, 23 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-449-serialize-and-deserialize-bst/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4183s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/449.webp&#34; &#xA;           alt=&#34;A binary search tree being serialized and deserialized, with each node softly glowing during the transformation.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 449: Serialize and Deserialize BST Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Design an algorithm to serialize and deserialize a binary search tree (BST). Serialization is converting the tree to a string format, while deserialization reconstructs the tree from this string. The goal is to ensure that the BST can be serialized to a compact string and can be accurately deserialized back into the original tree structure.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 513: Find Bottom Left Tree Value</title>
      <link>http://localhost:1313/leetcode/solution-513-find-bottom-left-tree-value/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-513-find-bottom-left-tree-value/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4211s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/513.webp&#34; &#xA;           alt=&#34;A tree with a glowing bottom-left node, showing the value of the deepest leftmost node in the binary tree.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 513: Find Bottom Left Tree Value Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the leftmost value in the last row of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 515: Find Largest Value in Each Tree Row</title>
      <link>http://localhost:1313/leetcode/solution-515-find-largest-value-in-each-tree-row/</link>
      <pubDate>Mon, 16 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-515-find-largest-value-in-each-tree-row/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4212s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/515.webp&#34; &#xA;           alt=&#34;A tree with rows of values, each row highlighted with the largest value softly glowing.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 515: Find Largest Value in Each Tree Row Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return an array of the largest value in each row of the tree (0-indexed).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 529: Minesweeper</title>
      <link>http://localhost:1313/leetcode/solution-529-minesweeper/</link>
      <pubDate>Sun, 15 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-529-minesweeper/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4222s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/529.webp&#34; &#xA;           alt=&#34;A glowing grid with mines and safe spots, where the player’s moves are highlighted to avoid mines.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 529: Minesweeper Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are playing the game Minesweeper. Given an m x n grid, you must reveal the square corresponding to the next click and update the grid according to Minesweeper&amp;rsquo;s rules. The grid can contain mines (&amp;lsquo;M&amp;rsquo;), empty squares (&amp;lsquo;E&amp;rsquo;), or revealed squares with adjacent mine counts.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 530: Minimum Absolute Difference in BST</title>
      <link>http://localhost:1313/leetcode/solution-530-minimum-absolute-difference-in-bst/</link>
      <pubDate>Sun, 15 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-530-minimum-absolute-difference-in-bst/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4224s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/530.webp&#34; &#xA;           alt=&#34;A binary search tree where nodes light up showing the minimum absolute difference between node values.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 530: Minimum Absolute Difference in BST Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 542: 01 Matrix</title>
      <link>http://localhost:1313/leetcode/solution-542-01-matrix/</link>
      <pubDate>Fri, 13 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-542-01-matrix/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4232s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/542.webp&#34; &#xA;           alt=&#34;A matrix where cells of 1s and 0s are arranged, with the shortest distance for 1s to 0s glowing softly.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 542: 01 Matrix Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given an m x n binary matrix, return the distance of the nearest 0 for each cell. The distance between two adjacent cells is 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 547: Number of Provinces</title>
      <link>http://localhost:1313/leetcode/solution-547-number-of-provinces/</link>
      <pubDate>Fri, 13 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-547-number-of-provinces/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4234s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/547.webp&#34; &#xA;           alt=&#34;A map of regions where provinces are counted and highlighted, each province glowing softly.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 547: Number of Provinces Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a matrix where each element indicates if two cities are directly connected. Your task is to determine the number of provinces formed by the cities. A province is a group of directly or indirectly connected cities.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 617: Merge Two Binary Trees</title>
      <link>http://localhost:1313/leetcode/solution-617-merge-two-binary-trees/</link>
      <pubDate>Fri, 06 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-617-merge-two-binary-trees/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4257s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/617.webp&#34; &#xA;           alt=&#34;Two binary trees merging together, with each node softly glowing as they combine.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 617: Merge Two Binary Trees Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given two binary trees, merge them into a new binary tree where overlapping nodes are summed, and non-overlapping nodes are retained as they are.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 623: Add One Row to Tree</title>
      <link>http://localhost:1313/leetcode/solution-623-add-one-row-to-tree/</link>
      <pubDate>Thu, 05 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-623-add-one-row-to-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4259s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/623.webp&#34; &#xA;           alt=&#34;A binary tree where a new row is being added, with the new row glowing as it is inserted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 623: Add One Row to Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree, and two integers val and depth. You need to add a row of nodes with value val at the given depth depth. The root node is considered to be at depth 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 655: Print Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-655-print-binary-tree/</link>
      <pubDate>Mon, 02 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-655-print-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4277s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/655.webp&#34; &#xA;           alt=&#34;A binary tree where nodes are printed visually, with the structure softly glowing as it is printed.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 655: Print Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;Given the root of a binary tree, construct a matrix representation of the tree using specific formatting rules to place each node in the appropriate position in the matrix.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 662: Maximum Width of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-662-maximum-width-of-binary-tree/</link>
      <pubDate>Sun, 01 Sep 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-662-maximum-width-of-binary-tree/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4291s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/662.webp&#34; &#xA;           alt=&#34;A binary tree where the maximum width is highlighted, with the width softly glowing as it’s measured.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 662: Maximum Width of Binary Tree Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Determine the maximum width of the tree, which is defined as the maximum width among all levels. The width of a level is the distance between the leftmost and rightmost non-null nodes, including null nodes in between that would be present in a complete binary tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 672: Bulb Switcher II</title>
      <link>http://localhost:1313/leetcode/solution-672-bulb-switcher-ii/</link>
      <pubDate>Sat, 31 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-672-bulb-switcher-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4285s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/672.webp&#34; &#xA;           alt=&#34;A set of bulbs where switches are turned on and off, with each change softly glowing.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 672: Bulb Switcher II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are in a room with &lt;code&gt;n&lt;/code&gt; bulbs, all initially turned on. There are four buttons on the wall, each with a different functionality: flip all bulbs, flip even-numbered bulbs, flip odd-numbered bulbs, and flip bulbs with labels &lt;code&gt;j = 3k + 1&lt;/code&gt;. You need to make exactly &lt;code&gt;presses&lt;/code&gt; presses. For each press, you can choose any button. Return the number of distinct possible configurations of the bulbs after performing all the presses.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 684: Redundant Connection</title>
      <link>http://localhost:1313/leetcode/solution-684-redundant-connection/</link>
      <pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-684-redundant-connection/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4290s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/684.webp&#34; &#xA;           alt=&#34;A graph where redundant connections are detected and softly glowing to indicate the loop.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 684: Redundant Connection Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a graph that started as a tree with n nodes. One additional edge has been added, creating a cycle. Your task is to find and return the redundant edge that, when removed, would turn the graph back into a tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 695: Max Area of Island</title>
      <link>http://localhost:1313/leetcode/solution-695-max-area-of-island/</link>
      <pubDate>Thu, 29 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-695-max-area-of-island/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4296s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/695.webp&#34; &#xA;           alt=&#34;A map of islands where the maximum area is calculated and softly glowing as the largest island is found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 695: Max Area of Island Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a binary matrix of size m x n, where 1 represents land and 0 represents water. An island is a group of 1&amp;rsquo;s connected horizontally or vertically. Return the area of the largest island. If there are no islands, return 0.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 721: Accounts Merge</title>
      <link>http://localhost:1313/leetcode/solution-721-accounts-merge/</link>
      <pubDate>Mon, 26 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-721-accounts-merge/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4311s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/721.webp&#34; &#xA;           alt=&#34;A set of accounts where identical accounts are merged, with each merge softly glowing as it’s processed.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 721: Accounts Merge Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a list of accounts, where each account consists of a name and a list of emails. Merge accounts that share common emails, and return the merged accounts in the format: name followed by sorted emails.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 733: Flood Fill</title>
      <link>http://localhost:1313/leetcode/solution-733-flood-fill/</link>
      <pubDate>Sun, 25 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-733-flood-fill/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4318s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/733.webp&#34; &#xA;           alt=&#34;A grid where the flood fill algorithm is applied, with the flooded area glowing softly as it spreads.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 733: Flood Fill Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an m x n grid representing an image, where each element in the grid corresponds to a pixel value. Additionally, you&amp;rsquo;re provided with three integers: sr (starting row), sc (starting column), and color. Your task is to perform a flood fill operation on the image starting at the pixel located at (sr, sc).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 743: Network Delay Time</title>
      <link>http://localhost:1313/leetcode/solution-743-network-delay-time/</link>
      <pubDate>Sat, 24 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-743-network-delay-time/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4324s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/743.webp&#34; &#xA;           alt=&#34;A network of nodes where the delay time is calculated, with the shortest delay glowing softly as it’s found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 743: Network Delay Time Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a network of &lt;code&gt;n&lt;/code&gt; nodes and a list of directed edges with travel times. You need to send a signal from a given node &lt;code&gt;k&lt;/code&gt;. Return the minimum time it takes for all nodes to receive the signal, or return &lt;code&gt;-1&lt;/code&gt; if it is impossible.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 752: Open the Lock</title>
      <link>http://localhost:1313/leetcode/solution-752-open-the-lock/</link>
      <pubDate>Fri, 23 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-752-open-the-lock/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4328s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/752.webp&#34; &#xA;           alt=&#34;A lock with combination digits, where each correct digit softly glows as it’s guessed correctly.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 752: Open the Lock Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a lock with 4 rotating wheels, each containing 10 slots labeled &amp;lsquo;0&amp;rsquo; to &amp;lsquo;9&amp;rsquo;. The wheels can rotate freely and wrap around. You must determine the minimum number of moves required to reach a target lock configuration, avoiding certain deadends.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 756: Pyramid Transition Matrix</title>
      <link>http://localhost:1313/leetcode/solution-756-pyramid-transition-matrix/</link>
      <pubDate>Fri, 23 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-756-pyramid-transition-matrix/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4330s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/756.webp&#34; &#xA;           alt=&#34;A pyramid structure where transitions occur, with the valid transitions glowing softly as they are made.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 756: Pyramid Transition Matrix Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are building a pyramid by stacking blocks, each represented by a color denoted by a letter. Each row above the bottom consists of one less block, centered on the row beneath. Only specific triangular patterns of blocks are allowed. A triangular pattern consists of three blocks: two at the bottom and one on top. Given the bottom row and allowed patterns, determine if it&amp;rsquo;s possible to construct the pyramid.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 785: Is Graph Bipartite?</title>
      <link>http://localhost:1313/leetcode/solution-785-is-graph-bipartite/</link>
      <pubDate>Tue, 20 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-785-is-graph-bipartite/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4343s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/785.webp&#34; &#xA;           alt=&#34;A graph where bipartiteness is checked, with the two sets glowing softly as they are separated.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 785: Is Graph Bipartite? Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given an undirected graph where each node is labeled between 0 and n - 1. The graph is represented as a 2D array, where graph[u] contains the nodes that are adjacent to node u. A graph is bipartite if its nodes can be divided into two sets such that every edge connects a node from one set to a node in the other set. Your task is to return true if the graph is bipartite, otherwise return false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 787: Cheapest Flights Within K Stops</title>
      <link>http://localhost:1313/leetcode/solution-787-cheapest-flights-within-k-stops/</link>
      <pubDate>Tue, 20 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-787-cheapest-flights-within-k-stops/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4345s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/787.webp&#34; &#xA;           alt=&#34;A map where the cheapest flight path is calculated, glowing softly as the optimal path is found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 787: Cheapest Flights Within K Stops Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a number of cities and a list of flights between them. Each flight has a price and connects two cities. You need to find the cheapest route from a given source city to a destination city with at most a certain number of stops. If no such route exists, return -1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 797: All Paths From Source to Target</title>
      <link>http://localhost:1313/leetcode/solution-797-all-paths-from-source-to-target/</link>
      <pubDate>Mon, 19 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-797-all-paths-from-source-to-target/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4354s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/797.webp&#34; &#xA;           alt=&#34;A graph where all paths are traced from source to target, with each path softly glowing as it is found.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 797: All Paths From Source to Target Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a directed acyclic graph (DAG) with &lt;code&gt;n&lt;/code&gt; nodes, labeled from 0 to n-1. Find all possible paths from node 0 to node n-1 and return these paths in any order. The graph is represented such that each node has a list of other nodes that can be visited directly from it.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 802: Find Eventual Safe States</title>
      <link>http://localhost:1313/leetcode/solution-802-find-eventual-safe-states/</link>
      <pubDate>Sun, 18 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-802-find-eventual-safe-states/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode4357s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/802.webp&#34; &#xA;           alt=&#34;A graph with nodes marked as safe, glowing softly as they are identified.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 802: Find Eventual Safe States Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&lt;p&gt;You are given a directed graph where each node represents a point, and edges represent possible transitions between nodes. A node is considered terminal if it has no outgoing edges. A node is deemed safe if every path starting from it leads either to a terminal node or another safe node. Your task is to identify all the safe nodes in the graph and return them in ascending order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 841: Keys and Rooms</title>
      <link>http://localhost:1313/leetcode/solution-841-keys-and-rooms/</link>
      <pubDate>Wed, 14 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-841-keys-and-rooms/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are in a building with multiple rooms, each containing a set of keys to unlock other rooms. Initially, only the first room (room 0) is unlocked. You are tasked with determining whether you can visit all the rooms, starting from room 0. To enter a locked room, you must have its corresponding key, which can only be obtained by visiting other rooms.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 863: All Nodes Distance K in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-863-all-nodes-distance-k-in-binary-tree/</link>
      <pubDate>Mon, 12 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-863-all-nodes-distance-k-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a binary tree, a target node within the tree, and a non-negative integer k, determine all the nodes that are exactly k edges away from the target node. Return these node values as a list in any order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 865: Smallest Subtree with all the Deepest Nodes</title>
      <link>http://localhost:1313/leetcode/solution-865-smallest-subtree-with-all-the-deepest-nodes/</link>
      <pubDate>Mon, 12 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-865-smallest-subtree-with-all-the-deepest-nodes/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the smallest subtree that contains all the nodes with the maximum depth in the tree. A node is considered the deepest if it has the greatest distance to the root among all nodes. The subtree of a node consists of the node itself and all its descendants.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 886: Possible Bipartition</title>
      <link>http://localhost:1313/leetcode/solution-886-possible-bipartition/</link>
      <pubDate>Sat, 10 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-886-possible-bipartition/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a group of n people, labeled from 1 to n. Each person may dislike other people, and they should not be placed in the same group. Your task is to determine if it is possible to split the group of people into two subgroups, such that no one in the same group dislikes each other. Each pair of dislikes is represented by an array of two people who cannot be in the same group. Return true if such a split is possible, otherwise return false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 909: Snakes and Ladders</title>
      <link>http://localhost:1313/leetcode/solution-909-snakes-and-ladders/</link>
      <pubDate>Thu, 08 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-909-snakes-and-ladders/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an n x n integer matrix &lt;code&gt;board&lt;/code&gt; where the cells are numbered from 1 to n² in a zigzag pattern starting from the bottom-left corner. Each cell may contain either &lt;code&gt;-1&lt;/code&gt; (indicating no special feature) or a number indicating a snake or ladder destination. You start at square 1 and can roll a 6-sided die to move between 1 and 6 steps. If you land on a square with a snake or ladder, you must move to its destination. Determine the minimum number of dice rolls needed to reach the final square &lt;code&gt;n²&lt;/code&gt;. Return -1 if it is not possible.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 919: Complete Binary Tree Inserter</title>
      <link>http://localhost:1313/leetcode/solution-919-complete-binary-tree-inserter/</link>
      <pubDate>Wed, 07 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-919-complete-binary-tree-inserter/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a complete binary tree. A complete binary tree is one where every level, except possibly the last, is completely filled, and all nodes are as far left as possible. Your task is to design a data structure that supports inserting new nodes while maintaining the completeness of the binary tree. Implement the CBTInserter class that supports two operations: inserting a new node and returning the root of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 934: Shortest Bridge</title>
      <link>http://localhost:1313/leetcode/solution-934-shortest-bridge/</link>
      <pubDate>Mon, 05 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-934-shortest-bridge/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an n x n binary matrix where 1 represents land and 0 represents water. There are exactly two islands in the grid, and you need to connect them by flipping the smallest number of 0&amp;rsquo;s to 1&amp;rsquo;s. An island is a group of 1&amp;rsquo;s that are connected horizontally or vertically. Your task is to find the minimum number of flips required to connect the two islands.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 958: Check Completeness of a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-958-check-completeness-of-a-binary-tree/</link>
      <pubDate>Sat, 03 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-958-check-completeness-of-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree. Determine if the tree is a complete binary tree. A complete binary tree is defined as follows: every level, except possibly the last, is completely filled, and all nodes in the last level are as far left as possible.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 959: Regions Cut By Slashes</title>
      <link>http://localhost:1313/leetcode/solution-959-regions-cut-by-slashes/</link>
      <pubDate>Sat, 03 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-959-regions-cut-by-slashes/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an n x n grid where each cell contains one of the following characters: &amp;lsquo;/&amp;rsquo;, &amp;lsquo;&#39;, or &amp;rsquo; &amp;lsquo;. These characters divide the grid into different regions. Your task is to determine how many distinct regions the grid is divided into.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 967: Numbers With Same Consecutive Differences</title>
      <link>http://localhost:1313/leetcode/solution-967-numbers-with-same-consecutive-differences/</link>
      <pubDate>Fri, 02 Aug 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-967-numbers-with-same-consecutive-differences/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Generate all numbers of length n such that the absolute difference between every two consecutive digits is exactly k. The generated numbers must not have leading zeros, and all digits should be valid.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 994: Rotting Oranges</title>
      <link>http://localhost:1313/leetcode/solution-994-rotting-oranges/</link>
      <pubDate>Tue, 30 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-994-rotting-oranges/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an m x n grid where each cell can be empty, contain a fresh orange, or a rotten orange. Every minute, any fresh orange that is adjacent to a rotten orange becomes rotten. The task is to determine the minimum number of minutes required for all fresh oranges to rot. If this is not possible, return -1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1020: Number of Enclaves</title>
      <link>http://localhost:1313/leetcode/solution-1020-number-of-enclaves/</link>
      <pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1020-number-of-enclaves/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a grid of size m x n where each cell is either land (1) or sea (0). Your task is to determine the number of land cells that are completely enclosed by sea cells. A land cell is considered enclosed if it cannot reach the boundary of the grid via other land cells.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1034: Coloring A Border</title>
      <link>http://localhost:1313/leetcode/solution-1034-coloring-a-border/</link>
      <pubDate>Fri, 26 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1034-coloring-a-border/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an m x n grid of integers where each value represents the color of a cell. You are also given three integers: &lt;code&gt;row&lt;/code&gt;, &lt;code&gt;col&lt;/code&gt;, and &lt;code&gt;color&lt;/code&gt;. The task is to change the color of the border of the connected component containing the cell at &lt;code&gt;grid[row][col]&lt;/code&gt;. A connected component is defined as a group of adjacent cells that have the same color. A border cell is a cell that is either adjacent to a different color cell or is on the boundary of the grid. You should return the updated grid where the border of the connected component is colored with the specified color.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1042: Flower Planting With No Adjacent</title>
      <link>http://localhost:1313/leetcode/solution-1042-flower-planting-with-no-adjacent/</link>
      <pubDate>Thu, 25 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1042-flower-planting-with-no-adjacent/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given n gardens labeled from 1 to n, and an array paths where paths[i] = [xi, yi] describes a bidirectional path between garden xi and garden yi. Each garden needs to be assigned one of 4 types of flowers. You need to ensure that for any two gardens connected by a path, they have different types of flowers. Your task is to return any valid flower assignment for all gardens such that no two adjacent gardens share the same flower type.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1091: Shortest Path in Binary Matrix</title>
      <link>http://localhost:1313/leetcode/solution-1091-shortest-path-in-binary-matrix/</link>
      <pubDate>Sat, 20 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1091-shortest-path-in-binary-matrix/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given an n x n binary matrix grid, find the shortest clear path in the matrix that connects the top-left cell (0, 0) to the bottom-right cell (n-1, n-1). A clear path is defined as a path where all cells along the path are 0, and the path can move in 8 possible directions (up, down, left, right, and diagonals). Return the length of the shortest clear path, or -1 if no such path exists.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1123: Lowest Common Ancestor of Deepest Leaves</title>
      <link>http://localhost:1313/leetcode/solution-1123-lowest-common-ancestor-of-deepest-leaves/</link>
      <pubDate>Wed, 17 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1123-lowest-common-ancestor-of-deepest-leaves/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, your task is to return the lowest common ancestor (LCA) of its deepest leaf nodes. The LCA of a set of nodes is the deepest node that is an ancestor of all the nodes in the set. A leaf node is one that does not have any children.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1129: Shortest Path with Alternating Colors</title>
      <link>http://localhost:1313/leetcode/solution-1129-shortest-path-with-alternating-colors/</link>
      <pubDate>Wed, 17 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1129-shortest-path-with-alternating-colors/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a directed graph with n nodes, where each node is labeled from 0 to n-1. The graph contains edges that can be either red or blue. You are provided with two lists of edges: redEdges and blueEdges, where redEdges[i] = [ai, bi] indicates a directed red edge from node ai to node bi, and blueEdges[j] = [uj, vj] indicates a directed blue edge from node uj to node vj. Your goal is to find the shortest alternating path from node 0 to each node x. Return an array answer where each answer[x] is the length of the shortest alternating path from node 0 to node x, or -1 if no such path exists.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1161: Maximum Level Sum of a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1161-maximum-level-sum-of-a-binary-tree/</link>
      <pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1161-maximum-level-sum-of-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, find the smallest level x (1-indexed) such that the sum of the values of nodes at level x is maximal. Each level of the tree corresponds to the distance from the root, with the root being level 1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1162: As Far from Land as Possible</title>
      <link>http://localhost:1313/leetcode/solution-1162-as-far-from-land-as-possible/</link>
      <pubDate>Sat, 13 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1162-as-far-from-land-as-possible/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a square grid of size n x n containing only 0s (water) and 1s (land), find the water cell that is farthest from any land cell based on Manhattan distance, and return that distance. If the grid has no water or no land, return -1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1202: Smallest String With Swaps</title>
      <link>http://localhost:1313/leetcode/solution-1202-smallest-string-with-swaps/</link>
      <pubDate>Tue, 09 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1202-smallest-string-with-swaps/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a string s and an array of pairs of indices pairs where each pair pairs[i] = [a, b] represents two indices in the string. You can swap the characters at any of these index pairs any number of times. Your task is to return the lexicographically smallest string that can be obtained after performing the swaps.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1254: Number of Closed Islands</title>
      <link>http://localhost:1313/leetcode/solution-1254-number-of-closed-islands/</link>
      <pubDate>Thu, 04 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1254-number-of-closed-islands/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 2D grid with 0s (land) and 1s (water). An island is a group of 0s connected 4-directionally, and a closed island is a group of 0s completely surrounded by 1s. Your task is to count how many closed islands are present in the grid.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1261: Find Elements in a Contaminated Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1261-find-elements-in-a-contaminated-binary-tree/</link>
      <pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1261-find-elements-in-a-contaminated-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a contaminated binary tree, recover it and implement a class to search for specific values in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1267: Count Servers that Communicate</title>
      <link>http://localhost:1313/leetcode/solution-1267-count-servers-that-communicate/</link>
      <pubDate>Wed, 03 Jul 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1267-count-servers-that-communicate/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 2D grid where each cell is either 1 (indicating a server) or 0 (no server). Two servers are said to communicate if they are in the same row or column. The task is to find the number of servers that can communicate with at least one other server.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1302: Deepest Leaves Sum</title>
      <link>http://localhost:1313/leetcode/solution-1302-deepest-leaves-sum/</link>
      <pubDate>Sat, 29 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1302-deepest-leaves-sum/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the sum of values of its deepest leaves. The deepest leaves are the nodes found at the lowest level of the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1306: Jump Game III</title>
      <link>http://localhost:1313/leetcode/solution-1306-jump-game-iii/</link>
      <pubDate>Sat, 29 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1306-jump-game-iii/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an array of non-negative integers arr and a starting index start. You can jump forward or backward from any index based on the values at the index. Your task is to determine whether you can reach an index with a value of 0.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1311: Get Watched Videos by Your Friends</title>
      <link>http://localhost:1313/leetcode/solution-1311-get-watched-videos-by-your-friends/</link>
      <pubDate>Fri, 28 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1311-get-watched-videos-by-your-friends/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given &lt;code&gt;n&lt;/code&gt; people with unique IDs and two lists: &lt;code&gt;watchedVideos&lt;/code&gt; and &lt;code&gt;friends&lt;/code&gt;. For a given ID and a level &lt;code&gt;k&lt;/code&gt;, find the list of videos watched by people at exactly level &lt;code&gt;k&lt;/code&gt; from you. Return the videos ordered by their frequency (in increasing order), and alphabetically if there is a tie in frequency.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1315: Sum of Nodes with Even-Valued Grandparent</title>
      <link>http://localhost:1313/leetcode/solution-1315-sum-of-nodes-with-even-valued-grandparent/</link>
      <pubDate>Fri, 28 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1315-sum-of-nodes-with-even-valued-grandparent/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, return the sum of the values of the nodes that have an even-valued grandparent. If there are no nodes with an even-valued grandparent, return 0. A grandparent is defined as the parent of a node’s parent, if it exists.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1319: Number of Operations to Make Network Connected</title>
      <link>http://localhost:1313/leetcode/solution-1319-number-of-operations-to-make-network-connected/</link>
      <pubDate>Fri, 28 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1319-number-of-operations-to-make-network-connected/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a network of computers, each labeled from 0 to n-1, and a list of direct connections between these computers. The network is initially connected in some way, but some computers are not directly connected. You can remove cables from existing direct connections and reconnect them between disconnected computers to minimize the number of operations required to make the entire network fully connected. The task is to determine the minimum number of operations needed. If it&amp;rsquo;s not possible to connect all the computers, return -1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1361: Validate Binary Tree Nodes</title>
      <link>http://localhost:1313/leetcode/solution-1361-validate-binary-tree-nodes/</link>
      <pubDate>Sun, 23 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1361-validate-binary-tree-nodes/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given &lt;code&gt;n&lt;/code&gt; nodes in a binary tree, numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;. Each node &lt;code&gt;i&lt;/code&gt; has two children: &lt;code&gt;leftChild[i]&lt;/code&gt; and &lt;code&gt;rightChild[i]&lt;/code&gt;. If a node has no left child, its value will be &lt;code&gt;-1&lt;/code&gt;. Similarly, if a node has no right child, its value will also be &lt;code&gt;-1&lt;/code&gt;. Your task is to return &lt;code&gt;true&lt;/code&gt; if and only if these nodes form exactly one valid binary tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1376: Time Needed to Inform All Employees</title>
      <link>http://localhost:1313/leetcode/solution-1376-time-needed-to-inform-all-employees/</link>
      <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1376-time-needed-to-inform-all-employees/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;A company has &lt;code&gt;n&lt;/code&gt; employees with a unique ID for each employee from 0 to n-1. The head of the company is the one with &lt;code&gt;headID&lt;/code&gt;. Each employee has one direct manager. The head will inform his direct subordinates, and they will inform their subordinates, and so on until all employees know about the urgent news. Each employee needs &lt;code&gt;informTime[i]&lt;/code&gt; minutes to inform their direct subordinates. Return the total time required to inform all employees.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1379: Find a Corresponding Node of a Binary Tree in a Clone of That Tree</title>
      <link>http://localhost:1313/leetcode/solution-1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/</link>
      <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1379-find-a-corresponding-node-of-a-binary-tree-in-a-clone-of-that-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given two binary trees: an original tree and a cloned tree. The cloned tree is a copy of the original tree, and you are given a reference to a node in the original tree. Your task is to return the reference to the corresponding node in the cloned tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1391: Check if There is a Valid Path in a Grid</title>
      <link>http://localhost:1313/leetcode/solution-1391-check-if-there-is-a-valid-path-in-a-grid/</link>
      <pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1391-check-if-there-is-a-valid-path-in-a-grid/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an m x n grid where each cell represents a street. The streets have different connections between neighboring cells. Starting from the top-left corner of the grid, you need to find if there exists a valid path to the bottom-right corner, following the direction of the streets.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1443: Minimum Time to Collect All Apples in a Tree</title>
      <link>http://localhost:1313/leetcode/solution-1443-minimum-time-to-collect-all-apples-in-a-tree/</link>
      <pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1443-minimum-time-to-collect-all-apples-in-a-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an undirected tree with &lt;code&gt;n&lt;/code&gt; vertices numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;. Some vertices in this tree contain apples. Each edge in the tree requires &lt;code&gt;1 second&lt;/code&gt; to traverse. Starting at vertex &lt;code&gt;0&lt;/code&gt;, determine the minimum time required to collect all apples and return to vertex &lt;code&gt;0&lt;/code&gt;. The tree structure is described by the array &lt;code&gt;edges&lt;/code&gt;, where &lt;code&gt;edges[i] = [ai, bi]&lt;/code&gt; indicates an edge between vertices &lt;code&gt;ai&lt;/code&gt; and &lt;code&gt;bi&lt;/code&gt;. Additionally, the array &lt;code&gt;hasApple&lt;/code&gt; specifies whether a vertex contains an apple (&lt;code&gt;true&lt;/code&gt;) or not (&lt;code&gt;false&lt;/code&gt;).&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1448: Count Good Nodes in Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1448-count-good-nodes-in-binary-tree/</link>
      <pubDate>Sat, 15 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1448-count-good-nodes-in-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, a node is considered &amp;lsquo;good&amp;rsquo; if in the path from the root to that node, there are no nodes with a value greater than the node itself. Return the total number of good nodes in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1457: Pseudo-Palindromic Paths in a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-1457-pseudo-palindromic-paths-in-a-binary-tree/</link>
      <pubDate>Fri, 14 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1457-pseudo-palindromic-paths-in-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary tree where each node contains a digit from 1 to 9. A path from the root to a leaf node is considered pseudo-palindromic if at least one permutation of the node values in the path can form a palindrome. Your task is to return the number of pseudo-palindromic paths in the tree.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1462: Course Schedule IV</title>
      <link>http://localhost:1313/leetcode/solution-1462-course-schedule-iv/</link>
      <pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1462-course-schedule-iv/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a set of courses numbered from 0 to numCourses - 1 and a list of prerequisites. Each prerequisite is a pair [ai, bi], indicating that you must complete course ai before course bi. For a series of queries, where each query asks whether a specific course is a prerequisite for another, you are tasked with determining whether each query is true or false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1466: Reorder Routes to Make All Paths Lead to the City Zero</title>
      <link>http://localhost:1313/leetcode/solution-1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero/</link>
      <pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1466-reorder-routes-to-make-all-paths-lead-to-the-city-zero/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given n cities and n - 1 roads, forming a tree structure. The roads have been directed, and some roads may need to be reoriented to ensure all cities can reach the capital city (city 0). Your task is to determine the minimum number of road reorientations required to make it possible for each city to reach city 0.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1519: Number of Nodes in the Sub-Tree With the Same Label</title>
      <link>http://localhost:1313/leetcode/solution-1519-number-of-nodes-in-the-sub-tree-with-the-same-label/</link>
      <pubDate>Sat, 08 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1519-number-of-nodes-in-the-sub-tree-with-the-same-label/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a tree with &lt;code&gt;n&lt;/code&gt; nodes, where each node has a label, and your task is to find the number of nodes in the subtree rooted at each node that have the same label as that node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1559: Detect Cycles in 2D Grid</title>
      <link>http://localhost:1313/leetcode/solution-1559-detect-cycles-in-2d-grid/</link>
      <pubDate>Tue, 04 Jun 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1559-detect-cycles-in-2d-grid/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a 2D grid of characters, find if there exists a cycle where the same character repeats in the grid. A cycle is defined as a path where a character appears 4 or more times, forming a loop that starts and ends at the same cell. The cycle must consist of adjacent cells, and you are not allowed to revisit the previous cell.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1609: Even Odd Tree</title>
      <link>http://localhost:1313/leetcode/solution-1609-even-odd-tree/</link>
      <pubDate>Thu, 30 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1609-even-odd-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;A binary tree is called Even-Odd if the values in each level of the tree follow certain rules. For every even-indexed level, all nodes must contain odd integers in strictly increasing order. For every odd-indexed level, all nodes must contain even integers in strictly decreasing order. Given the root of a binary tree, return true if the tree is Even-Odd, otherwise return false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1625: Lexicographically Smallest String After Applying Operations</title>
      <link>http://localhost:1313/leetcode/solution-1625-lexicographically-smallest-string-after-applying-operations/</link>
      <pubDate>Tue, 28 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1625-lexicographically-smallest-string-after-applying-operations/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a string s of even length consisting of digits from 0 to 9, and two integers a and b, return the lexicographically smallest string that can be obtained by applying two operations any number of times: adding a to all odd indices of s (with wrapping) and rotating s to the right by b positions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1631: Path With Minimum Effort</title>
      <link>http://localhost:1313/leetcode/solution-1631-path-with-minimum-effort/</link>
      <pubDate>Mon, 27 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1631-path-with-minimum-effort/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are a hiker navigating a terrain represented by a 2D grid of heights. Your goal is to find the path from the top-left corner to the bottom-right corner that minimizes the maximum height difference between any two consecutive cells.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1765: Map of Highest Peak</title>
      <link>http://localhost:1313/leetcode/solution-1765-map-of-highest-peak/</link>
      <pubDate>Tue, 14 May 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1765-map-of-highest-peak/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given a 2D grid where each cell is either water (1) or land (0), assign heights to the land cells such that the height difference between adjacent cells is at most 1. The goal is to maximize the height values of land cells while ensuring the height of water cells is 0. Return the grid with assigned heights.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1905: Count Sub Islands</title>
      <link>http://localhost:1313/leetcode/solution-1905-count-sub-islands/</link>
      <pubDate>Tue, 30 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1905-count-sub-islands/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given two m x n binary matrices, grid1 and grid2, where each cell can either be 0 (representing water) or 1 (representing land). An island is a group of connected 1&amp;rsquo;s, connected either horizontally or vertically. An island in grid2 is considered a sub-island if there is a corresponding island in grid1 that contains all the cells of the island in grid2. Your task is to determine the number of sub-islands in grid2.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1926: Nearest Exit from Entrance in Maze</title>
      <link>http://localhost:1313/leetcode/solution-1926-nearest-exit-from-entrance-in-maze/</link>
      <pubDate>Sun, 28 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1926-nearest-exit-from-entrance-in-maze/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a maze and need to find the nearest exit from the entrance. An exit is defined as an empty cell on the border of the maze. Return the shortest path to the nearest exit, or -1 if no exit is reachable.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1971: Find if Path Exists in Graph</title>
      <link>http://localhost:1313/leetcode/solution-1971-find-if-path-exists-in-graph/</link>
      <pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1971-find-if-path-exists-in-graph/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a graph with &lt;code&gt;n&lt;/code&gt; vertices labeled from 0 to &lt;code&gt;n-1&lt;/code&gt; (inclusive) and edges connecting pairs of vertices. Your task is to determine if there exists a valid path from a given source vertex to a destination vertex. The graph is undirected, and each pair of vertices is connected by at most one edge. The vertices are connected by edges as given in the input.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1992: Find All Groups of Farmland</title>
      <link>http://localhost:1313/leetcode/solution-1992-find-all-groups-of-farmland/</link>
      <pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1992-find-all-groups-of-farmland/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an m x n binary matrix representing a piece of land, where &amp;lsquo;1&amp;rsquo; denotes farmland and &amp;lsquo;0&amp;rsquo; denotes forest. Your task is to identify the coordinates of each rectangular group of contiguous farmland (1&amp;rsquo;s), where each group of farmland is isolated and not adjacent to another group. Return a list of 4-length arrays, where each array represents the top-left and bottom-right coordinates of a rectangular farmland group.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1993: Operations on Tree</title>
      <link>http://localhost:1313/leetcode/solution-1993-operations-on-tree/</link>
      <pubDate>Sun, 21 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-1993-operations-on-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a tree with &lt;code&gt;n&lt;/code&gt; nodes numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n - 1&lt;/code&gt; represented by a &lt;code&gt;parent&lt;/code&gt; array. You need to implement the &lt;code&gt;LockingTree&lt;/code&gt; class with methods for locking, unlocking, and upgrading nodes in the tree based on certain conditions.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2039: The Time When the Network Becomes Idle</title>
      <link>http://localhost:1313/leetcode/solution-2039-the-time-when-the-network-becomes-idle/</link>
      <pubDate>Wed, 17 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2039-the-time-when-the-network-becomes-idle/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are managing a network of servers connected by communication channels. One server, labeled as 0, acts as the master server, while the others are data servers. Each data server sends a message to the master server at the start and waits for a reply. The reply travels back via the same route the message took. If a server does not receive a reply within a specific period (defined by its patience value), it resends the message. The goal is to determine when the network will become idle, meaning there are no active messages being transmitted or received.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2059: Minimum Operations to Convert Number</title>
      <link>http://localhost:1313/leetcode/solution-2059-minimum-operations-to-convert-number/</link>
      <pubDate>Mon, 15 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2059-minimum-operations-to-convert-number/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 0-indexed integer array nums, containing distinct numbers, an integer start, and an integer goal. There is an integer x, initially set to start, and you need to transform x into goal by repeatedly performing operations. You can use any number from the array nums in the following ways: x + nums[i], x - nums[i], or x ^ nums[i] (bitwise-XOR). You can perform each operation any number of times in any order. If the resulting number goes outside the range 0 &amp;lt;= x &amp;lt;= 1000, no further operations can be performed. The task is to determine the minimum number of operations required to convert x from start to goal, or return -1 if it is not possible.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2101: Detonate the Maximum Bombs</title>
      <link>http://localhost:1313/leetcode/solution-2101-detonate-the-maximum-bombs/</link>
      <pubDate>Wed, 10 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2101-detonate-the-maximum-bombs/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a list of bombs represented by a 2D array &amp;lsquo;bombs&amp;rsquo; where each bomb is described by three integers: [xi, yi, ri]. xi and yi denote the X and Y coordinates of the bomb, while ri is its blast radius. Your task is to find the maximum number of bombs that can be detonated by initiating a detonation of one bomb.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2146: K Highest Ranked Items Within a Price Range</title>
      <link>http://localhost:1313/leetcode/solution-2146-k-highest-ranked-items-within-a-price-range/</link>
      <pubDate>Sat, 06 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2146-k-highest-ranked-items-within-a-price-range/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 2D grid representing a shop map with walls, empty spaces, and items with prices. Your task is to find the top &lt;code&gt;k&lt;/code&gt; highest-ranked items within a given price range. The ranking is based on distance, price, row, and column number.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2192: All Ancestors of a Node in a Directed Acyclic Graph</title>
      <link>http://localhost:1313/leetcode/solution-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/</link>
      <pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a directed acyclic graph (DAG) with &lt;code&gt;n&lt;/code&gt; nodes, numbered from 0 to &lt;code&gt;n-1&lt;/code&gt;. Along with this, you are given a list of directed edges where each edge &lt;code&gt;[fromi, toi]&lt;/code&gt; indicates a directed edge from node &lt;code&gt;fromi&lt;/code&gt; to node &lt;code&gt;toi&lt;/code&gt;. For each node in the graph, you need to determine the list of all its ancestors. A node &lt;code&gt;u&lt;/code&gt; is an ancestor of node &lt;code&gt;v&lt;/code&gt; if there is a path from &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt; through one or more directed edges. Return a list &lt;code&gt;answer&lt;/code&gt; where &lt;code&gt;answer[i]&lt;/code&gt; contains the sorted list of ancestors of the &lt;code&gt;i&lt;/code&gt;-th node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2316: Count Unreachable Pairs of Nodes in an Undirected Graph</title>
      <link>http://localhost:1313/leetcode/solution-2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/</link>
      <pubDate>Wed, 20 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2316-count-unreachable-pairs-of-nodes-in-an-undirected-graph/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given an undirected graph with n nodes and a list of edges connecting the nodes. The goal is to find the number of pairs of distinct nodes that are unreachable from each other.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2368: Reachable Nodes With Restrictions</title>
      <link>http://localhost:1313/leetcode/solution-2368-reachable-nodes-with-restrictions/</link>
      <pubDate>Fri, 15 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2368-reachable-nodes-with-restrictions/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a tree with n nodes and n - 1 edges, where nodes are labeled from 0 to n - 1. Additionally, a list of restricted nodes is provided. Your goal is to determine the maximum number of nodes that can be visited starting from node 0, without passing through any restricted node. Node 0 itself is not restricted.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2385: Amount of Time for Binary Tree to Be Infected</title>
      <link>http://localhost:1313/leetcode/solution-2385-amount-of-time-for-binary-tree-to-be-infected/</link>
      <pubDate>Wed, 13 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2385-amount-of-time-for-binary-tree-to-be-infected/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree where each node has a unique value, and an integer start representing the initial infected node. At minute 0, the infection begins at the node with value start. Each minute, an adjacent uninfected node becomes infected. Your task is to return the total number of minutes it takes for the entire tree to become infected.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2415: Reverse Odd Levels of Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-2415-reverse-odd-levels-of-binary-tree/</link>
      <pubDate>Sun, 10 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2415-reverse-odd-levels-of-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a perfect binary tree, reverse the values of the nodes at each odd level of the tree. The level of a node is defined as the number of edges along the path from the root to the node. A perfect binary tree is one where all nodes have two children and all leaves are on the same level.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2467: Most Profitable Path in a Tree</title>
      <link>http://localhost:1313/leetcode/solution-2467-most-profitable-path-in-a-tree/</link>
      <pubDate>Tue, 05 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2467-most-profitable-path-in-a-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;In a tree with n nodes labeled from 0 to n - 1, each node has a gate with a price to open. Alice starts at node 0 and Bob starts at node bob. Alice moves towards a leaf node, and Bob moves towards node 0. At every node, both Alice and Bob either pay the price to open the gate, or they receive a reward. If they reach a node simultaneously, they share the price/reward equally. Return the maximum net income Alice can achieve if she travels towards the optimal leaf node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2471: Minimum Number of Operations to Sort a Binary Tree by Level</title>
      <link>http://localhost:1313/leetcode/solution-2471-minimum-number-of-operations-to-sort-a-binary-tree-by-level/</link>
      <pubDate>Mon, 04 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2471-minimum-number-of-operations-to-sort-a-binary-tree-by-level/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given the root of a binary tree with unique values. In one operation, you can choose any two nodes at the same level and swap their values. Return the minimum number of operations needed to make the values at each level sorted in strictly increasing order.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2477: Minimum Fuel Cost to Report to the Capital</title>
      <link>http://localhost:1313/leetcode/solution-2477-minimum-fuel-cost-to-report-to-the-capital/</link>
      <pubDate>Mon, 04 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2477-minimum-fuel-cost-to-report-to-the-capital/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;A country network consists of n cities connected by n-1 bidirectional roads. The capital city is city 0, and each city has one representative with a car having a fixed number of seats. Calculate the minimum amount of fuel required for all representatives to reach the capital city.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2492: Minimum Score of a Path Between Two Cities</title>
      <link>http://localhost:1313/leetcode/solution-2492-minimum-score-of-a-path-between-two-cities/</link>
      <pubDate>Sat, 02 Mar 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2492-minimum-score-of-a-path-between-two-cities/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a set of cities, each connected by bidirectional roads. Each road has a distance, and the score of a path between two cities is defined as the minimum distance of any road on that path. The task is to find the minimum score of a path between city 1 and city n. You are allowed to visit the cities multiple times, and the roads may be repeated.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2556: Disconnect Path in a Binary Matrix by at Most One Flip</title>
      <link>http://localhost:1313/leetcode/solution-2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip/</link>
      <pubDate>Sun, 25 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2556-disconnect-path-in-a-binary-matrix-by-at-most-one-flip/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a binary matrix &lt;code&gt;grid&lt;/code&gt; where you can move from any cell &lt;code&gt;(row, col)&lt;/code&gt; to adjacent cells &lt;code&gt;(row + 1, col)&lt;/code&gt; or &lt;code&gt;(row, col + 1)&lt;/code&gt; only if they have the value 1. The grid is disconnected if there is no path from the top-left corner &lt;code&gt;(0, 0)&lt;/code&gt; to the bottom-right corner &lt;code&gt;(m - 1, n - 1)&lt;/code&gt;. You are allowed to flip at most one cell (changing a 1 to 0 or vice versa), but you cannot flip the cells &lt;code&gt;(0, 0)&lt;/code&gt; or &lt;code&gt;(m - 1, n - 1)&lt;/code&gt;. Return true if it is possible to disconnect the grid by flipping at most one cell, otherwise return false.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2583: Kth Largest Sum in a Binary Tree</title>
      <link>http://localhost:1313/leetcode/solution-2583-kth-largest-sum-in-a-binary-tree/</link>
      <pubDate>Thu, 22 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2583-kth-largest-sum-in-a-binary-tree/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 0-indexed array of strings &lt;code&gt;words&lt;/code&gt; and two integers &lt;code&gt;left&lt;/code&gt; and &lt;code&gt;right&lt;/code&gt;. A string is considered a vowel string if it starts and ends with a vowel character (vowels are &amp;lsquo;a&amp;rsquo;, &amp;rsquo;e&amp;rsquo;, &amp;lsquo;i&amp;rsquo;, &amp;lsquo;o&amp;rsquo;, &amp;lsquo;u&amp;rsquo;). Your task is to return the number of vowel strings in the array &lt;code&gt;words&lt;/code&gt; where the indices fall within the range [left, right].&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2596: Check Knight Tour Configuration</title>
      <link>http://localhost:1313/leetcode/solution-2596-check-knight-tour-configuration/</link>
      <pubDate>Wed, 21 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2596-check-knight-tour-configuration/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given an &lt;code&gt;n x n&lt;/code&gt; chessboard, the knight starts at the top-left corner and visits every cell exactly once. The knight&amp;rsquo;s movements are represented by a grid where &lt;code&gt;grid[row][col]&lt;/code&gt; indicates the order of the knight&amp;rsquo;s visit to that cell. Determine if this sequence of moves is valid, i.e., the knight moves according to its legal movement pattern.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2641: Cousins in Binary Tree II</title>
      <link>http://localhost:1313/leetcode/solution-2641-cousins-in-binary-tree-ii/</link>
      <pubDate>Fri, 16 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2641-cousins-in-binary-tree-ii/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;Given the root of a binary tree, replace the value of each node in the tree with the sum of all its cousins&amp;rsquo; values. Two nodes are cousins if they have the same depth but different parents. The depth of a node is the number of edges from the root to the node.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2658: Maximum Number of Fish in a Grid</title>
      <link>http://localhost:1313/leetcode/solution-2658-maximum-number-of-fish-in-a-grid/</link>
      <pubDate>Thu, 15 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2658-maximum-number-of-fish-in-a-grid/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 2D matrix &lt;code&gt;grid&lt;/code&gt; of size m x n, where each cell can either be a land cell (represented by 0) or a water cell (represented by a positive integer indicating the number of fish present in that cell). A fisher can start at any water cell and perform two operations any number of times: catch all the fish in the current cell or move to an adjacent water cell. Your task is to determine the maximum number of fish the fisher can catch if they start at the optimal water cell.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2685: Count the Number of Complete Components</title>
      <link>http://localhost:1313/leetcode/solution-2685-count-the-number-of-complete-components/</link>
      <pubDate>Mon, 12 Feb 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2685-count-the-number-of-complete-components/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a graph with &lt;code&gt;n&lt;/code&gt; vertices, numbered from &lt;code&gt;0&lt;/code&gt; to &lt;code&gt;n-1&lt;/code&gt;. The graph contains undirected edges described in a 2D array &lt;code&gt;edges&lt;/code&gt;, where each element &lt;code&gt;edges[i] = [ai, bi]&lt;/code&gt; indicates that there is an undirected edge between vertices &lt;code&gt;ai&lt;/code&gt; and &lt;code&gt;bi&lt;/code&gt;. A connected component is a subgraph in which there is a path between any two vertices, and no vertex is connected to vertices outside of the subgraph. A connected component is said to be complete if there is an edge between every pair of vertices in that component. Your task is to return the number of complete connected components in the graph.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2812: Find the Safest Path in a Grid</title>
      <link>http://localhost:1313/leetcode/solution-2812-find-the-safest-path-in-a-grid/</link>
      <pubDate>Tue, 30 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2812-find-the-safest-path-in-a-grid/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a square grid of size n x n, where each cell contains either a thief (represented by 1) or is empty (represented by 0). You start at the top-left corner of the grid and must find the maximum safeness factor for a path to the bottom-right corner. The safeness factor is defined as the minimum Manhattan distance from any cell in the path to the nearest thief.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2850: Minimum Moves to Spread Stones Over Grid</title>
      <link>http://localhost:1313/leetcode/solution-2850-minimum-moves-to-spread-stones-over-grid/</link>
      <pubDate>Sat, 27 Jan 2024 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/leetcode/solution-2850-minimum-moves-to-spread-stones-over-grid/</guid>
      <description>&lt;hr&gt;&#xA;&lt;p&gt;You are given a 3x3 grid representing stones placed in each cell. In one move, you can move a stone from its current cell to an adjacent cell. The goal is to place one stone in each cell, minimizing the number of moves.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Topological Sort on grid47</title>
    <link>https://www.grid47.xyz/tags/topological-sort/</link>
    <description>Recent content in Topological Sort on grid47</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <copyright>www.grid47.com - All rights reserved</copyright>
    <lastBuildDate>Wed, 06 Nov 2024 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://www.grid47.xyz/tags/topological-sort/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Leetcode 207: Course Schedule</title>
      <link>https://www.grid47.xyz/leetcode/solution-207-course-schedule/</link>
      <pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://www.grid47.xyz/leetcode/solution-207-course-schedule/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode543s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/207.webp&#34; &#xA;           alt=&#34;A calming flowchart with courses linking together, showing dependencies in a gentle, glowing path.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 207: Course Schedule Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;&#34;&gt; You are given a set of courses and a list of prerequisites. Each prerequisite is a pair of courses where the second course must be taken before the first one. Determine if it is possible to complete all courses based on these prerequisites. If there are cycles in the dependencies, it would be impossible to finish all courses. &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;problem-guide&#34;&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-tags&#34;&gt;&#xA;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Problem&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Problem&#39;)&#34;&gt;&#xA;             Problem             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Approach&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Approach&#39;)&#34;&gt;&#xA;             Approach             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Steps&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Steps&#39;)&#34;&gt;&#xA;             Steps             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Complexity&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Complexity&#39;)&#34;&gt;&#xA;             Complexity             &#xA;        &lt;/div&gt; &#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-content&#34;&gt;&#xA;&#xA;        &lt;div id=&#34;Problem&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: block;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;0&#34;&gt;Input Representations&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;1&#34;&gt;Output Specifications&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;2&#34;&gt;Core Logics&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;3&#34;&gt;Constraints&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;4&#34;&gt;Problem Assumptions&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;5&#34;&gt;Examples&lt;/button&gt;                &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Problem&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Input:&lt;/b&gt; You are given an integer numCourses representing the total number of courses and an array prerequisites where each element [a, b] indicates that course b must be completed before course a.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; numCourses = 3, prerequisites = [[1, 0], [2, 1]]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= numCourses &amp;lt;= 2000&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= prerequisites.length &amp;lt;= 5000&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • prerequisites[i].length == 2&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= ai, bi &amp;lt; numCourses&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • All prerequisites pairs are unique.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Output:&lt;/b&gt; Return true if it is possible to finish all the courses. Otherwise, return false.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; Output: true&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The returned value must indicate whether it is possible to complete all courses given the prerequisites.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; The goal is to determine if there is a cycle in the prerequisite graph. If there is no cycle, return true. If a cycle exists, return false.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Create a graph where each course points to its dependent courses.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Use a counter to track the number of prerequisites for each course.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Start with the courses that have no prerequisites and reduce the count of prerequisites for their dependent courses.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If all courses can be completed (i.e., the prerequisite counter reaches zero for all), return true. Otherwise, return false if any course cannot be completed.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;                      &#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; Ensure that the solution handles both small and large inputs efficiently.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The maximum number of courses is 2000.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The maximum number of prerequisites is 5000.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Courses are labeled with unique indices from 0 to numCourses - 1.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;        &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Assumptions:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The input graph is well-formed with valid course numbers and prerequisites.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;     &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: numCourses = 2, prerequisites = [[1, 0]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; There are 2 courses. To take course 1, you must first take course 0. This is possible, so the output is true.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: numCourses = 2, prerequisites = [[1, 0], [0, 1]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; There are 2 courses. Course 1 requires course 0, and course 0 requires course 1. This forms a cycle, so it is impossible to complete all courses. The output is false.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                    &lt;/div&gt;                         &#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Approach&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;0&#34;&gt;Approach&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;1&#34;&gt;Initial Thoughts&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;2&#34;&gt;Solution Designs&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;3&#34;&gt;Edge Cases&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Approach&#34;&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Approach:&lt;/b&gt; The solution involves topological sorting of the graph formed by courses and their prerequisites. If there is a cycle in the graph, it is impossible to complete all courses.&lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Observations:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The problem can be viewed as a cycle detection problem in a directed graph.&lt;/div&gt;&#xA;                            &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Topological sorting using Kahn&amp;#39;s algorithm can be used to detect cycles efficiently.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Construct a graph where each course points to its dependent courses.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Count the prerequisites for each course and track courses with zero prerequisites.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Process courses with zero prerequisites, reducing the count for dependent courses.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If all courses can be processed, return true. If not, return false.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Empty Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If there are no prerequisites, you can finish all courses.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Large Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The solution should handle up to 2000 courses and 5000 prerequisites efficiently.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Special Values:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If there is only one course, it can always be completed.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;       &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure that the solution handles cycles efficiently, especially with a large number of courses.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;                                                                        &#xA;                    &lt;/div&gt;&#xA;                                        &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Steps&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;0&#34;&gt; Code &lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;1&#34;&gt; 1 Function Definition&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;2&#34;&gt; 2 Graph Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;3&#34;&gt; 3 Dependency Counter Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;4&#34;&gt; 4 Graph and Dependency Counter Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;5&#34;&gt; 5 Graph Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;6&#34;&gt; 6 Dependency Counter Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;7&#34;&gt; 7 Queue Declaration&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;8&#34;&gt; 8 Queue Population&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;9&#34;&gt; 9 Queue Population Condition&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;10&#34;&gt; 10 Enqueue Course&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;11&#34;&gt; 11 While Queue Not Empty&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;12&#34;&gt; 12 Queue Size Calculation&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;13&#34;&gt; 13 Inner While Loop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;14&#34;&gt; 14 Dequeue Course&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;15&#34;&gt; 15 Pop Course from Queue&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;16&#34;&gt; 16 Process Dependencies&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;17&#34;&gt; 17 Dependency Counter Decrement&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;18&#34;&gt; 18 Check If Course Is Ready&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;19&#34;&gt; 19 Enqueue Ready Course&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;20&#34;&gt; 20 Final Check Loop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;21&#34;&gt; 21 Cycle Detection&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;22&#34;&gt; 22 Return False&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;23&#34;&gt; 23 Final Return&lt;/button&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Steps&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &#xA;                            &#xA;                            &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;canFinish&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; pre) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; graph(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; cnt(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Created graph and dependecy counter&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; pre.size(); i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        graph[pre[i][&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]].push_back(pre[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cnt[pre[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// Triaged course which does not have any dependency.&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(cnt[i] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; size &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(size&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; course &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;dep&lt;/span&gt;: graph[course]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                cnt[dep]&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(cnt[dep] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    q.push(dep);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }                &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(cnt[i] &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;;   &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;1 : Function Definition&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;canFinish&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; pre) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Define the function `canFinish` which takes the number of courses `n` and a vector of prerequisites `pre` representing course dependencies. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;2 : Graph Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; graph(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize a graph where each course is represented by an index, and the corresponding vector stores its dependent courses. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;3 : Dependency Counter Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; cnt(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize a counter array `cnt` to track the number of prerequisites (dependencies) each course has. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;4 : Graph and Dependency Counter Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; pre.size(); i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterate through each prerequisite pair in the `pre` list. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;5 : Graph Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        graph[pre[i][&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]].push_back(pre[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each prerequisite, add the dependent course to the corresponding graph entry. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;6 : Dependency Counter Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cnt[pre[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Increment the counter for the dependent course, indicating it has one more prerequisite. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;7 : Queue Declaration&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Declare a queue `q` to hold the courses that are ready to be taken (i.e., those with zero dependencies). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;8 : Queue Population&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Loop through all courses to find those with no prerequisites. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;9 : Queue Population Condition&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(cnt[i] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Check if a course has no dependencies by examining its counter value. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;10 : Enqueue Course&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Add the course with no dependencies to the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;11 : While Queue Not Empty&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Start a `while` loop to process courses in the queue until it&amp;#39;s empty. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;12 : Queue Size Calculation&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; size &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Get the current number of courses in the queue, which need to be processed. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;13 : Inner While Loop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(size&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterate through all the courses in the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;14 : Dequeue Course&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; course &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Get the course at the front of the queue to process. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;15 : Pop Course from Queue&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Remove the course from the queue after processing it. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;16 : Process Dependencies&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;dep&lt;/span&gt;: graph[course]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each dependent course of the current course, reduce its dependency count. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;17 : Dependency Counter Decrement&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                cnt[dep]&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Decrement the counter for each dependent course, indicating one less prerequisite. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;18 : Check If Course Is Ready&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(cnt[dep] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If a course now has no dependencies, it can be added to the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;19 : Enqueue Ready Course&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    q.push(dep);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Enqueue the course that has no remaining prerequisites. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;20 : Final Check Loop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Loop through all courses to check for any remaining prerequisites. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;21 : Cycle Detection&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(cnt[i] &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If any course has remaining prerequisites, return `false` as there&amp;#39;s a cycle. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;22 : Return False&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;;   &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Return `false` indicating it&amp;#39;s not possible to finish all courses due to a cycle. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;23 : Final Return&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Return `true` if all courses can be finished without any cycles. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;        &#xA;        &lt;div id=&#34;Complexity&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;0&#34;&gt;Time Complexities&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;1&#34;&gt;Space Complexities&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Complexity&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Average Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The time complexity is O(n &amp;#43; e), where n is the number of courses and e is the number of prerequisites.&lt;/div&gt;                                               &#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The space complexity is O(n &amp;#43; e) due to the graph representation and the prerequisite count array.&lt;/div&gt;    &#xA;                    &lt;/div&gt;&#xA;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt;        &#xA;&#xA;    &lt;/div&gt; &#xA;&#xA;    &lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;    &lt;ins class=&#34;adsbygoogle&#34;&#xA;        style=&#34;display:block; text-align:center;&#34;&#xA;        data-ad-layout=&#34;in-article&#34;&#xA;        data-ad-format=&#34;fluid&#34;&#xA;        data-ad-client=&#34;ca-pub-6219690368643953&#34;&#xA;        data-ad-slot=&#34;5533433286&#34;&gt;&lt;/ins&gt;&#xA;    &lt;script&gt;&#xA;        (adsbygoogle = window.adsbygoogle || []).push({});&#xA;    &lt;/script&gt;&#xA;&#xA;    &lt;script&gt;&#xA;        function switchProblemGuideContent(element, id) {&#xA;            document.querySelectorAll(&#39;.problem-guide-tag&#39;).forEach(tag =&gt; {&#xA;                tag.classList.remove(&#39;problem-guide-tag-active&#39;);&#xA;            });&#xA;&#xA;            element.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;&#xA;            document.querySelectorAll(&#39;.problem-guide-topic-content&#39;).forEach(content =&gt; {&#xA;                content.style.display = &#39;none&#39;;&#xA;            });&#xA;&#xA;            const activeContent = document.getElementById(id);&#xA;            activeContent.style.display = &#39;block&#39;;&#xA;            buttons_x(id)&#xA;        }&#xA;&#xA;        function buttons_x(id) {&#xA;&#xA;            const slides = document.getElementById(&#39;stepsSlides-&#39;+ id );&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-&#39; + id );&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;                console.log(buttons[index].id)&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;        }        &#xA;&#xA;        function buttons() {&#xA;            const slides = document.getElementById(&#39;stepsSlides-Problem&#39;);&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-Problem&#39;);&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;            const initialTag = document.querySelector(`.problem-guide-tag[data-target=&#34;Problem&#34;]`);&#xA;            if (initialTag) {&#xA;                initialTag.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            const contentElements = document.querySelectorAll(&#39;.problem-guide-content&#39;);&#xA;            let maxHeight = 0;&#xA;            contentElements.forEach(element =&gt; {&#xA;                const height = parseFloat(getComputedStyle(element).height);&#xA;                if (height &gt; maxHeight) {&#xA;                    maxHeight = height;&#xA;                }&#xA;            });&#xA;&#xA;            document.querySelector(&#39;.problem-guide-content&#39;).style.height = maxHeight + &#39;px&#39;;&#xA;&#xA;        }&#xA;&#xA;        document.addEventListener(&#39;DOMContentLoaded&#39;, buttons);&#xA;    &lt;/script&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/course-schedule/description/&#34;&gt;&lt;code&gt;Link to LeetCode Lab&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 210: Course Schedule II</title>
      <link>https://www.grid47.xyz/leetcode/solution-210-course-schedule-ii/</link>
      <pubDate>Thu, 17 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://www.grid47.xyz/leetcode/solution-210-course-schedule-ii/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode558s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/210.webp&#34; &#xA;           alt=&#34;A series of tasks gently forming a schedule, with dependencies softly highlighted as the courses unfold.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 210: Course Schedule II Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;&#34;&gt; You are given a set of courses with prerequisites, and you need to find a valid order to take them, or return an empty array if no valid order exists. &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;problem-guide&#34;&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-tags&#34;&gt;&#xA;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Problem&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Problem&#39;)&#34;&gt;&#xA;             Problem             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Approach&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Approach&#39;)&#34;&gt;&#xA;             Approach             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Steps&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Steps&#39;)&#34;&gt;&#xA;             Steps             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Complexity&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Complexity&#39;)&#34;&gt;&#xA;             Complexity             &#xA;        &lt;/div&gt; &#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-content&#34;&gt;&#xA;&#xA;        &lt;div id=&#34;Problem&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: block;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;0&#34;&gt;Input Representations&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;1&#34;&gt;Output Specifications&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;2&#34;&gt;Core Logics&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;3&#34;&gt;Constraints&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;4&#34;&gt;Problem Assumptions&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;5&#34;&gt;Examples&lt;/button&gt;                &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Problem&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Input:&lt;/b&gt; You are given a number of courses, `numCourses`, and a list of prerequisite pairs where each pair [ai, bi] indicates that you need to take course bi before course ai.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; [numCourses = 3, prerequisites = [[1,0], [2,1]]]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= numCourses &amp;lt;= 2000&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= prerequisites.length &amp;lt;= numCourses * (numCourses - 1)&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • prerequisites[i].length == 2&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= ai, bi &amp;lt; numCourses&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • ai != bi&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • All pairs [ai, bi] are distinct.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Output:&lt;/b&gt; Return a valid order in which to complete all the courses, or an empty array if no valid order exists.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; For numCourses = 3 and prerequisites = [[1,0], [2,1]], the output is [0, 1, 2].&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; To determine if it is possible to complete all the courses by sorting the courses in a valid order considering their prerequisites.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Represent the courses and their prerequisites as a directed graph.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Perform topological sorting on the graph using a queue to process nodes with no prerequisites.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Return the topologically sorted order if all courses can be taken, otherwise return an empty array.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;                      &#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; The constraints ensure the problem can be solved with an efficient algorithm for large inputs.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The number of courses can be up to 2000, so the solution should handle graphs with up to 2000 nodes and edges efficiently.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;        &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Assumptions:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The input courses and prerequisites form a directed graph, which may or may not have cycles.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;     &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Example 1&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; In this case, you need to take course 1 after course 0, and course 2 after course 1, so the valid order is [0, 1, 2].&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Example 2&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; The courses form a directed graph with dependencies, and a valid order is [0, 2, 1, 3].&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Example 3&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; The prerequisites form a cycle, making it impossible to complete the courses, so the output is an empty array.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                    &lt;/div&gt;                         &#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Approach&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;0&#34;&gt;Approach&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;1&#34;&gt;Initial Thoughts&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;2&#34;&gt;Solution Designs&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;3&#34;&gt;Edge Cases&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Approach&#34;&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Approach:&lt;/b&gt; This problem can be solved using topological sorting on a directed graph representing course dependencies.&lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Observations:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The problem involves checking if a directed graph is acyclic and finding a valid topological order.&lt;/div&gt;&#xA;                            &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • A queue can be used to process nodes with no incoming edges (prerequisites), and we can iteratively build the valid order.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Represent the courses and their prerequisites as a directed graph.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Track the number of incoming edges (prerequisites) for each course.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Use a queue to process courses that have no prerequisites (i.e., courses with zero incoming edges).&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • For each processed course, reduce the incoming edges of its dependent courses and add those with no remaining prerequisites to the queue.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If all courses are processed, return the topologically sorted order. Otherwise, return an empty array.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Empty Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If no prerequisites are given, the courses can be completed in any order.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Large Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The solution must handle up to 2000 courses efficiently.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Special Values:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If the prerequisites form a cycle, it is impossible to complete the courses.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;       &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure that the solution works within the time limits for large arrays (O(n &amp;#43; m) time complexity).&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;                                                                        &#xA;                    &lt;/div&gt;&#xA;                                        &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Steps&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;0&#34;&gt; Code &lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;1&#34;&gt; 1 Function Definition&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;2&#34;&gt; 2 Graph Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;3&#34;&gt; 3 In-degree Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;4&#34;&gt; 4 Building Graph&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;5&#34;&gt; 5 Graph Population&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;6&#34;&gt; 6 In-degree Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;7&#34;&gt; 7 Queue Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;8&#34;&gt; 8 Queue Population&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;9&#34;&gt; 9 In-degree Check&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;10&#34;&gt; 10 Queue Push&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;11&#34;&gt; 11 Answer Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;12&#34;&gt; 12 Processing Queue&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;13&#34;&gt; 13 Node Processing&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;14&#34;&gt; 14 Answer Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;15&#34;&gt; 15 Queue Pop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;16&#34;&gt; 16 Graph Traversal&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;17&#34;&gt; 17 In-degree Decrement&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;18&#34;&gt; 18 Queue Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;19&#34;&gt; 19 Queue Push Again&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;20&#34;&gt; 20 Return Statement&lt;/button&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Steps&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &#xA;                            &#xA;                            &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; findOrder(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; pre) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; gph(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; incnt(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; pre.size(); i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        gph[pre[i][&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]].push_back(pre[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        incnt[pre[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(incnt[i] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; ans;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; y &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans.push_back(y);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;x&lt;/span&gt;: gph[y]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            incnt[x]&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(incnt[x] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                q.push(x);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; ans.size() &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; n&lt;span style=&#34;color:#666&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;ans&lt;/span&gt;: vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;1 : Function Definition&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; findOrder(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; pre) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Define the function `findOrder`, which takes an integer `n` (number of courses/nodes) and a 2D vector `pre` (prerequisites), and returns the topological order of nodes. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;2 : Graph Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; gph(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize an adjacency list `gph` to represent the directed graph, where each node will store a list of its neighbors (nodes that depend on it). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;3 : In-degree Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; incnt(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize a vector `incnt` to keep track of the in-degree (number of incoming edges) for each node. Set all in-degrees initially to 0. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;4 : Building Graph&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; pre.size(); i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Loop through the prerequisite pairs in `pre` to build the graph and update the in-degrees. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;5 : Graph Population&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        gph[pre[i][&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]].push_back(pre[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each pair in `pre`, add the directed edge from `pre[i][1]` to `pre[i][0]` in the adjacency list `gph`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;6 : In-degree Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        incnt[pre[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Increase the in-degree of the node `pre[i][0]`, indicating that it has one more prerequisite. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;7 : Queue Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize a queue `q` to keep track of nodes with no prerequisites (i.e., nodes with an in-degree of 0). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;8 : Queue Population&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Loop through all nodes and add those with no incoming edges (in-degree of 0) to the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;9 : In-degree Check&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(incnt[i] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Check if the current node has no prerequisites (in-degree 0), indicating it can be processed. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;10 : Queue Push&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Add the current node with no prerequisites to the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;11 : Answer Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; ans;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize an empty vector `ans` to store the topologically sorted nodes. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;12 : Processing Queue&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; While the queue is not empty, process each node in topological order. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;13 : Node Processing&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; y &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Get the front node from the queue to process. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;14 : Answer Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans.push_back(y);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Add the current node `y` to the answer vector `ans` as part of the topological order. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;15 : Queue Pop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Remove the processed node from the front of the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;16 : Graph Traversal&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;x&lt;/span&gt;: gph[y]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each node `x` that depends on the current node `y`, reduce its in-degree by 1. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;17 : In-degree Decrement&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            incnt[x]&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Decrement the in-degree of node `x`, as one of its prerequisites (`y`) has been processed. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;18 : Queue Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(incnt[x] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If node `x` now has no prerequisites left (in-degree 0), it can be added to the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;19 : Queue Push Again&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                q.push(x);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Add node `x` to the queue for processing. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;20 : Return Statement&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; ans.size() &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; n&lt;span style=&#34;color:#666&#34;&gt;?&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;ans&lt;/span&gt;: vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt;();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If all nodes have been processed (i.e., the answer size equals `n`), return the topologically sorted order; otherwise, return an empty vector indicating a cycle or an impossible ordering. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;        &#xA;        &lt;div id=&#34;Complexity&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;0&#34;&gt;Time Complexities&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;1&#34;&gt;Space Complexities&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Complexity&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; m), where n is the number of courses and m is the number of prerequisites.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Average Case:&lt;/b&gt; O(n &amp;#43; m), since all nodes and edges must be processed.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; m), in the worst case all courses and prerequisites must be processed.&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The time complexity is dominated by the graph traversal and topological sorting.&lt;/div&gt;                                               &#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; m), since all the nodes and edges must be stored in memory.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; m), to store the graph and incoming edges.&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The space complexity is proportional to the number of nodes (courses) and edges (prerequisites).&lt;/div&gt;    &#xA;                    &lt;/div&gt;&#xA;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt;        &#xA;&#xA;    &lt;/div&gt; &#xA;&#xA;    &lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;    &lt;ins class=&#34;adsbygoogle&#34;&#xA;        style=&#34;display:block; text-align:center;&#34;&#xA;        data-ad-layout=&#34;in-article&#34;&#xA;        data-ad-format=&#34;fluid&#34;&#xA;        data-ad-client=&#34;ca-pub-6219690368643953&#34;&#xA;        data-ad-slot=&#34;5533433286&#34;&gt;&lt;/ins&gt;&#xA;    &lt;script&gt;&#xA;        (adsbygoogle = window.adsbygoogle || []).push({});&#xA;    &lt;/script&gt;&#xA;&#xA;    &lt;script&gt;&#xA;        function switchProblemGuideContent(element, id) {&#xA;            document.querySelectorAll(&#39;.problem-guide-tag&#39;).forEach(tag =&gt; {&#xA;                tag.classList.remove(&#39;problem-guide-tag-active&#39;);&#xA;            });&#xA;&#xA;            element.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;&#xA;            document.querySelectorAll(&#39;.problem-guide-topic-content&#39;).forEach(content =&gt; {&#xA;                content.style.display = &#39;none&#39;;&#xA;            });&#xA;&#xA;            const activeContent = document.getElementById(id);&#xA;            activeContent.style.display = &#39;block&#39;;&#xA;            buttons_x(id)&#xA;        }&#xA;&#xA;        function buttons_x(id) {&#xA;&#xA;            const slides = document.getElementById(&#39;stepsSlides-&#39;+ id );&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-&#39; + id );&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;                console.log(buttons[index].id)&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;        }        &#xA;&#xA;        function buttons() {&#xA;            const slides = document.getElementById(&#39;stepsSlides-Problem&#39;);&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-Problem&#39;);&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;            const initialTag = document.querySelector(`.problem-guide-tag[data-target=&#34;Problem&#34;]`);&#xA;            if (initialTag) {&#xA;                initialTag.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            const contentElements = document.querySelectorAll(&#39;.problem-guide-content&#39;);&#xA;            let maxHeight = 0;&#xA;            contentElements.forEach(element =&gt; {&#xA;                const height = parseFloat(getComputedStyle(element).height);&#xA;                if (height &gt; maxHeight) {&#xA;                    maxHeight = height;&#xA;                }&#xA;            });&#xA;&#xA;            document.querySelector(&#39;.problem-guide-content&#39;).style.height = maxHeight + &#39;px&#39;;&#xA;&#xA;        }&#xA;&#xA;        document.addEventListener(&#39;DOMContentLoaded&#39;, buttons);&#xA;    &lt;/script&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/course-schedule-ii/description/&#34;&gt;&lt;code&gt;Link to LeetCode Lab&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 310: Minimum Height Trees</title>
      <link>https://www.grid47.xyz/leetcode/solution-310-minimum-height-trees/</link>
      <pubDate>Mon, 07 Oct 2024 00:00:00 +0000</pubDate>
      <guid>https://www.grid47.xyz/leetcode/solution-310-minimum-height-trees/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode1051s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/310.webp&#34; &#xA;           alt=&#34;A series of tree structures, with each one growing taller or shorter as the minimum height tree is highlighted.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 310: Minimum Height Trees Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;&#34;&gt; You are given a tree with &amp;rsquo;n&amp;rsquo; nodes labeled from 0 to n-1, represented by &amp;rsquo;n-1&amp;rsquo; edges. Your task is to find all roots that minimize the height of the tree. The height of a tree is defined as the number of edges in the longest downward path from the root to any leaf. &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;problem-guide&#34;&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-tags&#34;&gt;&#xA;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Problem&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Problem&#39;)&#34;&gt;&#xA;             Problem             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Approach&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Approach&#39;)&#34;&gt;&#xA;             Approach             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Steps&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Steps&#39;)&#34;&gt;&#xA;             Steps             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Complexity&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Complexity&#39;)&#34;&gt;&#xA;             Complexity             &#xA;        &lt;/div&gt; &#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-content&#34;&gt;&#xA;&#xA;        &lt;div id=&#34;Problem&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: block;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;0&#34;&gt;Input Representations&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;1&#34;&gt;Output Specifications&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;2&#34;&gt;Core Logics&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;3&#34;&gt;Constraints&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;4&#34;&gt;Problem Assumptions&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;5&#34;&gt;Examples&lt;/button&gt;                &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Problem&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Input:&lt;/b&gt; The input consists of an integer &amp;#39;n&amp;#39; and a list of &amp;#39;n-1&amp;#39; edges that define the tree.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; n = 5, edges = [[1, 0], [1, 2], [2, 3], [2, 4]]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= n &amp;lt;= 20,000&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • edges.length == n - 1&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= ai, bi &amp;lt; n&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • ai != bi&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • All pairs (ai, bi) are distinct&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The input is guaranteed to be a valid tree&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Output:&lt;/b&gt; The output should be a list of integers representing the nodes that minimize the height of the tree.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; [2]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The output list can have one or more nodes.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; Find the nodes that minimize the height of the tree by iterating from leaf nodes towards the center of the tree.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Create an adjacency list representation of the tree.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Track the degree of each node to identify leaf nodes.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Remove leaf nodes iteratively to find the center(s) of the tree (or minimum height roots).&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Nodes remaining after iterating through the process are the minimum height tree roots.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;                      &#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; The solution needs to handle trees with up to 20,000 nodes efficiently.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure the algorithm works efficiently for large values of &amp;#39;n&amp;#39;.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Handle edge cases such as linear trees or balanced trees.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;        &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Assumptions:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The input tree is always valid and is guaranteed to contain no cycles.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The input edges will always form a connected tree.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;     &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; n = 5, edges = [[1, 0], [1, 2], [2, 3], [2, 4]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; Rooting the tree at node 2 minimizes the height, as it is centrally located.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; n = 6, edges = [[3, 0], [3, 1], [3, 2], [3, 4], [5, 4]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; Nodes 3 and 4 minimize the height of the tree, resulting in a height of 2.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; n = 7, edges = [[0, 1], [1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; Node 3 minimizes the tree height as it is the center of this linear tree.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                    &lt;/div&gt;                         &#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Approach&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;0&#34;&gt;Approach&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;1&#34;&gt;Initial Thoughts&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;2&#34;&gt;Solution Designs&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;3&#34;&gt;Edge Cases&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Approach&#34;&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Approach:&lt;/b&gt; The problem can be solved by progressively removing leaf nodes until only the central nodes remain, which are the roots of the minimum height trees.&lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Observations:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The tree is undirected and connected, which allows for a unique path between any two nodes.&lt;/div&gt;&#xA;                            &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The height of the tree is minimized when the root is as central as possible, which can be found by peeling off leaf nodes.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Represent the tree using an adjacency list.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Track the degree of each node and push leaf nodes into a queue.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Iteratively remove leaf nodes from the tree until one or two nodes remain, which will be the minimum height tree roots.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Empty Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • There is no need to handle empty inputs, as the problem guarantees a valid tree with at least one node.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Large Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The solution must efficiently handle the maximum constraint of n = 20,000.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Special Values:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If the tree is a line (i.e., a path), the root is the middle node(s).&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;       &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure the solution works in O(n) time to handle large inputs.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;                                                                        &#xA;                    &lt;/div&gt;&#xA;                                        &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Steps&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;0&#34;&gt; Code &lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;1&#34;&gt; 1 Function Definition&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;2&#34;&gt; 2 Base Case&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;3&#34;&gt; 3 Graph Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;4&#34;&gt; 4 Degree Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;5&#34;&gt; 5 Graph Construction&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;6&#34;&gt; 6 Edge Insertion&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;7&#34;&gt; 7 Edge Insertion&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;8&#34;&gt; 8 Degree Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;9&#34;&gt; 9 Degree Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;10&#34;&gt; 10 Queue Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;11&#34;&gt; 11 Queue Population&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;12&#34;&gt; 12 Queue Population&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;13&#34;&gt; 13 Queue Population&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;14&#34;&gt; 14 Result Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;15&#34;&gt; 15 BFS Loop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;16&#34;&gt; 16 Clear Result&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;17&#34;&gt; 17 Queue Size&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;18&#34;&gt; 18 BFS Inner Loop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;19&#34;&gt; 19 Queue Front&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;20&#34;&gt; 20 Queue Pop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;21&#34;&gt; 21 Result Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;22&#34;&gt; 22 Neighbor Processing&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;23&#34;&gt; 23 Degree Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;24&#34;&gt; 24 Leaf Detection&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;25&#34;&gt; 25 Queue Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;26&#34;&gt; 26 BFS End&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;27&#34;&gt; 27 Return Result&lt;/button&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Steps&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &#xA;                            &#xA;                            &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; findMinHeightTrees(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; edges) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(n &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; {&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; adj(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; degree(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;e&lt;/span&gt;: edges) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        adj[e[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]].push_back(e[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        adj[e[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]].push_back(e[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        degree[e[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        degree[e[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(degree[i] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        res.clear();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; sz &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(sz&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; tmp &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            res.push_back(tmp);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;nbr&lt;/span&gt;: adj[tmp]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                degree[nbr]&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(degree[nbr] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    q.push(nbr);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;1 : Function Definition&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; findMinHeightTrees(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; edges) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Define the function that accepts the number of nodes `n` and a vector of edges representing an undirected graph. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;2 : Base Case&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(n &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; {&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;};&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If there is only one node, return it as the result since it&amp;#39;s trivially the minimum height tree. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;3 : Graph Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; adj(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Create an adjacency list to represent the graph, where each node points to its neighbors. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;4 : Degree Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; degree(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize a degree array to keep track of the number of connections (edges) each node has. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;5 : Graph Construction&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;e&lt;/span&gt;: edges) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterate over all edges to build the adjacency list and update the degree of each node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;6 : Edge Insertion&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        adj[e[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]].push_back(e[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each edge, add the neighboring node to the adjacency list of the first node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;7 : Edge Insertion&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        adj[e[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]].push_back(e[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Similarly, add the neighboring node to the adjacency list of the second node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;8 : Degree Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        degree[e[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Increase the degree of the first node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;9 : Degree Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        degree[e[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Increase the degree of the second node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;10 : Queue Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize a queue to perform a breadth-first search (BFS) from the leaf nodes. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;11 : Queue Population&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterate through all the nodes to find those with only one connection (degree 1), which are leaves. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;12 : Queue Population&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(degree[i] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Check if the current node is a leaf node (degree 1). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;13 : Queue Population&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Push leaf nodes into the queue to start the BFS process. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;14 : Result Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize an empty result vector to store the nodes that will form the minimum height trees. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;15 : BFS Loop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Start the BFS loop to process the leaf nodes and iteratively remove them. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;16 : Clear Result&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        res.clear();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Clear the result vector to store the next set of leaf nodes. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;17 : Queue Size&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; sz &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Get the size of the current level of the BFS queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;18 : BFS Inner Loop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(sz&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Process all the nodes at the current level. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;19 : Queue Front&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; tmp &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Get the current node from the front of the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;20 : Queue Pop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Remove the current node from the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;21 : Result Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            res.push_back(tmp);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Add the current node to the result vector. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;22 : Neighbor Processing&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;nbr&lt;/span&gt;: adj[tmp]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Process all the neighbors of the current node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;23 : Degree Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                degree[nbr]&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Decrease the degree of the neighboring node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;24 : Leaf Detection&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(degree[nbr] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Check if the neighboring node has become a leaf (degree 1). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;25 : Queue Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    q.push(nbr);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Add the neighbor to the queue if it has become a leaf. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;26 : BFS End&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; End the main BFS loop. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;27 : Return Result&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Return the list of nodes that form the minimum height trees. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;        &#xA;        &lt;div id=&#34;Complexity&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;0&#34;&gt;Time Complexities&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;1&#34;&gt;Space Complexities&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Complexity&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Average Case:&lt;/b&gt; O(n)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The time complexity is O(n) as each node is processed at most once.&lt;/div&gt;                                               &#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The space complexity is O(n) due to the storage of the adjacency list and degree array.&lt;/div&gt;    &#xA;                    &lt;/div&gt;&#xA;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt;        &#xA;&#xA;    &lt;/div&gt; &#xA;&#xA;    &lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;    &lt;ins class=&#34;adsbygoogle&#34;&#xA;        style=&#34;display:block; text-align:center;&#34;&#xA;        data-ad-layout=&#34;in-article&#34;&#xA;        data-ad-format=&#34;fluid&#34;&#xA;        data-ad-client=&#34;ca-pub-6219690368643953&#34;&#xA;        data-ad-slot=&#34;5533433286&#34;&gt;&lt;/ins&gt;&#xA;    &lt;script&gt;&#xA;        (adsbygoogle = window.adsbygoogle || []).push({});&#xA;    &lt;/script&gt;&#xA;&#xA;    &lt;script&gt;&#xA;        function switchProblemGuideContent(element, id) {&#xA;            document.querySelectorAll(&#39;.problem-guide-tag&#39;).forEach(tag =&gt; {&#xA;                tag.classList.remove(&#39;problem-guide-tag-active&#39;);&#xA;            });&#xA;&#xA;            element.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;&#xA;            document.querySelectorAll(&#39;.problem-guide-topic-content&#39;).forEach(content =&gt; {&#xA;                content.style.display = &#39;none&#39;;&#xA;            });&#xA;&#xA;            const activeContent = document.getElementById(id);&#xA;            activeContent.style.display = &#39;block&#39;;&#xA;            buttons_x(id)&#xA;        }&#xA;&#xA;        function buttons_x(id) {&#xA;&#xA;            const slides = document.getElementById(&#39;stepsSlides-&#39;+ id );&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-&#39; + id );&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;                console.log(buttons[index].id)&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;        }        &#xA;&#xA;        function buttons() {&#xA;            const slides = document.getElementById(&#39;stepsSlides-Problem&#39;);&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-Problem&#39;);&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;            const initialTag = document.querySelector(`.problem-guide-tag[data-target=&#34;Problem&#34;]`);&#xA;            if (initialTag) {&#xA;                initialTag.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            const contentElements = document.querySelectorAll(&#39;.problem-guide-content&#39;);&#xA;            let maxHeight = 0;&#xA;            contentElements.forEach(element =&gt; {&#xA;                const height = parseFloat(getComputedStyle(element).height);&#xA;                if (height &gt; maxHeight) {&#xA;                    maxHeight = height;&#xA;                }&#xA;            });&#xA;&#xA;            document.querySelector(&#39;.problem-guide-content&#39;).style.height = maxHeight + &#39;px&#39;;&#xA;&#xA;        }&#xA;&#xA;        document.addEventListener(&#39;DOMContentLoaded&#39;, buttons);&#xA;    &lt;/script&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/minimum-height-trees/description/&#34;&gt;&lt;code&gt;Link to LeetCode Lab&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 802: Find Eventual Safe States</title>
      <link>https://www.grid47.xyz/leetcode/solution-802-find-eventual-safe-states/</link>
      <pubDate>Sun, 18 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://www.grid47.xyz/leetcode/solution-802-find-eventual-safe-states/</guid>
      <description>&lt;h2 id=&#34;hahahugoshortcode1313s0hbhb&#34;&gt;&lt;figure class=&#34;remote-image&#34; style=&#34;text-align:center; margin: 0;&#34;&gt;&#xA;    &lt;div style=&#34;position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;&#34;&gt;&#xA;      &lt;img src=&#34;https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/802.webp&#34; &#xA;           alt=&#34;A graph with nodes marked as safe, glowing softly as they are identified.&#34; &#xA;           style=&#34;position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;&#34;&gt;&#xA;    &lt;/div&gt;&#xA;    &#xA;      &lt;figcaption style=&#34;font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;&#34;&gt;&#xA;        Solution to LeetCode 802: Find Eventual Safe States Problem&#xA;      &lt;/figcaption&gt;&#xA;    &#xA;  &lt;/figure&gt;&#xA;  &lt;/h2&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;&#34;&gt; You are given a directed graph where each node represents a point, and edges represent possible transitions between nodes. A node is considered terminal if it has no outgoing edges. A node is deemed safe if every path starting from it leads either to a terminal node or another safe node. Your task is to identify all the safe nodes in the graph and return them in ascending order. &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;problem-guide&#34;&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-tags&#34;&gt;&#xA;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Problem&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Problem&#39;)&#34;&gt;&#xA;             Problem             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Approach&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Approach&#39;)&#34;&gt;&#xA;             Approach             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Steps&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Steps&#39;)&#34;&gt;&#xA;             Steps             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Complexity&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Complexity&#39;)&#34;&gt;&#xA;             Complexity             &#xA;        &lt;/div&gt; &#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-content&#34;&gt;&#xA;&#xA;        &lt;div id=&#34;Problem&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: block;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;0&#34;&gt;Input Representations&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;1&#34;&gt;Output Specifications&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;2&#34;&gt;Core Logics&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;3&#34;&gt;Constraints&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;4&#34;&gt;Problem Assumptions&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;5&#34;&gt;Examples&lt;/button&gt;                &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Problem&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Input:&lt;/b&gt; The input consists of a graph represented as a 2D array, where each node&amp;#39;s adjacency list is provided, followed by the conditions of the graph&amp;#39;s nodes.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • n == graph.length&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= n &amp;lt;= 10^4&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= graph[i].length &amp;lt;= n&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= graph[i][j] &amp;lt;= n - 1&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • graph[i] is sorted in a strictly increasing order&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Output:&lt;/b&gt; Return an array of integers representing the safe nodes in the graph, sorted in ascending order.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; Output: [2,4,5,6]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The returned array should be sorted in ascending order.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; To identify and return the safe nodes in the graph by using depth-first search (DFS) to track nodes that lead to terminal or safe nodes.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Perform a depth-first search (DFS) to determine which nodes are safe.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Track the visiting status of nodes (unvisited, visiting, or safe) to avoid cycles.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Return all nodes that are identified as safe, ensuring they are in ascending order.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;                      &#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; Constraints on the graph ensure that the number of nodes and edges will not exceed the bounds of typical graph traversal algorithms.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The number of nodes is between 1 and 10^4.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The number of edges is bounded by 4 * 10^4.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;        &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Assumptions:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The graph may contain self-loops or cycles, but the traversal will ensure safe nodes are correctly identified.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Each node is either part of a cycle or leads to a terminal node or a safe node.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;     &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: graph = [[1,2],[2,3],[5],[0],[5],[],[]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; In this graph, nodes 5 and 6 are terminal nodes because they have no outgoing edges. Nodes 2, 4, 5, and 6 are safe since all paths starting from these nodes lead either to a terminal node or another safe node.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: graph = [[1,2,3,4],[1,2],[3,4],[0,4],[]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; In this case, node 4 is the only terminal node, and it is safe. The paths starting at node 4 always lead to itself, making it a safe node.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                    &lt;/div&gt;                         &#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Approach&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;0&#34;&gt;Approach&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;1&#34;&gt;Initial Thoughts&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;2&#34;&gt;Solution Designs&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;3&#34;&gt;Edge Cases&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Approach&#34;&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Approach:&lt;/b&gt; To solve this problem, we can use a depth-first search (DFS) approach to explore each node and determine if it is safe based on its outgoing edges and the nodes it leads to.&lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Observations:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Safe nodes can be identified by ensuring all paths from them eventually lead to terminal nodes or other safe nodes.&lt;/div&gt;&#xA;                            &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • We will perform DFS from each node, tracking its status as either visiting, visited, or safe. Nodes that are part of cycles or lead to unsafe paths will not be marked as safe.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • For each node in the graph, perform a depth-first search (DFS) to check if it eventually reaches a terminal node or a safe node.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • During DFS, track the state of each node (unvisited, visiting, or safe) to handle cycles correctly.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • After the DFS traversal, collect all nodes marked as safe and return them in ascending order.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Empty Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If the graph has no nodes, there are no safe nodes to return.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Large Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • For large inputs, ensure the DFS algorithm is optimized to handle up to 10^4 nodes efficiently.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Special Values:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If the graph contains self-loops, treat them carefully by marking the node as unsafe if it leads to itself in a cycle.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;       &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure that the solution is efficient given the graph constraints, particularly the number of nodes and edges.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;                                                                        &#xA;                    &lt;/div&gt;&#xA;                                        &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Steps&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;0&#34;&gt; Code &lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;1&#34;&gt; 1 Function&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;2&#34;&gt; 2 Variable Declaration&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;3&#34;&gt; 3 Variable Declaration&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;4&#34;&gt; 4 Condition&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;5&#34;&gt; 5 Variable Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;6&#34;&gt; 6 Loop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;7&#34;&gt; 7 Conditional&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;8&#34;&gt; 8 Return Statement&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;9&#34;&gt; 9 Function&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;10&#34;&gt; 10 Condition&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;11&#34;&gt; 11 Mark Node as Visiting&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;12&#34;&gt; 12 Loop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;13&#34;&gt; 13 Conditional&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;14&#34;&gt; 14 Mark Node as Safe&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;15&#34;&gt; 15 Return Statement&lt;/button&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Steps&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &#xA;                            &#xA;                            &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; eventualSafeNodes(vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; graph) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; graph.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(n &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; vis(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(dfs(graph, i, vis)) res.push_back(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;dfs&lt;/span&gt;(vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; graph, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; cur, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;vis) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(vis[cur] &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; vis[cur] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vis[cur] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;nxt&lt;/span&gt;: graph[cur])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;dfs(graph, nxt, vis)) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vis[cur] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;1 : Function&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; eventualSafeNodes(vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; graph) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This is the function signature that defines the main function, `eventualSafeNodes`, which takes a graph (a vector of vectors of integers) as input and returns a vector of integers representing the safe nodes. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;2 : Variable Declaration&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; A vector `res` is declared to store the eventual safe nodes that will be found during the DFS traversal. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;3 : Variable Declaration&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; graph.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; The variable `n` is initialized to store the size of the graph (i.e., the number of nodes). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;4 : Condition&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(n &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If the graph is empty (n == 0), an empty vector `res` is returned as there are no nodes to process. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;5 : Variable Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; vis(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; A `vis` vector is initialized with zeroes, where each element represents the visitation state of a node (0 = not visited, 1 = visiting, 2 = visited). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;6 : Loop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; A for loop is used to iterate over all the nodes in the graph, starting from node 0 to node n-1. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;7 : Conditional&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(dfs(graph, i, vis)) res.push_back(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each node, the DFS function is called to check if it&amp;#39;s an eventual safe node. If the node is safe (DFS returns true), it is added to the result vector `res`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;8 : Return Statement&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; The function returns the vector `res`, which contains all the safe nodes found during the DFS traversal. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;9 : Function&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;dfs&lt;/span&gt;(vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; graph, &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; cur, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;vis) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This is the helper function `dfs` that performs depth-first search to explore the graph from a given node `cur`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;10 : Condition&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(vis[cur] &lt;span style=&#34;color:#666&#34;&gt;!=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; vis[cur] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If the node `cur` has already been visited (its state is not 0), the function returns whether the node is safe (state 2 means safe). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;11 : Mark Node as Visiting&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vis[cur] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; The node `cur` is marked as visiting (state 1) to indicate that it&amp;#39;s being explored. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;12 : Loop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;nxt&lt;/span&gt;: graph[cur])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; The function iterates over all the neighboring nodes (`nxt`) of the current node `cur`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;13 : Conditional&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;dfs(graph, nxt, vis)) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each neighboring node `nxt`, the DFS function is called recursively. If any neighbor leads to a cycle (DFS returns false), the current node is not safe, and the function returns false. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;14 : Mark Node as Safe&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vis[cur] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Once all the neighbors have been processed and no cycle is detected, the current node `cur` is marked as safe (state 2). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;15 : Return Statement&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; The function returns true, indicating that the current node `cur` is safe. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;        &#xA;        &lt;div id=&#34;Complexity&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;0&#34;&gt;Time Complexities&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;1&#34;&gt;Space Complexities&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Complexity&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; e), where n is the number of nodes and e is the number of edges in the graph.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Average Case:&lt;/b&gt; O(n &amp;#43; e), as DFS will visit each node and edge at most once.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; e), since each node and edge must be processed during DFS traversal.&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The time complexity is linear in terms of the number of nodes and edges in the graph.&lt;/div&gt;                                               &#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n), since the space needed to store node status and recursion stack is proportional to the number of nodes.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n), as we need to store the status of each node during the DFS traversal.&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The space complexity is linear with respect to the number of nodes in the graph.&lt;/div&gt;    &#xA;                    &lt;/div&gt;&#xA;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt;        &#xA;&#xA;    &lt;/div&gt; &#xA;&#xA;    &lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;    &lt;ins class=&#34;adsbygoogle&#34;&#xA;        style=&#34;display:block; text-align:center;&#34;&#xA;        data-ad-layout=&#34;in-article&#34;&#xA;        data-ad-format=&#34;fluid&#34;&#xA;        data-ad-client=&#34;ca-pub-6219690368643953&#34;&#xA;        data-ad-slot=&#34;5533433286&#34;&gt;&lt;/ins&gt;&#xA;    &lt;script&gt;&#xA;        (adsbygoogle = window.adsbygoogle || []).push({});&#xA;    &lt;/script&gt;&#xA;&#xA;    &lt;script&gt;&#xA;        function switchProblemGuideContent(element, id) {&#xA;            document.querySelectorAll(&#39;.problem-guide-tag&#39;).forEach(tag =&gt; {&#xA;                tag.classList.remove(&#39;problem-guide-tag-active&#39;);&#xA;            });&#xA;&#xA;            element.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;&#xA;            document.querySelectorAll(&#39;.problem-guide-topic-content&#39;).forEach(content =&gt; {&#xA;                content.style.display = &#39;none&#39;;&#xA;            });&#xA;&#xA;            const activeContent = document.getElementById(id);&#xA;            activeContent.style.display = &#39;block&#39;;&#xA;            buttons_x(id)&#xA;        }&#xA;&#xA;        function buttons_x(id) {&#xA;&#xA;            const slides = document.getElementById(&#39;stepsSlides-&#39;+ id );&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-&#39; + id );&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;                console.log(buttons[index].id)&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;        }        &#xA;&#xA;        function buttons() {&#xA;            const slides = document.getElementById(&#39;stepsSlides-Problem&#39;);&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-Problem&#39;);&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;            const initialTag = document.querySelector(`.problem-guide-tag[data-target=&#34;Problem&#34;]`);&#xA;            if (initialTag) {&#xA;                initialTag.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            const contentElements = document.querySelectorAll(&#39;.problem-guide-content&#39;);&#xA;            let maxHeight = 0;&#xA;            contentElements.forEach(element =&gt; {&#xA;                const height = parseFloat(getComputedStyle(element).height);&#xA;                if (height &gt; maxHeight) {&#xA;                    maxHeight = height;&#xA;                }&#xA;            });&#xA;&#xA;            document.querySelector(&#39;.problem-guide-content&#39;).style.height = maxHeight + &#39;px&#39;;&#xA;&#xA;        }&#xA;&#xA;        document.addEventListener(&#39;DOMContentLoaded&#39;, buttons);&#xA;    &lt;/script&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/find-eventual-safe-states/description/&#34;&gt;&lt;code&gt;Link to LeetCode Lab&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 851: Loud and Rich</title>
      <link>https://www.grid47.xyz/leetcode/solution-851-loud-and-rich/</link>
      <pubDate>Tue, 13 Aug 2024 00:00:00 +0000</pubDate>
      <guid>https://www.grid47.xyz/leetcode/solution-851-loud-and-rich/</guid>
      <description>&lt;hr&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;&#34;&gt; You are given a group of &lt;code&gt;n&lt;/code&gt; people, each with a unique amount of money and quietness. An array &lt;code&gt;richer&lt;/code&gt; specifies the relationships between people where &lt;code&gt;richer[i] = [ai, bi]&lt;/code&gt; indicates that person &lt;code&gt;ai&lt;/code&gt; has more money than person &lt;code&gt;bi&lt;/code&gt;. You are also given an array &lt;code&gt;quiet&lt;/code&gt; where &lt;code&gt;quiet[i]&lt;/code&gt; represents the quietness of person &lt;code&gt;i&lt;/code&gt;. Your task is to return an array &lt;code&gt;answer&lt;/code&gt; where &lt;code&gt;answer[x]&lt;/code&gt; is the person &lt;code&gt;y&lt;/code&gt; who has the least quietness among all people who have equal or more money than person &lt;code&gt;x&lt;/code&gt;. &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;problem-guide&#34;&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-tags&#34;&gt;&#xA;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Problem&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Problem&#39;)&#34;&gt;&#xA;             Problem             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Approach&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Approach&#39;)&#34;&gt;&#xA;             Approach             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Steps&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Steps&#39;)&#34;&gt;&#xA;             Steps             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Complexity&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Complexity&#39;)&#34;&gt;&#xA;             Complexity             &#xA;        &lt;/div&gt; &#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-content&#34;&gt;&#xA;&#xA;        &lt;div id=&#34;Problem&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: block;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;0&#34;&gt;Input Representations&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;1&#34;&gt;Output Specifications&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;2&#34;&gt;Core Logics&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;3&#34;&gt;Constraints&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;4&#34;&gt;Problem Assumptions&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;5&#34;&gt;Examples&lt;/button&gt;                &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Problem&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Input:&lt;/b&gt; The input consists of an array `richer`, where each element `richer[i] = [ai, bi]` represents a richer relationship between two people, and an array `quiet` where `quiet[i]` gives the quietness level of person `i`.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; Input: richer = [[2, 1], [3, 0], [4, 2]], quiet = [2, 3, 1, 0]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= n &amp;lt;= 500&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • quiet.length == n&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • All values of quiet are unique.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= richer.length &amp;lt;= n * (n - 1) / 2&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= ai, bi &amp;lt; n&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • ai != bi&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • All pairs in richer are unique and logically consistent.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Output:&lt;/b&gt; Return an array `answer` where each `answer[x]` represents the person with the least quietness among all people who have equal or more money than person `x`.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; Output: [3, 3, 2, 3]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The array `answer` must be of the same length as the input `quiet` array.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; The goal is to determine, for each person, the least quiet person who is either richer or equally rich.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 1: Build a graph of richer relationships, where each person points to those they are richer than.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 2: Use Depth First Search (DFS) to find the least quiet person among all people who have more money or are equally rich as the current person.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 3: Fill the result array with the index of the quietest person for each person in the group.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;                      &#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; Ensure that the solution works within the given constraints of `n` and `richer` size.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The input arrays `richer` and `quiet` will always be valid as per the problem&amp;#39;s constraints.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The function must handle up to 500 people efficiently.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;        &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Assumptions:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • All relationships in `richer` are logically consistent.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The input arrays `quiet` contain unique quietness values.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;     &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: richer = [[2, 1], [3, 0], [4, 2]], quiet = [2, 3, 1, 0]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; Here, person 0 is richer than 1, person 1 is richer than 2, and person 2 is richer than 3. By following the richer relationships and quietness values, we determine that for each person, the person with the least quietness among those richer or equally rich is as follows: [3, 3, 2, 3].&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: richer = [], quiet = [0]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; In this case, there is only one person. Since there are no richer relationships, the only answer is person 0 themselves. The output is [0].&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                    &lt;/div&gt;                         &#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Approach&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;0&#34;&gt;Approach&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;1&#34;&gt;Initial Thoughts&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;2&#34;&gt;Solution Designs&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;3&#34;&gt;Edge Cases&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Approach&#34;&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Approach:&lt;/b&gt; The solution leverages a depth-first search (DFS) approach to explore the richer relationships and determine the quietest person who is richer or equally rich.&lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Observations:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • We need to efficiently search for the quietest person who is richer or equally rich.&lt;/div&gt;&#xA;                            &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Using DFS will allow us to traverse the graph of relationships and propagate the quietest person for each person based on their richer relationships.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 1: Create a graph to store the richer relationships.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 2: Perform a DFS for each person to determine the quietest person among those who are richer or equally rich.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 3: Return the array of answers.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Empty Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • When there are no richer relationships, each person is only compared to themselves.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Large Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure the solution handles the case where `n` is large (up to 500) and all possible richer relationships are included.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Special Values:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If a person is the richest (or tied for the richest), their answer will be themselves.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;       &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The function must handle cases where no richer relationships exist.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;                                                                        &#xA;                    &lt;/div&gt;&#xA;                                        &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Steps&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;0&#34;&gt; Code &lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;1&#34;&gt; 1 Variable Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;2&#34;&gt; 2 Variable Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;3&#34;&gt; 3 Function Declaration&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;4&#34;&gt; 4 Populate Richer Relationships&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;5&#34;&gt; 5 Initialize Result Vector&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;6&#34;&gt; 6 Iterate Over Quiet Array&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;7&#34;&gt; 7 Return Result&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;8&#34;&gt; 8 Helper Function Declaration&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;9&#34;&gt; 9 Base Case Check&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;10&#34;&gt; 10 Initialize Current Person&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;11&#34;&gt; 11 Depth-First Search&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;12&#34;&gt; 12 Update Result&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;13&#34;&gt; 13 Return Result&lt;/button&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Steps&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &#xA;                            &#xA;                            &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;unordered_map&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; richer2;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; loudAndRich(vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; richer, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; quiet) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;v&lt;/span&gt;: richer) richer2[v[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]].push_back(v[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    res &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; (quiet.size(), &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; quiet.size(); i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) dfs(i, quiet);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;quiet) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(res[i] &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    res[i] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; i;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;j&lt;/span&gt; : richer2[i])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(quiet[res[i]] &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; quiet[dfs(j, quiet)]) res[i] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; res[j];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;1 : Variable Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;unordered_map&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; richer2;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Declare a hash map `richer2` to store relationships of richer individuals for each person. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;2 : Variable Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Declare a vector `res` to store the final results for each person. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;3 : Function Declaration&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; loudAndRich(vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; richer, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;amp;&lt;/span&gt; quiet) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Declare the function `loudAndRich`, which accepts the `richer` matrix and `quiet` vector to determine the least quiet richest person for each individual. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;4 : Populate Richer Relationships&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;v&lt;/span&gt;: richer) richer2[v[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]].push_back(v[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Populate the `richer2` map where for each person, the list of people they are richer than is stored. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;5 : Initialize Result Vector&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    res &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; (quiet.size(), &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize the `res` vector with the same size as the `quiet` vector, filled with -1. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;6 : Iterate Over Quiet Array&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; quiet.size(); i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) dfs(i, quiet);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterate through each person in the `quiet` array and call the `dfs` function to calculate the least quiet richest person for each. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;7 : Return Result&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Return the populated `res` vector containing the answers for each individual. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;8 : Helper Function Declaration&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;dfs&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;quiet) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Declare the helper function `dfs`, which performs a depth-first search to find the quietest and richest individual for person `i`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;9 : Base Case Check&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(res[i] &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Check if the result for person `i` has already been calculated. If so, return the result. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;10 : Initialize Current Person&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    res[i] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; i;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initially, assume that the least quiet richest person for `i` is themselves. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;11 : Depth-First Search&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;j&lt;/span&gt; : richer2[i])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each person `j` who is richer than `i`, perform a depth-first search to find their least quiet richest person. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;12 : Update Result&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(quiet[res[i]] &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; quiet[dfs(j, quiet)]) res[i] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; res[j];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If the quietness of the current person is greater than the quietness of the person found through DFS, update the result to the quieter person. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;13 : Return Result&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; res[i];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Return the result for person `i`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;        &#xA;        &lt;div id=&#34;Complexity&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;0&#34;&gt;Time Complexities&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;1&#34;&gt;Space Complexities&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Complexity&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Average Case:&lt;/b&gt; O(n &amp;#43; r)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; r)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The time complexity is O(n &amp;#43; r), where `n` is the number of people and `r` is the number of richer relationships. Each person is processed once, and we perform a DFS to explore all relationships.&lt;/div&gt;                                               &#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; r)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The space complexity is O(n &amp;#43; r), which accounts for the graph of richer relationships and the storage for the result array.&lt;/div&gt;    &#xA;                    &lt;/div&gt;&#xA;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt;        &#xA;&#xA;    &lt;/div&gt; &#xA;&#xA;    &lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;    &lt;ins class=&#34;adsbygoogle&#34;&#xA;        style=&#34;display:block; text-align:center;&#34;&#xA;        data-ad-layout=&#34;in-article&#34;&#xA;        data-ad-format=&#34;fluid&#34;&#xA;        data-ad-client=&#34;ca-pub-6219690368643953&#34;&#xA;        data-ad-slot=&#34;5533433286&#34;&gt;&lt;/ins&gt;&#xA;    &lt;script&gt;&#xA;        (adsbygoogle = window.adsbygoogle || []).push({});&#xA;    &lt;/script&gt;&#xA;&#xA;    &lt;script&gt;&#xA;        function switchProblemGuideContent(element, id) {&#xA;            document.querySelectorAll(&#39;.problem-guide-tag&#39;).forEach(tag =&gt; {&#xA;                tag.classList.remove(&#39;problem-guide-tag-active&#39;);&#xA;            });&#xA;&#xA;            element.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;&#xA;            document.querySelectorAll(&#39;.problem-guide-topic-content&#39;).forEach(content =&gt; {&#xA;                content.style.display = &#39;none&#39;;&#xA;            });&#xA;&#xA;            const activeContent = document.getElementById(id);&#xA;            activeContent.style.display = &#39;block&#39;;&#xA;            buttons_x(id)&#xA;        }&#xA;&#xA;        function buttons_x(id) {&#xA;&#xA;            const slides = document.getElementById(&#39;stepsSlides-&#39;+ id );&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-&#39; + id );&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;                console.log(buttons[index].id)&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;        }        &#xA;&#xA;        function buttons() {&#xA;            const slides = document.getElementById(&#39;stepsSlides-Problem&#39;);&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-Problem&#39;);&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;            const initialTag = document.querySelector(`.problem-guide-tag[data-target=&#34;Problem&#34;]`);&#xA;            if (initialTag) {&#xA;                initialTag.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            const contentElements = document.querySelectorAll(&#39;.problem-guide-content&#39;);&#xA;            let maxHeight = 0;&#xA;            contentElements.forEach(element =&gt; {&#xA;                const height = parseFloat(getComputedStyle(element).height);&#xA;                if (height &gt; maxHeight) {&#xA;                    maxHeight = height;&#xA;                }&#xA;            });&#xA;&#xA;            document.querySelector(&#39;.problem-guide-content&#39;).style.height = maxHeight + &#39;px&#39;;&#xA;&#xA;        }&#xA;&#xA;        document.addEventListener(&#39;DOMContentLoaded&#39;, buttons);&#xA;    &lt;/script&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/loud-and-rich/description/&#34;&gt;&lt;code&gt;Link to LeetCode Lab&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1462: Course Schedule IV</title>
      <link>https://www.grid47.xyz/leetcode/solution-1462-course-schedule-iv/</link>
      <pubDate>Thu, 13 Jun 2024 00:00:00 +0000</pubDate>
      <guid>https://www.grid47.xyz/leetcode/solution-1462-course-schedule-iv/</guid>
      <description>&lt;hr&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;&#34;&gt; You are given a set of courses numbered from 0 to numCourses - 1 and a list of prerequisites. Each prerequisite is a pair [ai, bi], indicating that you must complete course ai before course bi. For a series of queries, where each query asks whether a specific course is a prerequisite for another, you are tasked with determining whether each query is true or false. &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;problem-guide&#34;&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-tags&#34;&gt;&#xA;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Problem&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Problem&#39;)&#34;&gt;&#xA;             Problem             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Approach&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Approach&#39;)&#34;&gt;&#xA;             Approach             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Steps&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Steps&#39;)&#34;&gt;&#xA;             Steps             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Complexity&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Complexity&#39;)&#34;&gt;&#xA;             Complexity             &#xA;        &lt;/div&gt; &#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-content&#34;&gt;&#xA;&#xA;        &lt;div id=&#34;Problem&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: block;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;0&#34;&gt;Input Representations&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;1&#34;&gt;Output Specifications&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;2&#34;&gt;Core Logics&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;3&#34;&gt;Constraints&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;4&#34;&gt;Problem Assumptions&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;5&#34;&gt;Examples&lt;/button&gt;                &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Problem&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Input:&lt;/b&gt; You are provided with two inputs: numCourses, the number of courses, and prerequisites, an array of pairs indicating course dependencies. Additionally, you are given queries, where each query asks whether one course is a prerequisite for another.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; Input: numCourses = 3, prerequisites = [[1,0],[2,1],[2,0]], queries = [[1,0], [0,2]]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 2 &amp;lt;= numCourses &amp;lt;= 100&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= prerequisites.length &amp;lt;= (numCourses * (numCourses - 1) / 2)&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • prerequisites[i].length == 2&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= ai, bi &amp;lt;= numCourses - 1&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • ai != bi&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • All pairs [ai, bi] are unique&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The graph of prerequisites contains no cycles&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= queries.length &amp;lt;= 10^4&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= ui, vi &amp;lt;= numCourses - 1&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • ui != vi&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Output:&lt;/b&gt; The output consists of a boolean array, where each element represents the answer to the corresponding query. If the first course in a query is a prerequisite of the second course, the corresponding answer is true; otherwise, it is false.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; Output: [true, false]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The output is an array of booleans, each indicating whether the first course in a query is a prerequisite for the second course.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; Efficiently determine whether each course in the queries list is a prerequisite of another.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Construct a graph where each node represents a course and an edge from course A to course B indicates that A is a prerequisite for B.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • For each course, perform a breadth-first search (BFS) to find all courses that are reachable from it.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Store the reachable courses in a 2D array (reach), where reach[i][j] is true if course i is a prerequisite of course j.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • For each query, check the reach array to see if the first course is a prerequisite of the second.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;                      &#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; The problem has certain constraints to ensure that the solution can be computed within acceptable limits.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The maximum number of courses is 100, making it feasible to process using graph traversal algorithms like BFS.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The number of queries can be large, so the solution must be efficient in answering them.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;        &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Assumptions:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The graph of prerequisites is a Directed Acyclic Graph (DAG), meaning there are no cycles.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The input queries are valid and do not contain any invalid course numbers.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;     &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: numCourses = 3, prerequisites = [[1,0],[2,1],[2,0]], queries = [[1,0], [0,2]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; Output: [true, false]. Course 1 is a prerequisite of course 0, but course 0 is not a prerequisite of course 2.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: numCourses = 2, prerequisites = [], queries = [[0,1], [1,0]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; Output: [false, false]. Since there are no prerequisites, no course is a prerequisite of another.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                    &lt;/div&gt;                         &#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Approach&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;0&#34;&gt;Approach&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;1&#34;&gt;Initial Thoughts&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;2&#34;&gt;Solution Designs&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;3&#34;&gt;Edge Cases&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Approach&#34;&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Approach:&lt;/b&gt; To solve this problem, we will model the courses and their prerequisites as a directed graph and use breadth-first search (BFS) to find all prerequisites for each course.&lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Observations:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The problem is essentially about finding transitive closures in a directed graph.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • BFS can be used to explore all courses reachable from a given course, thus identifying all its prerequisites.&lt;/div&gt;&#xA;                            &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Using BFS to traverse the graph ensures we efficiently find all courses that are prerequisites for a given course.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Build the graph using an adjacency list, where each node points to its dependent courses.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Perform BFS from each course to determine all courses that are reachable from it.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • For each query, check if the first course is reachable from the second course using the BFS results.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Empty Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If there are no prerequisites, all queries will return false unless they are self-referential.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Large Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If there are a large number of queries (up to 10^4), the solution must handle them efficiently without repeated computations.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Special Values:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • For queries where both courses are the same, the result should always be true, as a course is trivially a prerequisite of itself.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;       &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure that the graph has no cycles, as stated in the problem&amp;#39;s constraints.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;                                                                        &#xA;                    &lt;/div&gt;&#xA;                                        &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Steps&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;0&#34;&gt; Code &lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;1&#34;&gt; 1 Function Definition&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;2&#34;&gt; 2 Variable Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;3&#34;&gt; 3 Graph Representation&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;4&#34;&gt; 4 Edge Insertion&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;5&#34;&gt; 5 Edge Insertion&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;6&#34;&gt; 6 BFS Traversal&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;7&#34;&gt; 7 Queue Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;8&#34;&gt; 8 Queue Operation&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;9&#34;&gt; 9 Visited Array Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;10&#34;&gt; 10 Visited Array Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;11&#34;&gt; 11 BFS Loop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;12&#34;&gt; 12 Queue Size Calculation&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;13&#34;&gt; 13 BFS Loop Inner&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;14&#34;&gt; 14 Queue Dequeue&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;15&#34;&gt; 15 Queue Dequeue&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;16&#34;&gt; 16 Neighbor Processing&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;17&#34;&gt; 17 Reach Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;18&#34;&gt; 18 Visitation Check&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;19&#34;&gt; 19 Mark as Visited&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;20&#34;&gt; 20 Queue Push&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;21&#34;&gt; 21 Answer Preparation&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;22&#34;&gt; 22 Query Evaluation&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;23&#34;&gt; 23 Query Answering&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;24&#34;&gt; 24 Return Final Answer&lt;/button&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Steps&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &#xA;                            &#xA;                            &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; checkIfPrerequisite(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; num, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; pre, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; q) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; reach(num, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt;(num, &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; grid(num);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: pre) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        grid[it[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]].push_back(it[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; num; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; vis(num, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);            &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        vis[i] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; sz &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(sz&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; tmp &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: grid[tmp]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    reach[i][it] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(vis[it]) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;continue&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    vis[it] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    q.push(it);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; ans(q.size());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; q.size(); i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#080;font-style:italic&#34;&gt;// is q[0] a pre of q[1];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#080;font-style:italic&#34;&gt;&lt;/span&gt;        ans[i] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; reach[q[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]][q[i][&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;1 : Function Definition&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; checkIfPrerequisite(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; num, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; pre, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; q) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This function checks if one course is a prerequisite for another, given a list of prerequisites and a set of queries. It returns a boolean vector indicating the answer for each query. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;2 : Variable Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; reach(num, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt;(num, &lt;span style=&#34;color:#a2f&#34;&gt;false&lt;/span&gt;));&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initializes a 2D boolean array &amp;#39;reach&amp;#39; to keep track of whether a course can reach another course (i.e., if one is a prerequisite of the other). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;3 : Graph Representation&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; grid(num);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Creates an adjacency list &amp;#39;grid&amp;#39; where each index represents a course, and the list at each index holds courses that are directly dependent on that course. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;4 : Edge Insertion&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: pre) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterates through each prerequisite pair, where &amp;#39;it&amp;#39; contains two elements: the first is the prerequisite course, and the second is the course that depends on it. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;5 : Edge Insertion&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        grid[it[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]].push_back(it[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Adds an edge to the adjacency list, indicating that course &amp;#39;it[0]&amp;#39; is a prerequisite for course &amp;#39;it[1]&amp;#39;. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;6 : BFS Traversal&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; num; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterates over each course to check which other courses it can reach using breadth-first search. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;7 : Queue Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initializes a queue for breadth-first search (BFS). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;8 : Queue Operation&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Pushes the current course (i) into the queue to begin BFS from that course. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;9 : Visited Array Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; vis(num, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);            &#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initializes a &amp;#39;vis&amp;#39; vector to track visited courses, ensuring each course is processed only once during BFS. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;10 : Visited Array Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        vis[i] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Marks the current course as visited. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;11 : BFS Loop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Starts the BFS loop, which continues as long as there are courses in the queue to process. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;12 : Queue Size Calculation&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; sz &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Stores the number of courses in the queue at the beginning of each BFS iteration. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;13 : BFS Loop Inner&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(sz&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Processes all courses at the current BFS level. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;14 : Queue Dequeue&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; tmp &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Gets the next course from the front of the queue to process. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;15 : Queue Dequeue&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Removes the processed course from the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;16 : Neighbor Processing&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: grid[tmp]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterates over all courses that are directly dependent on the current course &amp;#39;tmp&amp;#39;. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;17 : Reach Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    reach[i][it] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Marks that course &amp;#39;it&amp;#39; is reachable from course &amp;#39;i&amp;#39;. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;18 : Visitation Check&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(vis[it]) &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;continue&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Checks if the dependent course &amp;#39;it&amp;#39; has already been visited. If it has, it skips to the next course. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;19 : Mark as Visited&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    vis[it] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a2f&#34;&gt;true&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Marks course &amp;#39;it&amp;#39; as visited. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;20 : Queue Push&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    q.push(it);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Adds course &amp;#39;it&amp;#39; to the queue for further BFS processing. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;21 : Answer Preparation&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;bool&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; ans(q.size());&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initializes a boolean vector &amp;#39;ans&amp;#39; to store the results of each query. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;22 : Query Evaluation&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; q.size(); i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterates through each query to check if the first course is a prerequisite of the second. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;23 : Query Answering&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        ans[i] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; reach[q[i][&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]][q[i][&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each query, checks if the first course is a prerequisite of the second and stores the result in the &amp;#39;ans&amp;#39; vector. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;24 : Return Final Answer&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; ans;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Returns the vector &amp;#39;ans&amp;#39;, containing the results for each query. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;        &#xA;        &lt;div id=&#34;Complexity&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;0&#34;&gt;Time Complexities&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;1&#34;&gt;Space Complexities&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Complexity&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Average Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The time complexity is O(n &amp;#43; e), where n is the number of courses and e is the number of prerequisites. This is because we traverse all courses and their edges (dependencies) once.&lt;/div&gt;                                               &#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n^2)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; In the worst case, space complexity is O(n^2) to store the reachability matrix, but in general, it will be O(n &amp;#43; e) for storing the graph and visited nodes.&lt;/div&gt;    &#xA;                    &lt;/div&gt;&#xA;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt;        &#xA;&#xA;    &lt;/div&gt; &#xA;&#xA;    &lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;    &lt;ins class=&#34;adsbygoogle&#34;&#xA;        style=&#34;display:block; text-align:center;&#34;&#xA;        data-ad-layout=&#34;in-article&#34;&#xA;        data-ad-format=&#34;fluid&#34;&#xA;        data-ad-client=&#34;ca-pub-6219690368643953&#34;&#xA;        data-ad-slot=&#34;5533433286&#34;&gt;&lt;/ins&gt;&#xA;    &lt;script&gt;&#xA;        (adsbygoogle = window.adsbygoogle || []).push({});&#xA;    &lt;/script&gt;&#xA;&#xA;    &lt;script&gt;&#xA;        function switchProblemGuideContent(element, id) {&#xA;            document.querySelectorAll(&#39;.problem-guide-tag&#39;).forEach(tag =&gt; {&#xA;                tag.classList.remove(&#39;problem-guide-tag-active&#39;);&#xA;            });&#xA;&#xA;            element.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;&#xA;            document.querySelectorAll(&#39;.problem-guide-topic-content&#39;).forEach(content =&gt; {&#xA;                content.style.display = &#39;none&#39;;&#xA;            });&#xA;&#xA;            const activeContent = document.getElementById(id);&#xA;            activeContent.style.display = &#39;block&#39;;&#xA;            buttons_x(id)&#xA;        }&#xA;&#xA;        function buttons_x(id) {&#xA;&#xA;            const slides = document.getElementById(&#39;stepsSlides-&#39;+ id );&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-&#39; + id );&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;                console.log(buttons[index].id)&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;        }        &#xA;&#xA;        function buttons() {&#xA;            const slides = document.getElementById(&#39;stepsSlides-Problem&#39;);&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-Problem&#39;);&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;            const initialTag = document.querySelector(`.problem-guide-tag[data-target=&#34;Problem&#34;]`);&#xA;            if (initialTag) {&#xA;                initialTag.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            const contentElements = document.querySelectorAll(&#39;.problem-guide-content&#39;);&#xA;            let maxHeight = 0;&#xA;            contentElements.forEach(element =&gt; {&#xA;                const height = parseFloat(getComputedStyle(element).height);&#xA;                if (height &gt; maxHeight) {&#xA;                    maxHeight = height;&#xA;                }&#xA;            });&#xA;&#xA;            document.querySelector(&#39;.problem-guide-content&#39;).style.height = maxHeight + &#39;px&#39;;&#xA;&#xA;        }&#xA;&#xA;        document.addEventListener(&#39;DOMContentLoaded&#39;, buttons);&#xA;    &lt;/script&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/course-schedule-iv/description/&#34;&gt;&lt;code&gt;Link to LeetCode Lab&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1786: Number of Restricted Paths From First to Last Node</title>
      <link>https://www.grid47.xyz/leetcode/solution-1786-number-of-restricted-paths-from-first-to-last-node/</link>
      <pubDate>Sun, 12 May 2024 00:00:00 +0000</pubDate>
      <guid>https://www.grid47.xyz/leetcode/solution-1786-number-of-restricted-paths-from-first-to-last-node/</guid>
      <description>&lt;hr&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;&#34;&gt; &lt;p&gt;You are given a connected, undirected, weighted graph with n nodes, labeled from 1 to n. An array &amp;rsquo;edges&amp;rsquo; represents the edges in the graph where each element edges[i] = [ui, vi, weighti] indicates that there is an edge between nodes ui and vi with a weight of weighti. A path from node start to node end is a sequence of nodes [z0, z1, &amp;hellip;, zk] such that z0 = start, zk = end, and there is an edge between zi and zi+1 for each 0 &amp;lt;= i &amp;lt;= k-1.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 1976: Number of Ways to Arrive at Destination</title>
      <link>https://www.grid47.xyz/leetcode/solution-1976-number-of-ways-to-arrive-at-destination/</link>
      <pubDate>Tue, 23 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://www.grid47.xyz/leetcode/solution-1976-number-of-ways-to-arrive-at-destination/</guid>
      <description>&lt;hr&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;&#34;&gt; You are in a city with &lt;code&gt;n&lt;/code&gt; intersections, and roads connecting them with specific travel times. Your task is to find the number of different ways you can travel from intersection 0 to intersection n-1 in the shortest time possible. Since the result could be large, return it modulo (10^9 + 7). &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;problem-guide&#34;&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-tags&#34;&gt;&#xA;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Problem&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Problem&#39;)&#34;&gt;&#xA;             Problem             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Approach&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Approach&#39;)&#34;&gt;&#xA;             Approach             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Steps&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Steps&#39;)&#34;&gt;&#xA;             Steps             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Complexity&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Complexity&#39;)&#34;&gt;&#xA;             Complexity             &#xA;        &lt;/div&gt; &#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-content&#34;&gt;&#xA;&#xA;        &lt;div id=&#34;Problem&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: block;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;0&#34;&gt;Input Representations&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;1&#34;&gt;Output Specifications&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;2&#34;&gt;Core Logics&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;3&#34;&gt;Constraints&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;4&#34;&gt;Problem Assumptions&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;5&#34;&gt;Examples&lt;/button&gt;                &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Problem&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Input:&lt;/b&gt; The input consists of an integer `n` (the number of intersections) and a 2D integer array `roads` where each road is represented by three integers `[u, v, time]`, indicating a road between intersection `u` and `v` that takes `time` minutes to travel.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; n = 4, roads = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 2, 2], [1, 3, 2]]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= n &amp;lt;= 200&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • n - 1 &amp;lt;= roads.length &amp;lt;= n * (n - 1) / 2&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= ui, vi &amp;lt;= n - 1&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= time &amp;lt;= 10^9&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • ui != vi&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • There is at most one road between any two intersections&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • You can reach any intersection from any other intersection&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Output:&lt;/b&gt; The output should be a single integer, representing the number of different ways to travel from intersection 0 to intersection n-1 using the shortest time. The answer should be returned modulo (10^9 &amp;#43; 7).&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; Output: 2&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The result should be an integer.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; Find the number of ways to travel from intersection 0 to intersection n-1 in the shortest time.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 1: Build a graph where each node represents an intersection and each edge represents a road with a time cost.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 2: Use Dijkstra&amp;#39;s algorithm to find the shortest time to reach all intersections from intersection 0.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 3: Track the number of ways to reach each intersection with the shortest time, updating the count whenever a shorter path is found or an equal-length path is discovered.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 4: Return the number of ways to reach intersection n-1, modulo (10^9 &amp;#43; 7).&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;                      &#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; The solution must be efficient enough to handle the problem&amp;#39;s constraints.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The matrix size `n` can be as large as 200.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The number of roads can be as large as ( n(n - 1)/2 ), so the solution must be optimized.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;        &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Assumptions:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The graph is connected, meaning there&amp;#39;s always a path from intersection 0 to intersection n-1.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • There is only one road between any two intersections.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;     &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: n = 4, roads = [[0, 1, 1], [1, 2, 1], [2, 3, 1], [0, 2, 2], [1, 3, 2]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; In this case, the shortest time to go from intersection 0 to intersection 3 is 3 minutes, and there are two ways to achieve this: [0 -&amp;gt; 1 -&amp;gt; 2 -&amp;gt; 3] and [0 -&amp;gt; 2 -&amp;gt; 3].&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; Input: n = 3, roads = [[0, 1, 5], [1, 2, 10]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; In this case, the only possible way to go from intersection 0 to intersection 2 takes 15 minutes: [0 -&amp;gt; 1 -&amp;gt; 2].&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                    &lt;/div&gt;                         &#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Approach&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;0&#34;&gt;Approach&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;1&#34;&gt;Initial Thoughts&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;2&#34;&gt;Solution Designs&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;3&#34;&gt;Edge Cases&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Approach&#34;&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Approach:&lt;/b&gt; The approach involves using Dijkstra&amp;#39;s algorithm to find the shortest paths from intersection 0 to all other intersections, while keeping track of the number of ways to reach each intersection with the shortest time.&lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Observations:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Dijkstra&amp;#39;s algorithm is a natural fit for finding the shortest path in a graph with weighted edges.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • We need to track not only the shortest distances but also the number of ways to reach each node with those distances.&lt;/div&gt;&#xA;                            &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • We need to modify Dijkstra&amp;#39;s algorithm to maintain the count of ways to reach each node in the shortest time.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 1: Initialize a priority queue for Dijkstra&amp;#39;s algorithm with the start node (intersection 0).&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 2: Use a `ways` array to keep track of the number of ways to reach each intersection, and a `dst` array for the shortest time to each intersection.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 3: For each node, examine its neighbors. If a shorter path is found, update the time and the number of ways to reach that neighbor.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 4: If an equal-length path is found, add the number of ways from the current node to the neighbor modulo (10^9 &amp;#43; 7).&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Step 5: After processing all nodes, return the value of `ways[n-1]`.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Empty Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The problem guarantees that there is always at least one road connecting the intersections.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Large Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure the solution can handle the maximum number of roads and intersections, with up to 200 intersections.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Special Values:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If the graph has only two nodes, the answer is always 1 because there&amp;#39;s exactly one road between them.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;       &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure the result is calculated modulo (10^9 &amp;#43; 7).&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;                                                                        &#xA;                    &lt;/div&gt;&#xA;                                        &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Steps&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;0&#34;&gt; Code &lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;1&#34;&gt; 1 Function Definition&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;2&#34;&gt; 2 Data Structures&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;3&#34;&gt; 3 Loop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;4&#34;&gt; 4 Variable Assignment&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;5&#34;&gt; 5 Graph Construction&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;6&#34;&gt; 6 Graph Construction&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;7&#34;&gt; 7 Variable Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;8&#34;&gt; 8 Variable Assignment&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;9&#34;&gt; 9 Variable Assignment&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;10&#34;&gt; 10 Priority Queue Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;11&#34;&gt; 11 Priority Queue Push&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;12&#34;&gt; 12 Variable Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;13&#34;&gt; 13 Main Loop&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;14&#34;&gt; 14 Priority Queue Operations&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;15&#34;&gt; 15 Priority Queue Operations&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;16&#34;&gt; 16 Graph Traversal&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;17&#34;&gt; 17 Variable Assignment&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;18&#34;&gt; 18 Condition Check&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;19&#34;&gt; 19 Update Distance and Path&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;20&#34;&gt; 20 Update Path Count&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;21&#34;&gt; 21 Push to Priority Queue&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;22&#34;&gt; 22 Path Count Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;23&#34;&gt; 23 Path Count Update&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;24&#34;&gt; 24 Return Statement&lt;/button&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Steps&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &#xA;                            &#xA;                            &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;countPaths&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; rds) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;pll&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; gph(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;e&lt;/span&gt; : rds) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; u &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; e[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;], v &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; e[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;], time &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; e[&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        gph[u].push_back({v, time});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        gph[v].push_back({u, time});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;ll&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; ways(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;), dst(n, LLONG_MAX);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ways[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     dst[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    priority_queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;pll, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;pll&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt;, greater&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&amp;gt;&amp;gt;&lt;/span&gt; pq;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pq.push({&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;pq.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; [d, u] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; pq.top();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      pq.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(pll &lt;span style=&#34;color:#a0a000&#34;&gt;nb&lt;/span&gt; : gph[u]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; nxt &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; nb.first, t &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; nb.second;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(dst[nxt] &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; d &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; t) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       dst[nxt] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; d &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; t;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       ways[nxt] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ways[u];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       pq.push({d &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; t, nxt});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt; (dst[nxt] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; d &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; t) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       ways[nxt] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (ways[nxt] &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; ways[u]) &lt;span style=&#34;color:#666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1000000007&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; ways[n &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;1 : Function Definition&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;countPaths&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; rds) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This line defines the function `countPaths`, which takes an integer `n` (number of nodes) and a 2D vector `rds` (edges and times) as input. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;2 : Data Structures&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;pll&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; gph(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This initializes a graph `gph` represented as an adjacency list of pairs, where each pair holds a neighboring node and the edge&amp;#39;s weight. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;3 : Loop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a0a000&#34;&gt;e&lt;/span&gt; : rds) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This begins a loop over the input vector `rds`, which represents the edges of the graph, where each edge is described by a triplet (u, v, time). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;4 : Variable Assignment&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; u &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; e[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;], v &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; e[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;], time &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; e[&lt;span style=&#34;color:#666&#34;&gt;2&lt;/span&gt;];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; For each edge `e`, the values of `u` (start node), `v` (end node), and `time` (edge weight) are extracted. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;5 : Graph Construction&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        gph[u].push_back({v, time});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This adds the edge (v, time) to the adjacency list of node `u`, indicating a directed edge from `u` to `v` with weight `time`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;6 : Graph Construction&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        gph[v].push_back({u, time});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Similarly, this adds the edge (u, time) to the adjacency list of node `v`, making the graph undirected. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;7 : Variable Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;ll&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; ways(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;), dst(n, LLONG_MAX);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Two vectors are initialized: `ways` to store the number of ways to reach each node, and `dst` to store the shortest distance to each node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;8 : Variable Assignment&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ways[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Set the number of ways to reach the starting node (node 0) to 1. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;9 : Variable Assignment&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;     dst[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Set the distance to the starting node to 0. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;10 : Priority Queue Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    priority_queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;pll, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;pll&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt;, greater&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&amp;gt;&amp;gt;&lt;/span&gt; pq;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; A priority queue `pq` is initialized, which will be used to process nodes based on the shortest distance (min-heap). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;11 : Priority Queue Push&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    pq.push({&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Push the starting node (0) with distance 0 into the priority queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;12 : Variable Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; ans &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Initialize a variable `ans` to store the result. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;13 : Main Loop&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;pq.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Start a loop to process the nodes in the priority queue, which will always process the node with the smallest distance first. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;14 : Priority Queue Operations&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; [d, u] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; pq.top();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Extract the node with the smallest distance from the priority queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;15 : Priority Queue Operations&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;      pq.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Pop the node from the priority queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;16 : Graph Traversal&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(pll &lt;span style=&#34;color:#a0a000&#34;&gt;nb&lt;/span&gt; : gph[u]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Traverse the neighbors of node `u` in the graph. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;17 : Variable Assignment&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;          &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; nxt &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; nb.first, t &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; nb.second;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Extract the next node (`nxt`) and edge weight (`t`) from the neighbor pair. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;18 : Condition Check&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(dst[nxt] &lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; d &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; t) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Check if a shorter path to `nxt` is found. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;19 : Update Distance and Path&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       dst[nxt] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; d &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; t;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Update the shortest distance to `nxt`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;20 : Update Path Count&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       ways[nxt] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; ways[u];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Set the number of ways to reach `nxt` to the number of ways to reach `u`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;21 : Push to Priority Queue&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       pq.push({d &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; t, nxt});&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Push the updated node `nxt` with its new distance to the priority queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;22 : Path Count Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;   } &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#00a000&#34;&gt;if&lt;/span&gt; (dst[nxt] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; d &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; t) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If the current path to `nxt` is equal to the best known distance, update the number of ways. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;23 : Path Count Update&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;       ways[nxt] &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; (ways[nxt] &lt;span style=&#34;color:#666&#34;&gt;+&lt;/span&gt; ways[u]) &lt;span style=&#34;color:#666&#34;&gt;%&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1000000007&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Add the number of ways to reach `u` to the number of ways to reach `nxt`, keeping it modulo 1000000007. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;24 : Return Statement&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; ways[n &lt;span style=&#34;color:#666&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;];&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Return the number of ways to reach the last node (`n - 1`). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;        &#xA;        &lt;div id=&#34;Complexity&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;0&#34;&gt;Time Complexities&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;1&#34;&gt;Space Complexities&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Complexity&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O((n &amp;#43; m) log n), where n is the number of intersections and m is the number of roads.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Average Case:&lt;/b&gt; O((n &amp;#43; m) log n)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O((n &amp;#43; m) log n)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The time complexity is dominated by the priority queue operations in Dijkstra&amp;#39;s algorithm.&lt;/div&gt;                                               &#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; m)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; m), where n is the number of intersections and m is the number of roads.&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The space complexity is dominated by the storage required for the graph representation and the arrays used in Dijkstra&amp;#39;s algorithm.&lt;/div&gt;    &#xA;                    &lt;/div&gt;&#xA;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt;        &#xA;&#xA;    &lt;/div&gt; &#xA;&#xA;    &lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;    &lt;ins class=&#34;adsbygoogle&#34;&#xA;        style=&#34;display:block; text-align:center;&#34;&#xA;        data-ad-layout=&#34;in-article&#34;&#xA;        data-ad-format=&#34;fluid&#34;&#xA;        data-ad-client=&#34;ca-pub-6219690368643953&#34;&#xA;        data-ad-slot=&#34;5533433286&#34;&gt;&lt;/ins&gt;&#xA;    &lt;script&gt;&#xA;        (adsbygoogle = window.adsbygoogle || []).push({});&#xA;    &lt;/script&gt;&#xA;&#xA;    &lt;script&gt;&#xA;        function switchProblemGuideContent(element, id) {&#xA;            document.querySelectorAll(&#39;.problem-guide-tag&#39;).forEach(tag =&gt; {&#xA;                tag.classList.remove(&#39;problem-guide-tag-active&#39;);&#xA;            });&#xA;&#xA;            element.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;&#xA;            document.querySelectorAll(&#39;.problem-guide-topic-content&#39;).forEach(content =&gt; {&#xA;                content.style.display = &#39;none&#39;;&#xA;            });&#xA;&#xA;            const activeContent = document.getElementById(id);&#xA;            activeContent.style.display = &#39;block&#39;;&#xA;            buttons_x(id)&#xA;        }&#xA;&#xA;        function buttons_x(id) {&#xA;&#xA;            const slides = document.getElementById(&#39;stepsSlides-&#39;+ id );&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-&#39; + id );&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;                console.log(buttons[index].id)&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;        }        &#xA;&#xA;        function buttons() {&#xA;            const slides = document.getElementById(&#39;stepsSlides-Problem&#39;);&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-Problem&#39;);&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;            const initialTag = document.querySelector(`.problem-guide-tag[data-target=&#34;Problem&#34;]`);&#xA;            if (initialTag) {&#xA;                initialTag.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            const contentElements = document.querySelectorAll(&#39;.problem-guide-content&#39;);&#xA;            let maxHeight = 0;&#xA;            contentElements.forEach(element =&gt; {&#xA;                const height = parseFloat(getComputedStyle(element).height);&#xA;                if (height &gt; maxHeight) {&#xA;                    maxHeight = height;&#xA;                }&#xA;            });&#xA;&#xA;            document.querySelector(&#39;.problem-guide-content&#39;).style.height = maxHeight + &#39;px&#39;;&#xA;&#xA;        }&#xA;&#xA;        document.addEventListener(&#39;DOMContentLoaded&#39;, buttons);&#xA;    &lt;/script&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/description/&#34;&gt;&lt;code&gt;Link to LeetCode Lab&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
    <item>
      <title>Leetcode 2192: All Ancestors of a Node in a Directed Acyclic Graph</title>
      <link>https://www.grid47.xyz/leetcode/solution-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/</link>
      <pubDate>Mon, 01 Apr 2024 00:00:00 +0000</pubDate>
      <guid>https://www.grid47.xyz/leetcode/solution-2192-all-ancestors-of-a-node-in-a-directed-acyclic-graph/</guid>
      <description>&lt;hr&gt;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;&#34;&gt; You are given a directed acyclic graph (DAG) with &lt;code&gt;n&lt;/code&gt; nodes, numbered from 0 to &lt;code&gt;n-1&lt;/code&gt;. Along with this, you are given a list of directed edges where each edge &lt;code&gt;[fromi, toi]&lt;/code&gt; indicates a directed edge from node &lt;code&gt;fromi&lt;/code&gt; to node &lt;code&gt;toi&lt;/code&gt;. For each node in the graph, you need to determine the list of all its ancestors. A node &lt;code&gt;u&lt;/code&gt; is an ancestor of node &lt;code&gt;v&lt;/code&gt; if there is a path from &lt;code&gt;u&lt;/code&gt; to &lt;code&gt;v&lt;/code&gt; through one or more directed edges. Return a list &lt;code&gt;answer&lt;/code&gt; where &lt;code&gt;answer[i]&lt;/code&gt; contains the sorted list of ancestors of the &lt;code&gt;i&lt;/code&gt;-th node. &lt;/div&gt;&#xA;&#xA;&#xA;&#xA;&lt;div class=&#34;problem-guide&#34;&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-tags&#34;&gt;&#xA;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Problem&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Problem&#39;)&#34;&gt;&#xA;             Problem             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Approach&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Approach&#39;)&#34;&gt;&#xA;             Approach             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Steps&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Steps&#39;)&#34;&gt;&#xA;             Steps             &#xA;        &lt;/div&gt;&#xA;        &lt;div class=&#34;problem-guide-tag&#34; &#xA;             data-target=&#34;Complexity&#34; &#xA;             onclick=&#34;switchProblemGuideContent(this, &#39;Complexity&#39;)&#34;&gt;&#xA;             Complexity             &#xA;        &lt;/div&gt; &#xA;    &lt;/div&gt;&#xA;&#xA;    &#xA;    &lt;div class=&#34;problem-guide-content&#34;&gt;&#xA;&#xA;        &lt;div id=&#34;Problem&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: block;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;0&#34;&gt;Input Representations&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;1&#34;&gt;Output Specifications&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;2&#34;&gt;Core Logics&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;3&#34;&gt;Constraints&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;4&#34;&gt;Problem Assumptions&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Problem&#34; data-slide=&#34;5&#34;&gt;Examples&lt;/button&gt;                &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Problem&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Input:&lt;/b&gt; The input consists of an integer `n` representing the number of nodes in the graph, followed by a list of edges describing the directed edges.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; n = 6, edgeList = [[0,1],[0,2],[1,3],[1,4],[2,5],[4,5]]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= n &amp;lt;= 1000&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= edges.length &amp;lt;= min(2000, n * (n - 1) / 2)&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • edges[i].length == 2&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 0 &amp;lt;= fromi, toi &amp;lt;= n - 1&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • fromi != toi&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • There are no duplicate edges&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The graph is directed and acyclic&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Output:&lt;/b&gt; Return a list `answer` where `answer[i]` is the list of ancestors of the `i`-th node, sorted in ascending order.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Example:&lt;/b&gt; [[], [0], [0], [0, 1], [0, 1, 2], [0, 1, 2, 4]]&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The list of ancestors for each node should be sorted in ascending order.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; The goal is to compute the ancestors of each node in the graph efficiently.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1. Create a graph representation using adjacency lists for outgoing edges and maintain a count of incoming edges for each node.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 2. Perform a topological sort using Kahn&amp;#39;s algorithm to ensure that nodes are processed in the correct order.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 3. For each node, use its ancestors (processed nodes) and propagate the ancestors through the graph, adding them to the current node&amp;#39;s ancestor set.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;                      &#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Goal:&lt;/b&gt; The solution should handle up to 1000 nodes and up to 2000 edges efficiently.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1 &amp;lt;= n &amp;lt;= 1000&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • edges.length &amp;lt;= 2000&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;        &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Assumptions:&lt;/b&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The graph is acyclic, so there will be no cycles.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;     &#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Input:&lt;/b&gt; n = 6, edgeList = [[0,1],[0,2],[1,3],[1,4],[2,5],[4,5]]&lt;/div&gt;&#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • &lt;b&gt;Explanation:&lt;/b&gt; In this case, node 0 has no ancestors, node 1 has node 0 as an ancestor, node 3 has nodes 0 and 1 as ancestors, and so on.&lt;/div&gt;                                &#xA;                                &lt;br/&gt;&#xA;                            &#xA;                    &lt;/div&gt;                         &#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Approach&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;0&#34;&gt;Approach&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;1&#34;&gt;Initial Thoughts&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;2&#34;&gt;Solution Designs&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Approach&#34; data-slide=&#34;3&#34;&gt;Edge Cases&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Approach&#34;&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Approach:&lt;/b&gt; To find the ancestors of each node, we use a topological sort approach to traverse the graph, propagating ancestors through the nodes.&lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Observations:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Topological sorting is key to processing the nodes in the correct order.&lt;/div&gt;&#xA;                            &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • We need to track the ancestors of each node as we process the graph to ensure we capture all nodes that can reach the current node.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;                    &#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Steps:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 1. Create an adjacency list to store the graph.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 2. Use Kahn&amp;#39;s algorithm for topological sorting to determine the order in which nodes should be processed.&lt;/div&gt;&#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • 3. For each node, propagate ancestors from previously processed nodes.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Empty Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • If there are no edges, each node will only have itself as an ancestor.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Large Inputs:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • The solution should efficiently handle cases where `n` is large and the graph has many edges.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Special Values:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Handle edge cases like disconnected nodes where no edges lead to certain nodes.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;       &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Constraints:&lt;/b&gt;                        &#xA;                            &#xA;                                &lt;div style=&#34;margin-left: 20px;&#34;&gt; • Ensure that no cycles are present as the graph is guaranteed to be acyclic.&lt;/div&gt;&#xA;                            &#xA;                        &lt;/div&gt;                                                                        &#xA;                    &lt;/div&gt;&#xA;                                        &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;&#xA;        &lt;div id=&#34;Steps&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;0&#34;&gt; Code &lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;1&#34;&gt; 1 Function Definition&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;2&#34;&gt; 2 Variable Declaration&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;3&#34;&gt; 3 Variable Declaration&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;4&#34;&gt; 4 Variable Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;5&#34;&gt; 5 Looping&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;6&#34;&gt; 6 Graph Construction&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;7&#34;&gt; 7 Graph Construction&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;8&#34;&gt; 8 Queue Initialization&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;9&#34;&gt; 9 Looping&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;10&#34;&gt; 10 Queue Population&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;11&#34;&gt; 11 Looping&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;12&#34;&gt; 12 Queue Size Calculation&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;13&#34;&gt; 13 Looping&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;14&#34;&gt; 14 Queue Dequeue&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;15&#34;&gt; 15 Queue Dequeue&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;16&#34;&gt; 16 Graph Traversal&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;17&#34;&gt; 17 Edge Processing&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;18&#34;&gt; 18 Ancestor Tracking&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;19&#34;&gt; 19 Ancestor Propagation&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;20&#34;&gt; 20 Ancestor Propagation&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;21&#34;&gt; 21 Queue Population&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;22&#34;&gt; 22 Queue Population&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;23&#34;&gt; 23 Ancestor Assignment&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;24&#34;&gt; 24 Ancestor Assignment&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;25&#34;&gt; 25 Ancestor Assignment&lt;/button&gt;&#xA;                    &#xA;                        &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Steps&#34; data-slide=&#34;26&#34;&gt; 26 Return&lt;/button&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Steps&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &#xA;                            &#xA;                            &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; getAncestors(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; edges) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;set&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; dag(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; grid(n), sol(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; inward(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: edges) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        grid[it[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]].push_back(it[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        inward[it[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(inward[i] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; sz &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(sz&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; tmp &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: grid[tmp]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                inward[it]&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                dag[it].insert(tmp);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;x&lt;/span&gt;: dag[tmp])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    dag[it].insert(x);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(inward[it] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    q.push(it);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: dag[i]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            sol[i].push_back(it);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; sol;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &lt;/div&gt;&#xA;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;1 : Function Definition&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; getAncestors(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; n, vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&amp;amp;&lt;/span&gt; edges) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This defines the function that takes the number of nodes `n` and a list of directed edges as input, returning a vector of vectors that represents the ancestors for each node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;2 : Variable Declaration&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;set&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; dag(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; A vector of sets is initialized to keep track of the ancestors for each node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;3 : Variable Declaration&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; grid(n), sol(n);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; These vectors store the adjacency list `grid` for each node and the `sol` vector which will hold the ancestors for each node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;4 : Variable Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    vector&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; inward(n, &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This initializes the `inward` vector to keep track of the incoming degree (number of incoming edges) for each node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;5 : Looping&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: edges) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This loop iterates over each edge to build the graph and update the inward degree of the target node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;6 : Graph Construction&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        grid[it[&lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;]].push_back(it[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Adds an edge from node `it[0]` to node `it[1]` in the adjacency list `grid`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;7 : Graph Construction&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        inward[it[&lt;span style=&#34;color:#666&#34;&gt;1&lt;/span&gt;]]&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Increases the inward degree of node `it[1]` by 1, indicating that there is an incoming edge to this node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;8 : Queue Initialization&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    queue&lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt;&lt;span style=&#34;color:#666&#34;&gt;&amp;gt;&lt;/span&gt; q;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; A queue `q` is initialized to manage the nodes with no incoming edges (in-degree of 0). &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;9 : Looping&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This loop iterates through all nodes to find the nodes with no incoming edges. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;10 : Queue Population&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(inward[i] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;) q.push(i);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If a node has no incoming edges, it is pushed into the queue `q` for processing. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;11 : Looping&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(&lt;span style=&#34;color:#666&#34;&gt;!&lt;/span&gt;q.empty()) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; While the queue is not empty, nodes are processed to identify their ancestors. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;12 : Queue Size Calculation&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; sz &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.size();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Stores the size of the queue to process each node in the current level of the graph. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;13 : Looping&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;while&lt;/span&gt;(sz&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This loop processes each node in the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;14 : Queue Dequeue&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; tmp &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; q.front();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Pops the front node `tmp` from the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;15 : Queue Dequeue&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            q.pop();&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Removes the node from the queue after processing. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;16 : Graph Traversal&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: grid[tmp]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Traverses the neighbors of node `tmp` to identify the next nodes to process. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;17 : Edge Processing&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                inward[it]&lt;span style=&#34;color:#666&#34;&gt;--&lt;/span&gt;;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Decreases the inward degree of the neighbor node `it`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;18 : Ancestor Tracking&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                dag[it].insert(tmp);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Adds the current node `tmp` as an ancestor of node `it`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;19 : Ancestor Propagation&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;x&lt;/span&gt;: dag[tmp])&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This loop propagates ancestors from node `tmp` to its neighbors. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;20 : Ancestor Propagation&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    dag[it].insert(x);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Adds each ancestor of `tmp` to the set of ancestors of `it`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;21 : Queue Population&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;if&lt;/span&gt;(inward[it] &lt;span style=&#34;color:#666&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;)&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; If the inward degree of node `it` becomes zero, it is added to the queue. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;22 : Queue Population&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    q.push(it);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Adds node `it` to the queue for further processing. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;23 : Ancestor Assignment&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#0b0;font-weight:bold&#34;&gt;int&lt;/span&gt; i &lt;span style=&#34;color:#666&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#666&#34;&gt;0&lt;/span&gt;; i &lt;span style=&#34;color:#666&#34;&gt;&amp;lt;&lt;/span&gt; n; i&lt;span style=&#34;color:#666&#34;&gt;++&lt;/span&gt;) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; This loop iterates over each node to assign the ancestors for each node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;24 : Ancestor Assignment&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;for&lt;/span&gt;(&lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;auto&lt;/span&gt; &lt;span style=&#34;color:#a0a000&#34;&gt;it&lt;/span&gt;: dag[i]) {&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Iterates over the ancestors of node `i`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;25 : Ancestor Assignment&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            sol[i].push_back(it);&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Adds each ancestor `it` to the solution vector for node `i`. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                        &lt;div class=&#34;step-slide&#34;&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; &lt;b&gt;26 : Return&lt;/b&gt;&lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt;&#xA;                                &#xA;                                &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;&#34;&gt;&lt;code class=&#34;language-cpp&#34; data-lang=&#34;cpp&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a2f;font-weight:bold&#34;&gt;return&lt;/span&gt; sol;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;                                &#xA;                            &lt;/div&gt;&#xA;                            &lt;div class=&#34;&#34;&gt; Returns the solution vector, which contains the ancestors for each node. &lt;/div&gt;&#xA;                        &lt;/div&gt;&#xA;                    &#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt; &#xA;        &#xA;        &lt;div id=&#34;Complexity&#34; &#xA;            class=&#34;problem-guide-topic-content&#34; &#xA;            style=&#34;display: none;&#34;&gt;&#xA;&#xA;            &lt;div class=&#34;steps-container&#34;&gt;&#xA;                &lt;div class=&#34;step-problem-guide-tags&#34; id=&#34;stepButtons&#34;&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;0&#34;&gt;Time Complexities&lt;/button&gt;&#xA;                    &lt;button class=&#34;step-problem-guide-tag&#34; id=&#34;step-problem-guide-tag-Complexity&#34; data-slide=&#34;1&#34;&gt;Space Complexities&lt;/button&gt;&#xA;                &lt;/div&gt;&#xA;&#xA;                &lt;div class=&#34;steps-slides&#34; id=&#34;stepsSlides-Complexity&#34;&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; e), where n is the number of nodes and e is the number of edges.&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Average Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The time complexity is linear in terms of nodes and edges, as we perform a topological sort and propagate ancestors.&lt;/div&gt;                                               &#xA;                    &lt;/div&gt;&#xA;&#xA;                    &lt;div class=&#34;step-slide&#34;&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Best Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt;&#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Worst Case:&lt;/b&gt; O(n &amp;#43; e)&lt;/div&gt; &#xA;                        &lt;div class=&#34;&#34;&gt; &lt;b&gt;Description:&lt;/b&gt; The space complexity is also O(n &amp;#43; e) due to the storage of the graph and ancestor sets.&lt;/div&gt;    &#xA;                    &lt;/div&gt;&#xA;&#xA;                &lt;/div&gt;&#xA;            &lt;/div&gt;&#xA;        &lt;/div&gt;        &#xA;&#xA;    &lt;/div&gt; &#xA;&#xA;    &lt;script async src=&#34;https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953&#34;&#xA;     crossorigin=&#34;anonymous&#34;&gt;&lt;/script&gt;&#xA;    &lt;ins class=&#34;adsbygoogle&#34;&#xA;        style=&#34;display:block; text-align:center;&#34;&#xA;        data-ad-layout=&#34;in-article&#34;&#xA;        data-ad-format=&#34;fluid&#34;&#xA;        data-ad-client=&#34;ca-pub-6219690368643953&#34;&#xA;        data-ad-slot=&#34;5533433286&#34;&gt;&lt;/ins&gt;&#xA;    &lt;script&gt;&#xA;        (adsbygoogle = window.adsbygoogle || []).push({});&#xA;    &lt;/script&gt;&#xA;&#xA;    &lt;script&gt;&#xA;        function switchProblemGuideContent(element, id) {&#xA;            document.querySelectorAll(&#39;.problem-guide-tag&#39;).forEach(tag =&gt; {&#xA;                tag.classList.remove(&#39;problem-guide-tag-active&#39;);&#xA;            });&#xA;&#xA;            element.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;&#xA;            document.querySelectorAll(&#39;.problem-guide-topic-content&#39;).forEach(content =&gt; {&#xA;                content.style.display = &#39;none&#39;;&#xA;            });&#xA;&#xA;            const activeContent = document.getElementById(id);&#xA;            activeContent.style.display = &#39;block&#39;;&#xA;            buttons_x(id)&#xA;        }&#xA;&#xA;        function buttons_x(id) {&#xA;&#xA;            const slides = document.getElementById(&#39;stepsSlides-&#39;+ id );&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-&#39; + id );&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;                console.log(buttons[index].id)&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;        }        &#xA;&#xA;        function buttons() {&#xA;            const slides = document.getElementById(&#39;stepsSlides-Problem&#39;);&#xA;            const buttons = document.querySelectorAll(&#39;#step-problem-guide-tag-Problem&#39;);&#xA;            let currentIndex = 0;&#xA;            let startX = 0;&#xA;            let isDragging = false;&#xA;&#xA;            function updateSlides(index) {&#xA;                slides.style.transform = `translateX(-${index * 100}%)`;&#xA;                buttons.forEach(button =&gt; button.classList.remove(&#39;problem-guide-tag-active&#39;));&#xA;                buttons[index].classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            buttons.forEach((button, index) =&gt; {&#xA;                button.addEventListener(&#39;click&#39;, () =&gt; {&#xA;                    currentIndex = index;&#xA;                    updateSlides(currentIndex);&#xA;                });&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchstart&#39;, (e) =&gt; {&#xA;                startX = e.touches[0].clientX;&#xA;                isDragging = true;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchmove&#39;, (e) =&gt; {&#xA;                if (!isDragging) return;&#xA;                const moveX = e.touches[0].clientX - startX;&#xA;                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;&#xA;            });&#xA;&#xA;            slides.addEventListener(&#39;touchend&#39;, (e) =&gt; {&#xA;                isDragging = false;&#xA;                const endX = e.changedTouches[0].clientX;&#xA;                if (endX &lt; startX - 50 &amp;&amp; currentIndex &lt; buttons.length - 1) {&#xA;                    currentIndex++;&#xA;                } else if (endX &gt; startX + 50 &amp;&amp; currentIndex &gt; 0) {&#xA;                    currentIndex--;&#xA;                }&#xA;                updateSlides(currentIndex);&#xA;            });&#xA;&#xA;            updateSlides(currentIndex);&#xA;&#xA;            const initialTag = document.querySelector(`.problem-guide-tag[data-target=&#34;Problem&#34;]`);&#xA;            if (initialTag) {&#xA;                initialTag.classList.add(&#39;problem-guide-tag-active&#39;);&#xA;            }&#xA;&#xA;            const contentElements = document.querySelectorAll(&#39;.problem-guide-content&#39;);&#xA;            let maxHeight = 0;&#xA;            contentElements.forEach(element =&gt; {&#xA;                const height = parseFloat(getComputedStyle(element).height);&#xA;                if (height &gt; maxHeight) {&#xA;                    maxHeight = height;&#xA;                }&#xA;            });&#xA;&#xA;            document.querySelector(&#39;.problem-guide-content&#39;).style.height = maxHeight + &#39;px&#39;;&#xA;&#xA;        }&#xA;&#xA;        document.addEventListener(&#39;DOMContentLoaded&#39;, buttons);&#xA;    &lt;/script&gt;&#xA;&lt;/div&gt;&#xA;&#xA;&lt;p&gt;&lt;a href=&#34;https://leetcode.com/problems/all-ancestors-of-a-node-in-a-directed-acyclic-graph/description/&#34;&gt;&lt;code&gt;Link to LeetCode Lab&lt;/code&gt;&lt;/a&gt;&lt;/p&gt;</description>
    </item>
  </channel>
</rss>

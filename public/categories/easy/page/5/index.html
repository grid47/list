<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Easy | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Easy">
  <meta name="twitter:description" content="Blog by grid47">

	<meta property="og:url" content="http://localhost:1313/categories/easy/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Easy">
  <meta property="og:description" content="Blog by grid47">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
        

	
	
	<link rel="stylesheet" href="/css/leetcode.css" integrity="" crossorigin="anonymous" media="screen">



</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/courses/">Course</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
    <div class="main-content">
        
        <section class="recent-posts">            
            <div class="section-title">                
                <h2><span>All Posts</span></h2>                
            </div>            
            <div class="row listrecent">
                
                
<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-191-number-of-1-bits/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-191-number-of-1-bits/">Leetcode 191: Number of 1 Bits</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode451s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/191.webp" 
           alt="A glowing sequence of bits, with 1&#39;s gently illuminating and highlighting their presence." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 191: Number of 1 Bits Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given an integer array, determine if it is possible to partition the array into two subsets with equal sum. Return true if such a partition exists, otherwise return false. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of an array of integers &#39;nums&#39;.</div>
                        <div class=""> <b>Example:</b> For nums = [2, 6, 7, 4], the output is true.</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= nums.length &lt;= 200</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= nums[i] &lt;= 100</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return true if the array can be partitioned into two subsets with equal sum, otherwise return false.</div>
                        <div class=""> <b>Example:</b> For nums = [1, 2, 3, 9], the output is false.</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> To check if an array can be partitioned into two subsets with equal sum.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Calculate the total sum of the array.</div>
                            
                                <div style="margin-left: 20px;"> • 2. If the sum is odd, return false (since two equal subsets cannot be formed).</div>
                            
                                <div style="margin-left: 20px;"> • 3. If the sum is even, check if there exists a subset whose sum is half of the total sum using dynamic programming.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Use a dynamic programming approach to check if it&#39;s possible to form a subset with the target sum.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The array contains integers between 1 and 100, and its length is at most 200.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= nums.length &lt;= 200</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= nums[i] &lt;= 100</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input array contains only positive integers.</div>
                            
                                <div style="margin-left: 20px;"> • The array length is within the given constraints.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> For nums = [2, 6, 7, 4], the output is true.</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The array can be partitioned as [2, 6] and [7, 4], both with a sum of 8, making the partition possible.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> For nums = [1, 2, 3, 9], the output is false.</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The sum of the elements is 15, which is odd, so it&#39;s impossible to partition the array into two subsets with equal sum.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> To solve the problem, we need to first check if the sum of the array is even. If it&#39;s even, we will use dynamic programming to determine if a subset with half the sum exists.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • The total sum must be even for the array to be partitioned into two subsets with equal sum.</div>
                            
                            
                                <div style="margin-left: 20px;"> • A dynamic programming approach can be used to check if a subset sum of half the total sum is achievable.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Calculate the total sum of the array.</div>
                            
                                <div style="margin-left: 20px;"> • 2. If the total sum is odd, return false.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Set the target sum as half of the total sum.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Use dynamic programming to check if a subset with this target sum can be formed. Use a boolean dp array where dp[i] is true if a subset with sum i is possible.</div>
                            
                                <div style="margin-left: 20px;"> • 5. If dp[target] is true, return true. Otherwise, return false.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • For large inputs, ensure the dynamic programming approach runs efficiently by considering the time and space complexity.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the array has only one element, it cannot be partitioned into two subsets.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle cases where the sum is odd, or the array has a small number of elements.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Array Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Base Case, Recursion</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Base Case Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Memoization Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Conditional Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Recursive Call with Element Inclusion</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Return Memoized Result</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Main Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Assign Input Vector</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Sum Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Loop Iteration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Sum Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Odd Sum Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Divide Sum by Two</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="17"> 17 Memoization Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="18"> 18 Return DP Function Call</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> nums;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> memo[<span style="color:#666">201</span>][<span style="color:#666">10001</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">dp</span>(<span style="color:#0b0;font-weight:bold">int</span> idx, <span style="color:#0b0;font-weight:bold">int</span> sum) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(idx <span style="color:#666">==</span> nums.size()) <span style="color:#a2f;font-weight:bold">return</span> sum <span style="color:#666">==</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(memo[idx][sum] <span style="color:#666">!=</span> <span style="color:#666">-</span><span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> memo[idx][sum];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> res <span style="color:#666">=</span> dp(idx <span style="color:#666">+</span> <span style="color:#666">1</span>, sum);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(sum <span style="color:#666">&gt;=</span> nums[idx])
</span></span><span style="display:flex;"><span>        res <span style="color:#666">|=</span> dp(idx <span style="color:#666">+</span> <span style="color:#666">1</span>, sum <span style="color:#666">-</span> nums[idx]);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> memo[idx][sum] <span style="color:#666">=</span> res;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">canPartition</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>nums <span style="color:#666">=</span> nums;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">x</span>: nums)
</span></span><span style="display:flex;"><span>        sum <span style="color:#666">+=</span> x;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(sum <span style="color:#666">&amp;</span> <span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    sum <span style="color:#666">=</span> sum <span style="color:#666">/</span> <span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    memset(memo, <span style="color:#666">-</span><span style="color:#666">1</span>, <span style="color:#a2f;font-weight:bold">sizeof</span>(memo));
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> dp(<span style="color:#666">0</span>, sum);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> nums;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declare a vector `nums` to hold the input array of integers that needs to be partitioned. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Array Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> memo[<span style="color:#666">201</span>][<span style="color:#666">10001</span>];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize a 2D array `memo` with dimensions to store computed results for each index and sum to avoid redundant calculations in the dynamic programming solution. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Base Case, Recursion</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">dp</span>(<span style="color:#0b0;font-weight:bold">int</span> idx, <span style="color:#0b0;font-weight:bold">int</span> sum) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Define the function `dp` that takes two parameters: `idx`, the current index of the element being considered, and `sum`, the remaining sum we need to achieve. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Base Case Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(idx <span style="color:#666">==</span> nums.size()) <span style="color:#a2f;font-weight:bold">return</span> sum <span style="color:#666">==</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If we&#39;ve reached the end of the array (`idx == nums.size()`), return `true` if the remaining `sum` is 0, meaning we&#39;ve successfully partitioned the array. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Memoization Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(memo[idx][sum] <span style="color:#666">!=</span> <span style="color:#666">-</span><span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> memo[idx][sum];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Check if the current state (`idx`, `sum`) has already been computed by looking up the value in the `memo` table. If it has, return the stored result. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> res <span style="color:#666">=</span> dp(idx <span style="color:#666">+</span> <span style="color:#666">1</span>, sum);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Make a recursive call to `dp` by moving to the next index (`idx &#43; 1`) without including the current element in the sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Conditional Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(sum <span style="color:#666">&gt;=</span> nums[idx])
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Check if the current element (`nums[idx]`) can be included in the subset, i.e., if the remaining `sum` is greater than or equal to the current element. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Recursive Call with Element Inclusion</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        res <span style="color:#666">|=</span> dp(idx <span style="color:#666">+</span> <span style="color:#666">1</span>, sum <span style="color:#666">-</span> nums[idx]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Make a recursive call to `dp` including the current element (`nums[idx]`) by subtracting it from the remaining `sum`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Return Memoized Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> memo[idx][sum] <span style="color:#666">=</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Store the result of the current state (`idx`, `sum`) in the `memo` table and return it. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Main Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">canPartition</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> nums) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Define the main function `canPartition` that takes a vector `nums` and determines whether it is possible to partition the array into two subsets with equal sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Assign Input Vector</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>nums <span style="color:#666">=</span> nums;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Assign the input `nums` to the class member variable `nums` for use in the `dp` function. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Sum Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize a variable `sum` to store the total sum of the elements in `nums`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Loop Iteration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">x</span>: nums)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Iterate through each element `x` in the `nums` array. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Sum Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        sum <span style="color:#666">+=</span> x;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Accumulate the value of each element `x` to compute the total sum of the elements in the array. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Odd Sum Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(sum <span style="color:#666">&amp;</span> <span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Check if the sum is odd (`sum &amp; 1`). If it is, return `false` since an odd sum cannot be partitioned into two equal subsets. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Divide Sum by Two</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    sum <span style="color:#666">=</span> sum <span style="color:#666">/</span> <span style="color:#666">2</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Since the array needs to be split into two equal subsets, divide the total `sum` by 2 to determine the target sum for one subset. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>17 : Memoization Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    memset(memo, <span style="color:#666">-</span><span style="color:#666">1</span>, <span style="color:#a2f;font-weight:bold">sizeof</span>(memo));
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize the `memo` table by setting all values to `-1`, indicating that no state has been computed yet. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>18 : Return DP Function Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">dp</span>(<span style="color:#666">0</span>, sum);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Call the `dp` function starting from index 0 with the target sum (`sum`). Return the result of this call. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n * sum)</div>
                        <div class=""> <b>Average Case:</b> O(n * sum)</div>
                        <div class=""> <b>Worst Case:</b> O(n * sum)</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n * sum), where n is the number of elements in the array and sum is the total sum of the array.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(sum)</div>
                        <div class=""> <b>Worst Case:</b> O(sum)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(sum), where sum is the total sum of the array, due to the dynamic programming array.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/number-of-1-bits/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 18, 2024 - 7 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-191-number-of-1-bits/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-202-happy-number/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-202-happy-number/">Leetcode 202: Happy Number</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode514s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/202.webp" 
           alt="A glowing number slowly transforming into a smiley face, symbolizing happiness and positivity." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 202: Happy Number Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given the root of a binary tree and an integer targetSum. Your task is to count the total number of paths in the tree where the sum of node values along the path equals targetSum. The path does not need to start or end at the root or a leaf, but it must go downwards (from parent to child nodes). </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of a binary tree represented by the root node and an integer targetSum.</div>
                        <div class=""> <b>Example:</b> root = [3, 5, -2, 3, 1, null, 4], targetSum = 7</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= number of nodes &lt;= 1000</div>
                            
                                <div style="margin-left: 20px;"> • -10^9 &lt;= Node.val &lt;= 10^9</div>
                            
                                <div style="margin-left: 20px;"> • -1000 &lt;= targetSum &lt;= 1000</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return the number of paths in the tree that sum to targetSum.</div>
                        <div class=""> <b>Example:</b> 2</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be a non-negative integer representing the number of valid paths.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to count the number of paths that sum to targetSum while only moving downwards in the tree.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Perform a Depth-First Search (DFS) traversal of the tree.</div>
                            
                                <div style="margin-left: 20px;"> • 2. For each node, calculate the sum for all paths starting from that node.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Recursively check all possible paths for the sum matching the targetSum.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The algorithm should efficiently handle up to 1000 nodes in the tree.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The tree can contain up to 1000 nodes.</div>
                            
                                <div style="margin-left: 20px;"> • The targetSum is within the range [-1000, 1000].</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input tree is a valid binary tree.</div>
                            
                                <div style="margin-left: 20px;"> • The tree is not necessarily balanced.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: [3, 5, -2, 3, 1, null, 4], targetSum = 7</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> There are two paths in the tree that sum to 7: `5 -&gt; 3 -&gt; -2` and `3 -&gt; 1 -&gt; 4`.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: [10, 5, -3, 3, 2, null, 11, 3, -2, null, 1], targetSum = 8</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The three paths that sum to 8 are: `5 -&gt; 3`, `5 -&gt; 2 -&gt; 1`, and `-3 -&gt; 11`.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The approach uses DFS to explore all possible paths in the binary tree and checks whether the sum of the values along the path equals targetSum.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • DFS is a suitable approach to explore all potential paths in a binary tree.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We need to perform DFS starting from each node to explore all paths from that node downwards.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Perform DFS for each node in the tree.</div>
                            
                                <div style="margin-left: 20px;"> • 2. At each node, recursively calculate all paths starting from that node that sum to targetSum.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Track and count the paths that meet the targetSum condition.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the tree is empty (i.e., root is null), return 0.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure that the algorithm works efficiently for trees with up to 1000 nodes.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If targetSum is 0, consider paths where the sum of values along the path equals 0.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle large integer values within the specified range of [-10^9, 10^9].</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Class Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Variable Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Access Specifier</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Function Declarations And Calls</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Return At End</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Recursive Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Base Condition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Function Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Recursive Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Base Condition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Conditional Checks</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Recursive Call</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> cnt <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> pathSum(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> sum) {
</span></span><span style="display:flex;"><span>    dfs(root, sum);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> cnt;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">long</span> sum) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    test(root, sum);
</span></span><span style="display:flex;"><span>    dfs(root<span style="color:#666">-&gt;</span>left,  sum);
</span></span><span style="display:flex;"><span>    dfs(root<span style="color:#666">-&gt;</span>right, sum);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">test</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">long</span> sum) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>  (root     <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>  (root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> sum ) cnt<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>    test(root<span style="color:#666">-&gt;</span>left,  sum <span style="color:#666">-</span> root<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    test(root<span style="color:#666">-&gt;</span>right, sum <span style="color:#666">-</span> root<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Class Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declares the Solution class where the methods and variables are defined. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Variable Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> cnt <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes a counter to store the number of valid paths with the desired sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Access Specifier</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the public section of the class to include accessible methods. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Function Declarations And Calls</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">pathSum</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> sum) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declares the main function to calculate the total number of paths that sum to a target value. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dfs(root, sum);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calls the helper function &#39;dfs&#39; to traverse the tree starting from the root node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Return At End</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> cnt;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the total count of paths with the desired sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Recursive Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">long</span> sum) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the DFS function to traverse the binary tree and test each node for valid paths. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Base Condition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current node is null to terminate the recursion. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Function Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    test(root, sum);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calls the &#39;test&#39; function to check paths starting from the current node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dfs(root<span style="color:#666">-&gt;</span>left,  sum);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls &#39;dfs&#39; for the left child of the current node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dfs(root<span style="color:#666">-&gt;</span>right, sum);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls &#39;dfs&#39; for the right child of the current node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Recursive Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">test</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">long</span> sum) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the &#39;test&#39; function to check all paths starting at the current node for the target sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Base Condition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>  (root     <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Terminates the recursion when the node is null. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Conditional Checks</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>  (root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> sum ) cnt<span style="color:#666">++</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Increments the counter if the current node value equals the remaining sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    test(root<span style="color:#666">-&gt;</span>left,  sum <span style="color:#666">-</span> root<span style="color:#666">-&gt;</span>val);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively checks the left subtree for paths with the updated remaining sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    test(root<span style="color:#666">-&gt;</span>right, sum <span style="color:#666">-</span> root<span style="color:#666">-&gt;</span>val);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively checks the right subtree for paths with the updated remaining sum. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(N), where N is the number of nodes in the tree, if all paths meet the targetSum immediately.</div>
                        <div class=""> <b>Average Case:</b> O(N^2), where N is the number of nodes, due to the DFS for each node and the exploration of all paths.</div>
                        <div class=""> <b>Worst Case:</b> O(N^2), where N is the number of nodes, as every node can lead to a path traversal that checks all remaining nodes.</div> 
                        <div class=""> <b>Description:</b> The time complexity involves performing DFS and recursively checking all paths from each node, leading to an overall complexity of O(N^2).</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(H), for the recursive stack space.</div>
                        <div class=""> <b>Worst Case:</b> O(H), where H is the height of the tree, due to the recursion stack in DFS.</div> 
                        <div class=""> <b>Description:</b> The space complexity is determined by the recursion depth of the DFS traversal.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/happy-number/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 17, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-202-happy-number/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-205-isomorphic-strings/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-205-isomorphic-strings/">Leetcode 205: Isomorphic Strings</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode531s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/205.webp" 
           alt="Two strings gently morphing into each other, with glowing connections between each corresponding character." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 205: Isomorphic Strings Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given two non-empty linked lists where each node contains a single digit representing a non-negative integer. Add the two numbers and return the sum as a linked list, ensuring the most significant digit is at the head of the list. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> Each linked list represents a number where each node contains a single digit. The lists do not have leading zeros, except for the number 0 itself.</div>
                        <div class=""> <b>Example:</b> [3,4,2], [6,5,7]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= Number of nodes in each linked list &lt;= 100</div>
                            
                                <div style="margin-left: 20px;"> • Node.val &gt;= 0 and Node.val &lt;= 9</div>
                            
                                <div style="margin-left: 20px;"> • No leading zeros in the numbers except for 0 itself</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be a linked list representing the sum of the two numbers with the most significant digit at the head.</div>
                        <div class=""> <b>Example:</b> [9,0,0,9]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The result linked list must be formatted in the same way as the input.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Add two numbers represented by two linked lists and return the sum as a linked list.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Use two stacks to store the digits of the linked lists as we traverse them.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Pop the digits from the stacks, add them with the carry, and create new nodes to store the result.</div>
                            
                                <div style="margin-left: 20px;"> • 3. If a carry exists after processing both lists, create a new node for the carry.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Ensure that the final linked list is built without reversing the input lists.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The linked lists represent valid numbers without leading zeros except 0 itself.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= Number of nodes in each linked list &lt;= 100</div>
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= Node.val &lt;= 9</div>
                            
                                <div style="margin-left: 20px;"> • Do not reverse the input linked lists.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The linked lists are not empty and contain valid digits.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> [3,4,2], [6,5,7]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The two numbers are 342 and 657. Their sum is 999, which is represented as [9, 0, 0, 9].</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> [1,2], [3,4,5]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The two numbers are 12 and 345. Their sum is 357, represented as [3, 5, 7].</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> This problem can be solved by simulating the addition process using stacks to reverse the linked lists and adding corresponding digits along with a carry.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • The problem asks to avoid reversing the linked lists, which suggests using a stack to reverse the order temporarily.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We can use two stacks to simulate the addition process from the most significant digit to the least significant digit.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Create two stacks to store the digits of both linked lists.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Traverse both lists, pushing each digit onto its respective stack.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Pop digits from both stacks, add them with the carry, and store the result in a new linked list.</div>
                            
                                <div style="margin-left: 20px;"> • 4. If there&#39;s any carry left after processing both lists, create a new node for the carry.</div>
                            
                                <div style="margin-left: 20px;"> • 5. Return the result as the new linked list.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If any linked list is empty, it should be treated as 0.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • For larger inputs (up to 100 nodes), ensure that the solution handles the carry correctly and efficiently.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Consider cases where the numbers involve carry overs, such as adding [9,9] and [1].</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure that the algorithm runs in O(n) time and uses O(n) space for stack operations.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Stack Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Stack Population (L1)</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Push Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Linked List Traversal</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Stack Population (L2)</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Push Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Linked List Traversal</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Carry Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Node Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Addition Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Addition from S1</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Update Carry</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Pop Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Addition from S2</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Update Carry</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="17"> 17 Pop Operation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="18"> 18 Create Node</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="19"> 19 Update Node Links</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="20"> 20 Update Previous Node</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="21"> 21 Update Carry</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="22"> 22 Create Final Node</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="23"> 23 Final Carry Node</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="24"> 24 Update Node Links</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="25"> 25 Return Final Node</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ListNode<span style="color:#666">*</span> <span style="color:#00a000">addTwoNumbers</span>(ListNode<span style="color:#666">*</span> l1, ListNode<span style="color:#666">*</span> l2) {
</span></span><span style="display:flex;"><span>    stack<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> s1, s2;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(l1) {
</span></span><span style="display:flex;"><span>        s1.push(l1<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        l1 <span style="color:#666">=</span> l1<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(l2) {
</span></span><span style="display:flex;"><span>        s2.push(l2<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        l2 <span style="color:#666">=</span> l2<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> cry <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> node <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>, <span style="color:#666">*</span>prv <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>s1.empty() <span style="color:#666">||</span> <span style="color:#666">!</span>s2.empty()) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>s1.empty()) {
</span></span><span style="display:flex;"><span>            cry <span style="color:#666">+=</span> s1.top();
</span></span><span style="display:flex;"><span>            s1.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>s2.empty()) {
</span></span><span style="display:flex;"><span>            cry <span style="color:#666">+=</span> s2.top();
</span></span><span style="display:flex;"><span>            s2.pop();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> ListNode(cry <span style="color:#666">%</span> <span style="color:#666">10</span>);
</span></span><span style="display:flex;"><span>        node<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prv;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        prv <span style="color:#666">=</span> node;
</span></span><span style="display:flex;"><span>        cry <span style="color:#666">/=</span> <span style="color:#666">10</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(cry <span style="color:#666">!=</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>        node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> ListNode(cry <span style="color:#666">%</span><span style="color:#666">10</span>);
</span></span><span style="display:flex;"><span>        node<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prv;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ListNode<span style="color:#666">*</span> <span style="color:#00a000">addTwoNumbers</span>(ListNode<span style="color:#666">*</span> l1, ListNode<span style="color:#666">*</span> l2) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This is the function definition where two linked lists (l1 and l2) are passed as arguments. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Stack Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    stack<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> s1, s2;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Two stacks are created to hold the digits of the two linked lists. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Stack Population (L1)</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(l1) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Traverse the first linked list and push each node&#39;s value onto stack s1. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Push Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        s1.push(l1<span style="color:#666">-&gt;</span>val);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Push the current value of the node in l1 onto stack s1. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Linked List Traversal</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l1 <span style="color:#666">=</span> l1<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Move to the next node in the first linked list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Stack Population (L2)</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(l2) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Traverse the second linked list and push each node&#39;s value onto stack s2. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Push Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        s2.push(l2<span style="color:#666">-&gt;</span>val);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Push the current value of the node in l2 onto stack s2. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Linked List Traversal</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        l2 <span style="color:#666">=</span> l2<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Move to the next node in the second linked list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Carry Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> cry <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize a variable to store the carry during addition. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Node Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> node <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>, <span style="color:#666">*</span>prv <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize pointers for the result linked list: node for the current node and prv for the previous node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Addition Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>s1.empty() <span style="color:#666">||</span> <span style="color:#666">!</span>s2.empty()) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Start the loop to add corresponding digits from the two stacks while there are still elements in either stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Addition from S1</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>s1.empty()) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Check if stack s1 is not empty and add its top element to the carry. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Update Carry</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            cry <span style="color:#666">+=</span> s1.top();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Add the top element of stack s1 to the carry. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Pop Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            s1.pop();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pop the top element of stack s1. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Addition from S2</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>s2.empty()) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Check if stack s2 is not empty and add its top element to the carry. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Update Carry</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            cry <span style="color:#666">+=</span> s2.top();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Add the top element of stack s2 to the carry. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>17 : Pop Operation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            s2.pop();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pop the top element of stack s2. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>18 : Create Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> ListNode(cry <span style="color:#666">%</span> <span style="color:#666">10</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Create a new node with the value of the current digit (cry % 10). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>19 : Update Node Links</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        node<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prv;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Link the newly created node to the previous node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>20 : Update Previous Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        prv <span style="color:#666">=</span> node;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Update the previous node pointer to the current node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>21 : Update Carry</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        cry <span style="color:#666">/=</span> <span style="color:#666">10</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Update the carry by dividing it by 10. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>22 : Create Final Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(cry <span style="color:#666">!=</span> <span style="color:#666">0</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Check if there is a remaining carry to create a final node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>23 : Final Carry Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> ListNode(cry <span style="color:#666">%</span><span style="color:#666">10</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Create a final node with the carry value. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>24 : Update Node Links</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        node<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> prv;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Link the final node to the result list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>25 : Return Final Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> node;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Return the head of the newly created linked list that represents the sum. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n), where n is the length of the longer linked list.</div>
                        <div class=""> <b>Average Case:</b> O(n), as each node is processed once.</div>
                        <div class=""> <b>Worst Case:</b> O(n), as we process both lists in full.</div> 
                        <div class=""> <b>Description:</b> The time complexity is linear because we traverse each list once.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n), since we still need stacks for the input digits.</div>
                        <div class=""> <b>Worst Case:</b> O(n), due to the use of two stacks for storing the digits of both lists.</div> 
                        <div class=""> <b>Description:</b> The space complexity is linear because we use stacks to hold the digits before performing the addition.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/isomorphic-strings/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 17, 2024 - 7 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-205-isomorphic-strings/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-206-reverse-linked-list/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-206-reverse-linked-list/">Leetcode 206: Reverse Linked List</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode539s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/206.webp" 
           alt="A linked list where nodes glow and reverse in position, flowing smoothly backward." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 206: Reverse Linked List Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given n distinct points in the 2D plane. A boomerang is defined as a tuple of three points (i, j, k) where the distance between points i and j equals the distance between points i and k. Count the total number of boomerangs that can be formed from the given points. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> A list of n distinct points in the 2D plane, each represented by a pair of integers [xi, yi].</div>
                        <div class=""> <b>Example:</b> [[0,0], [1,0], [2,0]]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= n &lt;= 500</div>
                            
                                <div style="margin-left: 20px;"> • -10^4 &lt;= xi, yi &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • All points are distinct.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output is a single integer representing the number of boomerangs formed from the given points.</div>
                        <div class=""> <b>Example:</b> 2</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of boomerangs can be zero if no such triplets can be formed.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Count the total number of boomerangs by comparing distances between points.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. For each point, calculate the distances to all other points.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Store the frequency of each distance in a map (or hashmap).</div>
                            
                                <div style="margin-left: 20px;"> • 3. For each distinct distance, calculate the number of ways to pick two points that share the same distance from the current point.</div>
                            
                                <div style="margin-left: 20px;"> • 4. The number of boomerangs is the sum of all valid pairs for all distances.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The points are distinct, and the coordinates are within a specified range.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= n &lt;= 500</div>
                            
                                <div style="margin-left: 20px;"> • -10^4 &lt;= xi, yi &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • All points are distinct.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • All points are distinct and represented as pairs of integers.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> [[0,0], [1,0], [2,0]]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The two boomerangs formed are: [[1,0],[0,0],[2,0]] and [[1,0],[2,0],[0,0]].</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> [[1,1], [2,2], [3,3]]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The two boomerangs formed are: [[1,1], [2,2], [3,3]] and [[2,2], [1,1], [3,3]].</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The approach involves calculating distances between all pairs of points and counting valid triplets where the distance between two points is equal to the distance between another two points.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • For each point, we can calculate distances to all other points, which gives us potential boomerangs.</div>
                            
                                <div style="margin-left: 20px;"> • By storing the frequency of distances, we can efficiently calculate the number of valid boomerangs.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We can optimize the process by using a hashmap to store the distances from each point.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Iterate over each point in the list of points.</div>
                            
                                <div style="margin-left: 20px;"> • 2. For each point, calculate the distance to every other point and store the results in a hashmap.</div>
                            
                                <div style="margin-left: 20px;"> • 3. For each distance, calculate the number of valid pairs of points (i, j) such that the distance is the same.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Return the total count of boomerangs.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The input will always contain at least one point, so no need to handle empty inputs.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • For large inputs (up to 500 points), ensure that the solution efficiently handles the calculations of distances and the counting of pairs.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure that the solution handles cases with no possible boomerangs, such as when there are fewer than 3 points.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The algorithm should efficiently handle the maximum constraint of 500 points.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Nested Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Distance Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Map Operations</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Map Iteration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Result Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Map Reset</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Return</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Helper Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Distance Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Distance Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Return</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">numberOfBoomerangs</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> points) {
</span></span><span style="display:flex;"><span>    map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> points.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> points.size(); j<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> d <span style="color:#666">=</span> getDist(points[i], points[j]);
</span></span><span style="display:flex;"><span>            mp[d]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> [_, val]<span style="color:#666">:</span> mp)
</span></span><span style="display:flex;"><span>        res <span style="color:#666">+=</span> val <span style="color:#666">*</span> (val <span style="color:#666">-</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        mp.clear();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">getDist</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> a, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> b) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> a[<span style="color:#666">0</span>] <span style="color:#666">-</span> b[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> y <span style="color:#666">=</span> a[<span style="color:#666">1</span>] <span style="color:#666">-</span> b[<span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> x <span style="color:#666">*</span> x <span style="color:#666">+</span> y <span style="color:#666">*</span> y;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">numberOfBoomerangs</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> points) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the main function to calculate the number of boomerangs in a set of points. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> A map to store distances and their frequencies for each pair of points. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The result variable that will store the total number of boomerangs. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> points.size(); i<span style="color:#666">++</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Loop over each point in the list of points. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Nested Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> points.size(); j<span style="color:#666">++</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Inner loop to compare the current point with every other point. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Distance Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> d <span style="color:#666">=</span> getDist(points[i], points[j]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calculates the squared distance between two points. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Map Operations</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            mp[d]<span style="color:#666">++</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Increments the count of the calculated distance in the map. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Map Iteration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> [_, val]<span style="color:#666">:</span> mp)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Iterate over the map to calculate boomerangs based on the distances. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Result Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        res <span style="color:#666">+=</span> val <span style="color:#666">*</span> (val <span style="color:#666">-</span> <span style="color:#666">1</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> For each distance, calculate how many boomerangs can be formed using the frequency of that distance. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Map Reset</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        mp.clear();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Clears the map to start fresh for the next point. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Return</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the final count of boomerangs. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Helper Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">getDist</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> a, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> b) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Helper function to calculate the squared distance between two points. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Distance Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> a[<span style="color:#666">0</span>] <span style="color:#666">-</span> b[<span style="color:#666">0</span>];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calculates the difference in the x-coordinates of the two points. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Distance Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> y <span style="color:#666">=</span> a[<span style="color:#666">1</span>] <span style="color:#666">-</span> b[<span style="color:#666">1</span>];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calculates the difference in the y-coordinates of the two points. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Return</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> x <span style="color:#666">*</span> x <span style="color:#666">+</span> y <span style="color:#666">*</span> y;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the squared distance between the two points. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n^2)</div>
                        <div class=""> <b>Average Case:</b> O(n^2)</div>
                        <div class=""> <b>Worst Case:</b> O(n^2)</div> 
                        <div class=""> <b>Description:</b> In all cases, we need to calculate the distance between each pair of points, which results in O(n^2) time complexity.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n^2)</div> 
                        <div class=""> <b>Description:</b> In the worst case, we store distances for each point in a hashmap, resulting in O(n^2) space complexity.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/reverse-linked-list/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 17, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-206-reverse-linked-list/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-217-contains-duplicate/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-217-contains-duplicate/">Leetcode 217: Contains Duplicate</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode598s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/217.webp" 
           alt="A set of numbers gently rearranging, with duplicates softly fading out and unique ones glowing." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 217: Contains Duplicate Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given the positions of houses and heaters along a horizontal line. Your task is to find the minimum radius required for the heaters so that all houses are within the heater&rsquo;s warm radius. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of two arrays: `houses` representing the positions of the houses and `heaters` representing the positions of the heaters.</div>
                        <div class=""> <b>Example:</b> houses = [2, 5, 7, 10], heaters = [1, 8]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= houses.length, heaters.length &lt;= 3 * 10^4</div>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= houses[i], heaters[i] &lt;= 10^9</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return the minimum radius required for the heaters to cover all houses.</div>
                        <div class=""> <b>Example:</b> Output: 3</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be an integer representing the minimum radius for heaters.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Find the minimum radius required for heaters to ensure all houses are covered.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Sort the positions of both the houses and the heaters.</div>
                            
                                <div style="margin-left: 20px;"> • 2. For each house, calculate the nearest heater and determine the distance between them.</div>
                            
                                <div style="margin-left: 20px;"> • 3. The largest distance across all houses will determine the required radius of the heaters.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The constraints are based on the number of houses, heaters, and their positions.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The length of the `houses` and `heaters` arrays is between 1 and 30,000.</div>
                            
                                <div style="margin-left: 20px;"> • The positions of the houses and heaters range between 1 and 10^9.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The heaters can be placed at any position along the horizontal line.</div>
                            
                                <div style="margin-left: 20px;"> • There is no overlap in the positions of houses and heaters.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> houses = [2, 5, 7, 10], heaters = [1, 8]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> Heaters at positions 1 and 8 with a radius of 3 can cover all the houses.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> houses = [5, 10], heaters = [6]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> A heater at position 6 with a radius of 4 can cover both houses at positions 5 and 10.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The approach involves sorting the house and heater positions, then calculating the minimum required radius by comparing distances.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Sorting the houses and heaters simplifies the task of finding the nearest heater for each house.</div>
                            
                                <div style="margin-left: 20px;"> • A greedy approach that evaluates the closest heater to each house would be efficient.</div>
                            
                            
                                <div style="margin-left: 20px;"> • By calculating the distance from each house to its nearest heater, we can determine the minimum radius required for coverage.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Sort the `houses` and `heaters` arrays.</div>
                            
                                <div style="margin-left: 20px;"> • 2. For each house, use a two-pointer or binary search approach to find the nearest heater.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Track the largest distance to the nearest heater, which will be the required minimum radius.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • There will always be at least one house and one heater, as per the constraints.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle cases where the number of houses or heaters is large (up to 30,000).</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Consider cases where all heaters are clustered in one area or spread across a wide range.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure the solution works efficiently within the constraints of up to 30,000 houses and heaters.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Sorting</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Sorting</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Vector Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Left to Right Sweep</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Condition Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Update Distance</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Increment Home Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Increment Heater Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Right to Left Sweep</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Condition Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Update Distance</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Decrement Home Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Decrement Heater Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Final Calculation</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">findRadius</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> home, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> warm) {
</span></span><span style="display:flex;"><span>    sort(home.begin(), home.end());
</span></span><span style="display:flex;"><span>    sort(warm.begin(), warm.end());
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> home.size(), n <span style="color:#666">=</span> warm.size();
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res(m, INT_MAX);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> h <span style="color:#666">=</span> <span style="color:#666">0</span>, w <span style="color:#666">=</span> <span style="color:#666">0</span>; h <span style="color:#666">&lt;</span> m <span style="color:#666">&amp;&amp;</span> w <span style="color:#666">&lt;</span> n; ) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (home[h] <span style="color:#666">&lt;=</span> warm[w]) {
</span></span><span style="display:flex;"><span>            res[h] <span style="color:#666">=</span> warm[w] <span style="color:#666">-</span> home[h];
</span></span><span style="display:flex;"><span>            h<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> w<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> h <span style="color:#666">=</span> m <span style="color:#666">-</span> <span style="color:#666">1</span>, w <span style="color:#666">=</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>; h <span style="color:#666">&gt;=</span> <span style="color:#666">0</span> <span style="color:#666">&amp;&amp;</span> w <span style="color:#666">&gt;=</span> <span style="color:#666">0</span>; ) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (home[h] <span style="color:#666">&gt;=</span> warm[w]) {
</span></span><span style="display:flex;"><span>            res[h] <span style="color:#666">=</span> min(res[h], home[h] <span style="color:#666">-</span> warm[w]);
</span></span><span style="display:flex;"><span>            h<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> w<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">*</span>max_element(res.begin(), res.end());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">findRadius</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> home, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> warm) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the `findRadius` function, which takes two vectors, `home` and `warm`, representing the positions of homes and warm heaters, and returns the minimum radius required to ensure every home is covered. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Sorting</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    sort(home.begin(), home.end());
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Sorts the `home` vector to facilitate the process of finding the closest heater for each home. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Sorting</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    sort(warm.begin(), warm.end());
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Sorts the `warm` vector to make it easier to check the closest heater to a given home. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> home.size(), n <span style="color:#666">=</span> warm.size();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes `m` as the number of homes and `n` as the number of heaters. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Vector Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res(m, INT_MAX);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes a vector `res` of size `m` (the number of homes), setting each element to `INT_MAX` as an initial placeholder for the minimum distances to the closest heater. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Left to Right Sweep</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> h <span style="color:#666">=</span> <span style="color:#666">0</span>, w <span style="color:#666">=</span> <span style="color:#666">0</span>; h <span style="color:#666">&lt;</span> m <span style="color:#666">&amp;&amp;</span> w <span style="color:#666">&lt;</span> n; ) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Begins a loop that iterates over both homes (`h`) and heaters (`w`) from left to right to compute the closest heater to each home. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Condition Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (home[h] <span style="color:#666">&lt;=</span> warm[w]) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current home is to the left of or at the current heater position. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Update Distance</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            res[h] <span style="color:#666">=</span> warm[w] <span style="color:#666">-</span> home[h];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates the minimum distance for home `h` to the current heater `w`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Increment Home Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            h<span style="color:#666">++</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Increments the home pointer `h` to consider the next home. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Increment Heater Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> w<span style="color:#666">++</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current home is not covered by the current heater, increments the heater pointer `w` to check the next heater. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Right to Left Sweep</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> h <span style="color:#666">=</span> m <span style="color:#666">-</span> <span style="color:#666">1</span>, w <span style="color:#666">=</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>; h <span style="color:#666">&gt;=</span> <span style="color:#666">0</span> <span style="color:#666">&amp;&amp;</span> w <span style="color:#666">&gt;=</span> <span style="color:#666">0</span>; ) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Begins a loop that iterates over both homes (`h`) and heaters (`w`) from right to left to compute the closest heater to each home in the reverse direction. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Condition Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (home[h] <span style="color:#666">&gt;=</span> warm[w]) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current home is to the right of or at the current heater position. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Update Distance</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            res[h] <span style="color:#666">=</span> min(res[h], home[h] <span style="color:#666">-</span> warm[w]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates the minimum distance for home `h` by considering the current heater `w` and taking the minimum between the previous calculated distance and the new one. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Decrement Home Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            h<span style="color:#666">--</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Decrements the home pointer `h` to consider the next home in the reverse direction. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Decrement Heater Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> w<span style="color:#666">--</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current home is not covered by the current heater, decrements the heater pointer `w` to check the next heater in the reverse direction. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Final Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">*</span><span style="color:#00a000">max_element</span>(res.begin(), res.end());
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the maximum value from the `res` vector, which represents the largest of the minimum distances to the closest heater for all homes. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n log n)</div>
                        <div class=""> <b>Average Case:</b> O(n log n)</div>
                        <div class=""> <b>Worst Case:</b> O(n log n)</div> 
                        <div class=""> <b>Description:</b> Sorting the houses and heaters requires O(n log n) time, where n is the number of houses or heaters.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n) due to the storage required for sorting the arrays.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/contains-duplicate/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 16, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-217-contains-duplicate/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-225-implement-stack-using-queues/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-225-implement-stack-using-queues/">Leetcode 225: Implement Stack using Queues</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode643s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/225.webp" 
           alt="A series of glowing queues stacked neatly, showing elements being added and removed smoothly." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 225: Implement Stack using Queues Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given the root of a binary tree, return the most frequent subtree sum. A subtree sum is the sum of all the node values in the subtree rooted at any node, including the node itself. If there is a tie, return all the subtree sums with the highest frequency. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input is the root node of a binary tree with integer values.</div>
                        <div class=""> <b>Example:</b> [5, 2, -3]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= Number of nodes &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • -10^5 &lt;= Node.val &lt;= 10^5</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be a list of the most frequent subtree sums.</div>
                        <div class=""> <b>Example:</b> [2, -3, 4]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output list contains the most frequent subtree sums, with no specific order.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to identify the most frequent subtree sum(s) by traversing the tree and calculating the sum of each subtree.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Perform a depth-first search (DFS) on the tree.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Calculate the sum of each subtree and keep track of their frequencies.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Identify the subtree sum(s) with the highest frequency.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Return the list of those sums.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The tree contains at least one node, and the number of nodes is within the specified limit.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= Number of nodes &lt;= 10^4</div>
                            
                                <div style="margin-left: 20px;"> • -10^5 &lt;= Node.val &lt;= 10^5</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The binary tree is well-formed and follows valid tree structure rules.</div>
                            
                                <div style="margin-left: 20px;"> • The values of the nodes are integers, and they may be negative.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> [5, 2, -3]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this example, the subtree sums are calculated as follows: the sum of the subtree rooted at 5 is 5 &#43; 2 &#43; (-3) = 4; the sum of the subtree rooted at 2 is 2; the sum of the subtree rooted at -3 is -3. Therefore, the most frequent sums are [2, -3, 4].</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> We will perform a depth-first search (DFS) on the tree, calculate the subtree sums, and track the frequency of each sum. The most frequent sums will be identified and returned.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • DFS allows us to calculate the sum of each subtree while traversing the tree.</div>
                            
                                <div style="margin-left: 20px;"> • We need a data structure to store the frequencies of each subtree sum.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We can use a map or hash map to track the frequency of each sum. After the DFS, we will identify the sums with the highest frequency.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Initialize a map to store the frequency of each subtree sum.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Perform DFS on the tree, calculate the sum for each node, and update the frequency map.</div>
                            
                                <div style="margin-left: 20px;"> • 3. Track the maximum frequency encountered.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Collect all sums with the highest frequency and return them.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The tree will always have at least one node, so this case does not occur.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution should handle trees with up to 10,000 nodes efficiently.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Nodes with negative values should be correctly handled in the sum calculations.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The algorithm should ensure that it works efficiently within the given constraints.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Access Modifiers</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Variable Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Data Structure Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Frequency Reset</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Function Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Return Statement</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 DFS Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Base Case</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Local Variable Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Leaf Node Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Recursive DFS Calls</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Recursive DFS Left</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Recursive DFS Right</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Subtree Sum Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="17"> 17 Frequency Tracking</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="18"> 18 Max Frequency Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="19"> 19 Update Results</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="20"> 20 Add New Max Frequency</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="21"> 21 Update Max Frequency</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="22"> 22 Frequency Equality Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="23"> 23 Add Equal Frequency</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="24"> 24 Return Subtree Sum</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> mx;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> findFrequentTreeSum(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> ans;
</span></span><span style="display:flex;"><span>    map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    mx <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    dfs(root, mp, ans);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">dfs</span>(TreeNode<span style="color:#666">*</span> root, map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> mp, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> ans) {
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> res;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (root<span style="color:#666">-&gt;</span>left  <span style="color:#666">==</span> <span style="color:#a2f">NULL</span> <span style="color:#666">&amp;&amp;</span> 
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>right <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>)
</span></span><span style="display:flex;"><span>         { res <span style="color:#666">=</span> root<span style="color:#666">-&gt;</span>val; }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> l <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>left , mp, ans);
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> r <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>right, mp, ans);
</span></span><span style="display:flex;"><span>        res <span style="color:#666">=</span> l <span style="color:#666">+</span> r <span style="color:#666">+</span> root<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    mp[res] <span style="color:#666">+=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(mx <span style="color:#666">&lt;</span> mp[res]) {
</span></span><span style="display:flex;"><span>        ans.clear();
</span></span><span style="display:flex;"><span>        ans.push_back(res);
</span></span><span style="display:flex;"><span>        mx <span style="color:#666">=</span> mp[res];
</span></span><span style="display:flex;"><span>    } <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">if</span>(mx <span style="color:#666">==</span> mp[res]) {
</span></span><span style="display:flex;"><span>        ans.push_back(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> mx;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> A variable to keep track of the maximum frequency of the tree sums. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Access Modifiers</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Public section where the function definitions are accessible. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> findFrequentTreeSum(TreeNode<span style="color:#666">*</span> root) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the function that returns the most frequent tree sums from a given root. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Variable Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> A vector to store the most frequent tree sums. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Data Structure Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> A map to store the frequency of each tree sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Frequency Reset</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    mx <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes the maximum frequency to 0. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Function Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    dfs(root, mp, ans);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calls the dfs function to traverse the tree and compute the frequencies. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Return Statement</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the vector containing the most frequent tree sums. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : DFS Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">dfs</span>(TreeNode<span style="color:#666">*</span> root, map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> mp, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> ans) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the dfs function to traverse the tree and calculate the sum for each node. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Base Case</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Base case for the DFS, returns 0 if the current node is NULL. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Local Variable Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declares a variable to store the current subtree sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Leaf Node Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (root<span style="color:#666">-&gt;</span>left  <span style="color:#666">==</span> <span style="color:#a2f">NULL</span> <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>right <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) { res <span style="color:#666">=</span> root<span style="color:#666">-&gt;</span>val; }
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current node is a leaf node. If it is, the sum is just the node&#39;s value. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Recursive DFS Calls</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">else</span> {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current node is not a leaf, recursively calculate the left and right subtree sums. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Recursive DFS Left</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> l <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>left , mp, ans);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls dfs for the left child and stores the result in l. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Recursive DFS Right</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> r <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>right, mp, ans);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively calls dfs for the right child and stores the result in r. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Subtree Sum Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        res <span style="color:#666">=</span> l <span style="color:#666">+</span> r <span style="color:#666">+</span> root<span style="color:#666">-&gt;</span>val;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calculates the sum of the current node, left and right subtree sums. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>17 : Frequency Tracking</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    mp[res] <span style="color:#666">+=</span> <span style="color:#666">1</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates the frequency map with the current subtree sum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>18 : Max Frequency Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(mx <span style="color:#666">&lt;</span> mp[res]) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current subtree sum frequency is greater than the max frequency. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>19 : Update Results</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ans.clear();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Clears the results vector if a new max frequency is found. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>20 : Add New Max Frequency</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ans.push_back(res);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Adds the current sum to the results list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>21 : Update Max Frequency</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        mx <span style="color:#666">=</span> mp[res];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Updates the max frequency to the current frequency. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>22 : Frequency Equality Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    } <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#00a000">if</span>(mx <span style="color:#666">==</span> mp[res]) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current sum frequency equals the max frequency. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>23 : Add Equal Frequency</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ans.push_back(res);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Adds the current sum to the results list if it matches the max frequency. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>24 : Return Subtree Sum</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the current subtree sum to the caller. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n), where n is the number of nodes in the tree. Each node is visited once during the DFS.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n) due to the space required for the map to store the frequency of subtree sums and the recursion stack during DFS.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/implement-stack-using-queues/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 15, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-225-implement-stack-using-queues/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


            </div>
        </section>
<div class="bottompagination">
  <div class="pointerup"><i class="fa fa-caret-up"></i></div>
  <div class="navigation" role="navigation">
    
      <div class="pagination">
        
          <a class="ml-1 mr-1" href="/categories/easy/page/4/">&laquo; Prev</a>
          <a class="ml-1 mr-1" href="/categories/easy/page/4/">4</a>
        

        <span class="ml-1 mr-1">5</span>

        
          <a class="ml-1 mr-1" href="/categories/easy/page/6/">6</a>
          <a class="ml-1 mr-1" href="/categories/easy/page/6/">Next &raquo;</a>
        
      </div>
    
  </div>
</div></div>


            </div>
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
			<div class="d-md-flex align-items-center justify-content-center h-100">
				<h2 class="d-md-block d-none align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
			</div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
			
			<a class="mt-1 mb-1" href="/tags/array">array</a>
			
			<a class="mt-1 mb-1" href="/tags/backtracking">backtracking</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-indexed-tree">binary indexed tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search">binary search</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search-tree">binary search tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-tree">binary tree</a>
			
			<a class="mt-1 mb-1" href="/tags/bit-manipulation">bit manipulation</a>
			
			<a class="mt-1 mb-1" href="/tags/bitmask">bitmask</a>
			
			<a class="mt-1 mb-1" href="/tags/brainteaser">brainteaser</a>
			
			<a class="mt-1 mb-1" href="/tags/breadth-first-search">breadth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/bucket-sort">bucket sort</a>
			
			<a class="mt-1 mb-1" href="/tags/combinatorics">combinatorics</a>
			
			<a class="mt-1 mb-1" href="/tags/concurrency">concurrency</a>
			
			<a class="mt-1 mb-1" href="/tags/counting">counting</a>
			
			<a class="mt-1 mb-1" href="/tags/counting-sort">counting sort</a>
			
			<a class="mt-1 mb-1" href="/tags/data-stream">data stream</a>
			
			<a class="mt-1 mb-1" href="/tags/depth-first-search">depth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/design">design</a>
			
			<a class="mt-1 mb-1" href="/tags/divide-and-conquer">divide and conquer</a>
			
			<a class="mt-1 mb-1" href="/tags/doubly-linked-list">doubly-linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/dynamic-programming">dynamic programming</a>
			
			<a class="mt-1 mb-1" href="/tags/enumeration">enumeration</a>
			
			<a class="mt-1 mb-1" href="/tags/game-theory">game theory</a>
			
			<a class="mt-1 mb-1" href="/tags/geometry">geometry</a>
			
			<a class="mt-1 mb-1" href="/tags/graph">graph</a>
			
			<a class="mt-1 mb-1" href="/tags/greedy">greedy</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-function">hash function</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-table">hash table</a>
			
			<a class="mt-1 mb-1" href="/tags/heap-priority-queue">heap (priority queue)</a>
			
			<a class="mt-1 mb-1" href="/tags/interactive">interactive</a>
			
			<a class="mt-1 mb-1" href="/tags/iterator">iterator</a>
			
			<a class="mt-1 mb-1" href="/tags/linked-list">linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/math">math</a>
			
			<a class="mt-1 mb-1" href="/tags/matrix">matrix</a>
			
			<a class="mt-1 mb-1" href="/tags/memoization">memoization</a>
			
			<a class="mt-1 mb-1" href="/tags/minimum-spanning-tree">minimum spanning tree</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-queue">monotonic queue</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-stack">monotonic stack</a>
			
			<a class="mt-1 mb-1" href="/tags/number-theory">number theory</a>
			
			<a class="mt-1 mb-1" href="/tags/ordered-set">ordered set</a>
			
			<a class="mt-1 mb-1" href="/tags/prefix-sum">prefix sum</a>
			
			<a class="mt-1 mb-1" href="/tags/probability-and-statistics">probability and statistics</a>
			
			<a class="mt-1 mb-1" href="/tags/queue">queue</a>
			
			<a class="mt-1 mb-1" href="/tags/quickselect">quickselect</a>
			
			<a class="mt-1 mb-1" href="/tags/radix-sort">radix sort</a>
			
			<a class="mt-1 mb-1" href="/tags/randomized">randomized</a>
			
			<a class="mt-1 mb-1" href="/tags/recursion">recursion</a>
			
			<a class="mt-1 mb-1" href="/tags/reservoir-sampling">reservoir sampling</a>
			
			<a class="mt-1 mb-1" href="/tags/rolling-hash">rolling hash</a>
			
			<a class="mt-1 mb-1" href="/tags/segment-tree">segment tree</a>
			
			<a class="mt-1 mb-1" href="/tags/shortest-path">shortest path</a>
			
			<a class="mt-1 mb-1" href="/tags/simulation">simulation</a>
			
			<a class="mt-1 mb-1" href="/tags/sliding-window">sliding window</a>
			
			<a class="mt-1 mb-1" href="/tags/sorting">sorting</a>
			
			<a class="mt-1 mb-1" href="/tags/stack">stack</a>
			
			<a class="mt-1 mb-1" href="/tags/string">string</a>
			
			<a class="mt-1 mb-1" href="/tags/string-matching">string matching</a>
			
			<a class="mt-1 mb-1" href="/tags/topological-sort">topological sort</a>
			
			<a class="mt-1 mb-1" href="/tags/tree">tree</a>
			
			<a class="mt-1 mb-1" href="/tags/trie">trie</a>
			
			<a class="mt-1 mb-1" href="/tags/two-pointers">two pointers</a>
			
			<a class="mt-1 mb-1" href="/tags/union-find">union find</a>
			
		</div>
	</div>
</div>

<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

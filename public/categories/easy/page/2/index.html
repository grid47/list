<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

	
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Easy | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Easy">
  <meta name="twitter:description" content="Blog by grid47">

	<meta property="og:url" content="http://localhost:1313/categories/easy/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Easy">
  <meta property="og:description" content="Blog by grid47">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="website">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
        

	
	
	<link rel="stylesheet" href="/css/leetcode.css" integrity="" crossorigin="anonymous" media="screen">



</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/courses/">Course</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
    <div class="main-content">
        
        <section class="recent-posts">            
            <div class="section-title">                
                <h2><span>All Posts</span></h2>                
            </div>            
            <div class="row listrecent">
                
                
<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-35-search-insert-position/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-35-search-insert-position/">Leetcode 35: Search Insert Position</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1087s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/35.webp" 
           alt="A glowing insertion point in a calm array, gently creating a new position." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 35: Search Insert Position Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given an n x n 2D matrix representing an image, rotate the image by 90 degrees clockwise. The rotation should be done in-place, meaning you cannot allocate another 2D matrix. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input is a 2D matrix representing an image. The matrix is of size n x n, where n is between 1 and 20.</div>
                        <div class=""> <b>Example:</b> [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= n &lt;= 20</div>
                            
                                <div style="margin-left: 20px;"> • Each element of the matrix is an integer between -1000 and 1000.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return the matrix after rotating it by 90 degrees clockwise.</div>
                        <div class=""> <b>Example:</b> [[7, 4, 1], [8, 5, 2], [9, 6, 3]]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The result should be the rotated matrix, achieved in-place.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to rotate the matrix 90 degrees clockwise in-place without using extra space for another matrix.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Reverse the rows of the matrix.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Transpose the matrix by swapping the elements along the diagonal.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The input matrix has a size of n x n, where n is between 1 and 20. All matrix elements are integers between -1000 and 1000.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The matrix size is between 1 and 20.</div>
                            
                                <div style="margin-left: 20px;"> • Matrix elements are integers in the range [-1000, 1000].</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The matrix will always be a square matrix with the same number of rows and columns.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> [[1, 2, 3], [4, 5, 6], [7, 8, 9]]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this example, after reversing the rows and transposing, the final result is [[7, 4, 1], [8, 5, 2], [9, 6, 3]].</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> [[5, 1, 9, 11], [2, 4, 8, 10], [13, 3, 6, 7], [15, 14, 12, 16]]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this example, after rotating the matrix 90 degrees clockwise, the final result is [[15, 13, 2, 5], [14, 3, 4, 1], [12, 6, 8, 9], [16, 7, 10, 11]].</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The approach involves reversing the rows of the matrix and then transposing the matrix to achieve a 90-degree rotation.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Reversing the rows and transposing the matrix will effectively rotate it by 90 degrees clockwise.</div>
                            
                            
                                <div style="margin-left: 20px;"> • This approach is efficient as it modifies the matrix in place, without requiring additional space.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Reverse the order of rows in the matrix.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Transpose the matrix by swapping each element (i, j) with (j, i).</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The matrix will never be empty since n &gt;= 1.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The maximum size for n is 20, so the matrix size is at most 20 x 20, which is manageable.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Handle matrices with negative values or zeros, as these are valid elements in the matrix.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The matrix will always be square, and its elements will be integers in the range [-1000, 1000].</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Index Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Matrix Transposition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Matrix Transposition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Matrix Reflection</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Matrix Reflection</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Matrix Reflection</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">rotate</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> mtx) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>, j <span style="color:#666">=</span> mtx.size() <span style="color:#666">-</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(i <span style="color:#666">&lt;=</span> j)
</span></span><span style="display:flex;"><span>        swap(mtx[i<span style="color:#666">++</span>], mtx[j<span style="color:#666">--</span>]);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> mtx.size(); i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> i<span style="color:#666">+</span><span style="color:#666">1</span>; j<span style="color:#666">&lt;</span> mtx.size(); j<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>        swap(mtx[i][j], mtx[j][i]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">rotate</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> mtx) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This line declares a function named `rotate` that takes a 2D vector `mtx` representing the matrix as input and rotates it in-place. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Index Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>, j <span style="color:#666">=</span> mtx.size() <span style="color:#666">-</span> <span style="color:#666">1</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This line initializes two index variables `i` and `j` to represent the start and end indices of the matrix. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Matrix Transposition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(i <span style="color:#666">&lt;=</span> j)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This line starts a `while` loop to iterate through the matrix diagonally, swapping elements to transpose the matrix. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Matrix Transposition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        swap(mtx[i<span style="color:#666">++</span>], mtx[j<span style="color:#666">--</span>]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Inside the loop, the elements at indices `i` and `j` are swapped. The `i` and `j` indices are then incremented and decremented, respectively, to move to the next diagonal pair. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Matrix Reflection</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> mtx.size(); i<span style="color:#666">++</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This line starts a nested `for` loop to iterate through the upper triangular part of the matrix. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Matrix Reflection</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> i<span style="color:#666">+</span><span style="color:#666">1</span>; j<span style="color:#666">&lt;</span> mtx.size(); j<span style="color:#666">++</span>)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The inner loop iterates through the elements to the right of the current row. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Matrix Reflection</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        swap(mtx[i][j], mtx[j][i]);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The elements at indices `(i, j)` and `(j, i)` are swapped to reflect the matrix along the main diagonal, completing the 90-degree rotation. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n^2)</div>
                        <div class=""> <b>Average Case:</b> O(n^2)</div>
                        <div class=""> <b>Worst Case:</b> O(n^2)</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n^2) because we need to iterate through all the elements of the matrix for the reverse and transpose operations.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(1)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(1) as the matrix is modified in-place without using extra space.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/search-insert-position/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Nov 3, 2024 - 4 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-35-search-insert-position/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-66-plus-one/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-66-plus-one/">Leetcode 66: Plus One</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1238s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/66.webp" 
           alt="A glowing number gently increasing by one, signifying growth and positivity." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 66: Plus One Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given three strings s1, s2, and s3, determine whether s3 can be formed by interleaving s1 and s2. An interleaving is a way of combining s1 and s2 such that the characters of s1 and s2 maintain their relative order in the final string. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> You are given three strings s1, s2, and s3.</div>
                        <div class=""> <b>Example:</b> Input: s1 = &#39;abc&#39;, s2 = &#39;def&#39;, s3 = &#39;adbcef&#39;</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= s1.length, s2.length &lt;= 100</div>
                            
                                <div style="margin-left: 20px;"> • 0 &lt;= s3.length &lt;= 200</div>
                            
                                <div style="margin-left: 20px;"> • s1, s2, and s3 consist of lowercase English letters.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return true if s3 is formed by interleaving s1 and s2. Otherwise, return false.</div>
                        <div class=""> <b>Example:</b> Output: true</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Return true if s3 is an interleaving of s1 and s2, otherwise false.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to check if s3 can be formed by interleaving s1 and s2 while maintaining the relative order of characters in both strings.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Start from the beginning of s1, s2, and s3.</div>
                            
                                <div style="margin-left: 20px;"> • Check if the current character of s1 or s2 matches the current character of s3.</div>
                            
                                <div style="margin-left: 20px;"> • Recursively verify the remaining characters in s1 and s2 to see if they can form the rest of s3.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The problem constraints ensure that the input strings are within valid bounds.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • s1 and s2 can each have lengths up to 100 characters.</div>
                            
                                <div style="margin-left: 20px;"> • s3 can have a length up to 200 characters.</div>
                            
                                <div style="margin-left: 20px;"> • The strings consist of lowercase English letters only.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input strings s1, s2, and s3 are valid and follow the given constraints.</div>
                            
                                <div style="margin-left: 20px;"> • The function should efficiently handle the interleaving check for strings with lengths up to the maximum limits.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: s1 = &#39;abc&#39;, s2 = &#39;def&#39;, s3 = &#39;adbcef&#39;</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this case, s3 is an interleaving of s1 and s2 because we can alternate characters from s1 and s2 while maintaining their order to form s3.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: s1 = &#39;abc&#39;, s2 = &#39;def&#39;, s3 = &#39;abcdef&#39;</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this case, it is not possible to form s3 by interleaving s1 and s2, as the characters from s2 need to maintain their order after s1&#39;s characters.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The approach uses dynamic programming to check if s3 can be formed by interleaving s1 and s2 while preserving their order. A 2D table is used to store intermediate results, which helps in efficiently checking all combinations.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Both s1 and s2 must be used entirely to form s3.</div>
                            
                                <div style="margin-left: 20px;"> • We need to check the characters from both s1 and s2 one by one to form s3, while preserving their order.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We can use dynamic programming to break down the problem into smaller subproblems, checking whether each prefix of s1 and s2 can form a corresponding prefix of s3.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Initialize a 2D array memo to store the intermediate results of checking whether s3[0...k] can be formed using s1[0...i] and s2[0...j].</div>
                            
                                <div style="margin-left: 20px;"> • Iterate over the lengths of s1 and s2, filling the memo table by checking whether each character in s1 or s2 matches the current character in s3.</div>
                            
                                <div style="margin-left: 20px;"> • Return the value at memo[s1.length][s2.length] to determine if s3 can be formed by interleaving s1 and s2.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If all strings are empty (s1 = &#39;&#39;, s2 = &#39;&#39;, s3 = &#39;&#39;), the answer is true.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • When the lengths of s1 and s2 are near the upper limit (100), the algorithm should handle it efficiently using dynamic programming.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If s1 or s2 is empty, the solution depends solely on whether s3 matches the other string.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure the solution works within the provided constraints (maximum length of 100 for s1 and s2, 200 for s3).</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Variable Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Array Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Function Declaration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Base Case</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Memoization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Conditional Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Conditional Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Recursive Call</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Memoization Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Variable Assignment</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Variable Assignment</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Variable Assignment</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Condition Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="17"> 17 Array Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="18"> 18 Function Call</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string s1, s2, s3;
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> memo;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">dp</span>(<span style="color:#0b0;font-weight:bold">int</span> i, <span style="color:#0b0;font-weight:bold">int</span> j) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">==</span> s1.size() <span style="color:#666">&amp;&amp;</span> j <span style="color:#666">==</span> s2.size()) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(memo[i][j] <span style="color:#666">!=</span> <span style="color:#666">-</span><span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> memo[i][j];
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> k <span style="color:#666">=</span> i <span style="color:#666">+</span> j;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">&lt;</span> s1.size() <span style="color:#666">&amp;&amp;</span> s1[i] <span style="color:#666">==</span> s3[k])
</span></span><span style="display:flex;"><span>        ans <span style="color:#666">|=</span> dp(i <span style="color:#666">+</span> <span style="color:#666">1</span>, j);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(j <span style="color:#666">&lt;</span> s2.size() <span style="color:#666">&amp;&amp;</span> s2[j] <span style="color:#666">==</span> s3[k])
</span></span><span style="display:flex;"><span>        ans <span style="color:#666">|=</span> dp(i, j <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> memo[i][j] <span style="color:#666">=</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">isInterleave</span>(string s1, string s2, string s3) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>s1 <span style="color:#666">=</span> s1;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>s2 <span style="color:#666">=</span> s2;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>s3 <span style="color:#666">=</span> s3;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(s1.size() <span style="color:#666">+</span> s2.size() <span style="color:#666">!=</span> s3.size()) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>    memo.resize(s1.size() <span style="color:#666">+</span> <span style="color:#666">1</span>, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span>(s2.size() <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#666">-</span><span style="color:#666">1</span>));
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> dp(<span style="color:#666">0</span>, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Variable Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string s1, s2, s3;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declares three string variables to store the input strings. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Array Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> memo;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes a 2D vector `memo` to store the results of subproblems, using memoization to avoid redundant calculations. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Function Declaration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">dp</span>(<span style="color:#0b0;font-weight:bold">int</span> i, <span style="color:#0b0;font-weight:bold">int</span> j) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Declares a recursive function `dp` to check if the substring `s1[i:]` and `s2[j:]` can interleave to form `s3[i&#43;j:]`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Base Case</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">==</span> s1.size() <span style="color:#666">&amp;&amp;</span> j <span style="color:#666">==</span> s2.size()) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If we&#39;ve reached the end of both `s1` and `s2`, it means we&#39;ve successfully interleaved them, so return `true`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Memoization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(memo[i][j] <span style="color:#666">!=</span> <span style="color:#666">-</span><span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> memo[i][j];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the result for the current `i` and `j` is already stored in the memoization table. If so, return the stored value. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes a variable `ans` to store the result of the current subproblem. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> k <span style="color:#666">=</span> i <span style="color:#666">+</span> j;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calculates the index `k` in `s3` corresponding to the current positions in `s1` and `s2`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Conditional Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">&lt;</span> s1.size() <span style="color:#666">&amp;&amp;</span> s1[i] <span style="color:#666">==</span> s3[k])
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current character in `s1` matches the corresponding character in `s3`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ans <span style="color:#666">|=</span> dp(i <span style="color:#666">+</span> <span style="color:#666">1</span>, j);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively checks if the remaining substrings of `s1` and `s2` can interleave to form the remaining part of `s3`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Conditional Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(j <span style="color:#666">&lt;</span> s2.size() <span style="color:#666">&amp;&amp;</span> s2[j] <span style="color:#666">==</span> s3[k])
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the current character in `s2` matches the corresponding character in `s3`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Recursive Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ans <span style="color:#666">|=</span> dp(i, j <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Recursively checks if the remaining substrings of `s1` and `s2` can interleave to form the remaining part of `s3`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Memoization Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> memo[i][j] <span style="color:#666">=</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Stores the result of the current subproblem in the memoization table and returns it. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Variable Assignment</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>s1 <span style="color:#666">=</span> s1;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Assigns the input string `s1` to the class member variable `s1`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Variable Assignment</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>s2 <span style="color:#666">=</span> s2;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Assigns the input string `s2` to the class member variable `s2`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Variable Assignment</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">this</span><span style="color:#666">-&gt;</span>s3 <span style="color:#666">=</span> s3;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Assigns the input string `s3` to the class member variable `s3`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Condition Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(s1.size() <span style="color:#666">+</span> s2.size() <span style="color:#666">!=</span> s3.size()) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Checks if the sum of lengths of `s1` and `s2` is equal to the length of `s3`. If not, it&#39;s impossible to interleave, so return `false`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>17 : Array Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    memo.resize(s1.size() <span style="color:#666">+</span> <span style="color:#666">1</span>, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span>(s2.size() <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#666">-</span><span style="color:#666">1</span>));
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Resizes the `memo` vector to store results for all possible substrings of `s1` and `s2`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>18 : Function Call</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">dp</span>(<span style="color:#666">0</span>, <span style="color:#666">0</span>);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calls the `dp` function to check if the entire `s1` and `s2` can interleave to form `s3`, starting from the beginning of each string. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n * m)</div>
                        <div class=""> <b>Average Case:</b> O(n * m)</div>
                        <div class=""> <b>Worst Case:</b> O(n * m)</div> 
                        <div class=""> <b>Description:</b> Where n is the length of s1 and m is the length of s2. The worst-case time complexity occurs when we need to fill the entire memo table.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n * m)</div>
                        <div class=""> <b>Worst Case:</b> O(n * m)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n * m) due to the memo table storing the results for subproblems.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/plus-one/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 31, 2024 - 7 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-66-plus-one/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-67-add-binary/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-67-add-binary/">Leetcode 67: Add Binary</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1242s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/67.webp" 
           alt="Two radiant binary sequences gently merging into a new, illuminated result." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 67: Add Binary Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> You are given the root of a binary tree. Your task is to determine whether the tree is a valid binary search tree (BST). A binary search tree is valid if for every node in the tree, the value of all nodes in its left subtree are less than its own value, and the value of all nodes in its right subtree are greater than its own value. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of the root node of a binary tree.</div>
                        <div class=""> <b>Example:</b> Input: root = [3,2,4,1,5]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The tree contains between 1 and 10^4 nodes.</div>
                            
                                <div style="margin-left: 20px;"> • -2^31 &lt;= Node.val &lt;= 2^31 - 1</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> Return true if the tree is a valid binary search tree, otherwise return false.</div>
                        <div class=""> <b>Example:</b> Output: true</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The function must return true if the tree is a valid BST, and false otherwise.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to verify if the binary tree satisfies the conditions of a binary search tree at every node.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Traverse the tree in an inorder fashion.</div>
                            
                                <div style="margin-left: 20px;"> • Check if the node values are in strictly increasing order. If any node violates this rule, return false.</div>
                            
                                <div style="margin-left: 20px;"> • If the traversal completes without issues, return true.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The problem ensures that the binary tree follows the given constraints, including the value range for each node.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The tree has at least 1 node.</div>
                            
                                <div style="margin-left: 20px;"> • Each node&#39;s value is within the range [-2^31, 2^31 - 1].</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The tree is valid and can be represented in the form of a binary tree with integer values.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: root = [3,2,4,1,5]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this case, the tree is a valid binary search tree because the left subtree contains values less than 3, and the right subtree contains values greater than 3, with the same rule applying recursively to all nodes.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: root = [5,1,4,null,null,3,6]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this case, the tree is not a valid binary search tree because the right child of node 5 is 4, which is less than 5, violating the BST rule.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> We will use an inorder traversal to verify if the binary tree is a valid BST. In an inorder traversal of a BST, the values of nodes should appear in strictly increasing order. By comparing each node with the previously visited node, we can determine if the tree is a valid BST.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the tree is a valid BST, an inorder traversal should yield a sorted list of node values.</div>
                            
                            
                                <div style="margin-left: 20px;"> • We will use a stack-based iterative inorder traversal to ensure we efficiently check all nodes of the tree.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Use a stack to simulate the inorder traversal of the tree.</div>
                            
                                <div style="margin-left: 20px;"> • Traverse the tree while pushing nodes onto the stack.</div>
                            
                                <div style="margin-left: 20px;"> • Pop nodes from the stack and check if they are in strictly increasing order.</div>
                            
                                <div style="margin-left: 20px;"> • If any node violates the BST condition, return false. If the traversal completes successfully, return true.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • An empty tree is considered a valid BST, so return true.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • For large trees with up to 10^4 nodes, the solution must be efficient and handle the constraints effectively.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure that nodes with extreme values (-2^31 and 2^31 - 1) are handled correctly.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • Ensure the solution works efficiently within the given constraints.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Stack Operations</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Stack Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 While Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 If Condition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Stack Push</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Left Traversal</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Else Condition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Stack Top</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Stack Pop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 BST Validation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Return False</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Update Previous Node</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Move Right</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 End of While</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Return True</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">isValidBST</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    stack<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> stk;
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> node <span style="color:#666">=</span> root, <span style="color:#666">*</span>prv <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#080;font-style:italic">// stk.push(root);
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>stk.empty() <span style="color:#666">||</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(node) {
</span></span><span style="display:flex;"><span>            stk.push(node);
</span></span><span style="display:flex;"><span>            node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>left;
</span></span><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            node <span style="color:#666">=</span> stk.top();
</span></span><span style="display:flex;"><span>            stk.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(prv <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span> <span style="color:#666">&amp;&amp;</span> prv <span style="color:#666">-&gt;</span> val <span style="color:#666">&gt;=</span> node<span style="color:#666">-&gt;</span>val)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>            prv <span style="color:#666">=</span> node;
</span></span><span style="display:flex;"><span>            node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>right;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Stack Operations</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">isValidBST</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Start of the function. We&#39;re defining a function to check if a binary tree is a valid Binary Search Tree (BST). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Stack Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    stack<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> stk;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Here we initialize a stack to help with the iterative in-order traversal of the tree. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> node <span style="color:#666">=</span> root, <span style="color:#666">*</span>prv <span style="color:#666">=</span> <span style="color:#a2f">NULL</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> We initialize two pointers: &#39;node&#39; to traverse the tree and &#39;prv&#39; to keep track of the previous node in the in-order traversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : While Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>stk.empty() <span style="color:#666">||</span> node) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> We start a while loop that continues as long as there are nodes to process, either in the stack or in the &#39;node&#39; variable. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : If Condition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(node) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current node is not null, we process it by pushing it onto the stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Stack Push</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            stk.push(node);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> We push the current node onto the stack to visit its left subtree next. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Left Traversal</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>left;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Move to the left child of the current node to continue the in-order traversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Else Condition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If there are no more left children to visit (i.e., node is null), we process the node at the top of the stack. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Stack Top</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            node <span style="color:#666">=</span> stk.top();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Retrieve the top node from the stack, which is the next node in the in-order traversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Stack Pop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            stk.pop();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pop the node from the stack after processing it. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : BST Validation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(prv <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span> <span style="color:#666">&amp;&amp;</span> prv <span style="color:#666">-&gt;</span> val <span style="color:#666">&gt;=</span> node<span style="color:#666">-&gt;</span>val)
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> We check if the previous node&#39;s value is greater than or equal to the current node&#39;s value. If it is, the tree is not a valid BST. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Return False</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the previous node&#39;s value is greater than or equal to the current node&#39;s value, return false because the tree violates BST properties. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Update Previous Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            prv <span style="color:#666">=</span> node;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Update the &#39;prv&#39; pointer to the current node, which will be used for comparison in the next iteration. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Move Right</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>right;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Move to the right child of the current node to continue the in-order traversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : End of While</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    }
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> End of the while loop, indicating that all nodes have been processed. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Return True</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If no violations were found, return true indicating the tree is a valid BST. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n), where n is the number of nodes in the tree, because we visit each node once during the inorder traversal.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(n) in the worst case when the tree is skewed and all nodes are pushed onto the stack. In the best case, for a balanced tree, the space complexity is O(h), where h is the height of the tree.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/add-binary/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 31, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-67-add-binary/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-70-climbing-stairs/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-70-climbing-stairs/">Leetcode 70: Climbing Stairs</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1257s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/70.webp" 
           alt="A glowing staircase with each step symbolizing progress, slowly leading upwards." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 70: Climbing Stairs Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given the root of a binary tree, your task is to return the level order traversal of its nodes&rsquo; values. This means you should traverse the tree level by level, from left to right at each level. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> You are given the root of a binary tree, where each node has a value and pointers to its left and right children.</div>
                        <div class=""> <b>Example:</b> root = [5,3,8,1,4,null,9]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the tree is in the range [0, 2000].</div>
                            
                                <div style="margin-left: 20px;"> • -1000 &lt;= Node.val &lt;= 1000</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be a 2D array where each element represents a level in the binary tree. Each level is a list of node values at that level, traversed from left to right.</div>
                        <div class=""> <b>Example:</b> Output: [[5], [3, 8], [1, 4, 9]]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output should be an array of arrays where each inner array contains the values of the nodes at that level.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to perform a level order traversal of the binary tree using a queue to process nodes level by level.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Start by checking if the root is null. If it is, return an empty list.</div>
                            
                                <div style="margin-left: 20px;"> • Initialize a queue with the root node.</div>
                            
                                <div style="margin-left: 20px;"> • While the queue is not empty, process each node at the current level.</div>
                            
                                <div style="margin-left: 20px;"> • For each level, create a list of node values and add the left and right children of each node to the queue.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> Ensure the solution can handle a tree with up to 2000 nodes efficiently.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The tree can have between 0 and 2000 nodes.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The input is always a valid binary tree.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = [3,9,20,null,null,15,7]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The binary tree has the following structure:

       3
      / \
     9  20
        /  \
       15   7

The level order traversal is: [[3], [9, 20], [15, 7]]</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = [1]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The binary tree consists of just one node, which is the root node. The level order traversal is: [[1]]</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> root = []</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> An empty tree has no nodes, so the level order traversal is: []</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The problem can be solved using a breadth-first search (BFS) approach where we explore the tree level by level, ensuring nodes at each level are processed from left to right.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Level order traversal can be efficiently implemented using a queue.</div>
                            
                            
                                <div style="margin-left: 20px;"> • By using a queue, we can ensure that we process nodes level by level, which is the key to solving this problem.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Check if the root is null, return an empty list if it is.</div>
                            
                                <div style="margin-left: 20px;"> • Initialize a queue and add the root node to it.</div>
                            
                                <div style="margin-left: 20px;"> • While the queue is not empty, process each level by iterating over the nodes in the queue.</div>
                            
                                <div style="margin-left: 20px;"> • For each node in the current level, add its value to the result list and enqueue its left and right children if they exist.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • If the tree is empty (i.e., the root is null), return an empty list.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • For large trees with up to 2000 nodes, ensure the solution handles the input efficiently.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • If a node has only one child (either left or right), make sure it is properly handled during the level order traversal.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The tree must be processed within the provided constraints (2000 nodes).</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Base Case</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Queue Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Push Root to Queue</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Main BFS Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Level Size</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Result Vector</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Level Nodes Processing</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Queue Front</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Add Node Value</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Queue Pop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Left Child Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="14"> 14 Right Child Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="15"> 15 Push Level to Result</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="16"> 16 Return Result</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> levelOrder(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> ans;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    queue<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span><span style="display:flex;"><span>    q.push(root);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>            TreeNode<span style="color:#666">*</span> tmp <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>            res.push_back(tmp<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(tmp<span style="color:#666">-&gt;</span>left) q.push(tmp<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(tmp<span style="color:#666">-&gt;</span>right) q.push(tmp<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        ans.push_back(res);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> levelOrder(TreeNode<span style="color:#666">*</span> root) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Define the function &#39;levelOrder&#39; which takes the root of the tree and returns a 2D vector of integers, representing the tree&#39;s level-order traversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize an empty 2D vector &#39;ans&#39; to store the values of each level of the tree. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Base Case</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the tree is empty (root is NULL), return the empty result vector. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Queue Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    queue<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Create a queue to assist in performing a breadth-first search (BFS). The queue will hold nodes at each level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Push Root to Queue</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    q.push(root);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Push the root node to the queue to begin the level-order traversal. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Main BFS Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> While the queue is not empty, continue processing the nodes level by level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Level Size</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Store the current size of the queue, which represents the number of nodes at the current level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Result Vector</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initialize a temporary vector &#39;res&#39; to hold the node values for the current level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Level Nodes Processing</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span>) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Process each node at the current level by looping through the queue until all nodes at this level are visited. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Queue Front</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            TreeNode<span style="color:#666">*</span> tmp <span style="color:#666">=</span> q.front();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Get the front node from the queue, which is the current node to be processed. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Add Node Value</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            res.push_back(tmp<span style="color:#666">-&gt;</span>val);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Add the value of the current node to the &#39;res&#39; vector. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Queue Pop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            q.pop();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Pop the processed node from the queue. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Left Child Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(tmp<span style="color:#666">-&gt;</span>left) q.push(tmp<span style="color:#666">-&gt;</span>left);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current node has a left child, push it onto the queue for the next level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>14 : Right Child Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(tmp<span style="color:#666">-&gt;</span>right) q.push(tmp<span style="color:#666">-&gt;</span>right);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the current node has a right child, push it onto the queue for the next level. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>15 : Push Level to Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ans.push_back(res);
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> After processing all nodes at the current level, add the &#39;res&#39; vector to the final result vector &#39;ans&#39;. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>16 : Return Result</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Return the final 2D vector &#39;ans&#39; which contains the level-order traversal of the tree. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n)</div>
                        <div class=""> <b>Average Case:</b> O(n)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> In all cases, we must visit each node in the tree once, so the time complexity is O(n), where n is the number of nodes in the tree.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(n)</div> 
                        <div class=""> <b>Description:</b> In the worst case, the queue may hold all the nodes at the last level of the tree, resulting in a space complexity of O(n). In the best case, when the tree is perfectly balanced, the space complexity could be reduced to O(log n).</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/climbing-stairs/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 31, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-70-climbing-stairs/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-100-same-tree/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-100-same-tree/">Leetcode 100: Same Tree</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode11s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/100.webp" 
           alt="Two trees glowing in harmony, showing perfect symmetry and balance." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 100: Same Tree Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given a sorted array of unique elements, rotated between 1 and n times, find the minimum element in this array. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input is a sorted array of unique integers which is rotated between 1 and n times.</div>
                        <div class=""> <b>Example:</b> nums = [6,7,9,10,2,3,4]</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= n &lt;= 5000</div>
                            
                                <div style="margin-left: 20px;"> • -5000 &lt;= nums[i] &lt;= 5000</div>
                            
                                <div style="margin-left: 20px;"> • All elements in the array are unique.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output should be the minimum element in the rotated sorted array.</div>
                        <div class=""> <b>Example:</b> 2</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The array will always be rotated between 1 and n times.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> To find the minimum element, use a binary search approach that reduces the search space in each step.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • Initialize two pointers: start and end of the array.</div>
                            
                                <div style="margin-left: 20px;"> • Find the middle element and compare it with the rightmost element.</div>
                            
                                <div style="margin-left: 20px;"> • If the middle element is greater than the rightmost element, the minimum must be in the right half, so move the start pointer to mid &#43; 1.</div>
                            
                                <div style="margin-left: 20px;"> • Otherwise, move the end pointer to mid.</div>
                            
                                <div style="margin-left: 20px;"> • Repeat this process until the start pointer equals the end pointer, which will be the minimum element.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The input array is sorted but rotated between 1 and n times.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1 &lt;= n &lt;= 5000</div>
                            
                                <div style="margin-left: 20px;"> • -5000 &lt;= nums[i] &lt;= 5000</div>
                            
                                <div style="margin-left: 20px;"> • All elements in the array are unique.</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The array is sorted and rotated.</div>
                            
                                <div style="margin-left: 20px;"> • The array has at least one element.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> nums = [6,7,9,10,2,3,4]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The array was originally [2,3,4,6,7,9,10] and was rotated 4 times. The minimum element is 2.</div>                                
                                <br/>
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> nums = [10,11,13,15,18,20,1]</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> The array was originally [1,10,11,13,15,18,20] and was rotated 6 times. The minimum element is 1.</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> We can use binary search to find the minimum element efficiently in O(log n) time.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • Since the array is sorted and rotated, the minimum element will always be the pivot point where the array shifts from higher to lower values.</div>
                            
                            
                                <div style="margin-left: 20px;"> • Binary search will be optimal to reduce the time complexity to O(log n).</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • Initialize two pointers, start and end, at the beginning and the end of the array.</div>
                            
                                <div style="margin-left: 20px;"> • While the start pointer is less than the end pointer, calculate the middle index.</div>
                            
                                <div style="margin-left: 20px;"> • If the middle element is greater than the end element, the minimum must be on the right side, so update start to mid &#43; 1.</div>
                            
                                <div style="margin-left: 20px;"> • Otherwise, update the end pointer to mid.</div>
                            
                                <div style="margin-left: 20px;"> • When the start pointer equals the end pointer, that will be the minimum element.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The array will always have at least one element.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution must efficiently handle arrays with up to 5000 elements.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • Negative values and large values within the constraints should be handled correctly.</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The array will always contain unique elements.</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Variable Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Edge Case Handling</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Loop Iteration</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Binary Search</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 Midpoint Calculation</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Binary Search Logic</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Binary Search Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Binary Search Logic</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Binary Search Update</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="13"> 13 Return Value</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">findMin</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> nums.size();
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> s <span style="color:#666">=</span> <span style="color:#666">0</span>, e <span style="color:#666">=</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(n <span style="color:#666">==</span> <span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> nums[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(s <span style="color:#666">&lt;</span> e) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> mid <span style="color:#666">=</span> s <span style="color:#666">+</span> (e <span style="color:#666">-</span> s) <span style="color:#666">/</span> <span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// if(mid - 1 &gt;= 0 &amp;&amp; nums[mid] &lt; nums[mid - 1]) return nums[mid];
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(nums[e] <span style="color:#666">&lt;</span> nums[mid]) {
</span></span><span style="display:flex;"><span>            s <span style="color:#666">=</span> mid <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span>{
</span></span><span style="display:flex;"><span>            e <span style="color:#666">=</span> mid;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;Hi&#34;</span> <span style="color:#666">&lt;&lt;</span> e;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> nums[e];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">findMin</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> nums) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Defines the function `findMin`, which takes a vector of integers and returns the minimum element in a rotated sorted array. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> nums.size();
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes `n` to the size of the `nums` vector to handle the array&#39;s length and ensure valid indexing. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> s <span style="color:#666">=</span> <span style="color:#666">0</span>, e <span style="color:#666">=</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes `s` (start) and `e` (end) to the first and last indices of the array, respectively, setting the bounds for the binary search. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Variable Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Initializes `ans` to store the result of the minimum element (though it isn&#39;t used in the final implementation here). </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Edge Case Handling</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(n <span style="color:#666">==</span> <span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> nums[<span style="color:#666">0</span>];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Handles the edge case where the array has only one element. If true, returns that single element as the minimum. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Loop Iteration</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"></code></pre></div>                                
                            </div>
                            <div class=""> This space is reserved for the beginning of the loop that will iterate until the search range is narrowed down to a single element. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Binary Search</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(s <span style="color:#666">&lt;</span> e) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Begins the while loop for binary search, which will continue until the search range (`s` to `e`) is reduced to a single element. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : Midpoint Calculation</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> mid <span style="color:#666">=</span> s <span style="color:#666">+</span> (e <span style="color:#666">-</span> s) <span style="color:#666">/</span> <span style="color:#666">2</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Calculates the midpoint `mid` between `s` and `e` to split the array into two halves during each iteration. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Binary Search Logic</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(nums[e] <span style="color:#666">&lt;</span> nums[mid]) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Compares the element at the rightmost index (`e`) with the middle element. If the element at `e` is smaller, the minimum must be in the right half of the array. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Binary Search Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            s <span style="color:#666">=</span> mid <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Adjusts the start index `s` to `mid &#43; 1` to narrow the search to the right half of the array. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Binary Search Logic</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span>{
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the element at `e` is not smaller than the middle element, the minimum must lie in the left half or could be the middle itself. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Binary Search Update</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            e <span style="color:#666">=</span> mid;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Adjusts the end index `e` to `mid` to narrow the search to the left half of the array. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>13 : Return Value</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> nums[e];
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Returns the element at index `e`, which is the minimum element in the rotated sorted array. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(log n)</div>
                        <div class=""> <b>Average Case:</b> O(log n)</div>
                        <div class=""> <b>Worst Case:</b> O(log n)</div> 
                        <div class=""> <b>Description:</b> Binary search will run in logarithmic time.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1)</div>
                        <div class=""> <b>Worst Case:</b> O(1)</div> 
                        <div class=""> <b>Description:</b> The solution only requires a constant amount of space.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/same-tree/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 28, 2024 - 5 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-100-same-tree/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


<div class="col-lg-4 col-md-6 mb-30px card-group">
    <div class="card h-100">
        <div class="maxthumb">
            <a href="http://localhost:1313/leetcode/solution-94-binary-tree-inorder-traversal/">
                
                                
            </a>
        </div>
        <div class="card-body">
            <h2 class="card-title"><a class="text-dark" href="http://localhost:1313/leetcode/solution-94-binary-tree-inorder-traversal/">Leetcode 94: Binary Tree Inorder Traversal</a></h2>
            <h4 class="card-text"><h2 id="hahahugoshortcode1400s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/94.webp" 
           alt="A glowing tree with nodes softly illuminating as the inorder traversal progresses." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.5em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 94: Binary Tree Inorder Traversal Problem
      </figcaption>
    
  </figure>
  </h2>










<div class=""> Given the head of a linked list, find the node where the cycle begins. If no cycle exists, return null. The list may contain a cycle, which occurs if a node can be revisited by following the &rsquo;next&rsquo; pointers continuously. </div>



<div class="problem-guide">

    
    <div class="problem-guide-tags">

        <div class="problem-guide-tag" 
             data-target="Problem" 
             onclick="switchProblemGuideContent(this, 'Problem')">
             Problem             
        </div>
        <div class="problem-guide-tag" 
             data-target="Approach" 
             onclick="switchProblemGuideContent(this, 'Approach')">
             Approach             
        </div>
        <div class="problem-guide-tag" 
             data-target="Steps" 
             onclick="switchProblemGuideContent(this, 'Steps')">
             Steps             
        </div>
        <div class="problem-guide-tag" 
             data-target="Complexity" 
             onclick="switchProblemGuideContent(this, 'Complexity')">
             Complexity             
        </div> 
    </div>

    
    <div class="problem-guide-content">

        <div id="Problem" 
            class="problem-guide-topic-content" 
            style="display: block;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="0">Input Representations</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="1">Output Specifications</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="2">Core Logics</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="3">Constraints</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="4">Problem Assumptions</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Problem" data-slide="5">Examples</button>                
                </div>

                <div class="steps-slides" id="stepsSlides-Problem">

                    <div class="step-slide">
                        <div class=""> <b>Input:</b> The input consists of a linked list and an index &#39;pos&#39; where the tail node connects. If &#39;pos&#39; is -1, there is no cycle.</div>
                        <div class=""> <b>Example:</b> Input: head = [5, 3, 9, 4], pos = 2</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The number of nodes in the list is between 0 and 10^4.</div>
                            
                                <div style="margin-left: 20px;"> • Node values range between -10^5 and 10^5.</div>
                            
                                <div style="margin-left: 20px;"> • &#39;pos&#39; is either -1 or a valid index within the list.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Output:</b> The output is the node where the cycle begins, or null if no cycle is detected.</div>
                        <div class=""> <b>Example:</b> Output: tail connects to node index 2</div>
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The output is the node where the cycle begins, or null if no cycle exists.</div>
                            
                        </div>
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The goal is to detect the node where the cycle begins in the linked list.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • 1. Use two pointers, &#39;slow&#39; and &#39;fast&#39;, which start at the head of the list.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Move the slow pointer one step and the fast pointer two steps at a time.</div>
                            
                                <div style="margin-left: 20px;"> • 3. If a cycle exists, slow and fast pointers will meet at some point.</div>
                            
                                <div style="margin-left: 20px;"> • 4. Once a cycle is detected, reset one pointer to the head and keep the other at the meeting point.</div>
                            
                                <div style="margin-left: 20px;"> • 5. Move both pointers one step at a time until they meet again. This is the start of the cycle.</div>
                            
                        </div>
                    </div>                      

                    <div class="step-slide">
                        <div class=""> <b>Goal:</b> The solution should efficiently detect the cycle and identify the starting node without modifying the linked list.</div>
                        <div class=""> <b>Steps:</b>
                            
                                <div style="margin-left: 20px;"> • The solution should run in linear time, O(n), and use constant space, O(1).</div>
                            
                        </div>
                    </div>        
                    
                    <div class="step-slide">
                        <div class=""> <b>Assumptions:</b>
                            
                                <div style="margin-left: 20px;"> • The linked list may contain a cycle or it may be acyclic.</div>
                            
                                <div style="margin-left: 20px;"> • Nodes may contain integer values.</div>
                            
                        </div>
                    </div>     
                    
                    <div class="step-slide">
                            
                                <div style="margin-left: 20px;"> • <b>Input:</b> Input: head = [5, 3, 9, 4], pos = 2</div>
                                <div style="margin-left: 20px;"> • <b>Explanation:</b> In this example, the linked list has a cycle where the tail connects to the 2nd node (index 2).</div>                                
                                <br/>
                            
                    </div>                         
                    
                </div>
            </div>
        </div> 

        <div id="Approach" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="0">Approach</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="1">Initial Thoughts</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="2">Solution Designs</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Approach" data-slide="3">Edge Cases</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Approach">
                    
                    <div class="step-slide">
                        <div class=""> <b>Approach:</b> The solution uses Floyd&#39;s Cycle-Finding Algorithm (Tortoise and Hare) to detect the cycle and then find the starting node of the cycle.</div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Observations:</b>                        
                            
                                <div style="margin-left: 20px;"> • The problem can be solved by detecting the cycle first and then finding the cycle&#39;s start node.</div>
                            
                            
                                <div style="margin-left: 20px;"> • By using two pointers, one moving faster than the other, we can detect the cycle in O(n) time. Once the cycle is detected, finding the start node requires another O(n) pass.</div>
                            
                        </div>
                    </div>
                    
                    <div class="step-slide">
                        <div class=""> <b>Steps:</b>                        
                            
                                <div style="margin-left: 20px;"> • 1. Initialize two pointers, slow and fast, both pointing to the head of the list.</div>
                            
                                <div style="margin-left: 20px;"> • 2. Move the slow pointer one step and the fast pointer two steps at a time.</div>
                            
                                <div style="margin-left: 20px;"> • 3. If the fast pointer reaches the end (nullptr), return null (no cycle).</div>
                            
                                <div style="margin-left: 20px;"> • 4. If slow and fast pointers meet, a cycle exists.</div>
                            
                                <div style="margin-left: 20px;"> • 5. Reset one pointer to the head and keep the other at the meeting point. Move both pointers one step at a time until they meet again, which is the start of the cycle.</div>
                            
                        </div>
                    </div>


                    <div class="step-slide">
                        <div class=""> <b>Empty Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • An empty linked list should return null since there is no cycle.</div>
                            
                        </div>
                        <div class=""> <b>Large Inputs:</b>                        
                            
                                <div style="margin-left: 20px;"> • The algorithm should efficiently handle large lists with up to 10^4 nodes.</div>
                            
                        </div>
                        <div class=""> <b>Special Values:</b>                        
                            
                                <div style="margin-left: 20px;"> • When the cycle begins at the very first node or is self-referential (the last node points to itself).</div>
                            
                        </div>       
                        <div class=""> <b>Constraints:</b>                        
                            
                                <div style="margin-left: 20px;"> • The solution should run in linear time (O(n)) and use constant space (O(1)).</div>
                            
                        </div>                                                                        
                    </div>
                                        
                </div>
            </div>
        </div> 

        <div id="Steps" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="0"> Code </button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="1"> 1 Function Definition</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="2"> 2 Base Case Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="3"> 3 Pointer Initialization</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="4"> 4 Cycle Detection Loop</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="5"> 5 Move Slow Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="6"> 6 Move Fast Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="7"> 7 Cycle Detection Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="8"> 8 No Cycle Check</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="9"> 9 Second Loop for Cycle Start</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="10"> 10 Move Head Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="11"> 11 Move Slow Pointer</button>
                    
                        <button class="step-problem-guide-tag" id="step-problem-guide-tag-Steps" data-slide="12"> 12 Return Cycle Start Node</button>
                    
                </div>

                <div class="steps-slides" id="stepsSlides-Steps">

                    <div class="step-slide">
                        <div class=""> 
                            
                            <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ListNode <span style="color:#666">*</span><span style="color:#00a000">detectCycle</span>(ListNode <span style="color:#666">*</span>head) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(head <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    ListNode <span style="color:#666">*</span>fast <span style="color:#666">=</span> head, <span style="color:#666">*</span>slow<span style="color:#666">=</span> head;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(fast <span style="color:#666">&amp;&amp;</span> fast<span style="color:#666">-&gt;</span>next) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        slow <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        fast <span style="color:#666">=</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(fast <span style="color:#666">==</span> slow) <span style="color:#a2f;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>(fast <span style="color:#666">&amp;&amp;</span> fast<span style="color:#666">-&gt;</span>next)) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> (head <span style="color:#666">!=</span> slow) {
</span></span><span style="display:flex;"><span>        head <span style="color:#666">=</span> head<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        slow <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> slow;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div>
                        </div>
                    </div>

                    
                        <div class="step-slide">
                            <div class=""> <b>1 : Function Definition</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>ListNode <span style="color:#666">*</span><span style="color:#00a000">detectCycle</span>(ListNode <span style="color:#666">*</span>head) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This defines the `detectCycle` function that takes a pointer `head` to the start of the linked list and returns a pointer to the node where the cycle begins, or `NULL` if no cycle exists. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>2 : Base Case Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(head <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the list is empty (i.e., `head` is `NULL`), the function immediately returns `NULL`, as there can be no cycle in an empty list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>3 : Pointer Initialization</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    ListNode <span style="color:#666">*</span>fast <span style="color:#666">=</span> head, <span style="color:#666">*</span>slow<span style="color:#666">=</span> head;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Two pointers, `fast` and `slow`, are initialized to the head of the linked list. `fast` moves two steps at a time and `slow` moves one step at a time. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>4 : Cycle Detection Loop</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(fast <span style="color:#666">&amp;&amp;</span> fast<span style="color:#666">-&gt;</span>next) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This loop continues as long as `fast` and `fast-&gt;next` are valid, ensuring we do not run into null references while traversing the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>5 : Move Slow Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        slow <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The `slow` pointer moves one step forward in the linked list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>6 : Move Fast Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        fast <span style="color:#666">=</span> fast<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> The `fast` pointer moves two steps forward in the list. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>7 : Cycle Detection Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(fast <span style="color:#666">==</span> slow) <span style="color:#a2f;font-weight:bold">break</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the `fast` and `slow` pointers meet at the same node, a cycle is detected, and the loop breaks. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>8 : No Cycle Check</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>(fast <span style="color:#666">&amp;&amp;</span> fast<span style="color:#666">-&gt;</span>next)) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> If the `fast` pointer reaches the end of the list (`fast` or `fast-&gt;next` is `NULL`), no cycle exists, and the function returns `NULL`. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>9 : Second Loop for Cycle Start</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> (head <span style="color:#666">!=</span> slow) {
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> This loop moves both `head` and `slow` pointers one step at a time to find the node where the cycle begins. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>10 : Move Head Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        head <span style="color:#666">=</span> head<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `head` pointer one step forward. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>11 : Move Slow Pointer</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        slow <span style="color:#666">=</span> slow<span style="color:#666">-&gt;</span>next;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> Moves the `slow` pointer one step forward. </div>
                        </div>
                    
                        <div class="step-slide">
                            <div class=""> <b>12 : Return Cycle Start Node</b></div>
                            <div class="">
                                
                                <div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> slow;
</span></span></code></pre></div>                                
                            </div>
                            <div class=""> At this point, both the `head` and `slow` pointers are at the node where the cycle starts, and this node is returned. </div>
                        </div>
                    
                </div>
            </div>
        </div> 
        
        <div id="Complexity" 
            class="problem-guide-topic-content" 
            style="display: none;">

            <div class="steps-container">
                <div class="step-problem-guide-tags" id="stepButtons">
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="0">Time Complexities</button>
                    <button class="step-problem-guide-tag" id="step-problem-guide-tag-Complexity" data-slide="1">Space Complexities</button>
                </div>

                <div class="steps-slides" id="stepsSlides-Complexity">

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(n), when the cycle is detected after moving through most of the list.</div>
                        <div class=""> <b>Average Case:</b> O(n), the slow and fast pointers will meet at some point if a cycle exists.</div>
                        <div class=""> <b>Worst Case:</b> O(n), in the worst case, the fast pointer will traverse the entire list.</div> 
                        <div class=""> <b>Description:</b> The time complexity is O(n) because each pointer moves at most n steps.</div>                                               
                    </div>

                    <div class="step-slide">
                        <div class=""> <b>Best Case:</b> O(1), since no extra space is used.</div>
                        <div class=""> <b>Worst Case:</b> O(1), as the solution only uses two pointers.</div> 
                        <div class=""> <b>Description:</b> The space complexity is O(1), as only two pointers are used for cycle detection.</div>    
                    </div>

                </div>
            </div>
        </div>        

    </div> 

    <script>
        function switchProblemGuideContent(element, id) {
            document.querySelectorAll('.problem-guide-tag').forEach(tag => {
                tag.classList.remove('problem-guide-tag-active');
            });

            element.classList.add('problem-guide-tag-active');

            document.querySelectorAll('.problem-guide-topic-content').forEach(content => {
                content.style.display = 'none';
            });

            const activeContent = document.getElementById(id);
            activeContent.style.display = 'block';
            buttons_x(id)
        }

        function buttons_x(id) {

            const slides = document.getElementById('stepsSlides-'+ id );
            const buttons = document.querySelectorAll('#step-problem-guide-tag-' + id );
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
                console.log(buttons[index].id)
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

        }        

        function buttons() {
            const slides = document.getElementById('stepsSlides-Problem');
            const buttons = document.querySelectorAll('#step-problem-guide-tag-Problem');
            let currentIndex = 0;
            let startX = 0;
            let isDragging = false;

            function updateSlides(index) {
                slides.style.transform = `translateX(-${index * 100}%)`;
                buttons.forEach(button => button.classList.remove('problem-guide-tag-active'));
                buttons[index].classList.add('problem-guide-tag-active');
            }

            buttons.forEach((button, index) => {
                button.addEventListener('click', () => {
                    currentIndex = index;
                    updateSlides(currentIndex);
                });
            });

            slides.addEventListener('touchstart', (e) => {
                startX = e.touches[0].clientX;
                isDragging = true;
            });

            slides.addEventListener('touchmove', (e) => {
                if (!isDragging) return;
                const moveX = e.touches[0].clientX - startX;
                slides.style.transform = `translateX(calc(-${currentIndex * 100}% + ${moveX}px))`;
            });

            slides.addEventListener('touchend', (e) => {
                isDragging = false;
                const endX = e.changedTouches[0].clientX;
                if (endX < startX - 50 && currentIndex < buttons.length - 1) {
                    currentIndex++;
                } else if (endX > startX + 50 && currentIndex > 0) {
                    currentIndex--;
                }
                updateSlides(currentIndex);
            });

            updateSlides(currentIndex);

            const initialTag = document.querySelector(`.problem-guide-tag[data-target="Problem"]`);
            if (initialTag) {
                initialTag.classList.add('problem-guide-tag-active');
            }

            const contentElements = document.querySelectorAll('.problem-guide-content');
            let maxHeight = 0;
            contentElements.forEach(element => {
                const height = parseFloat(getComputedStyle(element).height);
                if (height > maxHeight) {
                    maxHeight = height;
                }
            });

            document.querySelector('.problem-guide-content').style.height = maxHeight + 'px';

        }

        document.addEventListener('DOMContentLoaded', buttons);
    </script>
</div>

<p><a href="https://leetcode.com/problems/binary-tree-inorder-traversal/description/"><code>Link to LeetCode Lab</code></a></p></h4>            
        </div>
        <div class="card-footer bg-white">
            <div class="wrapfooter">
                
                
                
                <span class="post-date">Oct 28, 2024 - 6 min read </span>
                <span class="post-read-more"><a href="http://localhost:1313/leetcode/solution-94-binary-tree-inorder-traversal/" title="Read Story"><svg class="svgIcon-use" width="25" height="25" viewbox="0 0 25 25"><path d="M19 6c0-1.1-.9-2-2-2H8c-1.1 0-2 .9-2 2v14.66h.012c.01.103.045.204.12.285a.5.5 0 0 0 .706.03L12.5 16.85l5.662 4.126a.508.508 0 0 0 .708-.03.5.5 0 0 0 .118-.285H19V6zm-6.838 9.97L7 19.636V6c0-.55.45-1 1-1h9c.55 0 1 .45 1 1v13.637l-5.162-3.668a.49.49 0 0 0-.676 0z" fill-rule="evenodd"></path></svg></a></span>
                <div class="clearfix"></div>
            </div>
        </div>
    </div>
</div>


            </div>
        </section>
<div class="bottompagination">
  <div class="pointerup"><i class="fa fa-caret-up"></i></div>
  <div class="navigation" role="navigation">
    
      <div class="pagination">
        
          <a class="ml-1 mr-1" href="/categories/easy/">&laquo; Prev</a>
          <a class="ml-1 mr-1" href="/categories/easy/">1</a>
        

        <span class="ml-1 mr-1">2</span>

        
          <a class="ml-1 mr-1" href="/categories/easy/page/3/">3</a>
          <a class="ml-1 mr-1" href="/categories/easy/page/3/">Next &raquo;</a>
        
      </div>
    
  </div>
</div></div>


            </div>
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
			<div class="d-md-flex align-items-center justify-content-center h-100">
				<h2 class="d-md-block d-none align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
			</div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
			
			<a class="mt-1 mb-1" href="/tags/array">array</a>
			
			<a class="mt-1 mb-1" href="/tags/backtracking">backtracking</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-indexed-tree">binary indexed tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search">binary search</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search-tree">binary search tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-tree">binary tree</a>
			
			<a class="mt-1 mb-1" href="/tags/bit-manipulation">bit manipulation</a>
			
			<a class="mt-1 mb-1" href="/tags/bitmask">bitmask</a>
			
			<a class="mt-1 mb-1" href="/tags/brainteaser">brainteaser</a>
			
			<a class="mt-1 mb-1" href="/tags/breadth-first-search">breadth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/bucket-sort">bucket sort</a>
			
			<a class="mt-1 mb-1" href="/tags/combinatorics">combinatorics</a>
			
			<a class="mt-1 mb-1" href="/tags/concurrency">concurrency</a>
			
			<a class="mt-1 mb-1" href="/tags/counting">counting</a>
			
			<a class="mt-1 mb-1" href="/tags/counting-sort">counting sort</a>
			
			<a class="mt-1 mb-1" href="/tags/data-stream">data stream</a>
			
			<a class="mt-1 mb-1" href="/tags/depth-first-search">depth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/design">design</a>
			
			<a class="mt-1 mb-1" href="/tags/divide-and-conquer">divide and conquer</a>
			
			<a class="mt-1 mb-1" href="/tags/doubly-linked-list">doubly-linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/dynamic-programming">dynamic programming</a>
			
			<a class="mt-1 mb-1" href="/tags/enumeration">enumeration</a>
			
			<a class="mt-1 mb-1" href="/tags/game-theory">game theory</a>
			
			<a class="mt-1 mb-1" href="/tags/geometry">geometry</a>
			
			<a class="mt-1 mb-1" href="/tags/graph">graph</a>
			
			<a class="mt-1 mb-1" href="/tags/greedy">greedy</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-function">hash function</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-table">hash table</a>
			
			<a class="mt-1 mb-1" href="/tags/heap-priority-queue">heap (priority queue)</a>
			
			<a class="mt-1 mb-1" href="/tags/interactive">interactive</a>
			
			<a class="mt-1 mb-1" href="/tags/iterator">iterator</a>
			
			<a class="mt-1 mb-1" href="/tags/linked-list">linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/math">math</a>
			
			<a class="mt-1 mb-1" href="/tags/matrix">matrix</a>
			
			<a class="mt-1 mb-1" href="/tags/memoization">memoization</a>
			
			<a class="mt-1 mb-1" href="/tags/minimum-spanning-tree">minimum spanning tree</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-queue">monotonic queue</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-stack">monotonic stack</a>
			
			<a class="mt-1 mb-1" href="/tags/number-theory">number theory</a>
			
			<a class="mt-1 mb-1" href="/tags/ordered-set">ordered set</a>
			
			<a class="mt-1 mb-1" href="/tags/prefix-sum">prefix sum</a>
			
			<a class="mt-1 mb-1" href="/tags/probability-and-statistics">probability and statistics</a>
			
			<a class="mt-1 mb-1" href="/tags/queue">queue</a>
			
			<a class="mt-1 mb-1" href="/tags/quickselect">quickselect</a>
			
			<a class="mt-1 mb-1" href="/tags/radix-sort">radix sort</a>
			
			<a class="mt-1 mb-1" href="/tags/randomized">randomized</a>
			
			<a class="mt-1 mb-1" href="/tags/recursion">recursion</a>
			
			<a class="mt-1 mb-1" href="/tags/reservoir-sampling">reservoir sampling</a>
			
			<a class="mt-1 mb-1" href="/tags/rolling-hash">rolling hash</a>
			
			<a class="mt-1 mb-1" href="/tags/segment-tree">segment tree</a>
			
			<a class="mt-1 mb-1" href="/tags/shortest-path">shortest path</a>
			
			<a class="mt-1 mb-1" href="/tags/simulation">simulation</a>
			
			<a class="mt-1 mb-1" href="/tags/sliding-window">sliding window</a>
			
			<a class="mt-1 mb-1" href="/tags/sorting">sorting</a>
			
			<a class="mt-1 mb-1" href="/tags/stack">stack</a>
			
			<a class="mt-1 mb-1" href="/tags/string">string</a>
			
			<a class="mt-1 mb-1" href="/tags/string-matching">string matching</a>
			
			<a class="mt-1 mb-1" href="/tags/topological-sort">topological sort</a>
			
			<a class="mt-1 mb-1" href="/tags/tree">tree</a>
			
			<a class="mt-1 mb-1" href="/tags/trie">trie</a>
			
			<a class="mt-1 mb-1" href="/tags/two-pointers">two pointers</a>
			
			<a class="mt-1 mb-1" href="/tags/union-find">union find</a>
			
		</div>
	</div>
</div>

<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

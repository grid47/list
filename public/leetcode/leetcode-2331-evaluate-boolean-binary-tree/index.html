<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2331: Evaluate Boolean Binary Tree | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2331: Evaluate Boolean Binary Tree">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2331: Evaluate Boolean Binary Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2331-evaluate-boolean-binary-tree/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2331: Evaluate Boolean Binary Tree">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2331: Evaluate Boolean Binary Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-03-18T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2331: Evaluate Boolean Binary Tree</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode690s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> evaluateTree(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>left <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>right) <span style="color:#a2f;font-weight:bold">return</span> root<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> <span style="color:#666">2</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> evaluateTree(root<span style="color:#666">-&gt;</span>left) <span style="color:#666">||</span> evaluateTree(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>      <span style="color:#a2f;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">evaluateTree</span>(root<span style="color:#666">-&gt;</span>left) <span style="color:#666">&amp;&amp;</span> evaluateTree(root<span style="color:#666">-&gt;</span>right);        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The task is to evaluate a binary tree that represents a logical expression. Each node of the tree can either be a leaf node or an internal node. The leaf nodes have values of either <code>0</code> or <code>1</code>, representing logical <code>false</code> and <code>true</code>, respectively. The internal nodes represent logical operators:</p>
<ul>
<li>A node with a value of <code>2</code> represents the logical OR operation (<code>||</code>).</li>
<li>A node with a value of <code>3</code> represents the logical AND operation (<code>&amp;&amp;</code>).</li>
</ul>
<p>Given a binary tree with these properties, the goal is to evaluate the tree and return the final result (<code>true</code> or <code>false</code>) based on the logical expressions formed by traversing the tree.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we can perform a <strong>recursive traversal</strong> of the tree. The traversal will evaluate the logical expression represented by the binary tree. We need to process each node according to its value:</p>
<ol>
<li>
<p><strong>Leaf Nodes</strong>: If a node is a leaf (it has no left or right child), its value directly determines the result. If the value is <code>1</code>, it means <code>true</code>, and if it is <code>0</code>, it means <code>false</code>.</p>
</li>
<li>
<p><strong>Internal Nodes (OR and AND operations)</strong>: For internal nodes, the value determines the type of logical operation:</p>
<ul>
<li>If the node’s value is <code>2</code>, it represents an OR operation (<code>||</code>). The result is <code>true</code> if either the left or the right child evaluates to <code>true</code>.</li>
<li>If the node’s value is <code>3</code>, it represents an AND operation (<code>&amp;&amp;</code>). The result is <code>true</code> only if both the left and right children evaluate to <code>true</code>.</li>
</ul>
</li>
</ol>
<p>The algorithm recursively computes the result of the subtrees, applying the corresponding logical operation at each internal node, and finally returns the result at the root.</p>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="step-1-function-definition">Step 1: Function Definition</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> evaluateTree(TreeNode<span style="color:#666">*</span> root) {
</span></span></code></pre></div><ul>
<li>The <code>evaluateTree</code> function takes the root of a binary tree as input. The result is a boolean value indicating whether the logical expression represented by the tree evaluates to <code>true</code> or <code>false</code>.</li>
</ul>
<h4 id="step-2-base-case-null-node">Step 2: Base Case: Null Node</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span></code></pre></div><ul>
<li>The first check handles the base case where the tree node is null. This could be a safeguard, though in a well-formed binary tree, the root node should never be null when the tree is given as input. If we encounter a null node, we return <code>false</code> as an indicator of an invalid or non-existent node.</li>
</ul>
<h4 id="step-3-leaf-node-check">Step 3: Leaf Node Check</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>left <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>right) <span style="color:#a2f;font-weight:bold">return</span> root<span style="color:#666">-&gt;</span>val;
</span></span></code></pre></div><ul>
<li>The next step checks if the current node is a leaf node, which means it has no left or right child. A leaf node’s value will either be <code>0</code> or <code>1</code>, representing logical <code>false</code> or <code>true</code>, respectively. Therefore, we return the value of the node as the result.</li>
</ul>
<h4 id="step-4-internal-node-handling-or-and-and-operations">Step 4: Internal Node Handling (OR and AND operations)</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> <span style="color:#666">2</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> evaluateTree(root<span style="color:#666">-&gt;</span>left) <span style="color:#666">||</span> evaluateTree(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>      <span style="color:#a2f;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">evaluateTree</span>(root<span style="color:#666">-&gt;</span>left) <span style="color:#666">&amp;&amp;</span> evaluateTree(root<span style="color:#666">-&gt;</span>right);
</span></span></code></pre></div><ul>
<li>For internal nodes:
<ul>
<li>If the node&rsquo;s value is <code>2</code>, it represents the logical OR (<code>||</code>) operation. We recursively evaluate both the left and right subtrees and return <code>true</code> if either subtree evaluates to <code>true</code>.</li>
<li>If the node’s value is <code>3</code>, it represents the logical AND (<code>&amp;&amp;</code>) operation. We recursively evaluate both the left and right subtrees and return <code>true</code> only if both subtrees evaluate to <code>true</code>.</li>
</ul>
</li>
</ul>
<p>The <code>evaluateTree</code> function is called recursively on the left and right subtrees, and the logical operation is applied based on the current node&rsquo;s value.</p>
<h4 id="step-5-final-return-value">Step 5: Final Return Value</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>Once the recursive calls finish, the function returns the final boolean result for the logical expression rooted at the given node. The recursive calls propagate back up to the root, and the final result is returned to the caller.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<p>The time complexity of the algorithm is <strong>O(N)</strong>, where <code>N</code> is the number of nodes in the binary tree. This is because we visit each node exactly once during the recursive traversal. Each recursive call processes a node and its children, and since there are <code>N</code> nodes, the total time complexity is linear in terms of the number of nodes.</p>
<h4 id="space-complexity">Space Complexity:</h4>
<p>The space complexity is <strong>O(H)</strong>, where <code>H</code> is the height of the binary tree. This is the space required for the recursion stack. In the worst case, the height of the tree is <code>N</code> (if the tree is skewed), and the space complexity would be <code>O(N)</code>. However, for a balanced tree, the height would be <code>log(N)</code>, resulting in a space complexity of <code>O(log(N))</code>.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This solution uses a simple recursive approach to evaluate the logical expression represented by a binary tree. Each node in the tree represents either a logical value (<code>0</code> or <code>1</code>) or a logical operation (<code>OR</code> or <code>AND</code>). The recursive traversal computes the result by evaluating subtrees and applying the appropriate logical operations at each internal node.</p>
<ul>
<li><strong>Time Complexity</strong>: The algorithm runs in linear time, i.e., <strong>O(N)</strong>, where <code>N</code> is the number of nodes in the tree.</li>
<li><strong>Space Complexity</strong>: The space complexity is proportional to the height of the tree, i.e., <strong>O(H)</strong>, where <code>H</code> is the height of the tree.</li>
</ul>
<p>This approach is efficient and easy to implement, making it a suitable solution for evaluating logical expressions represented by binary trees.</p>
<p><a href="https://leetcode.com/problems/evaluate-boolean-binary-tree/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/9a_cP54jn8Q?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

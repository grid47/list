<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 1171: Remove Zero Sum Consecutive Nodes from Linked List | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1171: Remove Zero Sum Consecutive Nodes from Linked List">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1171: Remove Zero Sum Consecutive Nodes from Linked List in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-1171-remove-zero-sum-consecutive-nodes-from-linked-list/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1171: Remove Zero Sum Consecutive Nodes from Linked List">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1171: Remove Zero Sum Consecutive Nodes from Linked List in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-07-12T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="Linked List">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 1171: Remove Zero Sum Consecutive Nodes from Linked List</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode94s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for singly-linked list.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct ListNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     ListNode *next;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     ListNode() : val(0), next(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     ListNode(int x) : val(x), next(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> removeZeroSumSublists(ListNode<span style="color:#666">*</span> head) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> dummy <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> ListNode(<span style="color:#666">0</span>), <span style="color:#666">*</span>cur <span style="color:#666">=</span> dummy;
</span></span><span style="display:flex;"><span>        dummy<span style="color:#666">-&gt;</span>next<span style="color:#666">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> prefix <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, ListNode<span style="color:#666">*&gt;</span> mp;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(cur) {
</span></span><span style="display:flex;"><span>            prefix <span style="color:#666">+=</span> cur<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(mp.count(prefix)) {
</span></span><span style="display:flex;"><span>                cur <span style="color:#666">=</span> mp[prefix]<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                <span style="color:#0b0;font-weight:bold">int</span> p <span style="color:#666">=</span> prefix <span style="color:#666">+</span> cur<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">while</span>(p <span style="color:#666">!=</span> prefix) {
</span></span><span style="display:flex;"><span>                    mp.erase(p);
</span></span><span style="display:flex;"><span>                    cur <span style="color:#666">=</span> cur<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                    p <span style="color:#666">+=</span> cur<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                mp[prefix]<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> cur<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            } <span style="color:#a2f;font-weight:bold">else</span> mp[prefix]  <span style="color:#666">=</span> cur;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cur <span style="color:#666">=</span> cur<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> dummy<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The task is to remove consecutive nodes in a singly-linked list that sum up to zero. Given a linked list represented by its head node, we need to modify the list such that any contiguous sequence of nodes that sums to zero is removed. The modified list should preserve the order of remaining nodes.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we can use a hashmap (or an unordered map) to keep track of the cumulative sums (prefix sums) encountered while traversing the linked list. The main steps of the approach are:</p>
<ol>
<li><strong>Cumulative Sum Calculation</strong>: As we traverse the linked list, we calculate the cumulative sum of the nodes.</li>
<li><strong>Map to Track Prefix Sums</strong>: Store each prefix sum along with the corresponding node in a map. If we encounter the same prefix sum again, it indicates that the sum of the nodes between these two nodes equals zero.</li>
<li><strong>Removing Zero-Sum Sublists</strong>: When we find a duplicate prefix sum, we remove all nodes between the previous occurrence of that prefix sum and the current node.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>Let’s break down the implementation step by step:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for singly-linked list.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct ListNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     ListNode *next;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     ListNode() : val(0), next(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     ListNode(int x) : val(x), next(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     ListNode(int x, ListNode *next) : val(x), next(next) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> removeZeroSumSublists(ListNode<span style="color:#666">*</span> head) {
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> dummy <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> ListNode(<span style="color:#666">0</span>), <span style="color:#666">*</span>cur <span style="color:#666">=</span> dummy;
</span></span><span style="display:flex;"><span>        dummy<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> head;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> prefix <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, ListNode<span style="color:#666">*&gt;</span> mp;
</span></span></code></pre></div><ul>
<li><strong>Lines 1-9</strong>: The <code>ListNode</code> struct defines a node in a singly linked list. The <code>Solution</code> class contains the method <code>removeZeroSumSublists</code>, which takes the head of the linked list as input.</li>
<li>A dummy node is created to simplify operations on the linked list, especially for cases where the head node might be part of a zero-sum sequence. The current pointer (<code>cur</code>) starts at the dummy node.</li>
<li>The variable <code>prefix</code> is initialized to store cumulative sums as we traverse the list. The map <code>mp</code> is used to track the prefix sums and their corresponding nodes.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(cur) {
</span></span><span style="display:flex;"><span>            prefix <span style="color:#666">+=</span> cur<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(mp.count(prefix)) {
</span></span><span style="display:flex;"><span>                cur <span style="color:#666">=</span> mp[prefix]<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                <span style="color:#0b0;font-weight:bold">int</span> p <span style="color:#666">=</span> prefix <span style="color:#666">+</span> cur<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">while</span>(p <span style="color:#666">!=</span> prefix) {
</span></span><span style="display:flex;"><span>                    mp.erase(p);
</span></span><span style="display:flex;"><span>                    cur <span style="color:#666">=</span> cur<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>                    p <span style="color:#666">+=</span> cur<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                mp[prefix]<span style="color:#666">-&gt;</span>next <span style="color:#666">=</span> cur<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            } <span style="color:#a2f;font-weight:bold">else</span> mp[prefix]  <span style="color:#666">=</span> cur;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            cur <span style="color:#666">=</span> cur<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><ul>
<li><strong>Lines 11-29</strong>: This <code>while</code> loop continues as long as the current node (<code>cur</code>) is not null.</li>
<li>The cumulative sum <code>prefix</code> is updated by adding the value of the current node (<code>cur-&gt;val</code>).</li>
<li>If the prefix sum already exists in the map (<code>mp</code>), it means there is a zero-sum sublist. The next steps involve:
<ul>
<li><strong>Moving Current Pointer</strong>: Set <code>cur</code> to the next node of the node corresponding to the last occurrence of this prefix sum.</li>
<li><strong>Erasing Intermediate Prefix Sums</strong>: A new sum <code>p</code> is calculated by adding the value of the node at the new <code>cur</code>. We then enter a loop that continues until <code>p</code> equals the current <code>prefix</code>, erasing entries in the map for each prefix sum encountered during this process.</li>
<li>After removing the zero-sum nodes, the next pointer of the node where the duplicate prefix sum was found is updated to skip over the removed nodes.</li>
</ul>
</li>
<li>If the prefix sum is not in the map, we simply add the current prefix sum and its corresponding node to the map.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> dummy<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li><strong>Line 31</strong>: Finally, the method returns the modified linked list, starting from the node following the dummy node, effectively skipping any zero-sum sublists.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<ol>
<li><strong>Time Complexity</strong>: (O(n)), where (n) is the number of nodes in the linked list. Each node is processed once, and operations with the map (insertions and deletions) are average (O(1)).</li>
<li><strong>Space Complexity</strong>: (O(n)) in the worst case, where every prefix sum is unique and stored in the map.</li>
</ol>
<h3 id="conclusion">Conclusion</h3>
<p>The <code>removeZeroSumSublists</code> function efficiently identifies and removes zero-sum sublists from a singly-linked list using prefix sums and a hashmap. This method is optimal for the problem, leveraging the properties of cumulative sums to streamline the process. The result is a modified linked list that maintains the order of nodes while excluding any contiguous nodes that sum to zero, making it a practical solution for similar linked list manipulation problems.</p>
<p><a href="https://leetcode.com/problems/remove-zero-sum-consecutive-nodes-from-linked-list/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/xZRozZEjizg?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

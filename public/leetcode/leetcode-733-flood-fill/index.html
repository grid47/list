<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 733: Flood Fill | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 733: Flood Fill">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 733: Flood Fill in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-733-flood-fill/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 733: Flood Fill">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 733: Flood Fill in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-08-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Matrix">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 733: Flood Fill</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1279s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/733.webp" 
           alt="A grid where the flood fill algorithm is applied, with the flooded area glowing softly as it spreads." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 733: Flood Fill Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1279s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> floodFill(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> image, <span style="color:#0b0;font-weight:bold">int</span> sr, <span style="color:#0b0;font-weight:bold">int</span> sc, <span style="color:#0b0;font-weight:bold">int</span> color) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(color <span style="color:#666">==</span> image[sr][sc]) <span style="color:#a2f;font-weight:bold">return</span> image;
</span></span><span style="display:flex;"><span>        dfs(image, sr, sc, color, image[sr][sc]);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> image;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> <span style="color:#666">&amp;</span> img, <span style="color:#0b0;font-weight:bold">int</span> r, <span style="color:#0b0;font-weight:bold">int</span> c, <span style="color:#0b0;font-weight:bold">int</span> color, <span style="color:#0b0;font-weight:bold">int</span> node) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> img.size(), n <span style="color:#666">=</span> img[<span style="color:#666">0</span>].size();
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (r <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> c <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> r <span style="color:#666">==</span> m <span style="color:#666">||</span> c <span style="color:#666">==</span> n <span style="color:#666">||</span> img[r][c] <span style="color:#666">!=</span> node)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        img[r][c] <span style="color:#666">=</span> color;
</span></span><span style="display:flex;"><span>        dfs(img, r <span style="color:#666">+</span> <span style="color:#666">1</span>, c, color, node);
</span></span><span style="display:flex;"><span>        dfs(img, r, c <span style="color:#666">+</span> <span style="color:#666">1</span>, color, node);
</span></span><span style="display:flex;"><span>        dfs(img, r <span style="color:#666">-</span> <span style="color:#666">1</span>, c, color, node);
</span></span><span style="display:flex;"><span>        dfs(img, r, c <span style="color:#666">-</span> <span style="color:#666">1</span>, color, node);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem is based on the classic <strong>Flood Fill</strong> algorithm, commonly used in image processing and computer graphics. The task is to perform a flood fill starting from a given pixel in a 2D grid (image) and fill all connected pixels that have the same initial color with a new color. The flood fill should be performed in four directions: up, down, left, and right. The goal is to return the image after performing the flood fill operation.</p>
<h3 id="approach">Approach</h3>
<p>The flood fill operation can be achieved using either a <strong>Breadth-First Search (BFS)</strong> or a <strong>Depth-First Search (DFS)</strong> algorithm. In this case, the DFS approach is used to explore the connected components starting from the given pixel and recursively fill all connected pixels that share the same initial color.</p>
<h4 id="steps-involved">Steps Involved:</h4>
<ol>
<li>
<p><strong>Check for the base condition:</strong>
If the color to fill is the same as the color of the starting pixel, then there&rsquo;s no need to modify the image, and we can return the image as is.</p>
</li>
<li>
<p><strong>Depth-First Search (DFS):</strong>
Start from the given pixel and explore all its neighbors. If the neighboring pixel has the same initial color, change its color to the new color and recursively explore its neighbors. This continues until all connected pixels are filled.</p>
</li>
<li>
<p><strong>Direction of exploration:</strong>
The flood fill explores the four possible directions (up, down, left, and right) from any pixel. If a neighbor is within the bounds of the image and has the same color as the starting pixel, it is recursively filled.</p>
</li>
<li>
<p><strong>Boundary checks:</strong>
Ensure that the current pixel is within the valid boundaries of the image (i.e., it should not go out of bounds).</p>
</li>
</ol>
<p>By following this approach, we efficiently fill the connected regions in the image, and the solution has a linear time complexity proportional to the size of the image.</p>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="1-the-floodfill-function">1. <strong>The <code>floodFill</code> Function</strong></h4>
<ul>
<li>This is the main function that initiates the flood fill process.</li>
<li>It takes the image (a 2D vector), the starting row (<code>sr</code>), starting column (<code>sc</code>), and the new color to fill (<code>color</code>).</li>
<li>Before starting the DFS, the function checks whether the new color is the same as the current color of the starting pixel (<code>image[sr][sc]</code>). If they are the same, the image is returned as is because no change is needed.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> floodFill(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> image, <span style="color:#0b0;font-weight:bold">int</span> sr, <span style="color:#0b0;font-weight:bold">int</span> sc, <span style="color:#0b0;font-weight:bold">int</span> color) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(color <span style="color:#666">==</span> image[sr][sc]) <span style="color:#a2f;font-weight:bold">return</span> image;  <span style="color:#080;font-style:italic">// Base case: If the target color is the same as the current color, return the image
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    dfs(image, sr, sc, color, image[sr][sc]);  <span style="color:#080;font-style:italic">// Call DFS to perform the flood fill
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#a2f;font-weight:bold">return</span> image;  <span style="color:#080;font-style:italic">// Return the updated image
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><ul>
<li>If the initial pixel&rsquo;s color is different from the new color, the DFS function is called with the starting pixel coordinates, new color, and the current color of the starting pixel.</li>
</ul>
<h4 id="2-the-dfs-depth-first-search-function">2. <strong>The <code>dfs</code> (Depth-First Search) Function</strong></h4>
<ul>
<li>The <code>dfs</code> function is the core of the flood fill process. It recursively explores the neighboring pixels and fills them if they match the initial color.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> <span style="color:#666">&amp;</span> img, <span style="color:#0b0;font-weight:bold">int</span> r, <span style="color:#0b0;font-weight:bold">int</span> c, <span style="color:#0b0;font-weight:bold">int</span> color, <span style="color:#0b0;font-weight:bold">int</span> node) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> img.size(), n <span style="color:#666">=</span> img[<span style="color:#666">0</span>].size();  <span style="color:#080;font-style:italic">// Get the dimensions of the image
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#a2f;font-weight:bold">if</span> (r <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> c <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> r <span style="color:#666">==</span> m <span style="color:#666">||</span> c <span style="color:#666">==</span> n <span style="color:#666">||</span> img[r][c] <span style="color:#666">!=</span> node) <span style="color:#a2f;font-weight:bold">return</span>;  <span style="color:#080;font-style:italic">// Base case: Boundary or mismatched color
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    
</span></span><span style="display:flex;"><span>    img[r][c] <span style="color:#666">=</span> color;  <span style="color:#080;font-style:italic">// Fill the current pixel with the new color
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    
</span></span><span style="display:flex;"><span>    dfs(img, r <span style="color:#666">+</span> <span style="color:#666">1</span>, c, color, node);  <span style="color:#080;font-style:italic">// Explore the pixel below (down)
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    dfs(img, r, c <span style="color:#666">+</span> <span style="color:#666">1</span>, color, node);  <span style="color:#080;font-style:italic">// Explore the pixel to the right (right)
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    dfs(img, r <span style="color:#666">-</span> <span style="color:#666">1</span>, c, color, node);  <span style="color:#080;font-style:italic">// Explore the pixel above (up)
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    dfs(img, r, c <span style="color:#666">-</span> <span style="color:#666">1</span>, color, node);  <span style="color:#080;font-style:italic">// Explore the pixel to the left (left)
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><ul>
<li>
<p><strong>Base Condition:</strong>
The function first checks if the current pixel is out of bounds or if it doesn&rsquo;t match the initial color (i.e., <code>img[r][c] != node</code>). If any of these conditions are true, it simply returns without doing anything.</p>
</li>
<li>
<p><strong>Recursion:</strong>
If the current pixel matches the initial color (<code>node</code>), it is filled with the new color (<code>color</code>). The DFS function is then called recursively for the neighboring pixels in all four directions (up, down, left, and right).</p>
</li>
<li>
<p><strong>Termination:</strong>
The recursion terminates when all reachable pixels with the same color as the starting pixel are filled.</p>
</li>
</ul>
<h4 id="3-the-recursive-process">3. <strong>The Recursive Process</strong></h4>
<ul>
<li>
<p>Starting from the pixel at <code>(sr, sc)</code>, the <code>dfs</code> function works recursively to fill all connected pixels that have the same initial color. The recursion explores all directions (up, down, left, and right) until all connected pixels are processed.</p>
</li>
<li>
<p>Once all reachable pixels are filled, the function returns, and the updated image is returned from the <code>floodFill</code> function.</p>
</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li>The time complexity of the flood fill operation is <strong>O(m * n)</strong>, where <code>m</code> is the number of rows and <code>n</code> is the number of columns in the image.</li>
<li>In the worst case, all pixels in the image need to be visited, which is why the time complexity is proportional to the total number of pixels.</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li>The space complexity is <strong>O(m * n)</strong> in the worst case, due to the space required by the recursion stack in the DFS. If the entire image is a single connected region, the recursion depth could reach <code>m * n</code>, causing the space complexity to be proportional to the number of pixels.</li>
<li>In practice, the space complexity may be smaller if fewer pixels are visited.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>The flood fill algorithm efficiently modifies a 2D grid by starting from a given pixel and recursively filling all connected pixels with the same color using DFS. This solution is particularly useful in scenarios like image editing, where we need to change the color of a specific region in an image.</p>
<p>The approach uses recursion to explore all four directions from the starting pixel and fill all connected pixels, ensuring that no pixel is missed. The solution is efficient, with a time complexity of <strong>O(m * n)</strong>, where <code>m</code> and <code>n</code> are the dimensions of the image.</p>
<p>This code provides a robust method for performing flood fills in grid-based problems and can be extended to various applications such as image processing, game development (e.g., area filling), and other grid-based algorithms.</p>
<p><a href="https://leetcode.com/problems/flood-fill/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/NomjaXe6kUE?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2744: Find Maximum Number of String Pairs | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2744: Find Maximum Number of String Pairs">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2744: Find Maximum Number of String Pairs in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2744-find-maximum-number-of-string-pairs/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2744: Find Maximum Number of String Pairs">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2744: Find Maximum Number of String Pairs in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-02-06T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="String">
    <meta property="article:tag" content="Simulation">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2744: Find Maximum Number of String Pairs</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode925s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> maximumNumberOfStringPairs(vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&amp;</span> words) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> vis[<span style="color:#666">676</span>] <span style="color:#666">=</span> {}, res <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">w</span> : words) {
</span></span><span style="display:flex;"><span>        res <span style="color:#666">+=</span> vis[(w[<span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">*</span> <span style="color:#666">26</span> <span style="color:#666">+</span> w[<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>        vis[(w[<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">*</span> <span style="color:#666">26</span> <span style="color:#666">+</span> w[<span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem asks us to find the maximum number of pairs of strings that can be formed from a list of strings such that each pair consists of two strings that are reverse of each other. The goal is to count how many such pairs exist within the given list of words.</p>
<p>For example:</p>
<ul>
<li>Given the list <code>[&quot;cd&quot;, &quot;dc&quot;, &quot;gg&quot;, &quot;cd&quot;]</code>, we have one pair &ldquo;cd&rdquo; and &ldquo;dc&rdquo;, and the answer would be 1.</li>
<li>In the list <code>[&quot;ab&quot;, &quot;ba&quot;, &quot;ab&quot;, &quot;ba&quot;]</code>, we would count the pair &ldquo;ab&rdquo; and &ldquo;ba&rdquo; twice.</li>
</ul>
<h3 id="approach">Approach</h3>
<p>The approach used in this solution is based on hashing and indexing. Specifically, we use an integer array <code>vis</code> to record which word pairs have already been seen. For each word, we check whether its reverse has been encountered before. If so, we increment the result counter <code>res</code> because a valid pair has been found.</p>
<p>The algorithm works in the following way:</p>
<ol>
<li><strong>Indexing Words</strong>: For each word, we create an index that uniquely represents the word and its reverse.</li>
<li><strong>Hash Map (or Array)</strong>: We maintain a boolean array <code>vis[676]</code>, where each index corresponds to a unique pair of characters.</li>
<li><strong>Counting Pairs</strong>: As we iterate through the list of words, for each word, we check whether its reverse has been seen before using the <code>vis</code> array. If it has, we increment the result.</li>
<li><strong>Efficiency</strong>: By using the <code>vis</code> array, we avoid repeatedly checking every pair, which makes the solution efficient.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="1-initialization-of-the-vis-array">1. <strong>Initialization of the <code>vis</code> Array</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> vis[<span style="color:#666">676</span>] <span style="color:#666">=</span> {}, res <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div><ul>
<li><strong><code>vis[676]</code></strong>: This array holds boolean values where each index represents a unique combination of two lowercase letters (from &lsquo;a&rsquo; to &lsquo;z&rsquo;). The size 676 is because there are 26 lowercase letters, and the total number of combinations of two letters is (26 \times 26 = 676).</li>
<li><strong><code>res = 0</code></strong>: This variable will store the number of valid pairs of words found.</li>
</ul>
<h4 id="2-iterating-over-the-words">2. <strong>Iterating Over the Words</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">const</span> <span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">w</span> : words) {
</span></span><span style="display:flex;"><span>    res <span style="color:#666">+=</span> vis[(w[<span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">*</span> <span style="color:#666">26</span> <span style="color:#666">+</span> w[<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>    vis[(w[<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">*</span> <span style="color:#666">26</span> <span style="color:#666">+</span> w[<span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Iterating through the list of words</strong>: The <code>for</code> loop goes through each string in the <code>words</code> array one by one.</li>
</ul>
<h4 id="3-calculating-the-reverse-pair-index">3. <strong>Calculating the Reverse Pair Index</strong></h4>
<ul>
<li><strong>First line inside the loop</strong>:</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>res <span style="color:#666">+=</span> vis[(w[<span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">*</span> <span style="color:#666">26</span> <span style="color:#666">+</span> w[<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>];
</span></span></code></pre></div><p>Here, we are checking if the reverse of the current word has been encountered before.</p>
<ul>
<li>
<p><strong><code>w[0]</code> and <code>w[1]</code></strong>: These refer to the two characters in the word <code>w</code>. <code>w[0]</code> is the first character and <code>w[1]</code> is the second character of the word.</p>
</li>
<li>
<p><strong>Index calculation</strong>: The expression <code>(w[1] - 'a') * 26 + w[0] - 'a'</code> calculates a unique index based on the two characters of the word. This works as follows:</p>
<ul>
<li>Subtract <code>'a'</code> from <code>w[0]</code> and <code>w[1]</code> to get their zero-based index (0 for &lsquo;a&rsquo;, 1 for &lsquo;b&rsquo;, etc.).</li>
<li>Then, we calculate the index for the reversed string by swapping the positions of <code>w[0]</code> and <code>w[1]</code>, and use the formula <code>(w[1] - 'a') * 26 + (w[0] - 'a')</code> to create a unique index for this reversed pair.</li>
</ul>
<p>For example, for the word &ldquo;ab&rdquo;, the reverse is &ldquo;ba&rdquo;, and the index for &ldquo;ba&rdquo; is calculated as <code>(1 * 26) + 0 = 26</code>. If &ldquo;ba&rdquo; has been encountered before, <code>vis[26]</code> will be <code>true</code>, and we can increment <code>res</code>.</p>
</li>
<li>
<p><strong>Incrementing the result</strong>: If <code>vis[(w[1] - 'a') * 26 + w[0] - 'a']</code> is non-zero, it means that the reverse of the current word has been seen before, so we increment <code>res</code>.</p>
</li>
</ul>
<h4 id="4-marking-the-current-word-pair-as-seen">4. <strong>Marking the Current Word Pair as Seen</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vis[(w[<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">*</span> <span style="color:#666">26</span> <span style="color:#666">+</span> w[<span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span></code></pre></div><ul>
<li><strong>Mark the pair as seen</strong>: After checking for the reverse pair, we mark the current word as seen by setting <code>vis[(w[0] - 'a') * 26 + w[1] - 'a']</code> to <code>true</code>. This allows us to check for future occurrences of words that may form valid pairs with subsequent words.</li>
</ul>
<h4 id="5-returning-the-result">5. <strong>Returning the Result</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div><ul>
<li>After processing all the words in the list, we return <code>res</code>, which now holds the total count of valid word pairs.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity</h4>
<p>The time complexity of this solution is (O(n)), where (n) is the number of words in the input list. This is because we iterate over the list once, and for each word, we perform constant-time operations (indexing and checking the <code>vis</code> array).</p>
<ul>
<li><strong>Word iteration</strong>: We iterate over the <code>words</code> array once, taking (O(n)) time.</li>
<li><strong>Index computation</strong>: For each word, calculating the index and updating the <code>vis</code> array takes constant time, i.e., (O(1)).</li>
</ul>
<p>Thus, the overall time complexity is (O(n)).</p>
<h4 id="space-complexity">Space Complexity</h4>
<p>The space complexity is (O(1)), as the <code>vis</code> array is of fixed size (676), which does not depend on the size of the input list. Other than that, we use only a few additional integer variables, which require constant space.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently counts the maximum number of pairs of strings that are reverses of each other by using a hash-based approach. The key idea is to represent the reversed word pairs using a unique index and store them in a fixed-size array. As we iterate through the words, we check if the reverse of each word has been seen before and update the result accordingly.</p>
<ul>
<li><strong>Time Complexity</strong>: (O(n)), where (n) is the number of words in the list.</li>
<li><strong>Space Complexity</strong>: (O(1)), due to the fixed-size <code>vis</code> array.</li>
</ul>
<p>This approach is optimal and solves the problem efficiently.</p>
<p><a href="https://leetcode.com/problems/find-maximum-number-of-string-pairs/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/f8qWoxowloA?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

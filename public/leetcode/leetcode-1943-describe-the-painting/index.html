<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 1943: Describe the Painting | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1943: Describe the Painting">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1943: Describe the Painting in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-1943-describe-the-painting/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1943: Describe the Painting">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1943: Describe the Painting in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-04-26T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="Sorting">
    <meta property="article:tag" content="Prefix Sum">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 1943: Describe the Painting</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode469s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">typedef</span> <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> ll;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span><span style="color:#666">&gt;&gt;</span> splitPainting(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> segs) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>       <span style="color:#080;font-style:italic">// sort(seg.begin(), seg.end());
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span>ll, ll<span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span>ll<span style="color:#666">&gt;&gt;</span> res;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> segs.size();
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#a0a000">seg</span> : segs) {
</span></span><span style="display:flex;"><span>            mp[seg[<span style="color:#666">0</span>]] <span style="color:#666">+=</span> seg[<span style="color:#666">2</span>];
</span></span><span style="display:flex;"><span>            mp[seg[<span style="color:#666">1</span>]] <span style="color:#666">-=</span> seg[<span style="color:#666">2</span>];
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        ll prv <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>, clr <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span> <span style="color:#a0a000">itr</span> : mp) {
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(clr )
</span></span><span style="display:flex;"><span>                res.push_back({prv, itr.first, clr});
</span></span><span style="display:flex;"><span>            clr <span style="color:#666">+=</span> itr.second;
</span></span><span style="display:flex;"><span>            prv <span style="color:#666">=</span> itr.first;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem at hand involves painting segments on a number line where each segment has a specific color value associated with it. The goal is to determine the resulting painted segments after combining overlapping segments, accounting for their color values. Each segment is defined by its start point, end point, and the color value, and the output should provide the distinct painted segments with their respective color values.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we utilize a <strong>sweep line algorithm</strong> combined with a <strong>map</strong> to efficiently track color contributions at each point on the number line. Here’s a breakdown of the approach:</p>
<ol>
<li>
<p><strong>Event Point Representation</strong>: For each segment, we represent the start and end points as events in a map where:</p>
<ul>
<li>The start point adds the color value.</li>
<li>The end point subtracts the color value.</li>
</ul>
</li>
<li>
<p><strong>Sorting and Processing Events</strong>: We then iterate over the sorted event points to determine how the total color value changes across the number line:</p>
<ul>
<li>If the current total color value is non-zero, we create a new segment from the last event to the current event with the accumulated color.</li>
<li>We update the total color value as we process each event.</li>
</ul>
</li>
<li>
<p><strong>Output Result</strong>: Finally, the result is built as a list of segments representing the painted areas with their color values.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>Let’s break down the provided code in detail:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">typedef</span> <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> ll; <span style="color:#080;font-style:italic">// Define &#39;ll&#39; as a shorthand for &#39;long long&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span><span style="color:#666">&gt;&gt;</span> splitPainting(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> segs) {
</span></span></code></pre></div><p>We define a class <code>Solution</code> and a public method <code>splitPainting</code>, which takes a 2D vector <code>segs</code> representing the segments to be painted.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>       <span style="color:#080;font-style:italic">// sort(seg.begin(), seg.end());
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span>ll, ll<span style="color:#666">&gt;</span> mp; <span style="color:#080;font-style:italic">// Initialize a map to hold the color contributions at different points
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span>ll<span style="color:#666">&gt;&gt;</span> res; <span style="color:#080;font-style:italic">// Initialize the result vector to store the final painted segments
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> segs.size(); <span style="color:#080;font-style:italic">// Get the number of segments
</span></span></span></code></pre></div><p>Although the sorting line is commented out, we initialize a <code>map</code> named <code>mp</code> to track the color changes, where the keys are the positions on the number line and the values are the cumulative color contributions. We also initialize a result vector <code>res</code> to store the final segments.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#a0a000">seg</span> : segs) {
</span></span><span style="display:flex;"><span>            mp[seg[<span style="color:#666">0</span>]] <span style="color:#666">+=</span> seg[<span style="color:#666">2</span>]; <span style="color:#080;font-style:italic">// Add the color value at the start of the segment
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            mp[seg[<span style="color:#666">1</span>]] <span style="color:#666">-=</span> seg[<span style="color:#666">2</span>]; <span style="color:#080;font-style:italic">// Subtract the color value at the end of the segment
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        }
</span></span></code></pre></div><p>We iterate over each segment in <code>segs</code>:</p>
<ul>
<li>For each segment, we increment the color contribution at the start of the segment by its color value (<code>seg[2]</code>).</li>
<li>We decrement the color contribution at the end of the segment (<code>seg[1]</code>) by the same color value.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        ll prv <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>, clr <span style="color:#666">=</span> <span style="color:#666">0</span>; <span style="color:#080;font-style:italic">// Initialize previous position and current color sum
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span> <span style="color:#a0a000">itr</span> : mp) {
</span></span></code></pre></div><p>We initialize <code>prv</code> to <code>-1</code> (to signify no previous position) and <code>clr</code> to <code>0</code> (to keep track of the current color value). We then start iterating over the entries in the map.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(clr) <span style="color:#080;font-style:italic">// Check if there is a current color contribution
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>                res.push_back({prv, itr.first, clr}); <span style="color:#080;font-style:italic">// If yes, add the segment to the result
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            clr <span style="color:#666">+=</span> itr.second; <span style="color:#080;font-style:italic">// Update the current color with the change at the current event point
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            prv <span style="color:#666">=</span> itr.first; <span style="color:#080;font-style:italic">// Update the previous position to the current event point
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        }
</span></span></code></pre></div><p>Within the loop:</p>
<ul>
<li>If <code>clr</code> is non-zero, it means we have a segment that has been painted with color, and we push a new segment into <code>res</code> defined by the previous position <code>prv</code>, the current position <code>itr.first</code>, and the current color <code>clr</code>.</li>
<li>We then update the current color value by adding the contribution from the current point <code>itr.second</code>.</li>
<li>Finally, we set <code>prv</code> to the current event point.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res; <span style="color:#080;font-style:italic">// Return the final list of painted segments
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>After processing all event points, we return the result vector <code>res</code>, which contains the distinct painted segments with their respective color values.</p>
<h3 id="complexity">Complexity</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: The time complexity of this solution is (O(n \log n)) due to the insertion into the map, where (n) is the number of segments. Each segment results in two operations on the map (one for the start and one for the end), and sorting the keys will dominate the time complexity.</p>
</li>
<li>
<p><strong>Space Complexity</strong>: The space complexity is (O(n)) as well, since we store each segment&rsquo;s contribution in the map and potentially have up to (2n) distinct event points.</p>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This code efficiently solves the problem of determining the painted segments on a number line based on overlapping segments with color values. By leveraging a map to keep track of color contributions and a sweep line approach, the solution combines simplicity and efficiency. The output provides a clear representation of how the number line is segmented and colored after processing all input segments.</p>
<h3 id="key-features">Key Features</h3>
<ol>
<li>
<p><strong>Event Point Tracking</strong>: The use of a map allows for efficient tracking of color contributions at specific points on the number line, enabling quick updates and lookups.</p>
</li>
<li>
<p><strong>Handling Overlaps</strong>: By subtracting color values at end points, the solution effectively handles overlapping segments, ensuring that the final output accurately represents the resultant painted segments.</p>
</li>
<li>
<p><strong>Dynamic Segment Creation</strong>: The algorithm dynamically creates segments based on changing color values, making it adaptable to a wide range of input scenarios.</p>
</li>
</ol>
<h3 id="use-cases">Use Cases</h3>
<p>This approach can be useful in various applications, including:</p>
<ul>
<li>
<p><strong>Graphics and Visualizations</strong>: In computer graphics, where multiple overlapping shapes need to be painted with different colors, understanding the resultant overlap can be crucial.</p>
</li>
<li>
<p><strong>Geographical Mapping</strong>: For applications in geographic information systems (GIS), where different regions may be colored based on various data attributes, such as population density or land use.</p>
</li>
<li>
<p><strong>Data Visualization</strong>: In data analysis tools that visualize trends over time, this approach can effectively represent how overlapping data points affect the visual outcome.</p>
</li>
</ul>
<h3 id="implementation-considerations">Implementation Considerations</h3>
<p>When implementing this solution, consider the following:</p>
<ul>
<li>
<p><strong>Input Validation</strong>: Ensure that the segments are well-defined, with valid start and end points.</p>
</li>
<li>
<p><strong>Performance Testing</strong>: Given the potential for large inputs, it’s advisable to test the performance of the implementation under various scenarios to ensure that it operates within acceptable time limits.</p>
</li>
<li>
<p><strong>Edge Cases</strong>: Handle special cases, such as segments that do not overlap or segments that completely overlap with others.</p>
</li>
</ul>
<p>By understanding and applying these concepts, one can effectively tackle similar problems involving overlapping intervals and color contributions.</p>
<p><a href="https://leetcode.com/problems/describe-the-painting/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/inJXN48LgPo?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

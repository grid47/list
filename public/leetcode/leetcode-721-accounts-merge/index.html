<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 721: Accounts Merge | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 721: Accounts Merge">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 721: Accounts Merge in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-721-accounts-merge/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 721: Accounts Merge">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 721: Accounts Merge in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-08-26T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="String">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Union Find">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 721: Accounts Merge</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1272s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/721.webp" 
           alt="A set of accounts where identical accounts are merged, with each merge softly glowing as itâ€™s processed." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 721: Accounts Merge Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1272s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&gt;</span> accountsMerge(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&gt;&amp;</span> acc) {
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span>string, string<span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span>string, set<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&gt;</span> gph;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">ac</span>: acc) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">1</span>; i <span style="color:#666">&lt;</span> ac.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>                mp[ac[i]] <span style="color:#666">=</span> ac[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>                gph[ac[i]].insert(ac[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>                gph[ac[<span style="color:#666">1</span>]].insert(ac[i]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        set<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;</span> seen;
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&gt;</span> ans;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: mp) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(seen.count(it.first)) <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>            vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;</span> tmp;
</span></span><span style="display:flex;"><span>            dfs(tmp, gph, seen, it.first);
</span></span><span style="display:flex;"><span>            sort(tmp.begin(), tmp.end());
</span></span><span style="display:flex;"><span>            tmp.insert(tmp.begin(), it.second);
</span></span><span style="display:flex;"><span>            ans.push_back(tmp);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>tmp, map<span style="color:#666">&lt;</span>string, set<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&gt;</span> <span style="color:#666">&amp;</span>gph, set<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>seen, string node) {
</span></span><span style="display:flex;"><span>        tmp.push_back(node);
</span></span><span style="display:flex;"><span>        seen.insert(node);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: gph[node]) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>seen.count(it)) {
</span></span><span style="display:flex;"><span>                dfs(tmp, gph, seen, it);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem asks us to <strong>merge accounts</strong> where multiple email addresses can belong to the same account, but may appear in different records. We are tasked with finding all the accounts that should be merged, where an account is merged if any two of its email addresses share a common domain. The final result should return the merged accounts, where each account is represented by a list of emails and the first email should represent the account holder&rsquo;s name.</p>
<h3 id="approach">Approach</h3>
<p>The solution follows a <strong>graph-based approach</strong> to represent the email addresses as nodes and the connections between them as edges. Hereâ€™s a step-by-step breakdown of how we can approach the problem:</p>
<ol>
<li>
<p><strong>Graph Representation</strong>: We model the problem as a graph, where each email address is a node. The edges between nodes represent that two email addresses belong to the same account. This is because an account can have multiple email addresses, and if one email address is linked to another, they belong to the same account.</p>
</li>
<li>
<p><strong>Union-Find or DFS</strong>: To merge accounts, we need to group connected components in the graph. This can be done using a <strong>Depth-First Search (DFS)</strong> approach or <strong>Union-Find</strong>. We will use DFS here to explore the connected components (i.e., the accounts).</p>
</li>
<li>
<p><strong>Mapping Emails to Accounts</strong>: We need to ensure that each email address is associated with the correct account holder&rsquo;s name. The first email in each list represents the account holderâ€™s name.</p>
</li>
<li>
<p><strong>Final Sorting</strong>: After collecting the connected components (i.e., all the email addresses that belong to the same account), we sort them lexicographically and insert the account holder&rsquo;s name as the first element in each merged account.</p>
</li>
<li>
<p><strong>Handling Already Seen Accounts</strong>: To avoid revisiting email addresses weâ€™ve already processed, we maintain a <code>seen</code> set, which ensures that we only visit each email once.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>Letâ€™s dive into the code to understand how it implements this approach:</p>
<ol>
<li>
<p><strong>Data Structures</strong>:</p>
<ul>
<li><code>mp</code>: A map to associate each email address with the account holderâ€™s name.</li>
<li><code>gph</code>: A map representing the graph where each email address points to a set of other email addresses connected to it.</li>
<li><code>seen</code>: A set to track the email addresses that have already been visited.</li>
<li><code>ans</code>: A vector of vectors where the final merged accounts will be stored.</li>
</ul>
</li>
<li>
<p><strong>Building the Graph</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">ac</span>: acc) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">1</span>; i <span style="color:#666">&lt;</span> ac.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        mp[ac[i]] <span style="color:#666">=</span> ac[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>        gph[ac[i]].insert(ac[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>        gph[ac[<span style="color:#666">1</span>]].insert(ac[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>The first loop iterates through each account in <code>acc</code>, where each account is represented as a vector of strings (the first element is the name and the rest are the email addresses).</li>
<li>For each email address, we map it to the account holderâ€™s name using the <code>mp</code> map.</li>
<li>We also build the graph by inserting edges between the current email and the next one, ensuring both directions (i.e., if <code>a</code> and <code>b</code> are connected, both <code>a</code> points to <code>b</code> and <code>b</code> points to <code>a</code>).</li>
</ul>
</li>
<li>
<p><strong>DFS Traversal</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>tmp, map<span style="color:#666">&lt;</span>string, set<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&gt;</span> <span style="color:#666">&amp;</span>gph, set<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>seen, string node) {
</span></span><span style="display:flex;"><span>    tmp.push_back(node);
</span></span><span style="display:flex;"><span>    seen.insert(node);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: gph[node]) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>seen.count(it)) {
</span></span><span style="display:flex;"><span>            dfs(tmp, gph, seen, it);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>The <code>dfs</code> function performs a Depth-First Search on the graph starting from the given email address (<code>node</code>).</li>
<li>It adds the current email to the <code>tmp</code> vector, marks it as seen, and recursively visits all its neighbors (emails connected in the graph).</li>
<li>This traversal collects all the email addresses that belong to the same account.</li>
</ul>
</li>
<li>
<p><strong>Building the Result</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: mp) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(seen.count(it.first)) <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;</span> tmp;
</span></span><span style="display:flex;"><span>    dfs(tmp, gph, seen, it.first);
</span></span><span style="display:flex;"><span>    sort(tmp.begin(), tmp.end());
</span></span><span style="display:flex;"><span>    tmp.insert(tmp.begin(), it.second);
</span></span><span style="display:flex;"><span>    ans.push_back(tmp);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>The second loop processes each email address in <code>mp</code> (which is the list of all emails encountered).</li>
<li>If the email has already been seen, it skips to the next one.</li>
<li>Otherwise, it performs a DFS to collect all emails connected to the current email.</li>
<li>After the DFS traversal, the emails are sorted lexicographically, and the account holder&rsquo;s name (from <code>mp</code>) is inserted as the first element of the result.</li>
<li>Finally, the merged account is added to the result vector <code>ans</code>.</li>
</ul>
</li>
<li>
<p><strong>Returning the Result</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div><ul>
<li>After processing all emails and their connected components, the function returns the merged accounts.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>:</p>
<ul>
<li><strong>Building the Graph</strong>: We iterate over each account and each email in it. This takes <strong>O(N * M)</strong> time, where <code>N</code> is the number of accounts and <code>M</code> is the average number of emails per account.</li>
<li><strong>DFS Traversal</strong>: We visit each email exactly once, so the DFS traversal takes <strong>O(V + E)</strong> time, where <code>V</code> is the number of emails and <code>E</code> is the number of edges (connections between emails). This is also <strong>O(N * M)</strong> in the worst case.</li>
<li><strong>Sorting the Result</strong>: After the DFS traversal, we sort the emails in each account, which takes <strong>O(K log K)</strong> for each account, where <code>K</code> is the number of emails in the account. In the worst case, the time complexity of sorting all accounts is <strong>O(N * M log M)</strong>.</li>
</ul>
<p>The overall time complexity is <strong>O(N * M + N * M log M)</strong>.</p>
</li>
<li>
<p><strong>Space Complexity</strong>:</p>
<ul>
<li>We use a map (<code>mp</code>) to store the account holderâ€™s name for each email, which takes <strong>O(V)</strong> space, where <code>V</code> is the number of unique email addresses.</li>
<li>We use a graph (<code>gph</code>) to store the adjacency list representation, which also takes <strong>O(V + E)</strong> space.</li>
<li>The <code>seen</code> set takes <strong>O(V)</strong> space.</li>
<li>The final result <code>ans</code> takes <strong>O(V)</strong> space.</li>
</ul>
<p>The overall space complexity is <strong>O(V + E)</strong>.</p>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently merges accounts by modeling the problem as a graph and performing a Depth-First Search (DFS) to find connected components. The approach ensures that we group emails belonging to the same account and sort them lexicographically for the final result. The use of a graph with an adjacency list allows us to efficiently check for connections between emails. The time complexity of <strong>O(N * M + N * M log M)</strong> and space complexity of <strong>O(V + E)</strong> makes this solution scalable for large inputs, where <code>N</code> is the number of accounts and <code>M</code> is the average number of emails per account. This approach efficiently solves the problem of merging accounts with multiple email addresses.</p>
<p><a href="https://leetcode.com/problems/accounts-merge/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/otzKJY8YhRg?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2359: Find Closest Node to Given Two Nodes | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2359: Find Closest Node to Given Two Nodes">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2359: Find Closest Node to Given Two Nodes in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2359-find-closest-node-to-given-two-nodes/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2359: Find Closest Node to Given Two Nodes">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2359: Find Closest Node to Given Two Nodes in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-03-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Graph">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2359: Find Closest Node to Given Two Nodes</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode708s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> dfs(<span style="color:#0b0;font-weight:bold">int</span> node, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>edge, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>vis, <span style="color:#0b0;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>        vis[node] <span style="color:#666">=</span> x;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(edge[node] <span style="color:#666">!=</span> <span style="color:#666">-</span><span style="color:#666">1</span> <span style="color:#666">&amp;&amp;</span> vis[edge[node]] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>            dfs(edge[node], edge, vis, x <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">closestMeetingNode</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> edges, <span style="color:#0b0;font-weight:bold">int</span> node1, <span style="color:#0b0;font-weight:bold">int</span> node2) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> edges.size();
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dist1(n, <span style="color:#666">-</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        dfs(node1, edges, dist1, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dist2(n, <span style="color:#666">-</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        dfs(node2, edges, dist2, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> dist, ans <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>, sol <span style="color:#666">=</span> INT_MAX;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(dist1[i] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span> <span style="color:#666">||</span> dist2[i] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>                dist <span style="color:#666">=</span> max(dist1[i], dist2[i]);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(dist <span style="color:#666">&lt;</span> sol) {
</span></span><span style="display:flex;"><span>                sol <span style="color:#666">=</span> dist;
</span></span><span style="display:flex;"><span>                ans <span style="color:#666">=</span> i;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given a directed graph where each node points to exactly one other node or to no node at all, you are given two starting nodes. The task is to find the &ldquo;closest meeting node&rdquo; — the node that can be reached by both starting nodes such that the maximum distance traveled by either node is minimized. If there are multiple such nodes, the smallest index should be returned.</p>
<h3 id="approach">Approach</h3>
<p>This problem is solved using Depth-First Search (DFS) to calculate distances from both starting nodes (<code>node1</code> and <code>node2</code>) to each other node. The idea is to determine the distance from each starting node to other nodes in the graph and then identify the node with the minimum &ldquo;maximum&rdquo; distance from both start points. Here’s a breakdown of how it works:</p>
<ol>
<li>
<p><strong>Using DFS to Track Distances:</strong></p>
<ul>
<li>We define a helper function <code>dfs()</code> that performs a depth-first traversal from a given node, calculating the distance to other reachable nodes.</li>
<li>As it traverses, it records the distance to each node in a <code>vis</code> vector, which acts as a distance array.</li>
</ul>
</li>
<li>
<p><strong>Calculating Distances from Each Starting Node:</strong></p>
<ul>
<li>The main function initializes two vectors (<code>dist1</code> and <code>dist2</code>) for tracking distances from <code>node1</code> and <code>node2</code>, respectively.</li>
<li>It calls <code>dfs()</code> twice, first with <code>node1</code> and <code>dist1</code>, and then with <code>node2</code> and <code>dist2</code>, to populate the distances from each node.</li>
</ul>
</li>
<li>
<p><strong>Finding the Closest Meeting Node:</strong></p>
<ul>
<li>After obtaining distances from both nodes, the algorithm iterates over all nodes.</li>
<li>For each node reachable from both starting points, it calculates the maximum distance from either starting node (<code>dist1[i]</code> and <code>dist2[i]</code>).</li>
<li>The node with the smallest &ldquo;maximum distance&rdquo; is selected as the closest meeting node. If there are multiple nodes with the same maximum distance, the one with the smallest index is chosen.</li>
</ul>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="step-1-define-dfs-to-calculate-distances">Step 1: Define DFS to Calculate Distances</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(<span style="color:#0b0;font-weight:bold">int</span> node, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>edge, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>vis, <span style="color:#0b0;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>    vis[node] <span style="color:#666">=</span> x;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(edge[node] <span style="color:#666">!=</span> <span style="color:#666">-</span><span style="color:#666">1</span> <span style="color:#666">&amp;&amp;</span> vis[edge[node]] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>        dfs(edge[node], edge, vis, x <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>The <code>dfs()</code> function recursively traverses the graph starting from <code>node</code>.</li>
<li>It marks each node with a distance <code>x</code>, representing the steps taken from the starting node.</li>
<li>If the current node points to another node (i.e., <code>edge[node] != -1</code>) and that node hasn’t been visited (<code>vis[edge[node]] == -1</code>), the function calls itself with the next node and increments the distance.</li>
</ul>
<h4 id="step-2-calculate-distances-from-node1-and-node2">Step 2: Calculate Distances from <code>node1</code> and <code>node2</code></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> edges.size();
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dist1(n, <span style="color:#666">-</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>dfs(node1, edges, dist1, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dist2(n, <span style="color:#666">-</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>dfs(node2, edges, dist2, <span style="color:#666">0</span>);
</span></span></code></pre></div><ul>
<li>We initialize two distance vectors (<code>dist1</code> and <code>dist2</code>) with <code>-1</code>, indicating that nodes haven’t been visited.</li>
<li>Using <code>dfs()</code>, we calculate distances from <code>node1</code> and <code>node2</code>, filling <code>dist1</code> and <code>dist2</code> with the shortest distances from each respective starting node to each reachable node.</li>
</ul>
<h4 id="step-3-find-the-closest-meeting-node">Step 3: Find the Closest Meeting Node</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> dist, ans <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>, sol <span style="color:#666">=</span> INT_MAX;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(dist1[i] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span> <span style="color:#666">||</span> dist2[i] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>        dist <span style="color:#666">=</span> max(dist1[i], dist2[i]);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(dist <span style="color:#666">&lt;</span> sol) {
</span></span><span style="display:flex;"><span>        sol <span style="color:#666">=</span> dist;
</span></span><span style="display:flex;"><span>        ans <span style="color:#666">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>We iterate through each node to find the one that minimizes the maximum distance between <code>node1</code> and <code>node2</code>.</li>
<li>For each node <code>i</code>, if both <code>dist1[i]</code> and <code>dist2[i]</code> are reachable (<code>!= -1</code>), we calculate the maximum of the two distances.</li>
<li>If this maximum distance is less than the current <code>sol</code>, we update <code>sol</code> and set <code>ans</code> to the current node.</li>
</ul>
<h4 id="step-4-return-the-result">Step 4: Return the Result</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div><ul>
<li>Finally, the node <code>ans</code> represents the closest meeting node based on the criteria and is returned as the output.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>DFS Traversal:</strong> Each DFS call traverses the graph from a starting node, which takes (O(n)) time for <code>n</code> nodes.</li>
<li><strong>Distance Calculation:</strong> We loop through all nodes once to determine the closest meeting node, which is also (O(n)).</li>
<li>Therefore, the overall time complexity is (O(n)).</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li>The space complexity is (O(n)) as we use two vectors (<code>dist1</code> and <code>dist2</code>) to store distances and additional stack space for recursion in DFS.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently finds the closest meeting node by leveraging DFS to track distances from both starting nodes. It calculates the minimum maximum distance to ensure both nodes can reach the target with the least delay, while also accounting for multiple valid nodes by selecting the smallest index when distances are equal. The use of distance tracking vectors and recursive DFS traversal makes this approach both time-efficient and straightforward, providing an optimal solution to the problem.</p>
<p><a href="https://leetcode.com/problems/find-closest-node-to-given-two-nodes/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/AZA8orksO4w?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

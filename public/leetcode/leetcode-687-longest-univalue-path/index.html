<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 687: Longest Univalue Path | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 687: Longest Univalue Path">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 687: Longest Univalue Path in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-687-longest-univalue-path/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 687: Longest Univalue Path">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 687: Longest Univalue Path in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-08-30T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 687: Longest Univalue Path</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1253s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/687.webp" 
           alt="A tree where the longest univalue path is traced and softly glowing as it’s found." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 687: Longest Univalue Path Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1253s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> maxi;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> longestUnivaluePath(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        maxi <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>((root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#666">||</span> (root<span style="color:#666">-&gt;</span>left <span style="color:#666">==</span> <span style="color:#a2f">NULL</span> <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>right <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>)  )
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        dfs(root);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> maxi;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">dfs</span>(TreeNode <span style="color:#666">*</span>root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> l <span style="color:#666">=</span> <span style="color:#666">0</span>, r <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> lft <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> rgt <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>((root<span style="color:#666">-&gt;</span>left <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) <span style="color:#666">&amp;&amp;</span> (root<span style="color:#666">-&gt;</span>left<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> root<span style="color:#666">-&gt;</span>val))
</span></span><span style="display:flex;"><span>        l <span style="color:#666">=</span> lft;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>((root<span style="color:#666">-&gt;</span>right <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) <span style="color:#666">&amp;&amp;</span> (root<span style="color:#666">-&gt;</span>right<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> root<span style="color:#666">-&gt;</span>val))
</span></span><span style="display:flex;"><span>        r <span style="color:#666">=</span> rgt;        
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        maxi <span style="color:#666">=</span> max(maxi, l <span style="color:#666">+</span> r);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">1</span> <span style="color:#666">+</span> max(l, r);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement:</h3>
<p>The problem at hand involves finding the longest univalue path in a binary tree. A univalue path is defined as a path where all nodes along the path have the same value. The task is to return the length of the longest path where the nodes have the same value. The path does not necessarily have to pass through the root, but it can go through any node in the tree.</p>
<h3 id="approach">Approach:</h3>
<p>To solve this problem, we use a <strong>Depth-First Search (DFS)</strong> approach. The main idea is to traverse the tree and calculate, for each node, the longest path that starts from that node and extends along its left and right subtrees while maintaining the same value. During this traversal, we also keep track of the maximum univalue path encountered so far.</p>
<p>We need to focus on two main things:</p>
<ol>
<li><strong>DFS Traversal</strong>: Recursively explore both left and right subtrees for each node.</li>
<li><strong>Path Calculation</strong>: For each node, calculate the longest univalue path starting from the current node and extending through its left and right children.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step):</h3>
<h4 id="1-treenode-definition">1. <strong>TreeNode Definition</strong></h4>
<p>The problem statement includes a predefined <code>TreeNode</code> structure:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> val;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>right;
</span></span><span style="display:flex;"><span>    TreeNode() <span style="color:#666">:</span> val(<span style="color:#666">0</span>), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x) <span style="color:#666">:</span> val(x), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x, TreeNode <span style="color:#666">*</span>left, TreeNode <span style="color:#666">*</span>right) <span style="color:#666">:</span> val(x), left(left), right(right) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Each <code>TreeNode</code> contains:</p>
<ul>
<li><code>val</code>: The value of the node.</li>
<li><code>left</code>: A pointer to the left child of the node.</li>
<li><code>right</code>: A pointer to the right child of the node.</li>
</ul>
<h4 id="2-main-solution-class">2. <strong>Main Solution Class</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> maxi;  <span style="color:#080;font-style:italic">// To store the maximum length of univalue path found.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> longestUnivaluePath(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        maxi <span style="color:#666">=</span> <span style="color:#666">0</span>;  <span style="color:#080;font-style:italic">// Initialize maxi to 0.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">if</span> ((root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#666">||</span> (root<span style="color:#666">-&gt;</span>left <span style="color:#666">==</span> <span style="color:#a2f">NULL</span> <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>right <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;  <span style="color:#080;font-style:italic">// If the root is null or the tree has no child, return 0.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        dfs(root);  <span style="color:#080;font-style:italic">// Start DFS traversal to calculate the univalue paths.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">return</span> maxi;  <span style="color:#080;font-style:italic">// Return the longest univalue path found.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span></code></pre></div><p>The function <code>longestUnivaluePath</code> initializes the <code>maxi</code> variable to track the longest path found. If the root is <code>NULL</code> or a leaf node (no children), the function returns <code>0</code> as there are no paths to explore. Otherwise, it calls the <code>dfs</code> function to start the depth-first search from the root and returns the result stored in <code>maxi</code>.</p>
<h4 id="3-dfs-function">3. <strong>DFS Function</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">dfs</span>(TreeNode <span style="color:#666">*</span>root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;  <span style="color:#080;font-style:italic">// Base case: if the node is NULL, return 0.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#0b0;font-weight:bold">int</span> l <span style="color:#666">=</span> <span style="color:#666">0</span>, r <span style="color:#666">=</span> <span style="color:#666">0</span>;  <span style="color:#080;font-style:italic">// Initialize the lengths of the left and right paths.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#0b0;font-weight:bold">int</span> lft <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>left);  <span style="color:#080;font-style:italic">// Recursive DFS for the left child.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#0b0;font-weight:bold">int</span> rgt <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>right);  <span style="color:#080;font-style:italic">// Recursive DFS for the right child.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// If the left child has the same value as the current node, extend the left path.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">if</span> ((root<span style="color:#666">-&gt;</span>left <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) <span style="color:#666">&amp;&amp;</span> (root<span style="color:#666">-&gt;</span>left<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> root<span style="color:#666">-&gt;</span>val))
</span></span><span style="display:flex;"><span>            l <span style="color:#666">=</span> lft;  
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// If the right child has the same value as the current node, extend the right path.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">if</span> ((root<span style="color:#666">-&gt;</span>right <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) <span style="color:#666">&amp;&amp;</span> (root<span style="color:#666">-&gt;</span>right<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> root<span style="color:#666">-&gt;</span>val))
</span></span><span style="display:flex;"><span>            r <span style="color:#666">=</span> rgt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// Update the maxi variable to store the maximum length of the univalue path.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        maxi <span style="color:#666">=</span> max(maxi, l <span style="color:#666">+</span> r);  
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// Return the longest univalue path starting from the current node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">1</span> <span style="color:#666">+</span> max(l, r);  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The <code>dfs</code> function works recursively to explore the tree. It computes the longest univalue path that starts from the current node and extends to its left or right subtree. Here’s how it works:</p>
<ul>
<li><strong>Base Case</strong>: If the current node is <code>NULL</code>, return <code>0</code> as there’s no path to explore.</li>
<li><strong>Recursive Case</strong>:
<ul>
<li>Call <code>dfs(root-&gt;left)</code> and <code>dfs(root-&gt;right)</code> to get the longest univalue paths starting from the left and right subtrees, respectively.</li>
<li>Check if the left or right children have the same value as the current node. If they do, extend the path from that child.</li>
</ul>
</li>
<li><strong>Update <code>maxi</code></strong>: After checking both left and right subtrees, calculate the total univalue path that passes through the current node by summing the lengths of the left and right paths (<code>l + r</code>), and update <code>maxi</code> with the maximum of its current value and the new path length.</li>
<li><strong>Return the Length</strong>: Return the length of the longest univalue path starting from the current node. Since the current node is part of the path, add <code>1</code> to the maximum of the left and right path lengths.</li>
</ul>
<h4 id="4-final-output">4. <strong>Final Output</strong></h4>
<p>Once the DFS is complete, the longest univalue path will be stored in <code>maxi</code>, which is then returned by the <code>longestUnivaluePath</code> function.</p>
<h3 id="complexity">Complexity:</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<p>The time complexity of this solution is <strong>O(N)</strong>, where <code>N</code> is the number of nodes in the binary tree. The reason for this is that the DFS function visits each node exactly once, performing a constant amount of work per node.</p>
<h4 id="space-complexity">Space Complexity:</h4>
<p>The space complexity is <strong>O(H)</strong>, where <code>H</code> is the height of the tree. This is due to the recursive nature of DFS, where the maximum number of recursive calls that can be stacked is equal to the height of the tree. In the worst case (a skewed tree), this could be <code>O(N)</code>.</p>
<h3 id="conclusion">Conclusion:</h3>
<p>This solution effectively solves the problem of finding the longest univalue path in a binary tree using a depth-first search (DFS) approach. It efficiently computes the longest path where all nodes have the same value by recursively exploring the left and right subtrees of each node while keeping track of the maximum path length found. The time and space complexity are optimal for a tree traversal algorithm, making this solution both time-efficient and space-efficient.</p>
<p><a href="https://leetcode.com/problems/longest-univalue-path/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/ZeBr9JMcjrU?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

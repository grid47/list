<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 938: Range Sum of BST | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 938: Range Sum of BST">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 938: Range Sum of BST in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-938-range-sum-of-bst/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 938: Range Sum of BST">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 938: Range Sum of BST in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-08-05T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Search Tree">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 938: Range Sum of BST</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1401s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> rangeSumBST(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> low, <span style="color:#0b0;font-weight:bold">int</span> high) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        sum <span style="color:#666">+=</span> rangeSumBST(root<span style="color:#666">-&gt;</span>left, low, high);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val <span style="color:#666">&gt;=</span> low <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>val <span style="color:#666">&lt;=</span> high)
</span></span><span style="display:flex;"><span>            sum <span style="color:#666">+=</span> root<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>        sum <span style="color:#666">+=</span> rangeSumBST(root<span style="color:#666">-&gt;</span>right, low, high);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> sum;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem at hand is to find the sum of values of all nodes within a Binary Search Tree (BST) that lie within a given range <code>[low, high]</code>. Given a BST, you are asked to return the sum of the node values that are within this specified range.</p>
<p>A Binary Search Tree (BST) is a tree data structure where for each node:</p>
<ul>
<li>The value of the left subtree node is less than the node’s value.</li>
<li>The value of the right subtree node is greater than the node’s value.</li>
</ul>
<p>You are provided with the root of the tree and the range <code>[low, high]</code>. The task is to compute the sum of all node values in the tree that lie within this range.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we can take advantage of the properties of a Binary Search Tree. Specifically, we can avoid traversing parts of the tree that are outside the range <code>[low, high]</code> to make the algorithm more efficient.</p>
<ol>
<li>
<p><strong>Traversal Strategy</strong>: Since the problem involves summing nodes within a certain range, an in-order traversal is suitable. In-order traversal ensures that the nodes of the tree are visited in ascending order of their values, which matches the nature of the Binary Search Tree.</p>
</li>
<li>
<p><strong>Pruning the Search Space</strong>:</p>
<ul>
<li>If the current node’s value is less than <code>low</code>, then all values in the left subtree are also less than <code>low</code>. Therefore, we can skip the entire left subtree and only recurse into the right subtree.</li>
<li>Similarly, if the current node’s value is greater than <code>high</code>, all values in the right subtree are also greater than <code>high</code>, and we can skip the right subtree and only recurse into the left subtree.</li>
<li>If the current node&rsquo;s value lies within the range <code>[low, high]</code>, we should add this value to the sum and continue searching both the left and right subtrees.</li>
</ul>
</li>
<li>
<p><strong>Base Case</strong>: The base case for recursion is when the current node is null, in which case we return 0 as there is nothing to sum.</p>
</li>
</ol>
<p>This approach ensures that we only traverse the relevant parts of the tree, making it more efficient than a simple brute-force traversal.</p>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<ol>
<li>
<p><strong>TreeNode Definition</strong>:
The problem assumes the following structure for the tree node:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> val;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>right;
</span></span><span style="display:flex;"><span>    TreeNode() <span style="color:#666">:</span> val(<span style="color:#666">0</span>), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x) <span style="color:#666">:</span> val(x), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x, TreeNode <span style="color:#666">*</span>left, TreeNode <span style="color:#666">*</span>right) <span style="color:#666">:</span> val(x), left(left), right(right) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>This is a standard definition for a binary tree node. Each node contains an integer value (<code>val</code>), and pointers to its left and right children.</p>
</li>
<li>
<p><strong>Recursive Function - <code>rangeSumBST</code></strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">rangeSumBST</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> low, <span style="color:#0b0;font-weight:bold">int</span> high) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    sum <span style="color:#666">+=</span> rangeSumBST(root<span style="color:#666">-&gt;</span>left, low, high);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val <span style="color:#666">&gt;=</span> low <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>val <span style="color:#666">&lt;=</span> high)
</span></span><span style="display:flex;"><span>        sum <span style="color:#666">+=</span> root<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>    sum <span style="color:#666">+=</span> rangeSumBST(root<span style="color:#666">-&gt;</span>right, low, high);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> sum;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p><strong>Base Case</strong>: <code>if(!root) return 0;</code></p>
<ul>
<li>If the current node is <code>null</code>, we return 0, as there are no nodes to sum in this part of the tree.</li>
</ul>
</li>
<li>
<p><strong>Recursive Traversal</strong>:</p>
<ul>
<li>We first call <code>rangeSumBST(root-&gt;left, low, high)</code> to process the left subtree. The sum of the left subtree nodes will be added to <code>sum</code>.</li>
<li>We then check if the current node’s value is within the specified range <code>[low, high]</code>. If it is, we add <code>root-&gt;val</code> to <code>sum</code>.</li>
<li>We finally call <code>rangeSumBST(root-&gt;right, low, high)</code> to process the right subtree and add its result to <code>sum</code>.</li>
</ul>
</li>
<li>
<p><strong>Return Value</strong>: After recursively summing the values in the left subtree, adding the value of the current node (if it is within the range), and summing the right subtree, we return the total sum for this subtree.</p>
</li>
</ul>
</li>
<li>
<p><strong>Efficiency</strong>:</p>
<ul>
<li>The function performs an in-order traversal of the tree, but with pruning: we only visit parts of the tree that might contain values within the given range. This pruning helps to skip unnecessary nodes, making the traversal more efficient than a full in-order traversal.</li>
</ul>
</li>
<li>
<p><strong>Final Sum</strong>: After the recursion finishes, the function returns the sum of all values in the range <code>[low, high]</code> in the tree.</p>
</li>
</ol>
<h3 id="complexity">Complexity</h3>
<ol>
<li>
<p><strong>Time Complexity</strong>:</p>
<ul>
<li>In the worst case, the algorithm needs to visit every node in the tree. However, due to the pruning technique, we can avoid traversing subtrees that are outside the range. Therefore, in the worst case, the time complexity is proportional to the number of nodes in the tree, <code>O(N)</code>, where <code>N</code> is the number of nodes in the tree.</li>
<li>In the best case, when the entire tree or large parts of it can be skipped due to pruning, the time complexity can be much less than <code>O(N)</code>.</li>
</ul>
</li>
<li>
<p><strong>Space Complexity</strong>:</p>
<ul>
<li>The space complexity is determined by the depth of the recursion stack. In the worst case, the depth of the recursion stack is equal to the height of the tree, which is <code>O(H)</code>, where <code>H</code> is the height of the tree.</li>
<li>For a balanced tree, the height is <code>O(log N)</code>, but in the worst case (for an unbalanced tree), the height can be <code>O(N)</code>.</li>
<li>Therefore, the space complexity is <code>O(H)</code>.</li>
</ul>
</li>
</ol>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently computes the sum of values within a given range in a Binary Search Tree using a recursive approach with pruning. By leveraging the properties of a BST, we avoid unnecessary traversal of subtrees that are outside the specified range, making the algorithm both efficient and elegant. The time complexity is <code>O(N)</code> in the worst case, where <code>N</code> is the number of nodes in the tree, and the space complexity is <code>O(H)</code>, where <code>H</code> is the height of the tree. This approach ensures that the solution is optimal for large trees and scales well with the size of the input.</p>
<p><a href="https://leetcode.com/problems/range-sum-of-bst/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/ISUXXRnKmx0?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2265: Count Nodes Equal to Average of Subtree | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2265: Count Nodes Equal to Average of Subtree">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2265: Count Nodes Equal to Average of Subtree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/solution-2265-count-nodes-equal-to-average-of-subtree/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2265: Count Nodes Equal to Average of Subtree">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2265: Count Nodes Equal to Average of Subtree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-03-25T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.a3d5489836b19de22a81ddc6bd21c17547d07529e67b266427378a04fa3ea727.css" integrity="sha256-o9VImDaxneIqgd3GvSHBdUfQdSnmeyZkJzeKBPo&#43;pyc=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="mainheading">
    <h1 class="sitetitle">grid47</h1>
    <p class="lead">
         Mohammed Yasir Eramangadan&#39;s Blog
    </p>
</div><div class="main-content">
        
        <div class="container">
            <div class="row">
                
                <div class="col-md-2 pl-0"><div class="share sticky-top sticky-top-offset">
    <p>Share</p>
    <ul>
        <li class="ml-1 mr-1">
        <a target="_blank" href="https://twitter.com/intent/tweet?text=Leetcode%202265%3a%20Count%20Nodes%20Equal%20to%20Average%20of%20Subtree&url=http%3a%2f%2flocalhost%3a1313%2fleetcode%2fsolution-2265-count-nodes-equal-to-average-of-subtree%2f" onclick="window.open(this.href, 'twitter-share', 'width=550,height=435');return false;">
        <i class="fab fa-twitter"></i>
        </a>
        </li>
        
        <li class="ml-1 mr-1">
        <a target="_blank" href="https://facebook.com/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fleetcode%2fsolution-2265-count-nodes-equal-to-average-of-subtree%2f" onclick="window.open(this.href, 'facebook-share', 'width=550,height=435');return false;">
        <i class="fab fa-facebook-f"></i>
        </a>
        </li>

        <li class="ml-1 mr-1">
        <a target="_blank" href="https://www.xing.com/spi/shares/new?url=http%3a%2f%2flocalhost%3a1313%2fleetcode%2fsolution-2265-count-nodes-equal-to-average-of-subtree%2f" onclick="window.open(this.href, 'xing-share', 'width=550,height=435');return false;">
        <i class="fab fa-xing"></i>
        </a>
        </li>        
    </ul>

    
</div>
</div>
                                
                <div class="col-md-9 flex-first flex-md-unordered">
                    <div class="mainheading">
                        	
                        
                        
                        
                        <div class="row post-top-meta">
                            <div class="col-xs-12 col-md-3 col-lg-2 text-center text-md-left mb-4 mb-md-0 md-nopad-right">
                                <img class="author-thumb" src="/images/logo.png" alt="grid47">
                            </div>
                            <div class="col-xs-12 col-md-9 col-lg-10 text-center text-md-left md-nopad-left">
                                <a target="_blank" class="link-dark">grid47</a><br>
                                <span class="author-description">
                                    Exploring patterns and algorithms<br>
                                    <i class="far fa-star"></i>
                                    Mar 25, 2024
                                    <i class="far fa-clock clock"></i>
                                    6 min read
                                </span>					
                            </div>
                        </div>			
                        	
                        
                                                
                        
                        <h1 class="posttitle">Leetcode 2265: Count Nodes Equal to Average of Subtree</h1> 
                    </div>

                    
                    
                    
                    

                    
                    <div class="article-post">
                        <hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode653s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>,<span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> solve(TreeNode<span style="color:#666">*</span> root){
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">==</span><span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> {<span style="color:#666">0</span>,<span style="color:#666">0</span>};
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">auto</span> left <span style="color:#666">=</span> solve(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> l_sum <span style="color:#666">=</span> left.first; <span style="color:#080;font-style:italic">// sum of nodes present in left sub tree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#0b0;font-weight:bold">int</span> l_cnt <span style="color:#666">=</span> left.second; <span style="color:#080;font-style:italic">// no. of nodes present in left sub tree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">auto</span> right <span style="color:#666">=</span> solve(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> r_sum <span style="color:#666">=</span> right.first; <span style="color:#080;font-style:italic">// sum of nodes present in right sub tree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#0b0;font-weight:bold">int</span> r_cnt <span style="color:#666">=</span> right.second; <span style="color:#080;font-style:italic">// no. of nodes present in left sub tree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> root<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> l_sum <span style="color:#666">+</span> r_sum;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> cnt <span style="color:#666">=</span> l_cnt <span style="color:#666">+</span> r_cnt <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> sum<span style="color:#666">/</span>cnt) ans<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> {sum,cnt};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">averageOfSubtree</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        solve(root);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>In this problem, you are given the root of a binary tree. Each node of the tree contains an integer value. The task is to find the number of nodes whose value is equal to the average of the values of the nodes in its subtree (including itself). The average of a node&rsquo;s subtree is defined as the sum of the values of all nodes in the subtree divided by the total number of nodes in the subtree.</p>
<p>You need to return the total count of nodes that satisfy the condition where the node&rsquo;s value is equal to the average of its subtree.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we can use a <strong>post-order traversal</strong> approach where:</p>
<ol>
<li>We recursively compute the sum and the count of nodes in the subtree rooted at each node.</li>
<li>For each node, we check if the value of the node equals the average of its subtree. If it does, we increase the count of such nodes.</li>
<li>We return both the sum and the number of nodes in the subtree for each node to facilitate calculations at its parent node.</li>
</ol>
<p>Here’s a more structured explanation of the approach:</p>
<ol>
<li><strong>Subtree Information</strong>: For each node, we need to calculate the sum of all nodes in its subtree and the total number of nodes in the subtree.</li>
<li><strong>Check Average</strong>: After calculating the sum and count of nodes in the subtree, we compare the value of the node with the average of its subtree, which is computed as <code>sum / count</code>.</li>
<li><strong>Recursion</strong>: We perform a post-order traversal of the tree, starting from the leaf nodes and moving upwards to the root. This ensures that when calculating the sum and count for a node, we already have the information for its left and right children.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="step-1-define-the-treenode-structure">Step 1: Define the TreeNode structure</h4>
<p>The <code>TreeNode</code> structure is defined as:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> val;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>right;
</span></span><span style="display:flex;"><span>    TreeNode() <span style="color:#666">:</span> val(<span style="color:#666">0</span>), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x) <span style="color:#666">:</span> val(x), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x, TreeNode <span style="color:#666">*</span>left, TreeNode <span style="color:#666">*</span>right) <span style="color:#666">:</span> val(x), left(left), right(right) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>This is a typical definition for a binary tree node, where <code>val</code> stores the value of the node, and <code>left</code> and <code>right</code> are pointers to its left and right child nodes, respectively.</p>
<h4 id="step-2-initialize-global-variables">Step 2: Initialize global variables</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div><ul>
<li><code>ans</code> is initialized to <code>0</code> and will keep track of the number of nodes whose value is equal to the average of their respective subtrees.</li>
</ul>
<h4 id="step-3-define-the-recursive-solve-function">Step 3: Define the recursive <code>solve</code> function</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> solve(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> {<span style="color:#666">0</span>, <span style="color:#666">0</span>};
</span></span></code></pre></div><ul>
<li>The <code>solve</code> function takes a <code>TreeNode* root</code> as input and returns a pair of integers:
<ul>
<li>The first element of the pair represents the sum of node values in the subtree rooted at <code>root</code>.</li>
<li>The second element represents the number of nodes in the subtree.</li>
</ul>
</li>
<li>If <code>root</code> is <code>NULL</code> (base case), we return a pair <code>{0, 0}</code>, indicating that there are no nodes in the subtree and the sum is zero.</li>
</ul>
<h4 id="step-4-recursively-solve-for-the-left-and-right-subtrees">Step 4: Recursively solve for the left and right subtrees</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">auto</span> left <span style="color:#666">=</span> solve(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> l_sum <span style="color:#666">=</span> left.first; <span style="color:#080;font-style:italic">// sum of nodes in the left subtree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#0b0;font-weight:bold">int</span> l_cnt <span style="color:#666">=</span> left.second; <span style="color:#080;font-style:italic">// number of nodes in the left subtree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">auto</span> right <span style="color:#666">=</span> solve(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> r_sum <span style="color:#666">=</span> right.first; <span style="color:#080;font-style:italic">// sum of nodes in the right subtree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#0b0;font-weight:bold">int</span> r_cnt <span style="color:#666">=</span> right.second; <span style="color:#080;font-style:italic">// number of nodes in the right subtree
</span></span></span></code></pre></div><ul>
<li>We recursively call the <code>solve</code> function for the left and right children of the current node. We store the results for the left and right subtrees, which include the sum and count of nodes.</li>
</ul>
<h4 id="step-5-calculate-the-sum-and-count-for-the-current-subtree">Step 5: Calculate the sum and count for the current subtree</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> root<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> l_sum <span style="color:#666">+</span> r_sum;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> cnt <span style="color:#666">=</span> l_cnt <span style="color:#666">+</span> r_cnt <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span></code></pre></div><ul>
<li>The total sum for the subtree rooted at the current node is the sum of:
<ul>
<li>The value of the current node (<code>root-&gt;val</code>).</li>
<li>The sum of the left subtree (<code>l_sum</code>).</li>
<li>The sum of the right subtree (<code>r_sum</code>).</li>
</ul>
</li>
<li>The total count for the subtree is the sum of:
<ul>
<li>The count of nodes in the left subtree (<code>l_cnt</code>).</li>
<li>The count of nodes in the right subtree (<code>r_cnt</code>).</li>
<li>1 (for the current node itself).</li>
</ul>
</li>
</ul>
<h4 id="step-6-check-if-the-nodes-value-equals-the-average-of-its-subtree">Step 6: Check if the node&rsquo;s value equals the average of its subtree</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span> (root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> sum <span style="color:#666">/</span> cnt) ans<span style="color:#666">++</span>;
</span></span></code></pre></div><ul>
<li>We check if the value of the current node (<code>root-&gt;val</code>) is equal to the average of its subtree, which is <code>sum / cnt</code>. If they are equal, we increment the <code>ans</code> variable, indicating that we found a node whose value equals the average of its subtree.</li>
</ul>
<h4 id="step-7-return-the-sum-and-count-of-the-current-subtree">Step 7: Return the sum and count of the current subtree</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> {sum, cnt};
</span></span></code></pre></div><ul>
<li>After processing the current node, we return the sum and count of the nodes in the subtree rooted at <code>root</code>.</li>
</ul>
<h4 id="step-8-invoke-the-solve-function-and-return-the-result">Step 8: Invoke the <code>solve</code> function and return the result</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">averageOfSubtree</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    solve(root);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>The <code>averageOfSubtree</code> function is the entry point for the solution. It invokes the <code>solve</code> function on the root of the binary tree and returns the value of <code>ans</code>, which is the total number of nodes whose value equals the average of their subtree.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<p>The time complexity of this solution is <strong>O(n)</strong>, where <code>n</code> is the number of nodes in the binary tree. This is because we visit each node exactly once during the post-order traversal, and at each node, we perform constant-time operations (sum and count calculations, comparisons, and increments).</p>
<h4 id="space-complexity">Space Complexity:</h4>
<p>The space complexity is <strong>O(h)</strong>, where <code>h</code> is the height of the binary tree. This is the space required for the recursion stack in the worst case. In the worst case, the tree is skewed (like a linked list), and the height is <code>n</code>. In the best case (balanced tree), the height is <code>log n</code>.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently computes the number of nodes in the binary tree whose value is equal to the average of the nodes in their subtree. By leveraging a post-order traversal, the algorithm computes the sum and count of each subtree while checking if the current node satisfies the condition. The solution has a time complexity of <strong>O(n)</strong>, making it optimal for large trees, and uses a recursion stack with space complexity <strong>O(h)</strong>. This approach is both effective and efficient for solving the problem of subtree averages in binary trees.</p>
<p><a href="https://leetcode.com/problems/count-nodes-equal-to-average-of-subtree/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/yg9A3yLTcsE?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

                    </div>
                    
                    
                    <div class="after-post-tags">
                        <ul class="tags">
                        
                        <li>
                        <a href="/tags/tree">Tree</a>
                        </li>
                        
                        <li>
                        <a href="/tags/depth-first-search">Depth-First Search</a>
                        </li>
                        
                        <li>
                        <a href="/tags/binary-tree">Binary Tree</a>
                        </li>
                        
                        </ul>
                    </div>
                    
                    
                    
                    <div class="row PageNavigation d-flex justify-content-between font-weight-bold">
                    
                        <a class="d-block col-md-6" href="http://localhost:1313/leetcode/solution-2264-largest-3-same-digit-number-in-string/"> &laquo; Leetcode 2264: Largest 3-Same-Digit Number in String</a>
                    
                    
                        <a class="d-block col-md-6 text-lg-right" href="http://localhost:1313/leetcode/solution-2266-count-number-of-texts/">Leetcode 2266: Count Number of Texts &raquo;</a>
                    
                    <div class="clearfix"></div>
                    </div>
                    
                </div>
                
            </div>
        </div>
        
        
    </div>


            </div>
<div class="jumbotron fortags">
	<div class="d-md-flex h-100">
		<div class="col-md-4 transpdark align-self-center text-center h-100">
			<div class="d-md-flex align-items-center justify-content-center h-100">
				<h2 class="d-md-block d-none align-self-center py-1 font-weight-light">Explore <span class="d-none d-md-inline">→</span></h2>
			</div>
		</div>
		<div class="col-md-8 p-5 align-self-center text-center">
			
			<a class="mt-1 mb-1" href="/tags/array">array</a>
			
			<a class="mt-1 mb-1" href="/tags/backtracking">backtracking</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-indexed-tree">binary indexed tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search">binary search</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-search-tree">binary search tree</a>
			
			<a class="mt-1 mb-1" href="/tags/binary-tree">binary tree</a>
			
			<a class="mt-1 mb-1" href="/tags/bit-manipulation">bit manipulation</a>
			
			<a class="mt-1 mb-1" href="/tags/bitmask">bitmask</a>
			
			<a class="mt-1 mb-1" href="/tags/brainteaser">brainteaser</a>
			
			<a class="mt-1 mb-1" href="/tags/breadth-first-search">breadth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/bucket-sort">bucket sort</a>
			
			<a class="mt-1 mb-1" href="/tags/combinatorics">combinatorics</a>
			
			<a class="mt-1 mb-1" href="/tags/concurrency">concurrency</a>
			
			<a class="mt-1 mb-1" href="/tags/counting">counting</a>
			
			<a class="mt-1 mb-1" href="/tags/counting-sort">counting sort</a>
			
			<a class="mt-1 mb-1" href="/tags/data-stream">data stream</a>
			
			<a class="mt-1 mb-1" href="/tags/database">database</a>
			
			<a class="mt-1 mb-1" href="/tags/depth-first-search">depth-first search</a>
			
			<a class="mt-1 mb-1" href="/tags/design">design</a>
			
			<a class="mt-1 mb-1" href="/tags/divide-and-conquer">divide and conquer</a>
			
			<a class="mt-1 mb-1" href="/tags/doubly-linked-list">doubly-linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/dynamic-programming">dynamic programming</a>
			
			<a class="mt-1 mb-1" href="/tags/enumeration">enumeration</a>
			
			<a class="mt-1 mb-1" href="/tags/game-theory">game theory</a>
			
			<a class="mt-1 mb-1" href="/tags/geometry">geometry</a>
			
			<a class="mt-1 mb-1" href="/tags/graph">graph</a>
			
			<a class="mt-1 mb-1" href="/tags/greedy">greedy</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-function">hash function</a>
			
			<a class="mt-1 mb-1" href="/tags/hash-table">hash table</a>
			
			<a class="mt-1 mb-1" href="/tags/heap-priority-queue">heap (priority queue)</a>
			
			<a class="mt-1 mb-1" href="/tags/interactive">interactive</a>
			
			<a class="mt-1 mb-1" href="/tags/iterator">iterator</a>
			
			<a class="mt-1 mb-1" href="/tags/linked-list">linked list</a>
			
			<a class="mt-1 mb-1" href="/tags/math">math</a>
			
			<a class="mt-1 mb-1" href="/tags/matrix">matrix</a>
			
			<a class="mt-1 mb-1" href="/tags/memoization">memoization</a>
			
			<a class="mt-1 mb-1" href="/tags/minimum-spanning-tree">minimum spanning tree</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-queue">monotonic queue</a>
			
			<a class="mt-1 mb-1" href="/tags/monotonic-stack">monotonic stack</a>
			
			<a class="mt-1 mb-1" href="/tags/number-theory">number theory</a>
			
			<a class="mt-1 mb-1" href="/tags/ordered-set">ordered set</a>
			
			<a class="mt-1 mb-1" href="/tags/prefix-sum">prefix sum</a>
			
			<a class="mt-1 mb-1" href="/tags/probability-and-statistics">probability and statistics</a>
			
			<a class="mt-1 mb-1" href="/tags/queue">queue</a>
			
			<a class="mt-1 mb-1" href="/tags/quickselect">quickselect</a>
			
			<a class="mt-1 mb-1" href="/tags/radix-sort">radix sort</a>
			
			<a class="mt-1 mb-1" href="/tags/randomized">randomized</a>
			
			<a class="mt-1 mb-1" href="/tags/recursion">recursion</a>
			
			<a class="mt-1 mb-1" href="/tags/reservoir-sampling">reservoir sampling</a>
			
			<a class="mt-1 mb-1" href="/tags/rolling-hash">rolling hash</a>
			
			<a class="mt-1 mb-1" href="/tags/segment-tree">segment tree</a>
			
			<a class="mt-1 mb-1" href="/tags/shortest-path">shortest path</a>
			
			<a class="mt-1 mb-1" href="/tags/simulation">simulation</a>
			
			<a class="mt-1 mb-1" href="/tags/sliding-window">sliding window</a>
			
			<a class="mt-1 mb-1" href="/tags/sorting">sorting</a>
			
			<a class="mt-1 mb-1" href="/tags/stack">stack</a>
			
			<a class="mt-1 mb-1" href="/tags/string">string</a>
			
			<a class="mt-1 mb-1" href="/tags/string-matching">string matching</a>
			
			<a class="mt-1 mb-1" href="/tags/topological-sort">topological sort</a>
			
			<a class="mt-1 mb-1" href="/tags/tree">tree</a>
			
			<a class="mt-1 mb-1" href="/tags/trie">trie</a>
			
			<a class="mt-1 mb-1" href="/tags/two-pointers">two pointers</a>
			
			<a class="mt-1 mb-1" href="/tags/union-find">union find</a>
			
		</div>
	</div>
</div>

<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            <div class="col-md-6 col-sm-6 text-center text-lg-right">    
                <a target="_blank" rel="noopener" href="https://www.wowthemes.net">Mediumish Theme</a> by WowThemes.net
            </div>
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

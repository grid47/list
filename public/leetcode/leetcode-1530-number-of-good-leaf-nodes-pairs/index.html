<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 1530: Number of Good Leaf Nodes Pairs | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1530: Number of Good Leaf Nodes Pairs">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1530: Number of Good Leaf Nodes Pairs in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-1530-number-of-good-leaf-nodes-pairs/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1530: Number of Good Leaf Nodes Pairs">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1530: Number of Good Leaf Nodes Pairs in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-06-07T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 1530: Number of Good Leaf Nodes Pairs</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode263s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">countPairs</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> dist) {
</span></span><span style="display:flex;"><span>        dfs(root, dist);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dfs(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> dist) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) {
</span></span><span style="display:flex;"><span>            vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res(dist <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>left <span style="color:#666">==</span> <span style="color:#a2f">NULL</span> <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>right <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>            vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res(dist <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>            res[<span style="color:#666">1</span>]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> left <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>left, dist);
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> right <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>right, dist);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">1</span>; i <span style="color:#666">&lt;=</span> dist <span style="color:#666">-</span> <span style="color:#666">1</span>; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> dist <span style="color:#666">-</span> <span style="color:#666">1</span>; j <span style="color:#666">&gt;=</span> <span style="color:#666">1</span>; j<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">+</span> j <span style="color:#666">&lt;=</span> dist)
</span></span><span style="display:flex;"><span>                ans <span style="color:#666">+=</span> left[i] <span style="color:#666">*</span> right[j];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res(dist <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">1</span>; i <span style="color:#666">&lt;=</span> dist <span style="color:#666">-</span> <span style="color:#666">2</span>; i<span style="color:#666">++</span> ) {
</span></span><span style="display:flex;"><span>            res[i <span style="color:#666">+</span> <span style="color:#666">1</span>] <span style="color:#666">=</span> left[i] <span style="color:#666">+</span> right[i];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The task is to count the number of good leaf node pairs in a binary tree. A pair of leaf nodes is considered &ldquo;good&rdquo; if their distance (the number of edges between them) is less than or equal to a given distance <code>dist</code>. The function should return the total count of such good leaf pairs.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we will use a depth-first search (DFS) approach. The key idea is to traverse the binary tree and, at each node, collect the distances of its leaf nodes. We will maintain a count of how many leaf nodes are at each distance from the current node. For every pair of distances from the left and right subtrees, we will check if their sum is less than or equal to <code>dist</code>. If it is, we add to our total count of good leaf pairs.</p>
<p>Here&rsquo;s a breakdown of the approach:</p>
<ol>
<li>
<p><strong>DFS Traversal</strong>: We perform a DFS starting from the root of the tree. At each node, we will compute the counts of leaf nodes at different distances.</p>
</li>
<li>
<p><strong>Base Cases</strong>:</p>
<ul>
<li>If the current node is <code>NULL</code>, we return a vector initialized to zero counts for each distance.</li>
<li>If the current node is a leaf (both left and right children are <code>NULL</code>), we return a vector with the count of leaf nodes at distance 1 (the current leaf).</li>
</ul>
</li>
<li>
<p><strong>Count Pairs</strong>:</p>
<ul>
<li>For every node, we combine the results from its left and right subtrees to count good leaf pairs. We do this by iterating through all possible distances from the left and right subtrees and checking if their sum is within the allowed distance <code>dist</code>.</li>
</ul>
</li>
<li>
<p><strong>Result Compilation</strong>: We compile the results into a vector that holds the counts of leaf nodes at each distance and return this vector to the parent call.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>Here&rsquo;s the provided code explained step by step:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">0</span>;  <span style="color:#080;font-style:italic">// To store the total count of good leaf pairs
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">countPairs</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> dist) {
</span></span><span style="display:flex;"><span>        dfs(root, dist);  <span style="color:#080;font-style:italic">// Start DFS from the root
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">return</span> ans;  <span style="color:#080;font-style:italic">// Return the total count
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span></code></pre></div><ul>
<li>We define a class <code>Solution</code> with a public method <code>countPairs</code> that initializes the DFS traversal.</li>
<li>We maintain a variable <code>ans</code> to count the number of good leaf pairs.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> dfs(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> dist) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) {
</span></span><span style="display:flex;"><span>            vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res(dist <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#666">0</span>);  <span style="color:#080;font-style:italic">// Return a zeroed vector for a null node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><ul>
<li>The <code>dfs</code> function takes the current node and the maximum distance as arguments.</li>
<li>If the current node is <code>NULL</code>, we return a zeroed vector of size <code>dist + 1</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>left <span style="color:#666">==</span> <span style="color:#a2f">NULL</span> <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>right <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>            vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res(dist <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#666">0</span>);  <span style="color:#080;font-style:italic">// For a leaf node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            res[<span style="color:#666">1</span>]<span style="color:#666">++</span>;  <span style="color:#080;font-style:italic">// There is one leaf at distance 1
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><ul>
<li>If we encounter a leaf node, we create a vector <code>res</code> initialized to zero and increment the count of leaf nodes at distance 1 before returning it.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> left <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>left, dist);  <span style="color:#080;font-style:italic">// Recur for left subtree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> right <span style="color:#666">=</span> dfs(root<span style="color:#666">-&gt;</span>right, dist);  <span style="color:#080;font-style:italic">// Recur for right subtree
</span></span></span></code></pre></div><ul>
<li>We recursively call <code>dfs</code> on the left and right children of the current node, storing the results in vectors <code>left</code> and <code>right</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">1</span>; i <span style="color:#666">&lt;=</span> dist <span style="color:#666">-</span> <span style="color:#666">1</span>; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> dist <span style="color:#666">-</span> <span style="color:#666">1</span>; j <span style="color:#666">&gt;=</span> <span style="color:#666">1</span>; j<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(i <span style="color:#666">+</span> j <span style="color:#666">&lt;=</span> dist)
</span></span><span style="display:flex;"><span>                    ans <span style="color:#666">+=</span> left[i] <span style="color:#666">*</span> right[j];  <span style="color:#080;font-style:italic">// Count good pairs
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><ul>
<li>Here, we iterate through the counts of leaf nodes from both subtrees.</li>
<li>For every combination of distances from the left (<code>i</code>) and right (<code>j</code>), we check if their sum is less than or equal to <code>dist</code>. If it is, we update <code>ans</code> by multiplying the counts from both sides.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res(dist <span style="color:#666">+</span> <span style="color:#666">1</span>, <span style="color:#666">0</span>);  <span style="color:#080;font-style:italic">// Prepare result vector for current node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">1</span>; i <span style="color:#666">&lt;=</span> dist <span style="color:#666">-</span> <span style="color:#666">2</span>; i<span style="color:#666">++</span> ) {
</span></span><span style="display:flex;"><span>            res[i <span style="color:#666">+</span> <span style="color:#666">1</span>] <span style="color:#666">=</span> left[i] <span style="color:#666">+</span> right[i];  <span style="color:#080;font-style:italic">// Combine counts of leaf nodes at distances
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;  <span style="color:#080;font-style:italic">// Return the counts to parent call
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>We prepare a result vector <code>res</code> to store counts of leaf nodes at each distance from the current node.</li>
<li>We populate this vector based on the counts from the left and right subtrees and return it to the parent call.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity</h4>
<ul>
<li>The time complexity of this algorithm is (O(N \cdot D)), where (N) is the number of nodes in the tree, and (D) is the maximum distance (or depth) we are considering. Each node may contribute to pair counts based on its distance from the leaf nodes in its subtrees.</li>
</ul>
<h4 id="space-complexity">Space Complexity</h4>
<ul>
<li>The space complexity is (O(D)) due to the recursive stack and the vectors used to store counts of leaf nodes at different distances. In the worst case, this could be proportional to the depth of the tree.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently counts good leaf node pairs in a binary tree using a recursive depth-first search approach. By collecting leaf node counts at various distances from each node and then combining these counts appropriately, we can achieve the desired result. This method is particularly effective due to its straightforward recursive structure, making it easy to implement and understand.</p>
<p><strong>Key Takeaways</strong>:</p>
<ul>
<li><strong>Recursive DFS Traversal</strong>: Utilizing recursion allows for an elegant and clear traversal of the binary tree.</li>
<li><strong>Dynamic Counting</strong>: The solution dynamically counts distances, enabling the efficient counting of good leaf pairs.</li>
<li><strong>Handling Edge Cases</strong>: The implementation correctly handles cases of leaf nodes and null nodes, ensuring robustness.</li>
</ul>
<p>This approach is not only efficient but also serves as a good example of applying DFS in tree problems, which is a common technique in data structure and algorithm challenges.</p>
<p><a href="https://leetcode.com/problems/number-of-good-leaf-nodes-pairs/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/f_epkBeS1LQ?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

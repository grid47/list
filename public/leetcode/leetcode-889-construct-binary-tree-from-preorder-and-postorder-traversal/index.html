<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 889: Construct Binary Tree from Preorder and Postorder Traversal | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 889: Construct Binary Tree from Preorder and Postorder Traversal">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 889: Construct Binary Tree from Preorder and Postorder Traversal in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-889-construct-binary-tree-from-preorder-and-postorder-traversal/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 889: Construct Binary Tree from Preorder and Postorder Traversal">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 889: Construct Binary Tree from Preorder and Postorder Traversal in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-08-10T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="Divide and Conquer">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 889: Construct Binary Tree from Preorder and Postorder Traversal</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1373s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> preIdx <span style="color:#666">=</span> <span style="color:#666">0</span>, postIdx <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> <span style="color:#00a000">constructFromPrePost</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> preorder, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> postorder) {
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#666">*</span> root <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(preorder[preIdx<span style="color:#666">++</span>]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val  <span style="color:#666">!=</span> postorder[postIdx])
</span></span><span style="display:flex;"><span>            root<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> constructFromPrePost(preorder, postorder);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val  <span style="color:#666">!=</span> postorder[postIdx])
</span></span><span style="display:flex;"><span>            root<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> constructFromPrePost(preorder, postorder);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        postIdx<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem at hand is to reconstruct a binary tree from two traversal sequences: <strong>preorder</strong> and <strong>postorder</strong>. Given two arrays <code>preorder</code> and <code>postorder</code>, the task is to construct the binary tree. The tree nodes are represented by a structure <code>TreeNode</code> that contains a <code>val</code> (node value), a <code>left</code> pointer to the left child, and a <code>right</code> pointer to the right child.</p>
<ul>
<li>
<p><strong>Preorder Traversal</strong>: A type of depth-first traversal where the root node is visited first, followed by the left subtree, and then the right subtree.</p>
</li>
<li>
<p><strong>Postorder Traversal</strong>: A type of depth-first traversal where the left subtree is visited first, followed by the right subtree, and then the root node.</p>
</li>
</ul>
<p>Given these two traversal sequences, the objective is to reconstruct the binary tree uniquely. The challenge lies in leveraging both traversals to efficiently reconstruct the tree structure.</p>
<h3 id="approach">Approach</h3>
<p>The approach used to solve this problem revolves around recursive tree construction using the <strong>preorder</strong> and <strong>postorder</strong> traversals. The key observations for solving the problem are:</p>
<ol>
<li><strong>Preorder traversal</strong> gives the root of the tree (or subtrees) first.</li>
<li><strong>Postorder traversal</strong> gives the root of the tree (or subtrees) last.</li>
</ol>
<h4 id="steps">Steps:</h4>
<ol>
<li><strong>First Step (Preorder root)</strong>: From the <strong>preorder</strong> traversal, the first element corresponds to the root of the current subtree (or the entire tree if we are starting from the root).</li>
<li><strong>Recursive Subtrees</strong>: After identifying the root node, we recursively build the left and right subtrees by identifying the respective elements in the <strong>preorder</strong> and <strong>postorder</strong> arrays.</li>
<li><strong>Postorder Consistency</strong>: In <strong>postorder</strong> traversal, the root of a subtree is always the last element. As we build the left and right subtrees recursively, we ensure that the subtrees&rsquo; root nodes are correctly matched by the postorder traversal.</li>
</ol>
<p>The solution is designed to traverse both arrays (preorder and postorder) and build the binary tree recursively while maintaining consistency between the two traversal sequences.</p>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<ol>
<li>
<p><strong>TreeNode Structure</strong>:
The <code>TreeNode</code> struct represents the binary tree node and is defined as follows:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> val;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>right;
</span></span><span style="display:flex;"><span>    TreeNode() <span style="color:#666">:</span> val(<span style="color:#666">0</span>), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x) <span style="color:#666">:</span> val(x), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x, TreeNode <span style="color:#666">*</span>left, TreeNode <span style="color:#666">*</span>right) <span style="color:#666">:</span> val(x), left(left), right(right) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The <code>TreeNode</code> contains:</p>
<ul>
<li><code>val</code>: The integer value of the node.</li>
<li><code>left</code>: A pointer to the left child node.</li>
<li><code>right</code>: A pointer to the right child node.</li>
</ul>
</li>
<li>
<p><strong>Recursive Tree Construction</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>TreeNode<span style="color:#666">*</span> <span style="color:#00a000">constructFromPrePost</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> preorder, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> postorder) {
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> root <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(preorder[preIdx<span style="color:#666">++</span>]);  <span style="color:#080;font-style:italic">// Step 1: Get the root node
</span></span></span></code></pre></div><ul>
<li>A new root node is created using the first element from the <code>preorder</code> array (i.e., the current root).</li>
<li>We increment the <code>preIdx</code> to move to the next element in the <code>preorder</code> array for subsequent recursive calls.</li>
</ul>
</li>
<li>
<p><strong>Constructing Left Subtree</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val <span style="color:#666">!=</span> postorder[postIdx])  <span style="color:#080;font-style:italic">// Ensure left subtree exists
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    root<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> constructFromPrePost(preorder, postorder);
</span></span></code></pre></div><ul>
<li>The condition checks if the value of the current root node (from <code>preorder</code>) is not equal to the current value in <code>postorder</code> (tracked by <code>postIdx</code>). If this is true, the left subtree exists, and we proceed to recursively construct it.</li>
</ul>
</li>
<li>
<p><strong>Constructing Right Subtree</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val <span style="color:#666">!=</span> postorder[postIdx])  <span style="color:#080;font-style:italic">// Ensure right subtree exists
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    root<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> constructFromPrePost(preorder, postorder);
</span></span></code></pre></div><ul>
<li>Similarly, if the root node value is not equal to the current value in <code>postorder</code>, we recursively construct the right subtree.</li>
</ul>
</li>
<li>
<p><strong>Postorder Completion</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>postIdx<span style="color:#666">++</span>;  <span style="color:#080;font-style:italic">// Move to the next postorder element
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">return</span> root;  <span style="color:#080;font-style:italic">// Return the constructed root node
</span></span></span></code></pre></div><ul>
<li>After constructing both subtrees (left and right), we increment <code>postIdx</code> to track the next element in the <code>postorder</code> traversal and return the constructed tree.</li>
</ul>
</li>
<li>
<p><strong>Global Indices</strong>:</p>
<ul>
<li>The indices <code>preIdx</code> and <code>postIdx</code> are used to keep track of the current position in the <code>preorder</code> and <code>postorder</code> arrays. These indices are global to ensure that the recursive calls can access and update them properly.</li>
</ul>
</li>
</ol>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li>The solution performs a single pass over both <code>preorder</code> and <code>postorder</code> arrays, with each element being processed exactly once. For each recursive call, we update the indices and create nodes. Thus, the time complexity is <strong>O(N)</strong>, where <code>N</code> is the number of nodes in the tree (which is also the length of the <code>preorder</code> or <code>postorder</code> array).</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li>The space complexity is <strong>O(N)</strong> due to the recursion stack and the space required to store the binary tree. We use additional space to store the tree nodes (<code>N</code> nodes in total), and the recursion stack depth can also go up to <code>N</code> in the worst case (if the tree is skewed).</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently reconstructs a binary tree from the given <strong>preorder</strong> and <strong>postorder</strong> traversals using a recursive approach. The key to solving this problem is the relationship between the root and the order of nodes in the two traversal sequences. By keeping track of the current root in <strong>preorder</strong> and ensuring consistency with the last element in <strong>postorder</strong>, the binary tree is reconstructed step by step.</p>
<p>The solution is optimal in both time and space, with a linear time complexity of <strong>O(N)</strong>, making it suitable for large input sizes. This approach ensures that the tree is reconstructed correctly and efficiently, leveraging both the <strong>preorder</strong> and <strong>postorder</strong> traversal properties.</p>
<p><a href="https://leetcode.com/problems/construct-binary-tree-from-preorder-and-postorder-traversal/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>
<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

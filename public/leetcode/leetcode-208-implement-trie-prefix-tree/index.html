<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 208: Implement Trie (Prefix Tree) | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 208: Implement Trie (Prefix Tree)">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 208: Implement Trie (Prefix Tree) in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-208-implement-trie-prefix-tree/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 208: Implement Trie (Prefix Tree)">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 208: Implement Trie (Prefix Tree) in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-10-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="String">
    <meta property="article:tag" content="Design">
    <meta property="article:tag" content="Trie">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 208: Implement Trie (Prefix Tree)</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode548s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/208.webp" 
           alt="A tree structure formed from words, with each node glowing softly, symbolizing the prefix search structure." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 208: Implement Trie (Prefix Tree) Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode548s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Node</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>Node<span style="color:#666">*&gt;</span> chd;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> isWord;
</span></span><span style="display:flex;"><span>    Node(<span style="color:#0b0;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>        chd.resize(n, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        isWord <span style="color:#666">=</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Trie</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    Node<span style="color:#666">*</span> root;
</span></span><span style="display:flex;"><span>    Trie() {
</span></span><span style="display:flex;"><span>        root <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> Node(<span style="color:#666">26</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">insert</span>(string word) {
</span></span><span style="display:flex;"><span>        Node<span style="color:#666">*</span> node <span style="color:#666">=</span> root;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> word.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>)
</span></span><span style="display:flex;"><span>                node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> Node(<span style="color:#666">26</span>);
</span></span><span style="display:flex;"><span>            node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        node<span style="color:#666">-&gt;</span>isWord <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">search</span>(string word) {
</span></span><span style="display:flex;"><span>        Node<span style="color:#666">*</span> node <span style="color:#666">=</span> root;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> word.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>            node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> node<span style="color:#666">-&gt;</span>isWord;        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">startsWith</span>(string word) {
</span></span><span style="display:flex;"><span>        Node<span style="color:#666">*</span> node <span style="color:#666">=</span> root;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> word.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>            node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Your Trie object will be instantiated and called as such:
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Trie* obj = new Trie();
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * obj-&gt;insert(word);
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * bool param_2 = obj-&gt;search(word);
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * bool param_3 = obj-&gt;startsWith(prefix);
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span></span></span></code></pre></div></h2>
<h3 id="-problem-statement">üåü Problem Statement</h3>
<p>In this problem, we need to design and implement a <strong>Trie</strong> (also known as a <strong>prefix tree</strong>), which is a powerful data structure used for efficiently storing and searching strings. A Trie allows for fast insertions, lookups, and prefix matching, making it ideal for tasks like autocomplete and dictionary-based operations.</p>
<p>The operations that need to be implemented are:</p>
<ol>
<li><strong>Insert:</strong> Insert a word into the Trie.</li>
<li><strong>Search:</strong> Check if a specific word exists in the Trie.</li>
<li><strong>StartsWith:</strong> Check if any word in the Trie starts with a given prefix.</li>
</ol>
<hr>
<h3 id="-approach">üß† Approach</h3>
<p>The Trie works by breaking down each word into characters and storing them in a tree structure. Each node represents a character, and paths from the root to leaf nodes represent the words or prefixes in the Trie. The beauty of a Trie is that strings with common prefixes share nodes, which leads to memory optimization.</p>
<p>The implementation will include three main operations:</p>
<ul>
<li><strong>Insert:</strong> Add a word to the Trie by inserting each character one by one.</li>
<li><strong>Search:</strong> Traverse the Trie based on the word&rsquo;s characters and check if the word exists.</li>
<li><strong>StartsWith:</strong> Check if a prefix exists in the Trie by traversing through the Trie based on the prefix‚Äôs characters.</li>
</ul>
<p>Each node will have:</p>
<ul>
<li>A vector <code>chd[]</code> for the 26 possible characters (for lowercase English letters).</li>
<li>A boolean <code>isWord</code> to mark if the node represents the end of a valid word.</li>
</ul>
<hr>
<h3 id="-step-by-step-code-breakdown">üî® Step-by-Step Code Breakdown</h3>
<h4 id="1-node-class-definition">1. <strong>Node Class Definition</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Node</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>Node<span style="color:#666">*&gt;</span> chd;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> isWord;
</span></span><span style="display:flex;"><span>    Node(<span style="color:#0b0;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>        chd.resize(n, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        isWord <span style="color:#666">=</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li><strong>Node Class:</strong> Represents each character in the Trie. It has:
<ul>
<li><strong><code>chd[]</code>:</strong> A vector holding child nodes. There are 26 possible child nodes (one for each lowercase English letter).</li>
<li><strong><code>isWord</code>:</strong> Marks whether the current node is the last character of a word.</li>
<li><strong>Constructor:</strong> Initializes the <code>chd</code> vector and sets <code>isWord</code> to <code>false</code>.</li>
</ul>
</li>
</ul>
<h4 id="2-trie-class-definition">2. <strong>Trie Class Definition</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Trie</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    Node<span style="color:#666">*</span> root;
</span></span><span style="display:flex;"><span>    Trie() {
</span></span><span style="display:flex;"><span>        root <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> Node(<span style="color:#666">26</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ul>
<li><strong>Root Node:</strong> The <code>root</code> is the starting point of the Trie, initialized with a <code>Node</code> that supports 26 children (for each letter of the alphabet).</li>
</ul>
<h4 id="3-insert-function">3. <strong>Insert Function</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">insert</span>(string word) {
</span></span><span style="display:flex;"><span>    Node<span style="color:#666">*</span> node <span style="color:#666">=</span> root;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> word.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>)
</span></span><span style="display:flex;"><span>            node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> Node(<span style="color:#666">26</span>);
</span></span><span style="display:flex;"><span>        node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    node<span style="color:#666">-&gt;</span>isWord <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Insert Operation:</strong> Adds a word to the Trie:
<ul>
<li>Traverse each character in the word.</li>
<li>If the corresponding child node doesn‚Äôt exist, create a new one.</li>
<li>Move to the next character and repeat.</li>
<li>Finally, mark the last node as the end of a word.</li>
</ul>
</li>
</ul>
<h4 id="4-search-function">4. <strong>Search Function</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">search</span>(string word) {
</span></span><span style="display:flex;"><span>    Node<span style="color:#666">*</span> node <span style="color:#666">=</span> root;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> word.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>        node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> node<span style="color:#666">-&gt;</span>isWord;        
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Search Operation:</strong> Checks if a word exists:
<ul>
<li>Traverse the Trie based on the characters of the word.</li>
<li>If a character is missing in the Trie (child node is <code>NULL</code>), return <code>false</code>.</li>
<li>If we reach the last character and it‚Äôs marked as the end of a word, return <code>true</code>.</li>
</ul>
</li>
</ul>
<h4 id="5-startswith-function">5. <strong>StartsWith Function</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">startsWith</span>(string word) {
</span></span><span style="display:flex;"><span>    Node<span style="color:#666">*</span> node <span style="color:#666">=</span> root;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> word.size(); i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>] <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>        node <span style="color:#666">=</span> node<span style="color:#666">-&gt;</span>chd[word[i] <span style="color:#666">-</span> <span style="color:#b44">&#39;a&#39;</span>];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">true</span>;        
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Prefix Matching:</strong> Checks if a prefix exists:
<ul>
<li>Traverse the Trie based on the characters of the prefix.</li>
<li>If at any point the character doesn‚Äôt exist, return <code>false</code>.</li>
<li>If the entire prefix is found, return <code>true</code>.</li>
</ul>
</li>
</ul>
<hr>
<h3 id="-complexity-analysis">üìà Complexity Analysis</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>Insert Operation:</strong> Each insertion involves traversing the Trie for each character in the word. Thus, the time complexity for <strong>insert</strong> is <strong>O(L)</strong>, where <code>L</code> is the length of the word.</li>
<li><strong>Search Operation:</strong> Searching for a word also involves traversing each character, so the time complexity for <strong>search</strong> is <strong>O(L)</strong>.</li>
<li><strong>StartsWith Operation:</strong> Like the search function, the time complexity for <strong>startsWith</strong> is <strong>O(L)</strong>, where <code>L</code> is the length of the prefix.</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>Space Complexity:</strong> The space required is <strong>O(N)</strong>, where <code>N</code> is the total number of nodes created. Since each node has an array of 26 child nodes, the space depends on the number of nodes and the depth of the Trie.</li>
</ul>
<hr>
<h3 id="-conclusion">üèÅ Conclusion</h3>
<p>The Trie is a highly efficient data structure for managing strings, allowing fast insertion, search, and prefix matching. By storing common prefixes only once, it optimizes space usage while providing fast access to words and prefixes.</p>
<p>With the <strong>Insert</strong>, <strong>Search</strong>, and <strong>StartsWith</strong> operations all running in <strong>O(L)</strong> time, where <code>L</code> is the length of the string or prefix, this structure is well-suited for tasks like autocompletion, spell-checking, and dictionary lookups.</p>
<p>The <strong>Trie</strong> class we‚Äôve implemented can handle large datasets efficiently, making it an invaluable tool for many applications where fast string lookup is needed! üåü</p>
<p><a href="https://leetcode.com/problems/implement-trie-prefix-tree/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/rJRTji53Ggk?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

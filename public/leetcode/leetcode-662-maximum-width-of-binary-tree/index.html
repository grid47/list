<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 662: Maximum Width of Binary Tree | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 662: Maximum Width of Binary Tree">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 662: Maximum Width of Binary Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-662-maximum-width-of-binary-tree/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 662: Maximum Width of Binary Tree">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 662: Maximum Width of Binary Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-09-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 662: Maximum Width of Binary Tree</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1242s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/662.webp" 
           alt="A binary tree where the maximum width is highlighted, with the width softly glowing as itâ€™s measured." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 662: Maximum Width of Binary Tree Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1242s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> widthOfBinaryTree(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> width <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        q.push({root, <span style="color:#666">0</span>});
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> f <span style="color:#666">=</span> q.front().second;
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> b <span style="color:#666">=</span> q.back().second;
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> cnt <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> cnt; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>                TreeNode<span style="color:#666">*</span> elem <span style="color:#666">=</span> q.front().first;
</span></span><span style="display:flex;"><span>                <span style="color:#0b0;font-weight:bold">int</span> idx <span style="color:#666">=</span> q.front().second <span style="color:#666">-</span> b;
</span></span><span style="display:flex;"><span>                q.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(elem<span style="color:#666">-&gt;</span>left  <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) q.push({elem<span style="color:#666">-&gt;</span>left,  <span style="color:#666">2</span> <span style="color:#666">*</span> idx <span style="color:#666">+</span> <span style="color:#666">1</span>});
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(elem<span style="color:#666">-&gt;</span>right <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) q.push({elem<span style="color:#666">-&gt;</span>right, <span style="color:#666">2</span> <span style="color:#666">*</span> idx <span style="color:#666">+</span> <span style="color:#666">2</span>});                
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            width <span style="color:#666">=</span> max(width, b <span style="color:#666">-</span> f <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> width;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem at hand requires determining the <strong>maximum width of a binary tree</strong>. The width of a binary tree is defined as the number of nodes on the <strong>longest level</strong> of the tree. To calculate this width efficiently, we need to consider both the <strong>level structure</strong> and the <strong>position of nodes</strong> at each level.</p>
<ul>
<li>The binary tree nodes are given by the <code>TreeNode</code> struct, which contains three fields: <code>val</code> (the value of the node), <code>left</code> (pointer to the left child), and <code>right</code> (pointer to the right child).</li>
<li>The goal is to return the maximum width of the binary tree, which is the maximum number of nodes present at any level of the tree.</li>
</ul>
<h3 id="approach">Approach</h3>
<p>To calculate the maximum width of a binary tree, we can take advantage of <strong>level-order traversal</strong> (also known as <strong>breadth-first traversal</strong>). The general approach is as follows:</p>
<ol>
<li>Use a <strong>queue</strong> to implement the level-order traversal of the binary tree.</li>
<li>At each level, record the <strong>position of the nodes</strong>. The position can be calculated by assigning each node an index that reflects its relative position within the level.</li>
<li>For each level, calculate the difference between the first and last node positions and update the width accordingly.</li>
<li>Track the maximum width observed during the traversal.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>The algorithm is implemented in the <code>Solution</code> class with the <code>widthOfBinaryTree</code> function. Let&rsquo;s break down the code step by step.</p>
<h4 id="1-edge-case-handling-empty-tree">1. <strong>Edge Case Handling (Empty Tree)</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span></code></pre></div><ul>
<li>Before starting the main logic, we handle the edge case where the root is <code>NULL</code>. In this case, the width is obviously <code>0</code>, and we return <code>0</code>.</li>
</ul>
<h4 id="2-queue-initialization">2. <strong>Queue Initialization</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> width <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>q.push({root, <span style="color:#666">0</span>});
</span></span></code></pre></div><ul>
<li>We declare a queue of pairs: each pair consists of a <code>TreeNode*</code> (the node) and an integer (its index at that level).</li>
<li>We initialize the queue by pushing the root node with an index of <code>0</code>. This index will represent the position of the root in the tree.</li>
</ul>
<h4 id="3-level-order-traversal">3. <strong>Level-Order Traversal</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> f <span style="color:#666">=</span> q.front().second;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> b <span style="color:#666">=</span> q.back().second;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> cnt <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> cnt; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#666">*</span> elem <span style="color:#666">=</span> q.front().first;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> idx <span style="color:#666">=</span> q.front().second <span style="color:#666">-</span> b;
</span></span><span style="display:flex;"><span>        q.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(elem<span style="color:#666">-&gt;</span>left <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) q.push({elem<span style="color:#666">-&gt;</span>left, <span style="color:#666">2</span> <span style="color:#666">*</span> idx <span style="color:#666">+</span> <span style="color:#666">1</span>});
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(elem<span style="color:#666">-&gt;</span>right <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) q.push({elem<span style="color:#666">-&gt;</span>right, <span style="color:#666">2</span> <span style="color:#666">*</span> idx <span style="color:#666">+</span> <span style="color:#666">2</span>});
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    width <span style="color:#666">=</span> max(width, b <span style="color:#666">-</span> f <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p><strong>While loop</strong>: We perform a level-order traversal using a <code>queue</code> that stores the nodes along with their respective indices. The traversal continues as long as the queue is not empty.</p>
</li>
<li>
<p><strong>f (front) and b (back)</strong>: We extract the <code>front</code> and <code>back</code> elements of the queue to calculate the width at the current level. The index difference between the front and back elements represents the width at that level.</p>
</li>
<li>
<p><strong>cnt (count)</strong>: The number of elements at the current level. This is equal to the size of the queue at the start of the loop.</p>
</li>
<li>
<p><strong>For loop</strong>: For each element in the current level:</p>
<ul>
<li>We compute the relative index (<code>idx</code>) of the current node by subtracting the back element&rsquo;s index (<code>b</code>) from the current node&rsquo;s index (<code>q.front().second</code>).</li>
<li>After processing the current node, we remove it from the queue (<code>q.pop()</code>).</li>
<li>If the node has a left child, we add it to the queue with the calculated index <code>2 * idx + 1</code>.</li>
<li>Similarly, if the node has a right child, we add it to the queue with the calculated index <code>2 * idx + 2</code>.</li>
</ul>
</li>
<li>
<p><strong>Width Update</strong>: After processing all nodes at the current level, we calculate the width as <code>b - f + 1</code> (difference between the indices of the back and front nodes plus one), and update the <code>width</code> variable to store the maximum width encountered so far.</p>
</li>
</ul>
<h4 id="4-return-the-result">4. <strong>Return the Result</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> width;
</span></span></code></pre></div><ul>
<li>Once the level-order traversal is complete, we return the maximum width observed during the process.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>O(n)</strong>: Each node is processed once in the <code>while</code> loop and within the inner <code>for</code> loop. Since each node is added and removed from the queue exactly once, the overall time complexity is linear with respect to the number of nodes, i.e., <code>O(n)</code>, where <code>n</code> is the number of nodes in the binary tree.</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>O(n)</strong>: The queue can store up to <code>n</code> nodes in the worst case (if the tree is skewed, such as in a degenerate tree). Therefore, the space complexity is proportional to the number of nodes in the tree.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This algorithm efficiently calculates the maximum width of a binary tree using a level-order traversal (breadth-first search). By using the indices of the nodes, it effectively computes the width at each level without the need to explicitly store the positions of all nodes at each level. The algorithm handles all edge cases, such as trees with fewer nodes or skewed trees, and provides an optimal solution with a time complexity of <code>O(n)</code> and a space complexity of <code>O(n)</code>. This approach is well-suited for solving problems involving tree traversal and calculating properties related to the width or levels of binary trees.</p>
<p><a href="https://leetcode.com/problems/maximum-width-of-binary-tree/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/zHz0Ut1r-_8?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

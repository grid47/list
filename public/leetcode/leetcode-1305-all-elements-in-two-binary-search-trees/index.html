<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 1305: All Elements in Two Binary Search Trees | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1305: All Elements in Two Binary Search Trees">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1305: All Elements in Two Binary Search Trees in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-1305-all-elements-in-two-binary-search-trees/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1305: All Elements in Two Binary Search Trees">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1305: All Elements in Two Binary Search Trees in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-06-29T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Search Tree">
    <meta property="article:tag" content="Sorting">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 1305: All Elements in Two Binary Search Trees</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode144s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> getAllElements(TreeNode<span style="color:#666">*</span> root1, TreeNode<span style="color:#666">*</span> root2) {
</span></span><span style="display:flex;"><span>        stack<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> st1, st2;
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(root1 <span style="color:#666">||</span> root2 <span style="color:#666">||</span> <span style="color:#666">!</span>st1.empty() <span style="color:#666">||</span> <span style="color:#666">!</span>st2.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span>(root1) {
</span></span><span style="display:flex;"><span>                st1.push(root1);
</span></span><span style="display:flex;"><span>                root1 <span style="color:#666">=</span> root1<span style="color:#666">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span>(root2) {
</span></span><span style="display:flex;"><span>                st2.push(root2);
</span></span><span style="display:flex;"><span>                root2 <span style="color:#666">=</span> root2<span style="color:#666">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(st2.empty() <span style="color:#666">||</span> (<span style="color:#666">!</span>st1.empty() <span style="color:#666">&amp;&amp;</span> st1.top()<span style="color:#666">-&gt;</span>val <span style="color:#666">&lt;</span> st2.top()<span style="color:#666">-&gt;</span>val)) {
</span></span><span style="display:flex;"><span>                root1 <span style="color:#666">=</span> st1.top();
</span></span><span style="display:flex;"><span>                st1.pop();
</span></span><span style="display:flex;"><span>                res.push_back(root1<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>                root1 <span style="color:#666">=</span> root1<span style="color:#666">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                root2 <span style="color:#666">=</span> st2.top();
</span></span><span style="display:flex;"><span>                st2.pop();
</span></span><span style="display:flex;"><span>                res.push_back(root2<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>                root2 <span style="color:#666">=</span> root2<span style="color:#666">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>Given two binary search trees (BSTs), the task is to merge all of their elements into a single sorted list. This requires performing an in-order traversal on both trees to access their elements in ascending order, and then merging the results. The solution should have a time complexity close to (O(m + n)), where (m) and (n) are the number of nodes in each tree, and it should avoid using extra space beyond the necessary output list.</p>
<h3 id="approach">Approach</h3>
<p>This solution uses <strong>in-order traversal</strong> and <strong>two stacks</strong> to simulate iterators for each BST:</p>
<ol>
<li><strong>In-Order Traversal</strong>: Since BSTs have elements in sorted order when traversed in-order, this traversal helps us access each tree’s elements in ascending order.</li>
<li><strong>Stack-Based Iterative In-Order Traversal</strong>: Instead of recursive traversal, this approach uses stacks to store nodes from each tree, simulating an in-order traversal. Each time the traversal visits a node, it either processes the node if it’s the smallest available node or goes to the next node’s right child.</li>
<li><strong>Simultaneous Traversal and Merge</strong>: By pushing nodes from both trees onto their respective stacks, we can compare the current smallest elements of each tree. The smaller value is added to the result list, and the corresponding traversal continues.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<ol>
<li>
<p><strong>Class and Method Definition</strong>:</p>
<ul>
<li>We define a class <code>Solution</code> with a public method <code>getAllElements</code> that takes pointers to two tree roots, <code>root1</code> and <code>root2</code>, as input and returns a sorted list of all elements from both trees.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> getAllElements(TreeNode<span style="color:#666">*</span> root1, TreeNode<span style="color:#666">*</span> root2) {
</span></span></code></pre></div></li>
<li>
<p><strong>Initialize Stacks and Result Vector</strong>:</p>
<ul>
<li>Two stacks, <code>st1</code> and <code>st2</code>, are initialized to store nodes for in-order traversal. A vector <code>res</code> is also initialized to store the sorted result.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        stack<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> st1, st2;
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;
</span></span></code></pre></div></li>
<li>
<p><strong>Loop until Traversal is Complete</strong>:</p>
<ul>
<li>The main <code>while</code> loop continues until both trees are completely traversed, which occurs when both <code>root1</code> and <code>root2</code> are <code>NULL</code> and both stacks are empty.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(root1 <span style="color:#666">||</span> root2 <span style="color:#666">||</span> <span style="color:#666">!</span>st1.empty() <span style="color:#666">||</span> <span style="color:#666">!</span>st2.empty()) {
</span></span></code></pre></div></li>
<li>
<p><strong>Push All Left Children to Stack</strong>:</p>
<ul>
<li>For both <code>root1</code> and <code>root2</code>, a nested <code>while</code> loop pushes all left children onto their respective stacks. This simulates moving to the smallest element in each tree.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span>(root1) {
</span></span><span style="display:flex;"><span>                st1.push(root1);
</span></span><span style="display:flex;"><span>                root1 <span style="color:#666">=</span> root1<span style="color:#666">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span>(root2) {
</span></span><span style="display:flex;"><span>                st2.push(root2);
</span></span><span style="display:flex;"><span>                root2 <span style="color:#666">=</span> root2<span style="color:#666">-&gt;</span>left;
</span></span><span style="display:flex;"><span>            }
</span></span></code></pre></div></li>
<li>
<p><strong>Merge Elements from Stacks</strong>:</p>
<ul>
<li>After both stacks are set up with left children, the code compares the top elements of each stack (the smallest unprocessed elements in each tree):
<ul>
<li>If <code>st2</code> is empty or <code>st1</code> has a smaller value than <code>st2</code>, the top element of <code>st1</code> is added to the result, and traversal continues to the right child of that element in <code>root1</code>.</li>
<li>Otherwise, the top element of <code>st2</code> is processed, added to the result, and traversal moves to its right child in <code>root2</code>.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(st2.empty() <span style="color:#666">||</span> (<span style="color:#666">!</span>st1.empty() <span style="color:#666">&amp;&amp;</span> st1.top()<span style="color:#666">-&gt;</span>val <span style="color:#666">&lt;</span> st2.top()<span style="color:#666">-&gt;</span>val)) {
</span></span><span style="display:flex;"><span>                root1 <span style="color:#666">=</span> st1.top();
</span></span><span style="display:flex;"><span>                st1.pop();
</span></span><span style="display:flex;"><span>                res.push_back(root1<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>                root1 <span style="color:#666">=</span> root1<span style="color:#666">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                root2 <span style="color:#666">=</span> st2.top();
</span></span><span style="display:flex;"><span>                st2.pop();
</span></span><span style="display:flex;"><span>                res.push_back(root2<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>                root2 <span style="color:#666">=</span> root2<span style="color:#666">-&gt;</span>right;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div></li>
<li>
<p><strong>Return the Result</strong>:</p>
<ul>
<li>After processing all nodes, the result vector <code>res</code> contains all elements from both trees in sorted order.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div></li>
</ol>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: (O(m + n)), where (m) and (n) are the number of nodes in <code>root1</code> and <code>root2</code>, respectively. Each node is visited exactly once, and the operations performed at each node are constant time.</li>
<li><strong>Space Complexity</strong>: (O(h1 + h2)), where (h1) and (h2) are the heights of the two trees. The stacks store at most <code>h1</code> and <code>h2</code> nodes, respectively, which is the space needed for a complete in-order traversal.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution provides an efficient and scalable way to merge elements from two BSTs into a sorted list by simulating in-order traversal iteratively with two stacks. By managing left children and comparisons iteratively, the approach avoids recursion and minimizes space usage beyond the necessary result list. This algorithm is particularly effective for balanced BSTs, where the time complexity is close to linear, and is adaptable for trees with varying structures or heights.</p>
<p><a href="https://leetcode.com/problems/all-elements-in-two-binary-search-trees/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/B97Hk1H2x2s?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 1145: Binary Tree Coloring Game | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1145: Binary Tree Coloring Game">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1145: Binary Tree Coloring Game in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-1145-binary-tree-coloring-game/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1145: Binary Tree Coloring Game">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1145: Binary Tree Coloring Game in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-07-15T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 1145: Binary Tree Coloring Game</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode83s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> lft, rht, val;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">btreeGameWinningMove</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> n, <span style="color:#0b0;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>        val <span style="color:#666">=</span> x;
</span></span><span style="display:flex;"><span>        cout<span style="color:#666">&lt;&lt;</span> n;
</span></span><span style="display:flex;"><span>        n <span style="color:#666">=</span> count(root);
</span></span><span style="display:flex;"><span>        cout<span style="color:#666">&lt;&lt;</span> n <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span>;        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> max(max(lft, rht), n <span style="color:#666">-</span> lft<span style="color:#666">-</span>rht <span style="color:#666">-</span><span style="color:#666">1</span>) <span style="color:#666">&gt;</span> n<span style="color:#666">/</span><span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">count</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> l <span style="color:#666">=</span> count(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> r <span style="color:#666">=</span> count(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> val)
</span></span><span style="display:flex;"><span>        lft <span style="color:#666">=</span> l, rht <span style="color:#666">=</span> r;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> l <span style="color:#666">+</span> r <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>In the &ldquo;Binary Tree Coloring Game,&rdquo; two players take turns coloring nodes on a binary tree. Player 1 starts by coloring a node, referred to as <code>x</code>. Player 2 then has the option to color any uncolored node on the tree. The objective of the game is for one player to gain control over more than half of the tree nodes.</p>
<p>Given the root of a binary tree, the total number of nodes <code>n</code>, and the initial node <code>x</code> that Player 1 colors, determine whether Player 2 can make a move to win the game by controlling more than half of the nodes.</p>
<h3 id="approach">Approach</h3>
<p>The solution takes a recursive approach to count the nodes in the binary tree, and it calculates the number of nodes on each side of the tree relative to the node <code>x</code>. The strategy focuses on Player 2&rsquo;s winning options by dividing the tree into three regions:</p>
<ol>
<li><strong>Left Subtree of Node <code>x</code></strong> (<code>lft</code>)</li>
<li><strong>Right Subtree of Node <code>x</code></strong> (<code>rht</code>)</li>
<li><strong>Remaining nodes excluding the subtree rooted at <code>x</code></strong></li>
</ol>
<p>To determine if Player 2 can win:</p>
<ol>
<li>The algorithm checks whether the largest region among these three has more than half of the total nodes.</li>
<li>If the largest region has more than <code>n / 2</code> nodes, Player 2 can win by coloring a node in that region.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>Here’s a breakdown of each part of the code:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span></code></pre></div><ul>
<li><strong>Lines 1-12</strong>: The code begins by defining the <code>TreeNode</code> structure and a <code>Solution</code> class that contains the solution to the problem.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> lft, rht, val;
</span></span></code></pre></div><ul>
<li><strong>Line 13</strong>: These are instance variables:
<ul>
<li><code>lft</code> and <code>rht</code> store the number of nodes in the left and right subtrees of the node <code>x</code>, respectively.</li>
<li><code>val</code> stores the value of node <code>x</code>.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> <span style="color:#00a000">btreeGameWinningMove</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">int</span> n, <span style="color:#0b0;font-weight:bold">int</span> x) {
</span></span><span style="display:flex;"><span>        val <span style="color:#666">=</span> x;
</span></span><span style="display:flex;"><span>        cout<span style="color:#666">&lt;&lt;</span> n;
</span></span></code></pre></div><ul>
<li><strong>Line 14-16</strong>: The <code>btreeGameWinningMove</code> function is defined with three parameters: the root of the tree, the total number of nodes <code>n</code>, and the value <code>x</code> representing the initial node chosen by Player 1. The value of <code>x</code> is stored in <code>val</code> for reference.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        n <span style="color:#666">=</span> count(root);
</span></span><span style="display:flex;"><span>        cout<span style="color:#666">&lt;&lt;</span> n <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;</span><span style="color:#b62;font-weight:bold">\n</span><span style="color:#b44">&#34;</span>;
</span></span></code></pre></div><ul>
<li><strong>Line 17-18</strong>: The <code>count</code> function is called to calculate the number of nodes in the tree and to populate the values of <code>lft</code> and <code>rht</code> by traversing the tree. The output <code>n</code> is re-assigned the result of <code>count</code> for further use.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">max</span>(max(lft, rht), n <span style="color:#666">-</span> lft <span style="color:#666">-</span> rht <span style="color:#666">-</span> <span style="color:#666">1</span>) <span style="color:#666">&gt;</span> n <span style="color:#666">/</span> <span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ul>
<li><strong>Line 19</strong>: The function returns a boolean result. It calculates the maximum node count in any of the three regions and checks if it exceeds <code>n / 2</code>. If it does, Player 2 has a winning move by taking control of that region.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">count</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span></code></pre></div><ul>
<li><strong>Line 20-21</strong>: The <code>count</code> helper function is defined, which recursively counts the number of nodes in the binary tree. If <code>root</code> is null, it returns <code>0</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> l <span style="color:#666">=</span> count(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> r <span style="color:#666">=</span> count(root<span style="color:#666">-&gt;</span>right);
</span></span></code></pre></div><ul>
<li><strong>Line 22-23</strong>: The function calls itself recursively for both the left and right subtrees, storing the count of nodes in <code>l</code> and <code>r</code>, respectively.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> val)
</span></span><span style="display:flex;"><span>            lft <span style="color:#666">=</span> l, rht <span style="color:#666">=</span> r;
</span></span></code></pre></div><ul>
<li><strong>Line 24-25</strong>: If the current node has the same value as <code>val</code> (i.e., it’s the node <code>x</code> chosen by Player 1), the values of <code>lft</code> and <code>rht</code> are set to <code>l</code> and <code>r</code>. This allows us to know the number of nodes in the left and right subtrees of <code>x</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> l <span style="color:#666">+</span> r <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li><strong>Line 26-28</strong>: The function returns the total node count for the current subtree, which is the sum of nodes in the left and right subtrees plus the root node itself.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: The time complexity is ( O(n) ) because the <code>count</code> function traverses all nodes in the binary tree once to determine the node counts for each subtree.</p>
</li>
<li>
<p><strong>Space Complexity</strong>: The space complexity is ( O(h) ), where ( h ) is the height of the binary tree. This accounts for the recursive stack used in the depth-first traversal, which can go as deep as the height of the tree.</p>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This C++ solution effectively determines whether Player 2 can win the &ldquo;Binary Tree Coloring Game&rdquo; by using a recursive function to count the nodes in the left and right subtrees of node <code>x</code>. The code then assesses whether any of the three possible regions has more than half of the total nodes, which would allow Player 2 to win. By taking advantage of a well-structured recursive approach, this solution provides an efficient way to handle binary tree manipulation and maximize control in a competitive game scenario.</p>
<p><a href="https://leetcode.com/problems/binary-tree-coloring-game/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/DIXDTh-aOQ4?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

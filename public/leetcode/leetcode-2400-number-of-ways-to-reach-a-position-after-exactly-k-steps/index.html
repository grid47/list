<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2400: Number of Ways to Reach a Position After Exactly k Steps | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2400: Number of Ways to Reach a Position After Exactly k Steps">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2400: Number of Ways to Reach a Position After Exactly k Steps in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2400-number-of-ways-to-reach-a-position-after-exactly-k-steps/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2400: Number of Ways to Reach a Position After Exactly k Steps">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2400: Number of Ways to Reach a Position After Exactly k Steps in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-03-12T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Math">
    <meta property="article:tag" content="Dynamic Programming">
    <meta property="article:tag" content="Combinatorics">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2400: Number of Ways to Reach a Position After Exactly k Steps</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode736s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> dp[<span style="color:#666">1001</span>][<span style="color:#666">1001</span>] <span style="color:#666">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> mod <span style="color:#666">=</span> <span style="color:#666">1000000007</span>;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> numberOfWays(<span style="color:#0b0;font-weight:bold">int</span> start, <span style="color:#0b0;font-weight:bold">int</span> end, <span style="color:#0b0;font-weight:bold">int</span> k) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">dfs</span>(k, abs(start <span style="color:#666">-</span> end));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">dfs</span>(<span style="color:#0b0;font-weight:bold">int</span> k, <span style="color:#0b0;font-weight:bold">int</span> d) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (d <span style="color:#666">&gt;=</span> k) <span style="color:#a2f;font-weight:bold">return</span> d <span style="color:#666">==</span> k;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(dp[k][d] <span style="color:#666">==</span> <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>            dp[k][d] <span style="color:#666">=</span> (<span style="color:#666">1</span> <span style="color:#666">+</span> dfs(k<span style="color:#666">-</span><span style="color:#666">1</span>, d <span style="color:#666">+</span> <span style="color:#666">1</span>) <span style="color:#666">+</span> dfs(k <span style="color:#666">-</span><span style="color:#666">1</span>, abs(d <span style="color:#666">-</span><span style="color:#666">1</span>))) <span style="color:#666">%</span> mod;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> dp[k][d] <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>We are tasked with determining the number of ways to reach a target position from a starting position with exactly <code>k</code> moves, where each move can either increase, decrease, or keep the current position unchanged. The positions are considered on a one-dimensional number line, and we are given two integers: <code>start</code> and <code>end</code>, which represent the initial and target positions, respectively.</p>
<p>Given the constraints:</p>
<ul>
<li>We need to calculate how many different ways we can move from <code>start</code> to <code>end</code> using exactly <code>k</code> moves.</li>
</ul>
<p>For example:</p>
<ul>
<li><strong>Input</strong>: <code>start = 1, end = 3, k = 2</code></li>
<li><strong>Output</strong>: <code>1</code>
<ul>
<li>Explanation: The only valid sequence of moves is: 1 → 2 → 3.</li>
</ul>
</li>
</ul>
<h3 id="approach">Approach</h3>
<p>This problem can be viewed as a dynamic programming problem where we want to count the number of valid sequences of moves that bring us from the <code>start</code> position to the <code>end</code> position in exactly <code>k</code> moves. Here&rsquo;s the step-by-step approach to solving the problem:</p>
<ol>
<li>
<p><strong>Recursive Exploration</strong>:</p>
<ul>
<li>At each step, we can either:
<ul>
<li>Increase the current position.</li>
<li>Decrease the current position.</li>
<li>Stay at the current position.</li>
</ul>
</li>
<li>Given that we are allowed exactly <code>k</code> moves, we need to explore all possible paths from <code>start</code> to <code>end</code> using these three types of moves.</li>
</ul>
</li>
<li>
<p><strong>Dynamic Programming to Avoid Redundant Calculations</strong>:</p>
<ul>
<li>Instead of recalculating the number of ways for the same state multiple times, we use a <strong>memoization</strong> technique with a dynamic programming table (<code>dp</code>). This table will store the results for subproblems to avoid redundant calculations.</li>
<li>The <code>dp[k][d]</code> entry represents the number of ways to move from <code>start</code> to <code>end</code> with exactly <code>k</code> moves, where the current distance is <code>d</code> (distance between the current position and the target position).</li>
</ul>
</li>
<li>
<p><strong>Base Case</strong>:</p>
<ul>
<li>If the current distance is greater than the number of remaining moves, then there are no valid paths to the target. Thus, the result is <code>0</code> in such cases.</li>
<li>If the distance is equal to the number of remaining moves (<code>d == k</code>), it means we have exactly reached the target in the given number of moves. This is the base case of our recursion.</li>
</ul>
</li>
<li>
<p><strong>Memoization</strong>:</p>
<ul>
<li>We will use memoization to store already computed results for a given <code>k</code> and <code>d</code> in the <code>dp</code> table. If a state has been computed before, we can simply return the stored result.</li>
</ul>
</li>
<li>
<p><strong>Modular Arithmetic</strong>:</p>
<ul>
<li>Since the result can be very large, the solution uses a modulus operation with <code>1000000007</code> to keep the numbers manageable and to avoid overflow.</li>
</ul>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="step-1-initialize-dp-table">Step 1: Initialize DP Table</h4>
<p>The <code>dp</code> table is initialized globally with all entries set to <code>0</code>. The size of the table is <code>1001 x 1001</code> because the maximum number of moves (<code>k</code>) is <code>1000</code> and the maximum distance (<code>d</code>) between the starting and target positions is also bounded by <code>1000</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> dp[<span style="color:#666">1001</span>][<span style="color:#666">1001</span>] <span style="color:#666">=</span> {};
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> mod <span style="color:#666">=</span> <span style="color:#666">1000000007</span>;
</span></span></code></pre></div><h4 id="step-2-main-function">Step 2: Main Function</h4>
<p>The main function <code>numberOfWays</code> is called with <code>start</code>, <code>end</code>, and <code>k</code> as input parameters. It computes the absolute difference between the start and end positions (<code>d = abs(start - end)</code>) and calls the <code>dfs</code> (depth-first search) function to compute the result.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">numberOfWays</span>(<span style="color:#0b0;font-weight:bold">int</span> start, <span style="color:#0b0;font-weight:bold">int</span> end, <span style="color:#0b0;font-weight:bold">int</span> k) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> dfs(k, abs(start <span style="color:#666">-</span> end));
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h4 id="step-3-depth-first-search-dfs-with-memoization">Step 3: Depth-First Search (DFS) with Memoization</h4>
<p>The <code>dfs</code> function performs the recursive computation. It takes two parameters:</p>
<ul>
<li><code>k</code>: The number of remaining moves.</li>
<li><code>d</code>: The current distance between the <code>start</code> and <code>end</code> positions.</li>
</ul>
<p>The function first checks if the current distance is greater than or equal to the remaining moves (<code>d &gt;= k</code>). If it is, the function checks whether <code>d == k</code>. If the distance equals <code>k</code>, it returns <code>1</code>, indicating a valid path. Otherwise, it returns <code>0</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span> (d <span style="color:#666">&gt;=</span> k) <span style="color:#a2f;font-weight:bold">return</span> d <span style="color:#666">==</span> k;
</span></span></code></pre></div><p>If the state <code>(k, d)</code> has already been computed (i.e., <code>dp[k][d] &gt; 0</code>), the function returns the stored value from the <code>dp</code> table.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(dp[k][d] <span style="color:#666">==</span> <span style="color:#666">0</span>)
</span></span></code></pre></div><p>If the value is not already computed, we recursively calculate the result by considering three possibilities:</p>
<ol>
<li>We can increase the distance by 1 (<code>dfs(k - 1, d + 1)</code>).</li>
<li>We can decrease the distance by 1 (<code>dfs(k - 1, abs(d - 1))</code>).</li>
<li>We can keep the distance unchanged (<code>dfs(k - 1, d)</code>).</li>
</ol>
<p>The result is the sum of these three possibilities, plus 1 to account for the current move.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>dp[k][d] <span style="color:#666">=</span> (<span style="color:#666">1</span> <span style="color:#666">+</span> dfs(k<span style="color:#666">-</span><span style="color:#666">1</span>, d <span style="color:#666">+</span> <span style="color:#666">1</span>) <span style="color:#666">+</span> dfs(k <span style="color:#666">-</span> <span style="color:#666">1</span>, abs(d <span style="color:#666">-</span> <span style="color:#666">1</span>))) <span style="color:#666">%</span> mod;
</span></span></code></pre></div><p>Finally, the function returns <code>dp[k][d] - 1</code> because we started with an initial move that doesn&rsquo;t count in the recursive calculations.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> dp[k][d] <span style="color:#666">-</span> <span style="color:#666">1</span>;
</span></span></code></pre></div><h4 id="step-4-return-the-result">Step 4: Return the Result</h4>
<p>After all recursive calls and memoization, the result is stored in <code>dp[k][d]</code>, and we return the number of ways to reach the target position in exactly <code>k</code> moves.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> dp[k][d] <span style="color:#666">-</span> <span style="color:#666">1</span>;
</span></span></code></pre></div><h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity</h4>
<ul>
<li>The function <code>dfs</code> is called recursively, and for each state <code>(k, d)</code>, we are computing the result at most once due to memoization.</li>
<li>The <code>dp</code> table has <code>1001 x 1001</code> entries, and each entry is computed once.</li>
<li>The overall time complexity is therefore <strong>O(k * d)</strong>, where <code>k</code> is the number of moves and <code>d</code> is the maximum possible distance between <code>start</code> and <code>end</code>.</li>
</ul>
<h4 id="space-complexity">Space Complexity</h4>
<ul>
<li>The space complexity is determined by the size of the <code>dp</code> table, which is <strong>O(k * d)</strong>. Given that the maximum values of <code>k</code> and <code>d</code> are both <code>1000</code>, the space complexity is <strong>O(1001 * 1001)</strong>.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution uses dynamic programming to efficiently compute the number of ways to reach a target position from a starting position in exactly <code>k</code> moves. The approach involves memoization to avoid redundant calculations, and the modular arithmetic ensures the result remains within the bounds of standard data types. The time and space complexities are manageable, making this solution suitable for large inputs.</p>
<p>Key Takeaways:</p>
<ul>
<li>The problem is solved using a recursive approach with memoization to track the number of ways to reach the target position.</li>
<li>The use of dynamic programming ensures that subproblems are solved only once, improving efficiency.</li>
<li>The modular arithmetic ensures that the result remains within bounds and prevents overflow.</li>
</ul>
<p><a href="https://leetcode.com/problems/number-of-ways-to-reach-a-position-after-exactly-k-steps/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/gFsI5OR-GfQ?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

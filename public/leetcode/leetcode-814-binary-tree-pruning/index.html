<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 814: Binary Tree Pruning | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 814: Binary Tree Pruning">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 814: Binary Tree Pruning in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-814-binary-tree-pruning/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 814: Binary Tree Pruning">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 814: Binary Tree Pruning in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-08-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 814: Binary Tree Pruning</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1325s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/814.webp" 
           alt="A binary tree where branches are pruned, with the pruned branches glowing softly as they are removed." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 814: Binary Tree Pruning Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1325s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> pruneTree(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> pruneTree(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>right<span style="color:#666">=</span> pruneTree(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>left <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>right <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem requires pruning a binary tree based on certain conditions. Specifically, we are tasked with removing all subtrees that do not contain any <code>1</code>s. In the context of this problem, each node in the binary tree contains either a <code>0</code> or a <code>1</code>. A subtree is pruned if it only contains <code>0</code>s, and if a node itself is <code>0</code> and it has no children with a <code>1</code>, it should be removed. The pruning operation should ensure that only those nodes and subtrees that are necessary for the tree to have a <code>1</code> remain.</p>
<p>We are given the root of a binary tree and need to return the root of the pruned tree. If the root itself is pruned, we return <code>NULL</code>.</p>
<h3 id="approach">Approach</h3>
<p>This problem can be efficiently solved by using a <strong>Depth First Search (DFS)</strong> approach, combined with <strong>recursion</strong> to traverse the tree and prune the subtrees that do not contain any <code>1</code>s.</p>
<ol>
<li><strong>DFS Traversal</strong>: We start at the root of the binary tree and recursively prune both the left and right subtrees.</li>
<li><strong>Prune Condition</strong>: After pruning the left and right subtrees, we check whether the current node itself should be pruned. A node is pruned if:
<ul>
<li>It has no left or right child (i.e., both children are <code>NULL</code>).</li>
<li>The node&rsquo;s value is <code>0</code>.</li>
</ul>
</li>
<li><strong>Post-Pruning</strong>: If a node&rsquo;s value is <code>0</code> and both its left and right subtrees are <code>NULL</code>, the node is pruned (i.e., the function returns <code>NULL</code>).</li>
<li><strong>Return Pruned Tree</strong>: If the node does not meet the pruning condition, we return it, either with or without a pruned subtree, depending on the result of the DFS traversal on its left and right children.</li>
</ol>
<p>This ensures that all unnecessary subtrees are removed, and only those parts of the tree that contribute to the presence of <code>1</code> remain.</p>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> pruneTree(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> pruneTree(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> pruneTree(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>left <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>right <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ol>
<li>
<p><strong>Base Case</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> root;
</span></span></code></pre></div><ul>
<li>This is the base case for the recursion. If the current node is <code>NULL</code> (i.e., it does not exist), we simply return <code>NULL</code> because there&rsquo;s nothing to prune.</li>
</ul>
</li>
<li>
<p><strong>Recursive Calls</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>root<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> pruneTree(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>root<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> pruneTree(root<span style="color:#666">-&gt;</span>right);
</span></span></code></pre></div><ul>
<li>These two lines recursively prune the left and right subtrees. We make recursive calls on the left and right children of the current node, which means that for each node in the tree, we prune its left and right subtrees first before evaluating whether the node itself should be pruned.</li>
</ul>
</li>
<li>
<p><strong>Prune the Current Node</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>left <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>root<span style="color:#666">-&gt;</span>right <span style="color:#666">&amp;&amp;</span> root<span style="color:#666">-&gt;</span>val <span style="color:#666">==</span> <span style="color:#666">0</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span></code></pre></div><ul>
<li>This line checks if the current node itself should be pruned. The node should be pruned if:
<ul>
<li>It has no left or right children (<code>!root-&gt;left &amp;&amp; !root-&gt;right</code>), meaning it is a leaf node.</li>
<li>Its value is <code>0</code> (<code>root-&gt;val == 0</code>).</li>
</ul>
</li>
<li>If both of these conditions are true, we return <code>NULL</code>, effectively removing this node from the tree.</li>
</ul>
</li>
<li>
<p><strong>Return Pruned Tree</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> root;
</span></span></code></pre></div><ul>
<li>If the current node is not pruned, we return it as is. This could be a node that either has a non-null child or contains a <code>1</code>. The recursion continues up the tree, ensuring all subtrees are pruned as necessary.</li>
</ul>
</li>
</ol>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li>The time complexity of this solution is <strong>O(n)</strong>, where <code>n</code> is the number of nodes in the binary tree. This is because we visit each node exactly once in a depth-first manner, performing constant time operations for each node (pruning and checking children).</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li>The space complexity is <strong>O(h)</strong>, where <code>h</code> is the height of the binary tree. This is due to the recursion stack. In the worst case, the height of the tree is equal to the number of nodes, leading to a space complexity of <strong>O(n)</strong>. However, in a balanced tree, the height would be <strong>O(log n)</strong>.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution effectively solves the problem of pruning a binary tree by removing subtrees that do not contain any <code>1</code>s, ensuring that only the necessary parts of the tree remain. The use of DFS with recursion ensures that we traverse the tree in an efficient manner, pruning subtrees as we go. The time complexity of <strong>O(n)</strong> and space complexity of <strong>O(h)</strong> make this approach optimal for large trees.</p>
<h4 id="key-points">Key Points:</h4>
<ul>
<li><strong>DFS Traversal</strong>: The algorithm uses depth-first search to traverse and prune the tree.</li>
<li><strong>Pruning Logic</strong>: The node is pruned if it’s a leaf node and has a value of <code>0</code>.</li>
<li><strong>Efficiency</strong>: The algorithm runs in <strong>O(n)</strong> time, where <code>n</code> is the number of nodes in the tree, and uses <strong>O(h)</strong> space, where <code>h</code> is the height of the tree.</li>
</ul>
<p>This approach is both efficient and easy to understand, making it suitable for solving the problem of pruning a binary tree in an optimal way.</p>
<p><a href="https://leetcode.com/problems/binary-tree-pruning/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>
<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

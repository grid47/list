<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 1382: Balance a Binary Search Tree | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1382: Balance a Binary Search Tree">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1382: Balance a Binary Search Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-1382-balance-a-binary-search-tree/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1382: Balance a Binary Search Tree">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1382: Balance a Binary Search Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-06-21T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Divide and Conquer">
    <meta property="article:tag" content="Greedy">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Search Tree">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 1382: Balance a Binary Search Tree</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode186s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> arr;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> balanceBST(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        inorder (root);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">reform</span>(<span style="color:#666">0</span>, arr.size()<span style="color:#666">-</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">inorder</span> (TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span> ) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        inorder (root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        arr.push_back(root<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        inorder (root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span> TreeNode<span style="color:#666">*</span> <span style="color:#00a000">reform</span>(<span style="color:#0b0;font-weight:bold">int</span> l, <span style="color:#0b0;font-weight:bold">int</span> r) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (l <span style="color:#666">&gt;</span> r) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>     <span style="color:#0b0;font-weight:bold">int</span> mid <span style="color:#666">=</span> (l <span style="color:#666">+</span> r)<span style="color:#666">/</span><span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>     TreeNode<span style="color:#666">*</span> node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(arr[mid]);
</span></span><span style="display:flex;"><span>     node<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> reform (l, mid <span style="color:#666">-</span><span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>     node<span style="color:#666">-&gt;</span>right<span style="color:#666">=</span> reform (mid <span style="color:#666">+</span><span style="color:#666">1</span>, r);
</span></span><span style="display:flex;"><span>     <span style="color:#a2f;font-weight:bold">return</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem involves balancing a binary search tree (BST). A binary search tree is balanced if, for every node, the height of its left and right subtrees differs by at most one. If a given BST is unbalanced, we need to restructure it to create a new BST that maintains its properties while ensuring it is balanced. This solution focuses on converting an unbalanced BST into a balanced one by utilizing in-order traversal and reformation techniques.</p>
<h3 id="approach">Approach</h3>
<p>To balance the BST, we can follow these steps:</p>
<ol>
<li>
<p><strong>In-Order Traversal</strong>: First, we perform an in-order traversal of the given BST. This traversal collects the values of the nodes in a sorted order because, by definition, in-order traversal of a BST returns values in ascending order.</p>
</li>
<li>
<p><strong>Reconstruction of the BST</strong>: After obtaining the sorted values, we reconstruct a new balanced BST. We do this by recursively selecting the middle element of the current range as the root of the subtree, ensuring that the left subtree consists of elements smaller than the root and the right subtree consists of elements larger than the root. This method guarantees that the newly formed tree is balanced.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>The provided C++ code implements the above approach with the following components:</p>
<ol>
<li>
<p><strong>TreeNode Structure</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> val;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>right;
</span></span><span style="display:flex;"><span>    TreeNode() <span style="color:#666">:</span> val(<span style="color:#666">0</span>), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x) <span style="color:#666">:</span> val(x), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x, TreeNode <span style="color:#666">*</span>left, TreeNode <span style="color:#666">*</span>right) <span style="color:#666">:</span> val(x), left(left), right(right) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>The <code>TreeNode</code> structure represents a node in the binary tree. Each node contains an integer value (<code>val</code>), a pointer to the left child (<code>left</code>), and a pointer to the right child (<code>right</code>).</li>
</ul>
</li>
<li>
<p><strong>Solution Class</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> arr;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> balanceBST(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        inorder(root);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">reform</span>(<span style="color:#666">0</span>, arr.size() <span style="color:#666">-</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ul>
<li>The <code>Solution</code> class contains a public method <code>balanceBST</code>, which takes the root of the unbalanced BST as an argument.</li>
<li>A vector <code>arr</code> is declared to store the sorted values collected during the in-order traversal.</li>
</ul>
</li>
<li>
<p><strong>In-Order Traversal Method</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">inorder</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        inorder(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        arr.push_back(root<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        inorder(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ul>
<li>The <code>inorder</code> method performs an in-order traversal of the BST.</li>
<li>If the current node (<code>root</code>) is <code>NULL</code>, it returns without doing anything. Otherwise, it recursively traverses the left subtree, adds the current node&rsquo;s value to the <code>arr</code> vector, and then traverses the right subtree.</li>
</ul>
</li>
<li>
<p><strong>Reconstruction Method</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> <span style="color:#00a000">reform</span>(<span style="color:#0b0;font-weight:bold">int</span> l, <span style="color:#0b0;font-weight:bold">int</span> r) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (l <span style="color:#666">&gt;</span> r) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> mid <span style="color:#666">=</span> (l <span style="color:#666">+</span> r) <span style="color:#666">/</span> <span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#666">*</span> node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(arr[mid]);
</span></span><span style="display:flex;"><span>        node<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> reform(l, mid <span style="color:#666">-</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        node<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> reform(mid <span style="color:#666">+</span> <span style="color:#666">1</span>, r);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>The <code>reform</code> method takes two indices, <code>l</code> and <code>r</code>, which represent the current range of the <code>arr</code> vector.</li>
<li>If <code>l</code> is greater than <code>r</code>, it returns <code>NULL</code>, indicating there are no nodes to create.</li>
<li>The middle index (<code>mid</code>) is calculated, and a new <code>TreeNode</code> is created using the value at this index. This node becomes the root of the current subtree.</li>
<li>The left and right subtrees are constructed recursively by calling <code>reform</code> on the appropriate segments of the array.</li>
<li>Finally, the newly constructed node is returned.</li>
</ul>
</li>
</ol>
<h3 id="complexity">Complexity</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>:</p>
<ul>
<li>The time complexity for this solution is (O(N)), where (N) is the number of nodes in the binary search tree. This is due to the two main operations: in-order traversal (to collect the values) and reconstruction (to form the new balanced BST).</li>
</ul>
</li>
<li>
<p><strong>Space Complexity</strong>:</p>
<ul>
<li>The space complexity is (O(N)) as well, primarily due to the storage of the sorted values in the <code>arr</code> vector. Additionally, the recursion stack could take up to (O(H)) space, where (H) is the height of the tree. In the worst case (for a skewed tree), this could also be (O(N)).</li>
</ul>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>The solution effectively balances a binary search tree by utilizing in-order traversal to collect the node values in a sorted manner, followed by reconstructing the tree from these values. This approach ensures that the resulting tree maintains the properties of a BST while being balanced. The implementation is efficient and straightforward, making it an excellent reference for developers and students studying tree data structures and algorithms in computer science. Understanding this method not only aids in mastering tree manipulations but also lays the groundwork for tackling more complex problems involving tree balancing and restructuring in various applications. Overall, the code exemplifies best practices in algorithm design and offers insights into the intricacies of binary search trees.</p>
<p><a href="https://leetcode.com/problems/balance-a-binary-search-tree/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/0KGdtzgL9Ec?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

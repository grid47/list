<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2588: Count the Number of Beautiful Subarrays | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2588: Count the Number of Beautiful Subarrays">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2588: Count the Number of Beautiful Subarrays in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2588-count-the-number-of-beautiful-subarrays/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2588: Count the Number of Beautiful Subarrays">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2588: Count the Number of Beautiful Subarrays in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-02-22T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="Bit Manipulation">
    <meta property="article:tag" content="Prefix Sum">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2588: Count the Number of Beautiful Subarrays</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode857s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> beautifulSubarrays(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> n<span style="color:#666">=</span> nums.size();
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> cnt <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>        mp[<span style="color:#666">0</span>] <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> tmp <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            tmp <span style="color:#666">^=</span> nums[i];
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(mp.count(tmp)) cnt<span style="color:#666">+=</span> mp[tmp];
</span></span><span style="display:flex;"><span>            mp[tmp]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> cnt;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem asks to find the number of &ldquo;beautiful&rdquo; subarrays in a given array <code>nums</code>. A subarray is considered &ldquo;beautiful&rdquo; if the XOR of all elements within the subarray is equal to 0. Our task is to efficiently compute the count of such subarrays in the given array.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we need to efficiently identify subarrays whose XOR results in 0. A brute force approach, where we check the XOR of every possible subarray, would be too slow for larger arrays due to its (O(n^2)) complexity. Instead, we can leverage a more efficient approach based on the <strong>XOR property</strong> and the concept of <strong>prefix XOR</strong>.</p>
<h4 id="key-observations">Key Observations:</h4>
<ol>
<li>
<p><strong>XOR of a Subarray</strong>: The XOR of elements in a subarray can be computed using a prefix XOR array. The XOR of elements from index <code>i</code> to <code>j</code> in the array is given by:
[
\text{XOR}(i, j) = \text{prefixXOR}[j] \oplus \text{prefixXOR}[i-1]
]
where <code>prefixXOR[i]</code> represents the XOR of all elements from the beginning of the array to index <code>i</code>.</p>
</li>
<li>
<p><strong>Zero XOR</strong>: If the XOR of a subarray is 0, it means the XOR of elements between indices <code>i</code> and <code>j</code> is equal. This implies:
[
\text{prefixXOR}[j] = \text{prefixXOR}[i-1]
]
This observation allows us to track the frequency of each prefix XOR value encountered as we iterate through the array.</p>
</li>
</ol>
<h4 id="algorithm">Algorithm:</h4>
<ul>
<li><strong>Step 1</strong>: Maintain a running XOR (<code>tmp</code>), which stores the XOR of all elements from the start of the array up to the current index.</li>
<li><strong>Step 2</strong>: Use a <code>map</code> to store the frequency of each prefix XOR value encountered so far.</li>
<li><strong>Step 3</strong>: For each element <code>nums[i]</code>, update the running XOR (<code>tmp</code>) and check if <code>tmp</code> has appeared before. If it has, it means there exists a subarray between the previous occurrence of <code>tmp</code> and the current index where the XOR of the subarray is 0.</li>
<li><strong>Step 4</strong>: Keep a count of the number of such subarrays.</li>
</ul>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="1-initialization">1. <strong>Initialization</strong>:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> cnt <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>mp[<span style="color:#666">0</span>] <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> tmp <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div><ul>
<li><strong>Explanation</strong>:
<ul>
<li>We initialize <code>cnt</code> to 0, which will store the final count of beautiful subarrays.</li>
<li>We use a <code>map</code> <code>mp</code> to store the frequency of each prefix XOR encountered. The key is the XOR value, and the value is the count of occurrences of that XOR. Initially, we set <code>mp[0] = 1</code> because a subarray starting from index 0 with XOR 0 is considered a valid subarray.</li>
<li><code>tmp</code> is the running XOR, initialized to 0.</li>
</ul>
</li>
</ul>
<h4 id="2-iterating-through-the-array">2. <strong>Iterating Through the Array</strong>:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>    tmp <span style="color:#666">^=</span> nums[i];
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (mp.count(tmp)) cnt <span style="color:#666">+=</span> mp[tmp];
</span></span><span style="display:flex;"><span>    mp[tmp]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Explanation</strong>:
<ul>
<li>We loop through each element <code>nums[i]</code> in the array.</li>
<li>For each element, we update <code>tmp</code> by performing an XOR with <code>nums[i]</code>. This updates <code>tmp</code> to be the XOR of all elements from the start of the array to the current element.</li>
<li>We then check if <code>tmp</code> has appeared before in the <code>map</code>. If it has, it means there are <code>mp[tmp]</code> subarrays that have a XOR of 0. We add <code>mp[tmp]</code> to <code>cnt</code>, since each occurrence of <code>tmp</code> represents a potential subarray with XOR 0.</li>
<li>We increment the count of <code>tmp</code> in the <code>map</code>, indicating that we have seen this XOR value again.</li>
</ul>
</li>
</ul>
<h4 id="3-returning-the-result">3. <strong>Returning the Result</strong>:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> cnt;
</span></span></code></pre></div><ul>
<li><strong>Explanation</strong>: After iterating through the entire array, <code>cnt</code> contains the total number of beautiful subarrays. We return <code>cnt</code> as the final result.</li>
</ul>
<h3 id="time-complexity">Time Complexity</h3>
<p>The time complexity of this solution can be analyzed as follows:</p>
<ol>
<li><strong>Iterating Over the Array</strong>: We iterate through the array once, which takes (O(n)), where (n) is the length of the array.</li>
<li><strong>Updating the Map</strong>: For each element, we perform a constant-time operation to update and check the map. The operations on the map (insertion, lookup) are (O(\log m)), where (m) is the number of distinct prefix XOR values encountered. However, since there are at most (n) distinct prefix XOR values, we can approximate this operation as (O(\log n)).</li>
<li><strong>Overall Complexity</strong>: The total time complexity is (O(n \log n)), which is efficient enough for large inputs.</li>
</ol>
<h3 id="space-complexity">Space Complexity</h3>
<p>The space complexity is (O(n)) due to the space required to store the map <code>mp</code>, which can hold at most (n) distinct prefix XOR values. Additionally, the space used for the <code>tmp</code> variable is constant.</p>
<h3 id="example-walkthrough">Example Walkthrough</h3>
<h4 id="input">Input:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> nums <span style="color:#666">=</span> {<span style="color:#666">4</span>, <span style="color:#666">2</span>, <span style="color:#666">2</span>, <span style="color:#666">6</span>, <span style="color:#666">4</span>};
</span></span></code></pre></div><ol>
<li>
<p><strong>Step 1</strong>: Initialize <code>cnt = 0</code>, <code>mp = {0: 1}</code>, and <code>tmp = 0</code>.</p>
</li>
<li>
<p><strong>Step 2</strong>: Start iterating over <code>nums</code>.</p>
<ul>
<li>
<p><strong>First iteration</strong> (i = 0):</p>
<ul>
<li><code>tmp ^= 4</code> → <code>tmp = 4</code></li>
<li><code>mp.count(4)</code> is 0, so we don&rsquo;t increment <code>cnt</code>.</li>
<li><code>mp[4] = 1</code></li>
</ul>
</li>
<li>
<p><strong>Second iteration</strong> (i = 1):</p>
<ul>
<li><code>tmp ^= 2</code> → <code>tmp = 6</code></li>
<li><code>mp.count(6)</code> is 0, so we don&rsquo;t increment <code>cnt</code>.</li>
<li><code>mp[6] = 1</code></li>
</ul>
</li>
<li>
<p><strong>Third iteration</strong> (i = 2):</p>
<ul>
<li><code>tmp ^= 2</code> → <code>tmp = 4</code></li>
<li><code>mp.count(4)</code> is 1, so we increment <code>cnt</code> by 1 (<code>cnt = 1</code>).</li>
<li><code>mp[4] = 2</code></li>
</ul>
</li>
<li>
<p><strong>Fourth iteration</strong> (i = 3):</p>
<ul>
<li><code>tmp ^= 6</code> → <code>tmp = 2</code></li>
<li><code>mp.count(2)</code> is 0, so we don&rsquo;t increment <code>cnt</code>.</li>
<li><code>mp[2] = 1</code></li>
</ul>
</li>
<li>
<p><strong>Fifth iteration</strong> (i = 4):</p>
<ul>
<li><code>tmp ^= 4</code> → <code>tmp = 6</code></li>
<li><code>mp.count(6)</code> is 1, so we increment <code>cnt</code> by 1 (<code>cnt = 2</code>).</li>
<li><code>mp[6] = 2</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Step 3</strong>: The final result is <code>cnt = 2</code>.</p>
</li>
</ol>
<h4 id="output">Output:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#666">2</span>
</span></span></code></pre></div><h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently counts the number of &ldquo;beautiful&rdquo; subarrays using the concept of prefix XOR and a hashmap to track the occurrences of each prefix XOR value. By leveraging the properties of XOR, we can solve the problem in (O(n \log n)) time, making it scalable for large inputs. This approach is both time-efficient and space-efficient, with a clear and concise implementation.</p>
<p><a href="https://leetcode.com/problems/count-the-number-of-beautiful-subarrays/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/JokGqRfyMPU?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

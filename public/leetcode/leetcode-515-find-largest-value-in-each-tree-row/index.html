<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 515: Find Largest Value in Each Tree Row | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 515: Find Largest Value in Each Tree Row">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 515: Find Largest Value in Each Tree Row in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-515-find-largest-value-in-each-tree-row/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 515: Find Largest Value in Each Tree Row">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 515: Find Largest Value in Each Tree Row in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-09-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 515: Find Largest Value in Each Tree Row</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1172s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/515.webp" 
           alt="A tree with rows of values, each row highlighted with the largest value softly glowing." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 515: Find Largest Value in Each Tree Row Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1172s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> largestValues(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>            queue<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>        q.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> mx;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>            mx <span style="color:#666">=</span> INT_MIN;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span> <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>                root <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>                q.pop();
</span></span><span style="display:flex;"><span>                mx <span style="color:#666">=</span> max(mx, root<span style="color:#666">-&gt;</span>val);                
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>left)  q.push(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>right) q.push(root<span style="color:#666">-&gt;</span>right);                
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            res.push_back(mx);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;    
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem at hand is to find the largest value in each level of a binary tree. Given a binary tree, we are tasked with returning a list of integers where each integer corresponds to the largest value found in each level of the tree.</p>
<p>For example, for the binary tree:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>         1
</span></span><span style="display:flex;"><span>        / \
</span></span><span style="display:flex;"><span>       3   2
</span></span><span style="display:flex;"><span>      / \   \
</span></span><span style="display:flex;"><span>     5   3   9
</span></span></code></pre></div><p>The output should be <code>[1, 3, 9]</code>, as:</p>
<ul>
<li>Level 1 has only the node <code>1</code>.</li>
<li>Level 2 has the nodes <code>3</code> and <code>2</code>, with the largest value being <code>3</code>.</li>
<li>Level 3 has the nodes <code>5</code>, <code>3</code>, and <code>9</code>, with the largest value being <code>9</code>.</li>
</ul>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we can use a <strong>breadth-first search (BFS)</strong> approach, where we traverse the tree level by level. The idea is to traverse the tree starting from the root node, and for each level, we keep track of the largest value. The BFS is ideal for this scenario because it naturally processes nodes level by level.</p>
<p>Hereâ€™s a step-by-step explanation of the approach:</p>
<ol>
<li>
<p><strong>Breadth-First Search (BFS)</strong>: We use a queue to store the nodes of the tree. The queue helps in processing nodes level by level. We start by pushing the root node into the queue.</p>
</li>
<li>
<p><strong>Iterate Through Levels</strong>: For each level of the tree, we:</p>
<ul>
<li>Track the number of nodes at that level (<code>sz</code>).</li>
<li>Traverse all nodes at the current level and find the maximum value.</li>
<li>If a node has left or right children, push those children into the queue to be processed in the next level.</li>
</ul>
</li>
<li>
<p><strong>Store Maximum Value for Each Level</strong>: After processing all nodes in a level, we store the largest value of that level.</p>
</li>
<li>
<p><strong>Return Result</strong>: After all levels are processed, the result is a list of maximum values for each level of the tree.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>The solution uses a breadth-first search to process the tree level by level and track the largest values for each level:</p>
<ol>
<li>
<p><strong>Initialize a Queue and Result Vector</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>queue<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>q.push(root);
</span></span></code></pre></div><ul>
<li>We initialize a queue <code>q</code> that will hold the nodes to be processed.</li>
<li>The <code>res</code> vector is used to store the largest value at each level.</li>
<li>If the tree is empty (i.e., the root is <code>nullptr</code>), we return an empty result.</li>
</ul>
</li>
<li>
<p><strong>Process Each Level</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>    mx <span style="color:#666">=</span> INT_MIN;
</span></span></code></pre></div><ul>
<li>We enter a loop that processes each level of the tree. The variable <code>sz</code> holds the number of nodes in the current level.</li>
<li><code>mx</code> is initialized to <code>INT_MIN</code> to keep track of the maximum value at the current level.</li>
</ul>
</li>
<li>
<p><strong>Process Nodes at Current Level</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span> <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>    root <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>    q.pop();
</span></span><span style="display:flex;"><span>    mx <span style="color:#666">=</span> max(mx, root<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>left)  q.push(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>right) q.push(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>We process each node at the current level by popping it from the front of the queue.</li>
<li>For each node, we compare its value with <code>mx</code> to track the maximum value at the current level.</li>
<li>If the node has a left or right child, we push them into the queue for processing in the next level.</li>
</ul>
</li>
<li>
<p><strong>Store Maximum Value for the Current Level</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>res.push_back(mx);
</span></span></code></pre></div><ul>
<li>After processing all nodes at the current level, we push the maximum value found (<code>mx</code>) into the <code>res</code> vector.</li>
</ul>
</li>
<li>
<p><strong>Return the Result</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div><ul>
<li>Once all levels have been processed, we return the <code>res</code> vector, which contains the largest values for each level of the tree.</li>
</ul>
</li>
</ol>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>O(n)</strong>: We traverse each node of the tree exactly once, and at each node, we perform constant-time operations such as comparing values and enqueuing child nodes. Here <code>n</code> is the number of nodes in the tree.</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>O(n)</strong>: In the worst case, the queue will contain all nodes at the last level of the tree. In a balanced binary tree, this would be roughly <code>n / 2</code> nodes, but in the worst case (e.g., a skewed tree), it could contain up to <code>n</code> nodes.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>In conclusion, this solution efficiently computes the largest value at each level of a binary tree using a breadth-first search (BFS) approach. The BFS ensures that we process each level of the tree sequentially, and by tracking the largest value in each level, we can build the result in linear time and space. This approach is optimal and well-suited for problems involving tree traversal where levels and node relationships are crucial, such as in binary tree level-order traversals.</p>
<p>This solution is both time-efficient and space-efficient, making it a great choice for handling large binary trees where we need to compute level-based information, such as finding the largest values at each level.</p>
<p><a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/0EVQluJY224?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

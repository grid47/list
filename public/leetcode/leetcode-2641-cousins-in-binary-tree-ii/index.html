<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2641: Cousins in Binary Tree II | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2641: Cousins in Binary Tree II">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2641: Cousins in Binary Tree II in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2641-cousins-in-binary-tree-ii/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2641: Cousins in Binary Tree II">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2641: Cousins in Binary Tree II in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-02-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2641: Cousins in Binary Tree II</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode882s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> replaceValueInTree(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        list<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        q.push_back(root);
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>val <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> sum <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">auto</span> it <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>                q.pop_front();
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(it<span style="color:#666">-&gt;</span>left <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>                    mp[it] <span style="color:#666">+=</span> it<span style="color:#666">-&gt;</span>left<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>                    q.push_back(it<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(it<span style="color:#666">-&gt;</span>right <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>                    mp[it] <span style="color:#666">+=</span> it<span style="color:#666">-&gt;</span>right<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>                    q.push_back(it<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                sum <span style="color:#666">+=</span> mp[it];
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: mp) {
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(it.first<span style="color:#666">-&gt;</span>left <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>                    it.first<span style="color:#666">-&gt;</span>left<span style="color:#666">-&gt;</span>val <span style="color:#666">=</span> sum <span style="color:#666">-</span> it.second;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(it.first<span style="color:#666">-&gt;</span>right <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>                    it.first<span style="color:#666">-&gt;</span>right<span style="color:#666">-&gt;</span>val <span style="color:#666">=</span> sum <span style="color:#666">-</span> it.second;
</span></span><span style="display:flex;"><span>                }    
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            mp.clear();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem asks us to modify a binary tree such that each node&rsquo;s value is replaced by the sum of all node values in its subtree except for its own value. Specifically, the value of each node should be updated to the sum of the values of all its descendants, excluding the node itself. The tree is represented by a binary tree structure with <code>left</code> and <code>right</code> child pointers.</p>
<h3 id="approach">Approach</h3>
<p>To solve the problem, we need to perform a level-order traversal (breadth-first search, BFS) of the tree, processing each level of the tree at a time and updating the values of the child nodes based on their parent nodes. The key idea is to accumulate the values of the left and right children for each node and update their values accordingly.</p>
<p>The approach is broken down as follows:</p>
<ol>
<li>
<p><strong>Level-Order Traversal (BFS)</strong>:</p>
<ul>
<li>We traverse the tree level by level. For each node at a given level, we calculate the sum of all nodes at that level and update their children&rsquo;s values.</li>
</ul>
</li>
<li>
<p><strong>Tracking Sum of Child Values</strong>:</p>
<ul>
<li>While traversing each node, we accumulate the sum of its left and right children into a map. This helps us to efficiently compute the sum of all child values for each node.</li>
</ul>
</li>
<li>
<p><strong>Updating Node Values</strong>:</p>
<ul>
<li>After processing all nodes at a level, we update the values of the children (left and right) of each node in that level to be the sum of all other nodes in their respective subtrees.</li>
</ul>
</li>
<li>
<p><strong>Iterating Through All Levels</strong>:</p>
<ul>
<li>We continue this process for all levels of the tree, ensuring each node’s value is updated correctly based on its subtree sum.</li>
</ul>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="1-initial-setup">1. <strong>Initial Setup</strong></h4>
<p>We begin by initializing a queue (<code>q</code>) to store nodes while performing the level-order traversal. A <code>map</code> called <code>mp</code> is used to track the sum of child values for each node. We set the root’s value to 0 as part of the tree transformation.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>list<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span><span style="display:flex;"><span>q.push_back(root);  <span style="color:#080;font-style:italic">// Start with the root node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>root<span style="color:#666">-&gt;</span>val <span style="color:#666">=</span> <span style="color:#666">0</span>;  <span style="color:#080;font-style:italic">// Set the root value to 0
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>map<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;  <span style="color:#080;font-style:italic">// Map to track the sum of child values for each node
</span></span></span></code></pre></div><h4 id="2-level-order-traversal-loop">2. <strong>Level-Order Traversal Loop</strong></h4>
<p>We perform a loop over the queue <code>q</code> that processes each level of the tree. For each level, we calculate the sum of child node values (<code>sum</code>) for all nodes at that level.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();  <span style="color:#080;font-style:italic">// Size of the current level
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> sum <span style="color:#666">=</span> <span style="color:#666">0</span>;  <span style="color:#080;font-style:italic">// Initialize the sum of child values for this level
</span></span></span></code></pre></div><h4 id="3-processing-nodes-in-the-current-level">3. <strong>Processing Nodes in the Current Level</strong></h4>
<p>For each node in the current level:</p>
<ul>
<li>We pop the node from the queue and check if it has left or right children.</li>
<li>If a child exists, we add its value to the sum of child values for that node and enqueue the child for the next level.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">auto</span> it <span style="color:#666">=</span> q.front();  <span style="color:#080;font-style:italic">// Get the front node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    q.pop_front();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(it<span style="color:#666">-&gt;</span>left <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>        mp[it] <span style="color:#666">+=</span> it<span style="color:#666">-&gt;</span>left<span style="color:#666">-&gt;</span>val;  <span style="color:#080;font-style:italic">// Add left child&#39;s value to the map
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        q.push_back(it<span style="color:#666">-&gt;</span>left);  <span style="color:#080;font-style:italic">// Enqueue left child
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(it<span style="color:#666">-&gt;</span>right <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>        mp[it] <span style="color:#666">+=</span> it<span style="color:#666">-&gt;</span>right<span style="color:#666">-&gt;</span>val;  <span style="color:#080;font-style:italic">// Add right child&#39;s value to the map
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        q.push_back(it<span style="color:#666">-&gt;</span>right);  <span style="color:#080;font-style:italic">// Enqueue right child
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    sum <span style="color:#666">+=</span> mp[it];  <span style="color:#080;font-style:italic">// Add the node&#39;s child sum to the total sum
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><h4 id="4-updating-child-node-values">4. <strong>Updating Child Node Values</strong></h4>
<p>After processing all nodes at the current level, we update the left and right child values based on the sum calculated previously. We subtract the stored value from the sum (this excludes the current node itself), and assign this new value to the children.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: mp) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(it.first<span style="color:#666">-&gt;</span>left <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>        it.first<span style="color:#666">-&gt;</span>left<span style="color:#666">-&gt;</span>val <span style="color:#666">=</span> sum <span style="color:#666">-</span> it.second;  <span style="color:#080;font-style:italic">// Update left child&#39;s value
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(it.first<span style="color:#666">-&gt;</span>right <span style="color:#666">!=</span> <span style="color:#a2f">NULL</span>) {
</span></span><span style="display:flex;"><span>        it.first<span style="color:#666">-&gt;</span>right<span style="color:#666">-&gt;</span>val <span style="color:#666">=</span> sum <span style="color:#666">-</span> it.second;  <span style="color:#080;font-style:italic">// Update right child&#39;s value
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }    
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>mp.clear();  <span style="color:#080;font-style:italic">// Clear the map for the next level
</span></span></span></code></pre></div><h4 id="5-returning-the-modified-tree">5. <strong>Returning the Modified Tree</strong></h4>
<p>Once the entire tree has been processed and all node values have been updated, we return the modified root node.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> root;  <span style="color:#080;font-style:italic">// Return the modified root
</span></span></span></code></pre></div><h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>BFS Traversal</strong>: We perform a level-order traversal of the tree, processing each node once. Since we process every node exactly once, the time complexity is (O(n)), where (n) is the number of nodes in the tree.</li>
<li><strong>Sum Calculation and Updates</strong>: The operations inside the BFS loop (such as checking children, adding to the map, and updating child values) are constant-time operations. Thus, the overall time complexity remains (O(n)).</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>Queue</strong>: The space required for the queue is proportional to the number of nodes at the widest level of the tree, which is (O(n)) in the worst case (for a completely unbalanced tree). Thus, the space complexity for the queue is (O(n)).</li>
<li><strong>Map</strong>: The map <code>mp</code> stores values for each node, so the space complexity for the map is (O(n)) in the worst case.</li>
<li><strong>Total Space Complexity</strong>: The overall space complexity is (O(n)) due to the queue and the map.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>The solution effectively handles the problem using a breadth-first search (BFS) traversal of the binary tree. By maintaining a map to track the sum of child values for each node and updating child node values after processing each level, the algorithm ensures that the tree is modified as required. The time complexity is linear in the number of nodes, and the space complexity is also linear, making this solution efficient for large trees. This approach avoids unnecessary recalculations and ensures that each node&rsquo;s value is updated efficiently based on its descendants.</p>
<p><a href="https://leetcode.com/problems/cousins-in-binary-tree-ii/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/xvwTd19SncE?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

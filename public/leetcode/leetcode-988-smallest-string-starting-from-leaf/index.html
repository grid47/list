<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 988: Smallest String Starting From Leaf | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 988: Smallest String Starting From Leaf">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 988: Smallest String Starting From Leaf in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-988-smallest-string-starting-from-leaf/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 988: Smallest String Starting From Leaf">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 988: Smallest String Starting From Leaf in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-07-31T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="String">
    <meta property="article:tag" content="Backtracking">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 988: Smallest String Starting From Leaf</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1435s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    string ans <span style="color:#666">=</span> <span style="color:#b44">&#34;~&#34;</span>;
</span></span><span style="display:flex;"><span>    string <span style="color:#00a000">smallestFromLeaf</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        recur(root, <span style="color:#b44">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">recur</span>(TreeNode<span style="color:#666">*</span> node, string s) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>node) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>node<span style="color:#666">-&gt;</span>left <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>node<span style="color:#666">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>            ans <span style="color:#666">=</span> min(ans, <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        cout <span style="color:#666">&lt;&lt;</span> node<span style="color:#666">-&gt;</span>val<span style="color:#666">&lt;&lt;</span><span style="color:#b44">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>        recur(node<span style="color:#666">-&gt;</span>left,  <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);
</span></span><span style="display:flex;"><span>        recur(node<span style="color:#666">-&gt;</span>right, <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);  
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem asks to find the lexicographically smallest string that starts from any leaf of a binary tree and moves upwards to the root. Each node in the tree contains a value between 0 and 25, representing a letter in the English alphabet (where 0 maps to &lsquo;a&rsquo;, 1 maps to &lsquo;b&rsquo;, and so on). The goal is to find the smallest string from any leaf node to the root, considering that the string is formed by concatenating the node values.</p>
<h3 id="approach">Approach</h3>
<p>This problem can be solved using a <strong>depth-first search (DFS)</strong> approach. The idea is to traverse the binary tree, starting from the root, and recursively explore the left and right subtrees. For each leaf node encountered, we form a string by concatenating the corresponding letter (based on the node’s value) and compare it with the previously smallest string found.</p>
<p>Key observations:</p>
<ol>
<li><strong>Leaf Nodes</strong>: A leaf node is defined as a node that does not have any children (both left and right children are null). We need to consider all possible paths that end at the leaf nodes.</li>
<li><strong>Lexicographical Order</strong>: The smallest string from the leaf to the root is determined by lexicographically comparing strings. The idea is to construct the string in reverse order (from leaf to root) and compare it to keep track of the lexicographically smallest one.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="1-helper-function-smallestfromleaf">1. <strong>Helper Function (<code>smallestFromLeaf</code>)</strong>:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>string ans <span style="color:#666">=</span> <span style="color:#b44">&#34;~&#34;</span>;
</span></span><span style="display:flex;"><span>string <span style="color:#00a000">smallestFromLeaf</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    recur(root, <span style="color:#b44">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>The function <code>smallestFromLeaf</code> initializes a variable <code>ans</code> to <code>&quot;~&quot;</code> (a string greater than any possible string formed by node values). It then calls the recursive helper function <code>recur</code> starting with the root of the binary tree.</li>
<li>The result of the smallest string is stored in <code>ans</code> and returned after the DFS traversal.</li>
</ul>
<h4 id="2-recursive-function-recur">2. <strong>Recursive Function (<code>recur</code>)</strong>:</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">recur</span>(TreeNode<span style="color:#666">*</span> node, string s) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>node) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>node<span style="color:#666">-&gt;</span>left <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>node<span style="color:#666">-&gt;</span>right) {
</span></span><span style="display:flex;"><span>        ans <span style="color:#666">=</span> min(ans, <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    cout <span style="color:#666">&lt;&lt;</span> node<span style="color:#666">-&gt;</span>val <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#39;\n&#39;</span>;
</span></span><span style="display:flex;"><span>    recur(node<span style="color:#666">-&gt;</span>left,  <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);
</span></span><span style="display:flex;"><span>    recur(node<span style="color:#666">-&gt;</span>right, <span style="color:#0b0;font-weight:bold">char</span>(node<span style="color:#666">-&gt;</span>val <span style="color:#666">+</span> <span style="color:#b44">&#39;a&#39;</span>) <span style="color:#666">+</span> s);  
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>The function <code>recur</code> performs a DFS traversal of the binary tree. It takes two parameters:</p>
<ul>
<li><code>node</code>: the current node being processed.</li>
<li><code>s</code>: the string constructed so far from the leaf node to the current node.</li>
</ul>
<p><strong>Base Case</strong>:</p>
<ul>
<li>If the current node is null (<code>if(!node)</code>), we return immediately as there is nothing to process.</li>
</ul>
<p><strong>Leaf Node Check</strong>:</p>
<ul>
<li>If the current node is a leaf node (both left and right children are null), the string formed by traversing from this leaf to the root is complete. At this point, we compute the string by adding the current node’s corresponding character (<code>char(node-&gt;val + 'a')</code>) to the string <code>s</code>, which holds the characters from the leaf to the root. This string is compared with the current <code>ans</code> to track the lexicographically smallest string.</li>
</ul>
<p><strong>Recursive Calls</strong>:</p>
<ul>
<li>The function recursively calls itself for the left and right children of the current node, appending the character corresponding to the current node’s value (<code>char(node-&gt;val + 'a')</code>) to the string <code>s</code> being passed down. This continues until all leaf nodes have been processed.</li>
<li>A debug print statement (<code>cout &lt;&lt; node-&gt;val &lt;&lt; '\n';</code>) is added to print the value of the current node for debugging purposes.</li>
</ul>
</li>
</ul>
<h4 id="3-string-construction">3. <strong>String Construction</strong>:</h4>
<ul>
<li>The string <code>s</code> is built from the leaf to the root, as we append the character for each node while traversing down. By the time we reach a leaf, the string <code>s</code> will have the characters corresponding to that leaf’s path to the root.</li>
<li>We use <code>char(node-&gt;val + 'a')</code> to convert a node’s integer value to a corresponding letter, ensuring that the node’s value <code>0</code> maps to <code>'a'</code>, <code>1</code> maps to <code>'b'</code>, and so on.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>DFS Traversal</strong>: We are performing a depth-first search on the binary tree, visiting each node exactly once. The time complexity of the DFS traversal is <strong>O(n)</strong>, where <code>n</code> is the number of nodes in the tree.</li>
<li><strong>String Comparison</strong>: At each leaf, we compare the current string with the smallest string found so far. Since the maximum length of a string is equal to the height of the tree (which is <strong>O(n)</strong> in the worst case), the string comparison operation takes <strong>O(h)</strong> time, where <code>h</code> is the height of the tree. In the worst case, <code>h = O(n)</code>, so the time complexity of comparing the strings is <strong>O(n)</strong>.</li>
</ul>
<p>Thus, the overall time complexity is <strong>O(n * h)</strong>, where <code>n</code> is the number of nodes and <code>h</code> is the height of the tree.</p>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>Recursive Stack</strong>: The space complexity of the DFS traversal is determined by the depth of the recursion stack, which is <strong>O(h)</strong>, where <code>h</code> is the height of the tree.</li>
<li><strong>String Storage</strong>: The string <code>s</code> can have at most <code>h</code> characters, so the space used by the string is also <strong>O(h)</strong>.</li>
</ul>
<p>Thus, the overall space complexity is <strong>O(h)</strong>.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently computes the lexicographically smallest string from a leaf to the root of a binary tree. By using a depth-first search approach and maintaining a running string that is constructed from leaf to root, we ensure that the solution is both time-efficient and easy to implement. The time complexity is <strong>O(n * h)</strong>, where <code>n</code> is the number of nodes in the tree and <code>h</code> is the height of the tree, making the approach scalable for larger trees. The space complexity is <strong>O(h)</strong>, as it only requires space proportional to the height of the tree for the recursive stack and the string being built.</p>
<p><a href="https://leetcode.com/problems/smallest-string-starting-from-leaf/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/UvdWfxQ_ZDs?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 109: Convert Sorted List to Binary Search Tree | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 109: Convert Sorted List to Binary Search Tree">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 109: Convert Sorted List to Binary Search Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-109-convert-sorted-list-to-binary-search-tree/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 109: Convert Sorted List to Binary Search Tree">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 109: Convert Sorted List to Binary Search Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-10-27T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Linked List">
    <meta property="article:tag" content="Divide and Conquer">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Binary Search Tree">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 109: Convert Sorted List to Binary Search Tree</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode56s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/109.webp" 
           alt="A flowing list of sorted numbers seamlessly transforming into a calm, glowing binary search tree." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 109: Convert Sorted List to Binary Search Tree Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode56s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> toBST(ListNode<span style="color:#666">*</span> start, ListNode<span style="color:#666">*</span> end) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(start <span style="color:#666">==</span> end) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> slw <span style="color:#666">=</span> start;
</span></span><span style="display:flex;"><span>        ListNode<span style="color:#666">*</span> fst <span style="color:#666">=</span> start;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(fst <span style="color:#666">!=</span> end <span style="color:#666">&amp;&amp;</span> fst<span style="color:#666">-&gt;</span>next <span style="color:#666">!=</span> end) {
</span></span><span style="display:flex;"><span>            slw <span style="color:#666">=</span> slw<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>            fst <span style="color:#666">=</span> fst<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        TreeNode<span style="color:#666">*</span> node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(slw<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        node<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> toBST(start, slw);
</span></span><span style="display:flex;"><span>        node<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> toBST(slw<span style="color:#666">-&gt;</span>next, end);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> node;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> <span style="color:#00a000">sortedListToBST</span>(ListNode<span style="color:#666">*</span> head) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(head <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> toBST(head, <span style="color:#a2f">NULL</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="-problem-statement-convert-a-sorted-linked-list-to-a-balanced-bst">🌟 <strong>Problem Statement: Convert a Sorted Linked List to a Balanced BST</strong></h3>
<p>Given a <strong>sorted singly linked list</strong>, the goal is to convert it into a <strong>balanced binary search tree (BST)</strong>. A balanced BST is one where the height difference between the left and right subtrees of any node is at most one. The challenge is to preserve the sorted order of the linked list while ensuring that the tree remains balanced.</p>
<hr>
<h3 id="-approach-turning-a-sorted-list-into-a-balanced-bst">🧠 <strong>Approach: Turning a Sorted List into a Balanced BST</strong></h3>
<p>To solve this problem, we need to construct the BST in a way that ensures:</p>
<ul>
<li>The <strong>middle element</strong> of the linked list becomes the <strong>root</strong> of the tree, ensuring balance.</li>
<li>The <strong>left subtree</strong> contains elements smaller than the root, and the <strong>right subtree</strong> contains elements larger than the root.</li>
</ul>
<p>Here’s how we can break it down:</p>
<h4 id="1-divide-and-conquer">1. <strong>Divide and Conquer:</strong></h4>
<ul>
<li>Select the <strong>middle element</strong> of the linked list as the root. This guarantees balance, as it divides the list into two equal halves for the left and right subtrees.</li>
</ul>
<h4 id="2-recursive-approach">2. <strong>Recursive Approach:</strong></h4>
<ul>
<li>Recursively apply the same logic to both the left and right halves of the list to build the left and right subtrees.</li>
</ul>
<h4 id="3-linked-list-traversal">3. <strong>Linked List Traversal:</strong></h4>
<ul>
<li>Use the <strong>slow and fast pointer technique</strong> (tortoise and hare algorithm) to efficiently find the middle node. This helps us traverse the list while maintaining references to the start and end nodes.</li>
</ul>
<hr>
<h3 id="-code-breakdown-step-by-step">🔧 <strong>Code Breakdown: Step-by-Step</strong></h3>
<h4 id="step-1-helper-function-tobst"><strong>Step 1: Helper Function <code>toBST</code></strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>TreeNode<span style="color:#666">*</span> <span style="color:#00a000">toBST</span>(ListNode<span style="color:#666">*</span> start, ListNode<span style="color:#666">*</span> end) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(start <span style="color:#666">==</span> end) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> slw <span style="color:#666">=</span> start;
</span></span><span style="display:flex;"><span>    ListNode<span style="color:#666">*</span> fst <span style="color:#666">=</span> start;
</span></span></code></pre></div><ul>
<li><strong><code>toBST</code></strong> takes <code>start</code> and <code>end</code> pointers as input and recursively divides the linked list into halves to construct the BST.</li>
<li>The <strong>slow pointer</strong> (<code>slw</code>) and <strong>fast pointer</strong> (<code>fst</code>) help us find the middle node of the list.</li>
</ul>
<h4 id="step-2-finding-the-middle-node"><strong>Step 2: Finding the Middle Node</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(fst <span style="color:#666">!=</span> end <span style="color:#666">&amp;&amp;</span> fst<span style="color:#666">-&gt;</span>next <span style="color:#666">!=</span> end) {
</span></span><span style="display:flex;"><span>        slw <span style="color:#666">=</span> slw<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>        fst <span style="color:#666">=</span> fst<span style="color:#666">-&gt;</span>next<span style="color:#666">-&gt;</span>next;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ul>
<li>The <strong>slow and fast pointers</strong> traverse the list. The <strong>slow pointer</strong> moves one step at a time, while the <strong>fast pointer</strong> moves two steps at a time.</li>
<li>By the time the fast pointer reaches the end, the slow pointer will be at the middle node. This node becomes the root of the current subtree.</li>
</ul>
<h4 id="step-3-constructing-the-node-and-recursive-calls"><strong>Step 3: Constructing the Node and Recursive Calls</strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> node <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(slw<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    node<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> toBST(start, slw);
</span></span><span style="display:flex;"><span>    node<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> toBST(slw<span style="color:#666">-&gt;</span>next, end);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> node;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>Create a new <code>TreeNode</code> with the value of the middle node.</li>
<li>Recursively build the left subtree (<code>start</code> to <code>slw</code>) and the right subtree (<code>slw-&gt;next</code> to <code>end</code>).</li>
<li>Return the newly created node.</li>
</ul>
<h4 id="step-4-main-function-sortedlisttobst"><strong>Step 4: Main Function <code>sortedListToBST</code></strong></h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>TreeNode<span style="color:#666">*</span> <span style="color:#00a000">sortedListToBST</span>(ListNode<span style="color:#666">*</span> head) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(head <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> toBST(head, <span style="color:#a2f">NULL</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong><code>sortedListToBST</code></strong> initiates the process by calling <code>toBST</code> with the head of the linked list.</li>
<li>If the linked list is empty, return <code>NULL</code>.</li>
</ul>
<hr>
<h3 id="-time-and-space-complexity">💡 <strong>Time and Space Complexity</strong></h3>
<h4 id="time-complexity-on"><strong>Time Complexity: O(n)</strong></h4>
<ul>
<li>Each node in the linked list is visited once. The <strong>slow and fast pointer technique</strong> allows us to find the middle node in <strong>O(n)</strong> time.</li>
<li>The tree is built recursively for each half of the list. Since each node is processed once, the total time complexity is <strong>O(n)</strong>.</li>
</ul>
<h4 id="space-complexity-olog-n"><strong>Space Complexity: O(log n)</strong></h4>
<ul>
<li>The space is used by the <strong>recursive call stack</strong>. In the case of a balanced tree, the maximum recursion depth is <strong>O(log n)</strong>, where <code>n</code> is the number of nodes in the linked list.</li>
</ul>
<hr>
<h3 id="-example-walkthrough">🔍 <strong>Example Walkthrough</strong></h3>
<p>Let’s walk through an example with the following sorted linked list:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>-10 -&gt; -3 -&gt; 0 -&gt; 5 -&gt; 9
</span></span></code></pre></div><ol>
<li><strong>Step 1:</strong> The <code>toBST</code> function is called with the entire list. The slow and fast pointers find <code>0</code> as the middle node, which becomes the root.</li>
<li><strong>Step 2:</strong> We recursively call <code>toBST</code> for the left half (<code>-10 -&gt; -3</code>) and right half (<code>5 -&gt; 9</code>):
<ul>
<li>The middle of the left half is <code>-3</code>, which becomes the left child of <code>0</code>.</li>
<li>The middle of the right half is <code>5</code>, which becomes the right child of <code>0</code>.</li>
</ul>
</li>
<li><strong>Step 3:</strong> Continue recursively for the sublists:
<ul>
<li>For the left subtree (<code>-10</code>), <code>-10</code> becomes the left child of <code>-3</code>.</li>
<li>For the right subtree (<code>9</code>), <code>9</code> becomes the right child of <code>5</code>.</li>
</ul>
</li>
<li><strong>Step 4:</strong> The recursion terminates when the sublist is empty, and the tree is fully constructed.</li>
</ol>
<p>The resulting BST is:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>         0
</span></span><span style="display:flex;"><span>       /   \
</span></span><span style="display:flex;"><span>     -3     5
</span></span><span style="display:flex;"><span>    /       \
</span></span><span style="display:flex;"><span>  -10        9
</span></span></code></pre></div><hr>
<h3 id="-conclusion">🚀 <strong>Conclusion</strong></h3>
<p>This approach efficiently converts a <strong>sorted singly linked list</strong> into a <strong>balanced binary search tree</strong>. By leveraging the <strong>divide and conquer</strong> strategy, the tree remains balanced, and the in-order traversal of the tree will yield the original sorted list. The solution is both <strong>time-efficient</strong> (O(n)) and <strong>space-efficient</strong> (O(log n)), making it suitable for large inputs.</p>
<p>The <strong>slow and fast pointer technique</strong> ensures that we find the middle node in a single pass through the list, guaranteeing optimal performance.</p>
<p>Happy coding, and enjoy building your BST! 🌱</p>
<hr>
<p><a href="https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/0E8Xxu6LV9o?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

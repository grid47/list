<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 813: Largest Sum of Averages | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 813: Largest Sum of Averages">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 813: Largest Sum of Averages in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-813-largest-sum-of-averages/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 813: Largest Sum of Averages">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 813: Largest Sum of Averages in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-08-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Dynamic Programming">
    <meta property="article:tag" content="Prefix Sum">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 813: Largest Sum of Averages</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1324s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/813.webp" 
           alt="A set of averages where the largest sum is calculated, glowing softly as the sum is found." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 813: Largest Sum of Averages Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1324s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">double</span> memo[<span style="color:#666">200</span>][<span style="color:#666">200</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">double</span> <span style="color:#00a000">largestSumOfAverages</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> nums, <span style="color:#0b0;font-weight:bold">int</span> k) {
</span></span><span style="display:flex;"><span>        memset(memo, <span style="color:#666">0</span>, <span style="color:#a2f;font-weight:bold">sizeof</span>(memo));
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> nums.size();
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">double</span> cur <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            cur <span style="color:#666">+=</span> nums[i];
</span></span><span style="display:flex;"><span>            memo[i <span style="color:#666">+</span> <span style="color:#666">1</span>][<span style="color:#666">1</span>] <span style="color:#666">=</span> cur <span style="color:#666">/</span> (i<span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> search(n, k, nums);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">double</span> <span style="color:#00a000">search</span>(<span style="color:#0b0;font-weight:bold">int</span> n, <span style="color:#0b0;font-weight:bold">int</span> k, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#666">&amp;</span>nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(memo[n][k] <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) <span style="color:#a2f;font-weight:bold">return</span> memo[n][k];
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">double</span> cur <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>; i <span style="color:#666">&gt;</span> <span style="color:#666">0</span>; i<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>            cur <span style="color:#666">+=</span> nums[i];
</span></span><span style="display:flex;"><span>            memo[n][k] <span style="color:#666">=</span> max(memo[n][k], search(i, k <span style="color:#666">-</span> <span style="color:#666">1</span>, nums) <span style="color:#666">+</span> cur <span style="color:#666">/</span> (n <span style="color:#666">-</span> i));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> memo[n][k];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>In this problem, we are tasked with dividing an array of integers into <code>k</code> non-empty contiguous subarrays, such that the sum of the averages of the subarrays is maximized. Given an array of integers <code>nums</code> and an integer <code>k</code>, we need to determine the largest possible sum of the averages of these subarrays.</p>
<p>The problem requires us to partition the array optimally so that each subarray&rsquo;s average contributes to the total sum, and we maximize the sum. The division of the array into subarrays can be tricky because of how averages work, so a strategic approach is necessary.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem optimally, we can use <strong>Dynamic Programming (DP)</strong> with <strong>Memoization</strong>. The main idea is to compute the maximum sum of averages by considering all possible partitions of the array.</p>
<p>Here&rsquo;s a step-by-step breakdown of the approach:</p>
<ol>
<li>
<p><strong>Dynamic Programming</strong>: We maintain a DP table where <code>memo[i][j]</code> represents the maximum sum of averages we can achieve by partitioning the first <code>i</code> elements of the array into <code>j</code> subarrays.</p>
</li>
<li>
<p><strong>Precompute Prefix Sums</strong>: Before starting the DP, we precompute the prefix sums of the array so that we can quickly compute the average of any subarray. The prefix sum at index <code>i</code> gives the sum of all elements in <code>nums[0..i-1]</code>. Using this, the average of a subarray from index <code>i</code> to <code>j</code> can be computed as <code>(prefix[j+1] - prefix[i]) / (j - i + 1)</code>.</p>
</li>
<li>
<p><strong>Recursive Search with Memoization</strong>: The solution uses recursion to explore all possible ways to partition the array into <code>k</code> subarrays. Each recursion tries to partition the array by considering the last partition to be a subarray from some index <code>i</code> to <code>n</code>, and the rest is handled by the DP table. This allows us to break the problem into subproblems and store results to avoid redundant computations.</p>
</li>
<li>
<p><strong>Base Case</strong>: The base case is when we have exactly <code>1</code> subarray, in which case the average of the entire array is used as the only element.</p>
</li>
<li>
<p><strong>Transition</strong>: The state transition is based on splitting the array into smaller subarrays, and for each subarray, we compute its average and combine it with the results from previous subarrays.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="step-1-initializing-the-memoization-table">Step 1: Initializing the Memoization Table</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>memset(memo, <span style="color:#666">0</span>, <span style="color:#a2f;font-weight:bold">sizeof</span>(memo));
</span></span></code></pre></div><ul>
<li>We initialize the <code>memo</code> table to store the results of subproblems. The size of the table is <code>[200][200]</code> since the problem constraints suggest that the number of elements in <code>nums</code> is manageable, and <code>k</code> is at most 200. This memoization ensures we donâ€™t compute the same subproblem multiple times, making the solution efficient.</li>
</ul>
<h4 id="step-2-calculating-the-prefix-sums-and-initializing-the-first-subarray">Step 2: Calculating the Prefix Sums and Initializing the First Subarray</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> nums.size();
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">double</span> cur <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>    cur <span style="color:#666">+=</span> nums[i];
</span></span><span style="display:flex;"><span>    memo[i <span style="color:#666">+</span> <span style="color:#666">1</span>][<span style="color:#666">1</span>] <span style="color:#666">=</span> cur <span style="color:#666">/</span> (i <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>We iterate through the array and compute the prefix sums (<code>cur</code>). For each prefix sum, we store the average of the first <code>i+1</code> elements in <code>memo[i+1][1]</code>, since this is the maximum sum we can get by using only one subarray from the start of the array to index <code>i</code>.</li>
</ul>
<h4 id="step-3-recursive-search-function">Step 3: Recursive Search Function</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">double</span> <span style="color:#00a000">search</span>(<span style="color:#0b0;font-weight:bold">int</span> n, <span style="color:#0b0;font-weight:bold">int</span> k, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(memo[n][k] <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) <span style="color:#a2f;font-weight:bold">return</span> memo[n][k];
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">double</span> cur <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>; i <span style="color:#666">&gt;</span> <span style="color:#666">0</span>; i<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>        cur <span style="color:#666">+=</span> nums[i];
</span></span><span style="display:flex;"><span>        memo[n][k] <span style="color:#666">=</span> max(memo[n][k], search(i, k <span style="color:#666">-</span> <span style="color:#666">1</span>, nums) <span style="color:#666">+</span> cur <span style="color:#666">/</span> (n <span style="color:#666">-</span> i));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> memo[n][k];
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>This is the core recursive function. It computes the maximum sum of averages for <code>n</code> elements and <code>k</code> subarrays.</li>
<li>First, it checks if the result is already memoized (<code>memo[n][k] &gt; 0</code>), and if so, returns the value.</li>
<li>It then computes the sum of elements from index <code>i</code> to <code>n</code> (which is part of the last subarray) and recursively calls the <code>search</code> function for the remaining elements (<code>i</code> to <code>n-1</code>) with <code>k-1</code> subarrays.</li>
<li>The function keeps track of the maximum possible sum by considering all possible ways of splitting the last subarray, and the result is memoized for future use.</li>
</ul>
<h4 id="step-4-final-result">Step 4: Final Result</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> <span style="color:#00a000">search</span>(n, k, nums);
</span></span></code></pre></div><ul>
<li>After initializing the first subarray averages, we call the <code>search</code> function to compute the maximum sum of averages for the entire array with <code>k</code> subarrays.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>O(n * k)</strong>:
<ul>
<li>We have <code>n</code> elements and at most <code>k</code> subarrays. For each state <code>memo[n][k]</code>, we try every possible split of the array into two subarrays, which results in <code>O(n)</code> recursive calls per state.</li>
<li>Thus, the time complexity is proportional to the number of states (<code>n * k</code>), and each state takes linear time (<code>O(n)</code>) to compute due to the recursive exploration.</li>
</ul>
</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>O(n * k)</strong>:
<ul>
<li>We are using a memoization table of size <code>n * k</code> to store the results for each subproblem, so the space complexity is directly proportional to the number of subproblems (<code>n * k</code>).</li>
</ul>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution effectively solves the problem of partitioning the array into <code>k</code> subarrays by using dynamic programming with memoization. By breaking the problem into smaller subproblems and storing intermediate results, we avoid redundant calculations and optimize the solution. The recursive approach, combined with efficient memoization, ensures that the solution is computed in a reasonable amount of time, even for larger input sizes.</p>
<p>In essence, this solution balances both time and space complexities to handle a variety of input sizes while providing an optimal solution to the problem. The approach is elegant, efficient, and applicable to similar problems involving partitioning or dynamic array processing.</p>
<p><a href="https://leetcode.com/problems/largest-sum-of-averages/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/3eqwUW6_cx4?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

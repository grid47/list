<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 538: Convert BST to Greater Tree | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 538: Convert BST to Greater Tree">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 538: Convert BST to Greater Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-538-convert-bst-to-greater-tree/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 538: Convert BST to Greater Tree">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 538: Convert BST to Greater Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-09-14T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Search Tree">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 538: Convert BST to Greater Tree</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1188s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/538.webp" 
           alt="A binary search tree where each node is gradually updated to a greater tree, with each transformation softly highlighted." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 538: Convert BST to Greater Tree Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1188s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> convertBST(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        convert(root);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">convert</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        convert(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>val <span style="color:#666">+=</span> sum;
</span></span><span style="display:flex;"><span>        sum <span style="color:#666">=</span> root<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>        convert(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem asks to convert a Binary Search Tree (BST) into a Greater Tree, where each node&rsquo;s value is replaced by the sum of all node values greater than or equal to the node&rsquo;s value in the original BST. The idea is to traverse the tree in a specific order and accumulate the sum as we go, updating each node with the accumulated sum.</p>
<h3 id="approach">Approach</h3>
<p>This problem involves transforming a given Binary Search Tree (BST) to a Greater Tree. The core idea is to traverse the tree in a reverse in-order fashion (right, root, left) to accumulate values. This reverse traversal ensures that at each node, we have already visited all the nodes that have a greater value. Here&rsquo;s how the approach works step by step:</p>
<ol>
<li>
<p><strong>In-Order Traversal</strong>: In a BST, an in-order traversal (left, root, right) will visit the nodes in increasing order of values. To accumulate the sum of all greater nodes, we need to traverse the tree in the reverse order, i.e., right, root, left.</p>
</li>
<li>
<p><strong>Accumulate Sum</strong>: As we traverse the tree in reverse in-order (right to left), we maintain a running sum (<code>sum</code>). When visiting a node, we update its value by adding the current value of <code>sum</code> to the node&rsquo;s value. Then, we update <code>sum</code> to reflect the new value of the node.</p>
</li>
<li>
<p><strong>Recursive Strategy</strong>: The solution involves a recursive depth-first search (DFS) to visit each node in the reverse in-order sequence. The DFS will start at the rightmost node (the largest node in the BST), accumulate the sum, update the node&rsquo;s value, and then proceed to the left subtree.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<ol>
<li><strong>TreeNode Structure</strong>:
<ul>
<li>We begin with a <code>TreeNode</code> struct definition, where each node contains an integer value (<code>val</code>), and pointers to the left and right children (<code>left</code>, <code>right</code>).</li>
<li>The constructor allows us to initialize nodes either with a value or with a left and right child as well.</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> val;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>right;
</span></span><span style="display:flex;"><span>    TreeNode() <span style="color:#666">:</span> val(<span style="color:#666">0</span>), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x) <span style="color:#666">:</span> val(x), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x, TreeNode <span style="color:#666">*</span>left, TreeNode <span style="color:#666">*</span>right) <span style="color:#666">:</span> val(x), left(left), right(right) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ol start="2">
<li><strong>Main Solution Class</strong>:
<ul>
<li>The <code>Solution</code> class contains the function <code>convertBST</code> which initiates the conversion of the BST to a Greater Tree.</li>
<li>It also contains a helper function <code>convert</code> that performs the actual recursive traversal and transformation.</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sum <span style="color:#666">=</span> <span style="color:#666">0</span>;  <span style="color:#080;font-style:italic">// Initialize sum to 0 to accumulate the values.
</span></span></span></code></pre></div><ol start="3">
<li><strong>convertBST Function</strong>:
<ul>
<li>This function is the entry point of the solution and calls the recursive <code>convert</code> function.</li>
<li>The <code>convertBST</code> function returns the root of the modified tree after conversion.</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> <span style="color:#00a000">convertBST</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        convert(root);  <span style="color:#080;font-style:italic">// Start converting the tree.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">return</span> root;  <span style="color:#080;font-style:italic">// Return the root of the modified tree.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span></code></pre></div><ol start="4">
<li><strong>convert Function</strong>:
<ul>
<li>The <code>convert</code> function is a recursive function that traverses the tree in reverse in-order.</li>
<li>The base case checks if the <code>root</code> is <code>nullptr</code>. If it is, the function simply returns as there are no nodes to process.</li>
<li>The function first recurses on the right child, then updates the node’s value with the accumulated sum, and finally recurses on the left child.</li>
</ul>
</li>
</ol>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">convert</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>root) <span style="color:#a2f;font-weight:bold">return</span>;  <span style="color:#080;font-style:italic">// If the node is null, return (base case).
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        convert(root<span style="color:#666">-&gt;</span>right);  <span style="color:#080;font-style:italic">// First, visit the right subtree (larger nodes).
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>val <span style="color:#666">+=</span> sum;  <span style="color:#080;font-style:italic">// Update the current node&#39;s value with the accumulated sum.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        sum <span style="color:#666">=</span> root<span style="color:#666">-&gt;</span>val;  <span style="color:#080;font-style:italic">// Update the sum to the current node&#39;s new value.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        convert(root<span style="color:#666">-&gt;</span>left);  <span style="color:#080;font-style:italic">// Finally, visit the left subtree (smaller nodes).
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>Traversal Time</strong>: The algorithm performs a depth-first traversal of the tree. Since each node is visited exactly once, the time complexity is proportional to the number of nodes in the tree, i.e., <code>O(n)</code>, where <code>n</code> is the number of nodes in the binary search tree.</li>
<li><strong>Overall Time Complexity</strong>: <code>O(n)</code> where <code>n</code> is the number of nodes in the tree.</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>Recursive Stack</strong>: The space complexity is determined by the depth of the recursive call stack. In the worst case, the tree could be skewed (i.e., a linked list), resulting in a recursion depth of <code>O(n)</code>. In a balanced tree, the recursion depth would be <code>O(log n)</code>. Thus, the space complexity is <code>O(n)</code> in the worst case, but it can be <code>O(log n)</code> for balanced trees.</li>
<li><strong>Overall Space Complexity</strong>: <code>O(n)</code> in the worst case due to recursion stack.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution effectively converts a Binary Search Tree (BST) into a Greater Tree where each node&rsquo;s value is replaced by the sum of all node values greater than or equal to the node&rsquo;s original value. The approach relies on a reverse in-order traversal to accumulate values from the rightmost node to the leftmost node. This ensures that at each step, the node is updated with the sum of all greater nodes in the tree. The solution is efficient with a time complexity of <code>O(n)</code> and space complexity of <code>O(n)</code> (in the worst case), making it optimal for this problem.</p>
<p><a href="https://leetcode.com/problems/convert-bst-to-greater-tree/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/AFDxiYO9XzY?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

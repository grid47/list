<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2196: Create Binary Tree From Descriptions | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2196: Create Binary Tree From Descriptions">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2196: Create Binary Tree From Descriptions in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2196-create-binary-tree-from-descriptions/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2196: Create Binary Tree From Descriptions">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2196: Create Binary Tree From Descriptions in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-04-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2196: Create Binary Tree From Descriptions</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode615s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> createBinaryTree(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> desc) {
</span></span><span style="display:flex;"><span>        set<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> s;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#a0a000">v</span>: desc) {
</span></span><span style="display:flex;"><span>            s.insert(v[<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>            s.insert(v[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">v</span>: desc) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(s.find(v[<span style="color:#666">1</span>]) <span style="color:#666">!=</span> s.end()) {
</span></span><span style="display:flex;"><span>                s.erase(v[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> root <span style="color:#666">=</span> <span style="color:#666">*</span>s.begin();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// found root
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#080;font-style:italic">// next create map for nodes
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#080;font-style:italic">// connect them as given in desc
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>
</span></span><span style="display:flex;"><span>        map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, TreeNode<span style="color:#666">*&gt;</span> mp;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">v</span>: desc) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(mp.find(v[<span style="color:#666">0</span>]) <span style="color:#666">==</span> mp.end()) {
</span></span><span style="display:flex;"><span>                mp[v[<span style="color:#666">0</span>]] <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(v[<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(mp.find(v[<span style="color:#666">1</span>]) <span style="color:#666">==</span> mp.end()) {
</span></span><span style="display:flex;"><span>                mp[v[<span style="color:#666">1</span>]] <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(v[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">v</span>: desc) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> paret <span style="color:#666">=</span> v[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> child <span style="color:#666">=</span> v[<span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> left  <span style="color:#666">=</span> v[<span style="color:#666">2</span>];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(left) mp[paret]<span style="color:#666">-&gt;</span>left  <span style="color:#666">=</span> mp[child];
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">else</span>     mp[paret]<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> mp[child];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> mp[root];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem requires constructing a binary tree based on a set of relationships provided in a 2D vector <code>desc</code>. Each element of the vector <code>desc</code> represents a relationship between a parent and a child node. The task is to reconstruct the binary tree from these relationships and return the root node of the tree.</p>
<p>Each vector in <code>desc</code> contains three integers:</p>
<ol>
<li>The first integer represents the parent node.</li>
<li>The second integer represents the child node.</li>
<li>The third integer indicates whether the child node is the left or right child of the parent. If the third integer is 1, the child is the left child; otherwise, it is the right child.</li>
</ol>
<h3 id="approach">Approach</h3>
<p>To construct the binary tree from the given descriptions in <code>desc</code>, the following approach is used:</p>
<ol>
<li>
<p><strong>Identify the Root</strong>:</p>
<ul>
<li>The first step is to identify the root node of the tree. The root is the only node that does not appear as a child in any of the relationships. Thus, by iterating over the <code>desc</code> list and keeping track of which nodes are children, we can find the root.</li>
</ul>
</li>
<li>
<p><strong>Create Nodes</strong>:</p>
<ul>
<li>After identifying the root, we need to create all the nodes of the binary tree. We use a <code>map</code> to store the nodes by their values, allowing us to easily access or create a node whenever required.</li>
</ul>
</li>
<li>
<p><strong>Build Relationships</strong>:</p>
<ul>
<li>Once all the nodes are created, we can proceed to build the relationships between the nodes as described in <code>desc</code>. For each parent-child pair, we assign the left or right child based on the third value in the vector.</li>
</ul>
</li>
<li>
<p><strong>Return the Root</strong>:</p>
<ul>
<li>After constructing the binary tree, the root node is returned.</li>
</ul>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="step-1-identify-the-root-node">Step 1: Identify the Root Node</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>set<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> s;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> <span style="color:#a0a000">v</span> : desc) {
</span></span><span style="display:flex;"><span>    s.insert(v[<span style="color:#666">0</span>]);  <span style="color:#080;font-style:italic">// Insert parent node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    s.insert(v[<span style="color:#666">1</span>]);  <span style="color:#080;font-style:italic">// Insert child node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><ul>
<li>A set <code>s</code> is used to keep track of all nodes that are either parents or children. This set will help us identify the root node later, as the root is the only node that does not appear as a child.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">v</span> : desc) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (s.find(v[<span style="color:#666">1</span>]) <span style="color:#666">!=</span> s.end()) {
</span></span><span style="display:flex;"><span>        s.erase(v[<span style="color:#666">1</span>]);  <span style="color:#080;font-style:italic">// Remove child nodes from the set
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>We iterate over each entry in <code>desc</code>. If the child node is already in the set <code>s</code>, we remove it, because a node that is a child cannot be the root.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> root <span style="color:#666">=</span> <span style="color:#666">*</span>s.begin();  <span style="color:#080;font-style:italic">// The remaining element in the set is the root
</span></span></span></code></pre></div><ul>
<li>The remaining element in the set <code>s</code> is the root node, as it has never been marked as a child.</li>
</ul>
<h4 id="step-2-create-the-binary-tree-nodes">Step 2: Create the Binary Tree Nodes</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, TreeNode<span style="color:#666">*&gt;</span> mp;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">v</span> : desc) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (mp.find(v[<span style="color:#666">0</span>]) <span style="color:#666">==</span> mp.end()) {
</span></span><span style="display:flex;"><span>        mp[v[<span style="color:#666">0</span>]] <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(v[<span style="color:#666">0</span>]);  <span style="color:#080;font-style:italic">// Create the parent node if not already created
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (mp.find(v[<span style="color:#666">1</span>]) <span style="color:#666">==</span> mp.end()) {
</span></span><span style="display:flex;"><span>        mp[v[<span style="color:#666">1</span>]] <span style="color:#666">=</span> <span style="color:#a2f;font-weight:bold">new</span> TreeNode(v[<span style="color:#666">1</span>]);  <span style="color:#080;font-style:italic">// Create the child node if not already created
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>A <code>map&lt;int, TreeNode*&gt;</code> called <code>mp</code> is used to store nodes. For each pair of parent-child nodes in <code>desc</code>, we check if the parent and child nodes have already been created. If not, we create new nodes for them.</li>
</ul>
<h4 id="step-3-build-the-parent-child-relationships">Step 3: Build the Parent-Child Relationships</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">v</span> : desc) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> parent <span style="color:#666">=</span> v[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> child <span style="color:#666">=</span> v[<span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> left <span style="color:#666">=</span> v[<span style="color:#666">2</span>];
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (left) {
</span></span><span style="display:flex;"><span>        mp[parent]<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> mp[child];  <span style="color:#080;font-style:italic">// Set the left child
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        mp[parent]<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> mp[child];  <span style="color:#080;font-style:italic">// Set the right child
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>For each parent-child relationship, we use the <code>left</code> value to determine whether to set the child as the left or right child of the parent. This is done by checking if <code>left</code> is <code>1</code> or <code>0</code>. If <code>left</code> is <code>1</code>, the child is set as the left child; otherwise, the child is set as the right child.</li>
</ul>
<h4 id="step-4-return-the-root-node">Step 4: Return the Root Node</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> mp[root];
</span></span></code></pre></div><ul>
<li>Finally, the function returns the root node from the <code>map</code>. Since we already identified the root earlier, it is now available in <code>mp[root]</code>.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>O(n)</strong>, where <code>n</code> is the number of nodes in the tree (i.e., the number of elements in <code>desc</code>). This is because:
<ul>
<li>We iterate through <code>desc</code> three times:
<ul>
<li>First to identify the root node.</li>
<li>Second to create nodes.</li>
<li>Third to build the parent-child relationships.</li>
</ul>
</li>
<li>Each of these operations is linear with respect to the number of nodes.</li>
</ul>
</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>O(n)</strong>, where <code>n</code> is the number of nodes in the tree. This space is used to store:
<ul>
<li>The set <code>s</code>, which contains at most <code>n</code> nodes.</li>
<li>The map <code>mp</code>, which also stores <code>n</code> nodes.</li>
</ul>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution constructs a binary tree based on a list of parent-child relationships described by the <code>desc</code> array. By efficiently identifying the root node, creating nodes, and building relationships, the solution provides a clean and optimized approach for tree reconstruction.</p>
<p>The algorithm uses a <code>set</code> to identify the root and a <code>map</code> to manage the nodes and their relationships, ensuring that the tree is reconstructed in linear time. This makes the solution efficient and scalable for large inputs, with a time complexity of O(n) and space complexity of O(n).</p>
<p>This code provides a well-structured and easy-to-understand approach for solving the problem of building a binary tree from a set of node relationships. It can be easily extended or modified to accommodate other variations of tree construction problems.</p>
<p><a href="https://leetcode.com/problems/create-binary-tree-from-descriptions/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/yWkrFfqO7NA?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

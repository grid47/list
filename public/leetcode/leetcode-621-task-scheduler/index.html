<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 621: Task Scheduler | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 621: Task Scheduler">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 621: Task Scheduler in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-621-task-scheduler/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 621: Task Scheduler">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 621: Task Scheduler in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-09-05T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="Greedy">
    <meta property="article:tag" content="Sorting">
    <meta property="article:tag" content="Heap (Priority Queue)">
    <meta property="article:tag" content="Counting">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 621: Task Scheduler</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1219s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/621.webp" 
           alt="A glowing task list where tasks are scheduled, with optimal scheduling steps softly illuminating." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 621: Task Scheduler Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1219s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> leastInterval(vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">char</span><span style="color:#666">&gt;&amp;</span> tasks, <span style="color:#0b0;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// if(n == 0) return tasks.size();
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">char</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">char</span> <span style="color:#a0a000">x</span>: tasks)
</span></span><span style="display:flex;"><span>            mp[x]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        priority_queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">char</span><span style="color:#666">&gt;&gt;</span> pq;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: mp) {
</span></span><span style="display:flex;"><span>            pq.push({it.second, it.first});
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> time <span style="color:#666">=</span> <span style="color:#666">0</span>, net <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>pq.empty()) {
</span></span><span style="display:flex;"><span>            vector<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">char</span><span style="color:#666">&gt;&gt;</span> tmp;
</span></span><span style="display:flex;"><span>            time <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n <span style="color:#666">+</span> <span style="color:#666">1</span>; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>pq.empty()) {
</span></span><span style="display:flex;"><span>                    <span style="color:#080;font-style:italic">// cout&lt;&lt;pq.top().first &lt;&lt; &#34; &#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>                    tmp.push_back(pq.top());
</span></span><span style="display:flex;"><span>                    pq.pop();
</span></span><span style="display:flex;"><span>                    time<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: tmp) {
</span></span><span style="display:flex;"><span>                it.first<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(it.first)
</span></span><span style="display:flex;"><span>                    pq.push(it);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            net <span style="color:#666">+=</span> <span style="color:#666">!</span>pq.empty()<span style="color:#666">?</span> n <span style="color:#666">+</span> <span style="color:#666">1</span><span style="color:#666">:</span> time;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> net;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem is to determine the least amount of time required to complete a set of tasks with cooling periods between the same tasks. You are given a list of tasks, each represented by a character, and a cooling period <code>n</code>. The goal is to schedule the tasks in such a way that no two identical tasks are executed within <code>n</code> units of time.</p>
<p>The cooling period <code>n</code> defines the minimum number of units of time that must pass between two consecutive executions of the same task. If there are idle times when no tasks are available to schedule, they should be accounted for as well.</p>
<p>Your task is to calculate the least interval (time) required to complete all tasks.</p>
<h3 id="approach">Approach</h3>
<p>This problem can be efficiently solved using a <strong>greedy approach</strong> combined with a <strong>priority queue</strong> (max-heap). Here&rsquo;s the breakdown of the approach:</p>
<ol>
<li>
<p><strong>Task Frequency Calculation:</strong> We first count the frequency of each task. The higher the frequency, the higher its priority in the scheduling process.</p>
</li>
<li>
<p><strong>Max-Heap to Select Tasks:</strong> We use a max-heap to always pick the most frequent task available to execute. The heap ensures that tasks with higher frequencies are processed first, and tasks that still need to be executed are moved to the heap again after the cooling period.</p>
</li>
<li>
<p><strong>Time Simulation:</strong> Each cycle consists of executing the most frequent tasks and then waiting for a cooling period. The cycle runs until all tasks are completed. If there are idle times (when no task is available to schedule), they are accounted for as well.</p>
</li>
<li>
<p><strong>Cooling Period Management:</strong> After each cycle, the tasks that are processed are decremented (one execution), and those tasks that still need to be executed are put back into the heap for future cycles. If tasks have no remaining executions left, they are discarded.</p>
</li>
</ol>
<p>By simulating this process, we can compute the minimum time required to complete all tasks.</p>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="step-1-count-task-frequencies">Step 1: Count Task Frequencies</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">char</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">char</span> <span style="color:#a0a000">x</span>: tasks)
</span></span><span style="display:flex;"><span>    mp[x]<span style="color:#666">++</span>;
</span></span></code></pre></div><ul>
<li>We use a map to count how many times each task occurs in the <code>tasks</code> list. Each key represents a task, and the value is the number of times that task appears.</li>
</ul>
<h4 id="step-2-create-a-max-heap-for-task-prioritization">Step 2: Create a Max-Heap for Task Prioritization</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>priority_queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">char</span><span style="color:#666">&gt;&gt;</span> pq;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: mp) {
</span></span><span style="display:flex;"><span>    pq.push({it.second, it.first});
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>We create a priority queue (max-heap) to prioritize tasks based on their frequency. The heap stores pairs of <code>&lt;frequency, task&gt;</code>. The task with the highest frequency will always be at the top of the heap, ensuring that we schedule the most frequent tasks first.</li>
</ul>
<h4 id="step-3-time-simulation-loop">Step 3: Time Simulation Loop</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> time <span style="color:#666">=</span> <span style="color:#666">0</span>, net <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>pq.empty()) {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">char</span><span style="color:#666">&gt;&gt;</span> tmp;
</span></span><span style="display:flex;"><span>    time <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n <span style="color:#666">+</span> <span style="color:#666">1</span>; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>pq.empty()) {
</span></span><span style="display:flex;"><span>            tmp.push_back(pq.top());
</span></span><span style="display:flex;"><span>            pq.pop();
</span></span><span style="display:flex;"><span>            time<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ul>
<li>We simulate each unit of time using a loop that continues as long as there are tasks in the heap. For each unit of time, we attempt to execute up to <code>n + 1</code> tasks (since we can process up to <code>n + 1</code> tasks within each cooling period).</li>
<li>We push the most frequent tasks from the heap into the <code>tmp</code> vector and increment the <code>time</code> for each task processed.</li>
</ul>
<h4 id="step-4-update-task-frequency-after-execution">Step 4: Update Task Frequency After Execution</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: tmp) {
</span></span><span style="display:flex;"><span>    it.first<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(it.first)
</span></span><span style="display:flex;"><span>        pq.push(it);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>After executing a task, we decrement its frequency by 1 (<code>it.first--</code>). If a task still needs to be executed (its frequency is greater than 0), we push it back into the heap for future scheduling.</li>
</ul>
<h4 id="step-5-calculate-time-for-each-cycle">Step 5: Calculate Time for Each Cycle</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>net <span style="color:#666">+=</span> <span style="color:#666">!</span>pq.empty()<span style="color:#666">?</span> n <span style="color:#666">+</span> <span style="color:#666">1</span><span style="color:#666">:</span> time;
</span></span></code></pre></div><ul>
<li>After each cycle, if there are still tasks left in the heap, we account for the full cooling period <code>n + 1</code>. If there are no tasks left to process, we use the actual <code>time</code> spent in that cycle.</li>
</ul>
<h4 id="step-6-return-the-total-time">Step 6: Return the Total Time</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> net;
</span></span></code></pre></div><ul>
<li>Once all tasks are completed and the heap is empty, we return the total time spent to complete all tasks.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>O(N log K)</strong>, where <code>N</code> is the number of tasks and <code>K</code> is the number of unique tasks. The main operations involving the priority queue are the insertions and extractions, both of which take <strong>O(log K)</strong> time. In the worst case, every task will be pushed and popped from the heap, resulting in a time complexity of <strong>O(N log K)</strong>.</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>O(K)</strong>, where <code>K</code> is the number of unique tasks. We use a map to store the frequency of each task, and the priority queue stores each unique task with its frequency. Hence, the space complexity is proportional to the number of unique tasks.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently calculates the least amount of time needed to complete all tasks while respecting the cooling period between identical tasks. By using a greedy approach with a priority queue, we ensure that tasks are scheduled in an optimal order, prioritizing the most frequent tasks. The use of the max-heap allows us to select the tasks with the highest frequency, ensuring that we always work on tasks that require the most attention.</p>
<p>The solution handles various edge cases, including:</p>
<ul>
<li>Tasks with different frequencies.</li>
<li>Scenarios where there are fewer tasks than the available cooling time.</li>
<li>Edge cases where no cooling period is required (<code>n = 0</code>).</li>
</ul>
<p>The time and space complexity are efficient enough for large inputs, making this approach suitable for solving problems with large task lists and cooling periods. This solution strikes a balance between clarity and efficiency, ensuring both correctness and optimal performance for a variety of test cases.</p>
<p><a href="https://leetcode.com/problems/task-scheduler/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/s8p8ukTyA2I?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 501: Find Mode in Binary Search Tree | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 501: Find Mode in Binary Search Tree">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 501: Find Mode in Binary Search Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-501-find-mode-in-binary-search-tree/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 501: Find Mode in Binary Search Tree">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 501: Find Mode in Binary Search Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-09-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Search Tree">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 501: Find Mode in Binary Search Tree</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1168s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/501.webp" 
           alt="A glowing tree with nodes lighting up to highlight the mode, with the mode’s value softly radiating." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 501: Find Mode in Binary Search Tree Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1168s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> maxFreq <span style="color:#666">=</span> <span style="color:#666">0</span>, currFreq <span style="color:#666">=</span> <span style="color:#666">0</span>, precursor <span style="color:#666">=</span> INT_MIN;
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> findMode(TreeNode <span style="color:#666">*</span>root)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        inorderTraversal(root);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">inorderTraversal</span>(TreeNode <span style="color:#666">*</span>root)
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span>; <span style="color:#080;font-style:italic">// Stop condition
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        inorderTraversal(root<span style="color:#666">-&gt;</span>left); <span style="color:#080;font-style:italic">// Traverse left subtree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">if</span> (precursor <span style="color:#666">==</span> root<span style="color:#666">-&gt;</span>val) currFreq<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">else</span> currFreq <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (currFreq <span style="color:#666">&gt;</span> maxFreq)
</span></span><span style="display:flex;"><span>        {<span style="color:#080;font-style:italic">// Current node value has higher frequency than any previous visited
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            res.clear();
</span></span><span style="display:flex;"><span>            maxFreq <span style="color:#666">=</span> currFreq;
</span></span><span style="display:flex;"><span>            res.push_back(root<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">if</span> (currFreq <span style="color:#666">==</span> maxFreq)
</span></span><span style="display:flex;"><span>        {<span style="color:#080;font-style:italic">// Current node value has a frequency equal to the highest of previous visited
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            res.push_back(root<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        precursor <span style="color:#666">=</span> root<span style="color:#666">-&gt;</span>val; <span style="color:#080;font-style:italic">// Update the precursor
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        inorderTraversal(root<span style="color:#666">-&gt;</span>right); <span style="color:#080;font-style:italic">// Traverse right subtree
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The task is to find the mode(s) in a binary search tree (BST), where the mode is defined as the value(s) that appear most frequently. Given the properties of a BST—where left nodes are smaller than the root and right nodes are larger—finding the mode can be efficiently achieved by leveraging an in-order traversal, which visits nodes in ascending order. The challenge here is to traverse the tree and track frequencies without extra space for storing all nodes, resulting in an optimal, in-place solution.</p>
<h3 id="approach">Approach</h3>
<p>This solution employs in-order traversal to visit nodes in ascending order. As we traverse each node, we compare it with the previously visited node to determine if the current value is the same. If it is, we increment the frequency count. If not, we reset the count for the new value. By maintaining the maximum frequency encountered, we can efficiently update the result list whenever a new mode or another equally frequent value is found. Here’s a detailed breakdown of each component:</p>
<ol>
<li>
<p><strong>In-Order Traversal</strong>:</p>
<ul>
<li>In-order traversal is ideal for BSTs because it visits nodes in a sorted order, allowing us to detect sequences of identical values.</li>
<li>During traversal, if the current node’s value matches the previously visited node’s value, we increment the frequency counter. If not, we reset the counter to 1.</li>
</ul>
</li>
<li>
<p><strong>Tracking Frequencies</strong>:</p>
<ul>
<li>Three main variables help track the frequency: <code>maxFreq</code> (to store the highest frequency encountered), <code>currFreq</code> (current frequency of the value being checked), and <code>precursor</code> (the value of the last visited node).</li>
<li>When <code>currFreq</code> surpasses <code>maxFreq</code>, we clear the result vector <code>res</code> and add the current node’s value as the new mode. If <code>currFreq</code> equals <code>maxFreq</code>, we add the current node’s value to <code>res</code> since it has the same highest frequency.</li>
</ul>
</li>
<li>
<p><strong>Edge Case Handling</strong>:</p>
<ul>
<li>If the BST is empty (<code>root == NULL</code>), we immediately return an empty result vector, as there are no nodes to process.</li>
</ul>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>Here is a breakdown of the code:</p>
<ol>
<li>
<p><strong>Data Member Initialization</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> maxFreq <span style="color:#666">=</span> <span style="color:#666">0</span>, currFreq <span style="color:#666">=</span> <span style="color:#666">0</span>, precursor <span style="color:#666">=</span> INT_MIN;
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> res;
</span></span></code></pre></div><ul>
<li><code>maxFreq</code>: Tracks the maximum frequency of any node value encountered so far.</li>
<li><code>currFreq</code>: Tracks the frequency of the current node value.</li>
<li><code>precursor</code>: Holds the last visited node’s value, initialized to <code>INT_MIN</code> as a placeholder.</li>
<li><code>res</code>: Stores the result modes (values that appear with the highest frequency).</li>
</ul>
</li>
<li>
<p><strong>Main Function (<code>findMode</code>)</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> findMode(TreeNode <span style="color:#666">*</span>root) {
</span></span><span style="display:flex;"><span>    inorderTraversal(root);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><code>findMode</code> serves as the main function that initiates the in-order traversal of the BST.</li>
<li>After traversal, it returns the result vector <code>res</code> containing the modes of the tree.</li>
</ul>
</li>
<li>
<p><strong>Recursive In-Order Traversal (<code>inorderTraversal</code>)</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">inorderTraversal</span>(TreeNode <span style="color:#666">*</span>root) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    inorderTraversal(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (precursor <span style="color:#666">==</span> root<span style="color:#666">-&gt;</span>val) currFreq<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">else</span> currFreq <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span> (currFreq <span style="color:#666">&gt;</span> maxFreq) {
</span></span><span style="display:flex;"><span>        res.clear();
</span></span><span style="display:flex;"><span>        maxFreq <span style="color:#666">=</span> currFreq;
</span></span><span style="display:flex;"><span>        res.push_back(root<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">else</span> <span style="color:#a2f;font-weight:bold">if</span> (currFreq <span style="color:#666">==</span> maxFreq) {
</span></span><span style="display:flex;"><span>        res.push_back(root<span style="color:#666">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    precursor <span style="color:#666">=</span> root<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>    inorderTraversal(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li><strong>Base Case</strong>: If the current node is <code>NULL</code>, the function returns immediately, ending recursion for that path.</li>
<li><strong>Left Subtree Traversal</strong>: The function first recursively traverses the left subtree, consistent with in-order traversal.</li>
<li><strong>Frequency Check</strong>:
<ul>
<li>If the current node’s value equals <code>precursor</code>, it means the same value has been encountered consecutively, so <code>currFreq</code> is incremented.</li>
<li>If the value differs, <code>currFreq</code> is reset to 1 for this new value.</li>
</ul>
</li>
<li><strong>Updating Results</strong>:
<ul>
<li>If <code>currFreq</code> exceeds <code>maxFreq</code>, we clear the <code>res</code> vector (as a new mode with a higher frequency has been found), update <code>maxFreq</code> to <code>currFreq</code>, and add the current node’s value to <code>res</code>.</li>
<li>If <code>currFreq</code> matches <code>maxFreq</code>, the current node’s value has the same frequency as previous modes, so it’s added to <code>res</code>.</li>
</ul>
</li>
<li><strong>Right Subtree Traversal</strong>: After processing the current node, we traverse the right subtree to complete the in-order traversal.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ol>
<li>
<p><strong>Time Complexity</strong>:</p>
<ul>
<li><strong>O(n)</strong>: We visit each node exactly once during the in-order traversal, where <code>n</code> is the number of nodes in the BST.</li>
</ul>
</li>
<li>
<p><strong>Space Complexity</strong>:</p>
<ul>
<li><strong>O(h)</strong>: The recursion stack requires space proportional to the height of the tree, which is <code>O(log n)</code> for a balanced BST and <code>O(n)</code> for a skewed BST.</li>
</ul>
</li>
</ol>
<h3 id="conclusion">Conclusion</h3>
<p>This solution leverages in-order traversal to efficiently find the modes in a BST. By maintaining a frequency count of consecutive values, we avoid the need for extra storage or additional traversals. The approach is both time-efficient and space-optimized for BST structures, with performance largely determined by tree height. This implementation is ideal for cases where memory constraints are tight, as it only uses minimal extra space for tracking modes and frequencies.</p>
<p><a href="https://leetcode.com/problems/find-mode-in-binary-search-tree/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/cHwafswjTlE?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2131: Longest Palindrome by Concatenating Two Letter Words | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2131: Longest Palindrome by Concatenating Two Letter Words">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2131: Longest Palindrome by Concatenating Two Letter Words in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2131-longest-palindrome-by-concatenating-two-letter-words/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2131: Longest Palindrome by Concatenating Two Letter Words">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2131: Longest Palindrome by Concatenating Two Letter Words in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-04-07T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="String">
    <meta property="article:tag" content="Greedy">
    <meta property="article:tag" content="Counting">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2131: Longest Palindrome by Concatenating Two Letter Words</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode577s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> longestPalindrome(vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&amp;</span> words) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> unpaired <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#666">&lt;</span>string, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(string <span style="color:#a0a000">w</span>: words) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(w[<span style="color:#666">0</span>] <span style="color:#666">==</span> w[<span style="color:#666">1</span>]) {
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(mp[w] <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>                    unpaired<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>                    ans <span style="color:#666">+=</span> <span style="color:#666">4</span>;
</span></span><span style="display:flex;"><span>                    mp[w]<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                    unpaired<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>                    mp[w]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                string rev <span style="color:#666">=</span> w;
</span></span><span style="display:flex;"><span>                reverse(rev.begin(), rev.end());
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(mp[rev] <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>                    ans <span style="color:#666">+=</span> <span style="color:#666">4</span>;
</span></span><span style="display:flex;"><span>                    mp[rev]<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>                } <span style="color:#a2f;font-weight:bold">else</span> mp[w]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (unpaired <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) ans <span style="color:#666">+=</span> <span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem is to find the length of the longest palindrome that can be formed by concatenating a list of words. A palindrome reads the same forward and backward. In this case, we are given an array of strings where each string consists of two lowercase letters. The goal is to maximize the length of the palindrome that can be constructed using these words, taking into account that some words can contribute to the palindrome both directly and indirectly through their reverse pairs.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we can use the following approach:</p>
<ol>
<li><strong>Count Words</strong>: Use a hash map (or unordered map) to keep track of the counts of each word.</li>
<li><strong>Check for Pairs</strong>: For each word, check if it can form a palindrome by pairing with its reverse.</li>
<li><strong>Handle Unpaired Words</strong>: If there are words that are palindromes themselves (like &ldquo;aa&rdquo; or &ldquo;bb&rdquo;), keep track of them separately, as they can contribute to the center of the palindrome.</li>
<li><strong>Calculate Total Length</strong>: The total length of the palindrome will be computed by counting the lengths contributed by pairs of words, while ensuring that unpaired words are counted appropriately.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>Here&rsquo;s a detailed breakdown of the implementation:</p>
<ol>
<li>
<p><strong>Class Declaration</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span></code></pre></div><ul>
<li>The <code>Solution</code> class is defined, encapsulating the method that will solve the problem.</li>
</ul>
</li>
<li>
<p><strong>Function Definition</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">longestPalindrome</span>(vector<span style="color:#666">&lt;</span>string<span style="color:#666">&gt;&amp;</span> words) {
</span></span></code></pre></div><ul>
<li>The public member function <code>longestPalindrome</code> takes a vector of strings as input and will return an integer representing the maximum length of the palindrome.</li>
</ul>
</li>
<li>
<p><strong>Initialization</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> ans <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> unpaired <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>unordered_map<span style="color:#666">&lt;</span>string, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> mp;
</span></span></code></pre></div><ul>
<li><code>ans</code> will store the total length of the palindrome.</li>
<li><code>unpaired</code> keeps track of how many unpaired palindromic words we have encountered.</li>
<li><code>mp</code> is a hash map that stores the frequency of each word.</li>
</ul>
</li>
<li>
<p><strong>Iterate Through Words</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(string <span style="color:#a0a000">w</span>: words) {
</span></span></code></pre></div><ul>
<li>This loop iterates through each word in the input vector.</li>
</ul>
</li>
<li>
<p><strong>Check for Self-Palindromes</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(w[<span style="color:#666">0</span>] <span style="color:#666">==</span> w[<span style="color:#666">1</span>]) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(mp[w] <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>        unpaired<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>        ans <span style="color:#666">+=</span> <span style="color:#666">4</span>;
</span></span><span style="display:flex;"><span>        mp[w]<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        unpaired<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        mp[w]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>If the word is a palindrome (e.g., &ldquo;aa&rdquo;, &ldquo;bb&rdquo;), we check if we have previously encountered it.</li>
<li>If yes, we decrement the count of unpaired palindromic words and add 4 to the total length since each palindrome contributes twice its length.</li>
<li>If no, we increment the count of unpaired palindromic words and store it in the hash map.</li>
</ul>
</li>
<li>
<p><strong>Check for Reversible Pairs</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    string rev <span style="color:#666">=</span> w;
</span></span><span style="display:flex;"><span>    reverse(rev.begin(), rev.end());
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(mp[rev] <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>        ans <span style="color:#666">+=</span> <span style="color:#666">4</span>;
</span></span><span style="display:flex;"><span>        mp[rev]<span style="color:#666">--</span>;
</span></span><span style="display:flex;"><span>    } <span style="color:#a2f;font-weight:bold">else</span> mp[w]<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>For words that are not self-palindromes, we check if their reverse exists in the hash map.</li>
<li>If the reverse is found, we add 4 to the total length for the pair and decrement the count of that reverse word in the hash map.</li>
<li>If the reverse is not found, we add the current word to the hash map.</li>
</ul>
</li>
<li>
<p><strong>Handle Remaining Unpaired Words</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span> (unpaired <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) ans <span style="color:#666">+=</span> <span style="color:#666">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div><ul>
<li>After processing all words, if there are any unpaired palindromic words left, we can place one in the center of the palindrome, contributing 2 to the total length.</li>
<li>Finally, we return the computed length stored in <code>ans</code>.</li>
</ul>
</li>
<li>
<p><strong>End of Class</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li>This curly brace marks the end of the <code>Solution</code> class definition.</li>
</ul>
</li>
</ol>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: (O(n))</p>
<ul>
<li>The time complexity is (O(n)) where (n) is the number of words in the input vector. We make a single pass through the list of words, and operations on the unordered map (insertion and lookup) take average (O(1)) time.</li>
</ul>
</li>
<li>
<p><strong>Space Complexity</strong>: (O(n))</p>
<ul>
<li>The space complexity is (O(n)) as we might store every unique word in the hash map.</li>
</ul>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>The <code>longestPalindrome</code> function effectively calculates the maximum length of a palindrome that can be constructed from a list of words by utilizing pairs and self-palindromic words. The efficient use of a hash map allows us to track the counts of words and their reverses, while the method handles both the pairing of words and the potential inclusion of unpaired palindromes systematically.</p>
<p>This approach demonstrates a keen understanding of both string manipulation and hash maps in C++. The solution is not only efficient but also elegantly handles the requirements of the problem, providing a clear path to achieving the desired outcome.</p>
<p>In summary, this implementation is a strong example of solving a combinatorial problem using data structures efficiently, making it applicable in various contexts where palindrome formation and word pairing are relevant. The code is clear, concise, and structured in a way that makes it easy to follow, ensuring maintainability and readability.</p>
<p><a href="https://leetcode.com/problems/longest-palindrome-by-concatenating-two-letter-words/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/kBMf-m5we-8?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 797: All Paths From Source to Target | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 797: All Paths From Source to Target">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 797: All Paths From Source to Target in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-797-all-paths-from-source-to-target/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 797: All Paths From Source to Target">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 797: All Paths From Source to Target in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-08-19T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Backtracking">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Graph">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 797: All Paths From Source to Target</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1315s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/797.webp" 
           alt="A graph where all paths are traced from source to target, with each path softly glowing as it is found." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 797: All Paths From Source to Target Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1315s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> allPathsSourceTarget(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> graph) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> ans;
</span></span><span style="display:flex;"><span>        queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span>        q.push({<span style="color:#666">0</span>, {<span style="color:#666">0</span>}});
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> q.front().first;
</span></span><span style="display:flex;"><span>            vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> t <span style="color:#666">=</span> q.front().second;
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(x <span style="color:#666">==</span> graph.size() <span style="color:#666">-</span> <span style="color:#666">1</span>) ans.push_back(t);
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">k</span>: graph[x]) {
</span></span><span style="display:flex;"><span>                t.push_back(k);
</span></span><span style="display:flex;"><span>                q.push({k, t});
</span></span><span style="display:flex;"><span>                t.pop_back();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>In this problem, we are given a directed graph represented as an adjacency list <code>graph</code>, where each node is a non-negative integer. The task is to find all possible paths from the source node (node 0) to the target node (the last node in the graph). Each path must be a sequence of nodes that starts at node 0 and ends at the last node, following the directed edges of the graph.</p>
<p>This problem is essentially about finding all possible paths in a directed graph, starting from the source and ending at the target. The challenge is to explore all paths efficiently while adhering to the structure of the graph.</p>
<h3 id="approach">Approach</h3>
<p>The approach to solve this problem is to use <strong>breadth-first search (BFS)</strong> with a queue. The BFS technique is ideal for exploring all paths from the source to the target because it processes nodes level by level, ensuring that all possible paths are considered. By maintaining the path as we traverse the graph, we can capture all valid paths from the source to the target.</p>
<p>Here’s how we can break the problem into smaller steps:</p>
<ol>
<li>
<p><strong>Use a Queue for BFS</strong>: We&rsquo;ll utilize a queue where each element contains a node and the path taken to reach that node. This ensures that when we reach a node, we know the exact sequence of nodes leading up to it.</p>
</li>
<li>
<p><strong>Traverse the Graph</strong>: From the source node, explore all adjacent nodes recursively, adding them to the current path.</p>
</li>
<li>
<p><strong>Capture Valid Paths</strong>: Once we reach the target node (the last node in the graph), we add the current path to our result.</p>
</li>
<li>
<p><strong>Backtrack Efficiently</strong>: Since we are using BFS, we will not need to explicitly backtrack. The queue takes care of processing the nodes in the correct order.</p>
</li>
</ol>
<p>By using this BFS-based approach, we ensure that we explore all potential paths from the source to the target while maintaining efficiency.</p>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>Let’s go through the code step by step to understand its implementation:</p>
<h4 id="step-1-initialize-the-result-and-queue">Step 1: Initialize the Result and Queue</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> ans;
</span></span><span style="display:flex;"><span>queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span>q.push({<span style="color:#666">0</span>, {<span style="color:#666">0</span>}});
</span></span></code></pre></div><ul>
<li><code>ans</code>: A vector of vectors that will store all valid paths from the source to the target.</li>
<li><code>q</code>: A queue used to perform the breadth-first search (BFS). Each element in the queue is a pair, where:
<ul>
<li>The first element is a node <code>x</code>.</li>
<li>The second element is a vector of integers representing the current path taken to reach node <code>x</code>.</li>
</ul>
</li>
<li>Initially, we push the source node (node 0) into the queue, with the path being <code>{0}</code>.</li>
</ul>
<h4 id="step-2-start-bfs-loop">Step 2: Start BFS Loop</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> q.front().first;
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> t <span style="color:#666">=</span> q.front().second;
</span></span><span style="display:flex;"><span>    q.pop();
</span></span></code></pre></div><ul>
<li>The loop continues as long as there are elements in the queue. This ensures that we process all nodes and paths.</li>
<li>We pop the front element of the queue to get the current node <code>x</code> and the path <code>t</code> taken to reach that node.</li>
</ul>
<h4 id="step-3-check-for-target-node">Step 3: Check for Target Node</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(x <span style="color:#666">==</span> graph.size() <span style="color:#666">-</span> <span style="color:#666">1</span>) ans.push_back(t);
</span></span></code></pre></div><ul>
<li>If the current node <code>x</code> is the target node (the last node in the graph, which is <code>graph.size() - 1</code>), we add the current path <code>t</code> to the result <code>ans</code>. This indicates that we’ve found a valid path from the source to the target.</li>
</ul>
<h4 id="step-4-explore-adjacent-nodes">Step 4: Explore Adjacent Nodes</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">k</span>: graph[x]) {
</span></span><span style="display:flex;"><span>    t.push_back(k);
</span></span><span style="display:flex;"><span>    q.push({k, t});
</span></span><span style="display:flex;"><span>    t.pop_back();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>For each adjacent node <code>k</code> to the current node <code>x</code> (i.e., each node that can be reached directly from node <code>x</code>), we do the following:
<ul>
<li>Add node <code>k</code> to the current path <code>t</code>.</li>
<li>Push the new node <code>k</code> and the updated path <code>t</code> into the queue. This ensures that we continue exploring paths from node <code>k</code>.</li>
<li>After the push, we backtrack by removing node <code>k</code> from the path <code>t</code> using <code>t.pop_back()</code>. This is necessary because we need to keep <code>t</code> intact for future iterations, maintaining the correct path sequence.</li>
</ul>
</li>
</ul>
<h4 id="step-5-return-the-result">Step 5: Return the Result</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span></code></pre></div><ul>
<li>Once the BFS loop has processed all possible paths, we return the result <code>ans</code>, which contains all valid paths from the source to the target node.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<p>The time complexity of this solution is <strong>O(N + E)</strong>, where:</p>
<ul>
<li><code>N</code> is the number of nodes in the graph (i.e., <code>graph.size()</code>).</li>
<li><code>E</code> is the total number of edges in the graph (i.e., the sum of the lengths of the adjacency lists in the <code>graph</code>).</li>
</ul>
<p>This is because each node and edge is processed at most once during the BFS. For each node, we explore all of its neighbors (edges), and for each edge, we push a new path into the queue. Therefore, the overall time complexity depends on the number of nodes and edges in the graph.</p>
<h4 id="space-complexity">Space Complexity:</h4>
<p>The space complexity is <strong>O(N + E)</strong> due to:</p>
<ul>
<li>The space required for storing the graph, which is <code>O(N + E)</code> as it is represented as an adjacency list.</li>
<li>The space required for the queue, which could store paths for each possible traversal of the graph. In the worst case, the queue can hold a number of paths proportional to the number of edges.</li>
</ul>
<p>Thus, the space complexity is dominated by the graph&rsquo;s adjacency list and the queue that stores the paths during BFS.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This solution uses breadth-first search (BFS) to explore all possible paths from the source node (0) to the target node (the last node in the graph). The BFS approach is suitable because it ensures that all paths are considered without unnecessary recomputation. By maintaining the path along with the node being processed, we are able to efficiently capture all valid paths from the source to the target.</p>
<p>The algorithm is efficient, with a time complexity of O(N + E) and space complexity of O(N + E), making it scalable to large graphs. The use of a queue allows us to explore the graph level by level, ensuring that every potential path is processed correctly. The backtracking step (via <code>t.pop_back()</code>) ensures that paths are managed efficiently without modifying the paths prematurely.</p>
<p>This method is optimal for finding all paths in a directed graph from a given source to a target, and its clear and straightforward implementation ensures that it can be easily adapted for similar graph traversal problems.</p>
<p><a href="https://leetcode.com/problems/all-paths-from-source-to-target/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/MQU2IIWwaOg?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 934: Shortest Bridge | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 934: Shortest Bridge">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 934: Shortest Bridge in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-934-shortest-bridge/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 934: Shortest Bridge">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 934: Shortest Bridge in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-08-05T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Matrix">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 934: Shortest Bridge</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1399s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> shortestBridge(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>        queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">bool</span> flag <span style="color:#666">=</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> grid.size(), n <span style="color:#666">=</span> grid[<span style="color:#666">0</span>].size();
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> m; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> n; j<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span> (grid[i][j]) {
</span></span><span style="display:flex;"><span>                    dfs(i, j, q, grid);
</span></span><span style="display:flex;"><span>                    flag <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#a2f;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> (flag) <span style="color:#a2f;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> step <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> dir[<span style="color:#666">5</span>] <span style="color:#666">=</span> {<span style="color:#666">0</span>,<span style="color:#666">1</span>,<span style="color:#666">0</span>,<span style="color:#666">-</span><span style="color:#666">1</span>,<span style="color:#666">0</span>};
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> sz; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>                pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> p <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>                q.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> <span style="color:#666">4</span>; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> p.first <span style="color:#666">+</span> dir[i], y <span style="color:#666">=</span> p.second <span style="color:#666">+</span> dir[i<span style="color:#666">+</span><span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>                    <span style="color:#a2f;font-weight:bold">if</span>(x <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> y <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> x <span style="color:#666">&gt;=</span> grid.size() <span style="color:#666">||</span> y <span style="color:#666">&gt;=</span> grid[<span style="color:#666">0</span>].size() <span style="color:#666">||</span> grid[x][y] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>                        <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>                    <span style="color:#a2f;font-weight:bold">if</span>(grid[x][y] <span style="color:#666">==</span> <span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> step;
</span></span><span style="display:flex;"><span>                    q.push({x, y});
</span></span><span style="display:flex;"><span>                    grid[x][y] <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            step<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(<span style="color:#0b0;font-weight:bold">int</span> x, <span style="color:#0b0;font-weight:bold">int</span> y, queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> <span style="color:#666">&amp;</span>q, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> <span style="color:#666">&amp;</span>grid) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(x <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> y <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> x <span style="color:#666">&gt;=</span> grid.size() <span style="color:#666">||</span> y <span style="color:#666">&gt;=</span> grid[<span style="color:#666">0</span>].size() <span style="color:#666">||</span> grid[x][y] <span style="color:#666">!=</span> <span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>        q.push(make_pair(x, y));
</span></span><span style="display:flex;"><span>        grid[x][y] <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        dfs(x <span style="color:#666">+</span> <span style="color:#666">1</span>, y, q, grid);
</span></span><span style="display:flex;"><span>        dfs(x <span style="color:#666">-</span> <span style="color:#666">1</span>, y, q, grid);
</span></span><span style="display:flex;"><span>        dfs(x, y <span style="color:#666">+</span> <span style="color:#666">1</span>, q, grid);
</span></span><span style="display:flex;"><span>        dfs(x, y <span style="color:#666">-</span> <span style="color:#666">1</span>, q, grid);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem involves finding the shortest bridge between two islands in a 2D grid. Each cell in the grid can be:</p>
<ul>
<li><code>1</code> representing land.</li>
<li><code>0</code> representing water.</li>
</ul>
<p>The grid contains two islands, and your task is to connect these islands by flipping the fewest number of <code>0</code>s to <code>1</code>s, i.e., build the shortest bridge. The bridge should connect the two islands through water cells, while the bridge itself is made of the water cells turned into land. You are required to return the minimum number of flips needed to connect the two islands.</p>
<h3 id="approach">Approach</h3>
<p>This problem is typically solved by employing a <strong>Breadth-First Search (BFS)</strong> algorithm in conjunction with <strong>Depth-First Search (DFS)</strong> to identify the two islands and find the shortest path to connect them.</p>
<h4 id="step-by-step-explanation">Step-by-Step Explanation:</h4>
<ol>
<li>
<p><strong>Identifying the First Island using DFS</strong>:</p>
<ul>
<li>First, we need to find one of the islands. We can do this by iterating through the grid and performing a DFS search from the first <code>1</code> we encounter. This will allow us to mark all the land cells of this island and store their coordinates in a queue for the next step.</li>
<li>During the DFS traversal, we mark all the cells of the first island as <code>-1</code> to prevent visiting them again, and we store the coordinates of these cells in a queue. These coordinates will later serve as the starting points for the BFS.</li>
</ul>
</li>
<li>
<p><strong>Expanding the Search using BFS</strong>:</p>
<ul>
<li>Once the first island is identified, the next step is to start the BFS from the coordinates of the first island&rsquo;s land cells. The BFS will explore the neighboring water cells (<code>0</code>s) and gradually expand the search in all four directions (up, down, left, right).</li>
<li>The BFS continues until it encounters the second island&rsquo;s land cells. As soon as the second island is reached, the BFS will return the number of water cells (<code>0</code>s) traversed, which corresponds to the number of flips needed to connect the two islands.</li>
</ul>
</li>
<li>
<p><strong>Return the Result</strong>:</p>
<ul>
<li>The result is the number of steps taken by the BFS to connect the two islands, which is the minimal number of flips required to build the bridge.</li>
</ul>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<ol>
<li>
<p><strong>DFS for the First Island</strong>:
We start by using DFS to identify and mark the first island in the grid. The DFS function <code>dfs(x, y)</code> explores all connected <code>1</code>s (land cells) and marks them as <code>-1</code> to prevent revisiting them.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">void</span> <span style="color:#00a000">dfs</span>(<span style="color:#0b0;font-weight:bold">int</span> x, <span style="color:#0b0;font-weight:bold">int</span> y, queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> q, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(x <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> y <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> x <span style="color:#666">&gt;=</span> grid.size() <span style="color:#666">||</span> y <span style="color:#666">&gt;=</span> grid[<span style="color:#666">0</span>].size() <span style="color:#666">||</span> grid[x][y] <span style="color:#666">!=</span> <span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    q.push(make_pair(x, y));  <span style="color:#080;font-style:italic">// Add land cell to the queue for BFS
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    grid[x][y] <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>;  <span style="color:#080;font-style:italic">// Mark the land cell as visited
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    dfs(x <span style="color:#666">+</span> <span style="color:#666">1</span>, y, q, grid);  <span style="color:#080;font-style:italic">// Explore down
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    dfs(x <span style="color:#666">-</span> <span style="color:#666">1</span>, y, q, grid);  <span style="color:#080;font-style:italic">// Explore up
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    dfs(x, y <span style="color:#666">+</span> <span style="color:#666">1</span>, q, grid);  <span style="color:#080;font-style:italic">// Explore right
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    dfs(x, y <span style="color:#666">-</span> <span style="color:#666">1</span>, q, grid);  <span style="color:#080;font-style:italic">// Explore left
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><ul>
<li>This function is invoked when we first find a <code>1</code> (land) during the grid traversal.</li>
<li>We then mark all land cells connected to this one, effectively identifying the first island and storing its cells in a queue.</li>
</ul>
</li>
<li>
<p><strong>BFS to Find the Shortest Bridge</strong>:
After marking the first island, we use BFS to find the shortest path to the second island. BFS is particularly suited for finding the shortest path in an unweighted grid like this.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> step <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> dir[<span style="color:#666">5</span>] <span style="color:#666">=</span> {<span style="color:#666">0</span>,<span style="color:#666">1</span>,<span style="color:#666">0</span>,<span style="color:#666">-</span><span style="color:#666">1</span>,<span style="color:#666">0</span>};  <span style="color:#080;font-style:italic">// Direction vectors for up, right, down, and left
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();  <span style="color:#080;font-style:italic">// Get the number of elements in the queue
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> sz; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> p <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>        q.pop();  <span style="color:#080;font-style:italic">// Get the next land cell from the queue
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> <span style="color:#666">4</span>; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> p.first <span style="color:#666">+</span> dir[i], y <span style="color:#666">=</span> p.second <span style="color:#666">+</span> dir[i <span style="color:#666">+</span> <span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#080;font-style:italic">// Check if the new position is valid and within bounds
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            <span style="color:#a2f;font-weight:bold">if</span>(x <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> y <span style="color:#666">&lt;</span> <span style="color:#666">0</span> <span style="color:#666">||</span> x <span style="color:#666">&gt;=</span> grid.size() <span style="color:#666">||</span> y <span style="color:#666">&gt;=</span> grid[<span style="color:#666">0</span>].size() <span style="color:#666">||</span> grid[x][y] <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">continue</span>;  <span style="color:#080;font-style:italic">// Skip invalid positions or already visited cells
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            <span style="color:#a2f;font-weight:bold">if</span>(grid[x][y] <span style="color:#666">==</span> <span style="color:#666">1</span>) <span style="color:#a2f;font-weight:bold">return</span> step;  <span style="color:#080;font-style:italic">// If we find land of the second island, return the step count
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            q.push({x, y});  <span style="color:#080;font-style:italic">// Add the water cell to the queue for further exploration
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            grid[x][y] <span style="color:#666">=</span> <span style="color:#666">-</span><span style="color:#666">1</span>;  <span style="color:#080;font-style:italic">// Mark the water cell as visited
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    step<span style="color:#666">++</span>;  <span style="color:#080;font-style:italic">// Increase the number of steps after expanding one level
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><ul>
<li>The BFS starts by processing the first islandâ€™s land cells stored in the queue. For each cell, it explores the adjacent cells (up, down, left, right).</li>
<li>If an adjacent cell is water (<code>0</code>), it is added to the queue, and its value is marked as visited by setting it to <code>-1</code>.</li>
<li>If an adjacent cell is land (<code>1</code>), the BFS terminates, and the step count is returned.</li>
</ul>
</li>
<li>
<p><strong>Main Function</strong>:
The <code>shortestBridge()</code> function initializes the BFS process after identifying the first island using DFS. It sets up the queue and handles the BFS iterations.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">shortestBridge</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> grid) {
</span></span><span style="display:flex;"><span>    queue<span style="color:#666">&lt;</span>pair<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> flag <span style="color:#666">=</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> grid.size(), n <span style="color:#666">=</span> grid[<span style="color:#666">0</span>].size();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> m; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> n; j<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> (grid[i][j]) {
</span></span><span style="display:flex;"><span>                dfs(i, j, q, grid);  <span style="color:#080;font-style:italic">// Find the first island and mark it
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>                flag <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (flag) <span style="color:#a2f;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> bfs(grid, q);  <span style="color:#080;font-style:italic">// Perform BFS to find the shortest bridge
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><ul>
<li>The function starts by iterating over the grid to find the first <code>1</code> (land). Once found, DFS is invoked to mark all the land cells of the first island.</li>
<li>After identifying the first island, BFS is used to find the shortest path to the second island, and the result is returned.</li>
</ul>
</li>
</ol>
<h3 id="time-complexity">Time Complexity</h3>
<ul>
<li><strong>DFS</strong>: The DFS function visits every cell of the grid exactly once, so its time complexity is <strong>O(m * n)</strong>, where <code>m</code> is the number of rows and <code>n</code> is the number of columns in the grid.</li>
<li><strong>BFS</strong>: Similarly, the BFS function also processes each cell of the grid exactly once, making its time complexity <strong>O(m * n)</strong>.</li>
</ul>
<p>Thus, the overall time complexity is <strong>O(m * n)</strong>, where <code>m</code> is the number of rows and <code>n</code> is the number of columns in the grid.</p>
<h3 id="space-complexity">Space Complexity</h3>
<ul>
<li>The space complexity is <strong>O(m * n)</strong> because the space used by the queue in the BFS can grow to the size of the grid in the worst case.</li>
<li>Additionally, the DFS modifies the grid in place, which does not require extra space.</li>
</ul>
<p>Therefore, the space complexity is <strong>O(m * n)</strong> due to the storage used by the grid and the queue.</p>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently solves the problem of finding the shortest bridge between two islands in a 2D grid using a combination of <strong>DFS</strong> to identify the first island and <strong>BFS</strong> to find the shortest path. The use of BFS ensures that the minimal number of flips is computed in optimal time, and by modifying the grid in place, we minimize space complexity. This approach ensures that the problem is solved efficiently, even for large grids.</p>
<p><a href="https://leetcode.com/problems/shortest-bridge/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/1RZijG2c1CA?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

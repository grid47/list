<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 1937: Maximum Number of Points with Cost | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1937: Maximum Number of Points with Cost">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1937: Maximum Number of Points with Cost in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-1937-maximum-number-of-points-with-cost/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1937: Maximum Number of Points with Cost">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1937: Maximum Number of Points with Cost in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-04-27T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Dynamic Programming">
    <meta property="article:tag" content="Matrix">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 1937: Maximum Number of Points with Cost</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode466s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> pts;
</span></span><span style="display:flex;"><span>    map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span><span style="color:#666">&gt;&gt;</span> mp;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#00a000">dp</span>(<span style="color:#0b0;font-weight:bold">int</span> idx, <span style="color:#0b0;font-weight:bold">int</span> prv) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(idx <span style="color:#666">==</span> pts.size()) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(mp.count(idx) <span style="color:#666">&amp;&amp;</span> mp[idx].count(prv)) <span style="color:#a2f;font-weight:bold">return</span> mp[idx][prv];
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> ans <span style="color:#666">=</span> LLONG_MIN;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(prv <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> pts[<span style="color:#666">0</span>].size(); i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>                ans <span style="color:#666">=</span> max(ans, pts[idx][i] <span style="color:#666">+</span> dp(idx <span style="color:#666">+</span> <span style="color:#666">1</span>, i));
</span></span><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> pts[<span style="color:#666">0</span>].size(); i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>                ans <span style="color:#666">=</span> max(ans, pts[idx][i] <span style="color:#666">-</span> abs(i <span style="color:#666">-</span> prv) <span style="color:#666">+</span> dp(idx <span style="color:#666">+</span> <span style="color:#666">1</span>, i));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> mp[idx][prv] <span style="color:#666">=</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#00a000">maxPoints</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> points) {
</span></span><span style="display:flex;"><span>        pts <span style="color:#666">=</span> points;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> pts.size(), n <span style="color:#666">=</span> pts[<span style="color:#666">0</span>].size();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span><span style="color:#666">&gt;</span> prv(n);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) prv[i] <span style="color:#666">=</span> pts[<span style="color:#666">0</span>][i];
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> m <span style="color:#666">-</span> <span style="color:#666">1</span>; j<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span><span style="color:#666">&gt;</span> left(n, <span style="color:#666">0</span>), right(n, <span style="color:#666">0</span>), cur(n, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            left[<span style="color:#666">0</span>] <span style="color:#666">=</span> prv[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>            right[n <span style="color:#666">-</span> <span style="color:#666">1</span>] <span style="color:#666">=</span> prv[n <span style="color:#666">-</span> <span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">1</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>                left[i] <span style="color:#666">=</span> max(left[i <span style="color:#666">-</span> <span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#666">1</span>, prv[i]);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> n <span style="color:#666">-</span> <span style="color:#666">2</span>; i <span style="color:#666">&gt;=</span> <span style="color:#666">0</span>; i<span style="color:#666">--</span>)
</span></span><span style="display:flex;"><span>                right[i] <span style="color:#666">=</span> max(right[i <span style="color:#666">+</span> <span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#666">1</span>, prv[i]);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>                cur[i] <span style="color:#666">=</span> max(left[i], right[i]) <span style="color:#666">+</span> pts[j <span style="color:#666">+</span> <span style="color:#666">1</span>][i];
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            prv <span style="color:#666">=</span> cur;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> ans <span style="color:#666">=</span> LLONG_MIN;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>            ans <span style="color:#666">=</span> max(ans, prv[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem at hand is to maximize the points collected while traversing a grid of points. Each point in the grid has a certain score, and the traversal must follow specific rules regarding movement between points. The primary objective is to navigate through this grid in such a way that the total points accumulated are maximized.</p>
<h3 id="approach">Approach</h3>
<p>To tackle this problem, we utilize a dynamic programming strategy that allows us to efficiently compute the maximum points that can be obtained by traversing the grid while adhering to the given movement constraints. The approach can be broken down into several key steps:</p>
<ol>
<li>
<p><strong>Dynamic Programming Initialization</strong>: We initialize a memoization structure to store previously computed values, which helps avoid redundant calculations.</p>
</li>
<li>
<p><strong>Iterate Over Rows</strong>: We iterate through each row of points in the grid, calculating the maximum possible scores for each position based on the scores of the previous row.</p>
</li>
<li>
<p><strong>Two-Pass Calculation</strong>: For each row, we perform two passes—one from left to right to compute scores influenced by the left side, and another from right to left for the right side. This ensures we accurately consider the impact of the distance from the previous point.</p>
</li>
<li>
<p><strong>Final Calculation</strong>: After processing all rows, we determine the maximum score achievable from the last row of computed values.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> pts;
</span></span><span style="display:flex;"><span>    map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span><span style="color:#666">&gt;&gt;</span> mp;
</span></span></code></pre></div><p>In the above code snippet, we define a class <code>Solution</code> with two member variables: <code>pts</code> to store the points grid, and <code>mp</code> to serve as our memoization map for dynamic programming.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#00a000">dp</span>(<span style="color:#0b0;font-weight:bold">int</span> idx, <span style="color:#0b0;font-weight:bold">int</span> prv) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(idx <span style="color:#666">==</span> pts.size()) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">0</span>;
</span></span></code></pre></div><p>The <code>dp</code> function is defined to calculate the maximum points recursively. It takes the current index (<code>idx</code>) and the previous column index (<code>prv</code>). If we reach the end of the points array, we return 0, indicating no more points can be collected.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(mp.count(idx) <span style="color:#666">&amp;&amp;</span> mp[idx].count(prv)) <span style="color:#a2f;font-weight:bold">return</span> mp[idx][prv];
</span></span></code></pre></div><p>This line checks if the result for the current index and previous column is already computed and stored in the memoization map. If it is, we return the stored value to avoid recalculating.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> ans <span style="color:#666">=</span> LLONG_MIN;
</span></span></code></pre></div><p>We initialize <code>ans</code> to the minimum possible long long value to ensure any score calculated is larger.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(prv <span style="color:#666">==</span> <span style="color:#666">-</span><span style="color:#666">1</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> pts[<span style="color:#666">0</span>].size(); i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>                ans <span style="color:#666">=</span> max(ans, pts[idx][i] <span style="color:#666">+</span> dp(idx <span style="color:#666">+</span> <span style="color:#666">1</span>, i));
</span></span><span style="display:flex;"><span>        } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> pts[<span style="color:#666">0</span>].size(); i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>                ans <span style="color:#666">=</span> max(ans, pts[idx][i] <span style="color:#666">-</span> abs(i <span style="color:#666">-</span> prv) <span style="color:#666">+</span> dp(idx <span style="color:#666">+</span> <span style="color:#666">1</span>, i));
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>The core logic for calculating the maximum points is divided based on whether there is a previous column (<code>prv</code>). If <code>prv</code> is -1 (indicating the start), we simply add the point value of the current position. Otherwise, we adjust the score based on the distance from the previous position using the formula <code>pts[idx][i] - abs(i - prv)</code>.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> mp[idx][prv] <span style="color:#666">=</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>Finally, we store the computed maximum points for the current index and previous position in the memoization map before returning the result.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#00a000">maxPoints</span>(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> points) {
</span></span><span style="display:flex;"><span>        pts <span style="color:#666">=</span> points;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> m <span style="color:#666">=</span> pts.size(), n <span style="color:#666">=</span> pts[<span style="color:#666">0</span>].size();
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span><span style="color:#666">&gt;</span> prv(n);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) prv[i] <span style="color:#666">=</span> pts[<span style="color:#666">0</span>][i];
</span></span></code></pre></div><p>In the <code>maxPoints</code> function, we initialize the grid of points and compute the dimensions (<code>m</code> for rows and <code>n</code> for columns). We also set up an array <code>prv</code> to store the maximum points collected from the previous row.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> m <span style="color:#666">-</span> <span style="color:#666">1</span>; j<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span><span style="color:#666">&gt;</span> left(n, <span style="color:#666">0</span>), right(n, <span style="color:#666">0</span>), cur(n, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            left[<span style="color:#666">0</span>] <span style="color:#666">=</span> prv[<span style="color:#666">0</span>];
</span></span><span style="display:flex;"><span>            right[n <span style="color:#666">-</span> <span style="color:#666">1</span>] <span style="color:#666">=</span> prv[n <span style="color:#666">-</span> <span style="color:#666">1</span>];
</span></span></code></pre></div><p>We begin iterating over each row, creating three temporary arrays—<code>left</code>, <code>right</code>, and <code>cur</code>—to hold computed values. We initialize the first and last elements of <code>left</code> and <code>right</code> to the respective values from the previous row.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">1</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>                left[i] <span style="color:#666">=</span> max(left[i <span style="color:#666">-</span> <span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#666">1</span>, prv[i]);
</span></span></code></pre></div><p>In the left pass, we compute the maximum score attainable for each position considering scores from the left side. We ensure to reduce the potential score by 1 for each step to account for distance constraints.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> n <span style="color:#666">-</span> <span style="color:#666">2</span>; i <span style="color:#666">&gt;=</span> <span style="color:#666">0</span>; i<span style="color:#666">--</span>)
</span></span><span style="display:flex;"><span>                right[i] <span style="color:#666">=</span> max(right[i <span style="color:#666">+</span> <span style="color:#666">1</span>] <span style="color:#666">-</span> <span style="color:#666">1</span>, prv[i]);
</span></span></code></pre></div><p>Similarly, in the right pass, we compute scores from the right side.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>                cur[i] <span style="color:#666">=</span> max(left[i], right[i]) <span style="color:#666">+</span> pts[j <span style="color:#666">+</span> <span style="color:#666">1</span>][i];
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            prv <span style="color:#666">=</span> cur;
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>After both passes, we compute the maximum score for the current row by taking the maximum value from the left and right arrays and adding the current point value. The results are stored back into <code>prv</code> for the next iteration.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">long</span> <span style="color:#0b0;font-weight:bold">long</span> ans <span style="color:#666">=</span> LLONG_MIN;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>)
</span></span><span style="display:flex;"><span>            ans <span style="color:#666">=</span> max(ans, prv[i]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Finally, we compute the overall maximum score from the last processed row and return it.</p>
<h3 id="complexity">Complexity</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: The time complexity of this solution is (O(m \cdot n)), where (m) is the number of rows and (n) is the number of columns in the points grid. Each cell is processed a limited number of times.</p>
</li>
<li>
<p><strong>Space Complexity</strong>: The space complexity is also (O(n)) due to the temporary arrays used to hold intermediate results during computation.</p>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This solution efficiently calculates the maximum points achievable in a grid by employing dynamic programming techniques. The memoization strategy avoids redundant computations, significantly improving the performance for larger grids. The method handles the distance constraints effectively through systematic left and right evaluations, ensuring that the optimal path is followed to accumulate the highest score possible.</p>
<h3 id="key-features">Key Features</h3>
<ol>
<li>
<p><strong>Dynamic Programming</strong>: Utilizes dynamic programming for efficient computation of maximum scores while keeping track of past results to avoid recalculations.</p>
</li>
<li>
<p><strong>Two-Pass Evaluation</strong>: The left and right passes allow for comprehensive consideration of potential scores based on the movement rules.</p>
</li>
<li>
<p><strong>Scalability</strong>: The approach scales well with larger input sizes due to its linear time complexity.</p>
</li>
</ol>
<h3 id="use-cases">Use Cases</h3>
<p>This function can be applied in various scenarios, such as:</p>
<ul>
<li><strong>Game Development</strong>: Maximizing scores in point collection games based on player movement.</li>
<li><strong>Pathfinding Algorithms</strong>: Adapting the logic to find optimal paths in weighted graphs or grids.</li>
<li><strong>Resource Allocation</strong>: Allocating resources in grids where rewards vary based on location.</li>
</ul>
<h3 id="implementation-considerations">Implementation Considerations</h3>
<p>When implementing this function, consider:</p>
<ul>
<li><strong>Input Validation</strong>: Ensure that the input grid is properly formatted and non-empty.</li>
<li><strong>Edge Cases</strong>: Test scenarios where the grid has a single row or column, or where all points have the same value.</li>
<li><strong>Performance Testing</strong>: Evaluate performance under extreme cases with large grids to confirm efficiency and correctness.</li>
</ul>
<p>This detailed breakdown and explanation should provide a clear understanding of the approach used in this solution while also highlighting its relevance and applicability across different programming challenges.</p>
<p><a href="https://leetcode.com/problems/maximum-number-of-points-with-cost/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/ik1y7fz8AOc?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2812: Find the Safest Path in a Grid | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2812: Find the Safest Path in a Grid">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2812: Find the Safest Path in a Grid in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2812-find-the-safest-path-in-a-grid/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2812: Find the Safest Path in a Grid">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2812: Find the Safest Path in a Grid in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-01-30T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Binary Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Union Find">
    <meta property="article:tag" content="Matrix">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2812: Find the Safest Path in a Grid</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode958s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> maximumSafenessFactor(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> g) {
</span></span><span style="display:flex;"><span>    queue<span style="color:#666">&lt;</span>array<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">2</span><span style="color:#666">&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> dir[<span style="color:#666">5</span>] <span style="color:#666">=</span> {<span style="color:#666">1</span>, <span style="color:#666">0</span>, <span style="color:#666">-</span><span style="color:#666">1</span>, <span style="color:#666">0</span>, <span style="color:#666">1</span>}, n <span style="color:#666">=</span> g.size();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; <span style="color:#666">++</span>i)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> n; <span style="color:#666">++</span>j)
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> (g[i][j])
</span></span><span style="display:flex;"><span>                q.push({i, j});
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> (<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">auto</span> [i, j] <span style="color:#666">=</span> q.front(); q.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> d <span style="color:#666">=</span> <span style="color:#666">0</span>; d <span style="color:#666">&lt;</span> <span style="color:#666">4</span>; <span style="color:#666">++</span>d) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> i <span style="color:#666">+</span> dir[d], y <span style="color:#666">=</span> j <span style="color:#666">+</span> dir[d <span style="color:#666">+</span> <span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> (min(x, y) <span style="color:#666">&gt;=</span> <span style="color:#666">0</span> <span style="color:#666">&amp;&amp;</span> max(x, y) <span style="color:#666">&lt;</span> n <span style="color:#666">&amp;&amp;</span> g[x][y] <span style="color:#666">==</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>                g[x][y] <span style="color:#666">=</span> g[i][j] <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>                q.push({x, y});
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    priority_queue<span style="color:#666">&lt;</span>array<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">3</span><span style="color:#666">&gt;&gt;</span> pq;
</span></span><span style="display:flex;"><span>    pq.push({g[<span style="color:#666">0</span>][<span style="color:#666">0</span>], <span style="color:#666">0</span>, <span style="color:#666">0</span>});
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span> (pq.top()[<span style="color:#666">1</span>] <span style="color:#666">&lt;</span> n <span style="color:#666">-</span> <span style="color:#666">1</span> <span style="color:#666">||</span> pq.top()[<span style="color:#666">2</span>] <span style="color:#666">&lt;</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">auto</span> [sf, i, j] <span style="color:#666">=</span> pq.top(); pq.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> d <span style="color:#666">=</span> <span style="color:#666">0</span>; d <span style="color:#666">&lt;</span> <span style="color:#666">4</span>; <span style="color:#666">++</span>d) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> i <span style="color:#666">+</span> dir[d], y <span style="color:#666">=</span> j <span style="color:#666">+</span> dir[d <span style="color:#666">+</span> <span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span> (min(x, y) <span style="color:#666">&gt;=</span> <span style="color:#666">0</span> <span style="color:#666">&amp;&amp;</span> max(x, y) <span style="color:#666">&lt;</span> n <span style="color:#666">&amp;&amp;</span> g[x][y] <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>                pq.push({min(sf, g[x][y]), x, y});
</span></span><span style="display:flex;"><span>                g[x][y] <span style="color:#666">*=</span> <span style="color:#666">-</span><span style="color:#666">1</span>; 
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> pq.top()[<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>In this problem, you are given a square grid <code>g</code> of size <code>n x n</code> where each cell can either be:</p>
<ul>
<li><code>0</code>, representing an empty cell, or</li>
<li><code>1</code>, representing a cell containing an obstacle.</li>
</ul>
<p>The task is to compute the <strong>maximum safeness factor</strong> for the top-left to bottom-right path, which is defined as the minimum number of steps needed to traverse from the top-left corner to the bottom-right corner. The grid represents a map, where obstacles reduce the available path options. You are asked to find the path that maximizes the safeness factor (the minimum distance to an obstacle) while traveling along the grid.</p>
<h3 id="approach">Approach</h3>
<p>The solution can be broken down into two primary phases:</p>
<ol>
<li>
<p><strong>Flood Fill (BFS)</strong>: In the first phase, we will calculate the <strong>minimum distance to the nearest obstacle</strong> for every empty cell in the grid. This is accomplished using a multi-source breadth-first search (BFS), where all obstacle cells are treated as the starting points, and we propagate distances from these points to every adjacent empty cell.</p>
</li>
<li>
<p><strong>Dijkstra-like Algorithm for Safeness Factor</strong>: After calculating the distances in the previous phase, we will employ a modified Dijkstra algorithm. Here, we treat each cell as a node and aim to find the safest path from the top-left corner to the bottom-right corner. The goal is to maximize the safeness factor along the path, which corresponds to the minimum distance to an obstacle encountered along that path.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<ol>
<li>
<p><strong>Initialization</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>queue<span style="color:#666">&lt;</span>array<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">2</span><span style="color:#666">&gt;&gt;</span> q;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> dir[<span style="color:#666">5</span>] <span style="color:#666">=</span> {<span style="color:#666">1</span>, <span style="color:#666">0</span>, <span style="color:#666">-</span><span style="color:#666">1</span>, <span style="color:#666">0</span>, <span style="color:#666">1</span>}, n <span style="color:#666">=</span> g.size();
</span></span></code></pre></div><ul>
<li>A <code>queue</code> is initialized to perform a BFS for the first phase. We will store the coordinates of cells and their corresponding distances to the nearest obstacle.</li>
<li>The <code>dir</code> array represents the four possible movement directions: down, right, up, and left (clockwise).</li>
<li><code>n</code> stores the size of the grid (<code>n x n</code>), where <code>n</code> is the number of rows or columns.</li>
</ul>
</li>
<li>
<p><strong>Multi-source BFS to Calculate Minimum Distances</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; <span style="color:#666">++</span>i)
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> j <span style="color:#666">=</span> <span style="color:#666">0</span>; j <span style="color:#666">&lt;</span> n; <span style="color:#666">++</span>j)
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (g[i][j])
</span></span><span style="display:flex;"><span>            q.push({i, j});
</span></span></code></pre></div><ul>
<li>The outer loop iterates through all the cells in the grid. If a cell contains an obstacle (<code>g[i][j] == 1</code>), we add it to the queue as a starting point for the BFS.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span> (<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">auto</span> [i, j] <span style="color:#666">=</span> q.front(); q.pop();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> d <span style="color:#666">=</span> <span style="color:#666">0</span>; d <span style="color:#666">&lt;</span> <span style="color:#666">4</span>; <span style="color:#666">++</span>d) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> i <span style="color:#666">+</span> dir[d], y <span style="color:#666">=</span> j <span style="color:#666">+</span> dir[d <span style="color:#666">+</span> <span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (min(x, y) <span style="color:#666">&gt;=</span> <span style="color:#666">0</span> <span style="color:#666">&amp;&amp;</span> max(x, y) <span style="color:#666">&lt;</span> n <span style="color:#666">&amp;&amp;</span> g[x][y] <span style="color:#666">==</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>            g[x][y] <span style="color:#666">=</span> g[i][j] <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>            q.push({x, y});
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>We perform BFS, where for each obstacle cell, we propagate the distance to its neighboring empty cells. The grid <code>g</code> is updated in-place to store the minimum distance to the nearest obstacle for each empty cell.</li>
<li>For each neighboring cell, we ensure it is within bounds and has not already been visited (indicated by <code>g[x][y] == 0</code>).</li>
</ul>
</li>
<li>
<p><strong>Dijkstra-like Algorithm to Find Safeness Factor</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>priority_queue<span style="color:#666">&lt;</span>array<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>, <span style="color:#666">3</span><span style="color:#666">&gt;&gt;</span> pq;
</span></span><span style="display:flex;"><span>pq.push({g[<span style="color:#666">0</span>][<span style="color:#666">0</span>], <span style="color:#666">0</span>, <span style="color:#666">0</span>});
</span></span></code></pre></div><ul>
<li>We initialize a max-priority queue (<code>pq</code>) to process cells based on their safeness factor (minimum distance to an obstacle). The priority queue stores tuples of the form <code>(safeness factor, x, y)</code> where <code>safeness factor</code> represents the minimum distance to an obstacle along the path to that cell.</li>
<li>We push the starting cell (top-left corner) into the queue with its calculated safeness factor (<code>g[0][0]</code>).</li>
</ul>
</li>
<li>
<p><strong>Process Cells to Maximize Safeness Factor</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span> (pq.top()[<span style="color:#666">1</span>] <span style="color:#666">&lt;</span> n <span style="color:#666">-</span> <span style="color:#666">1</span> <span style="color:#666">||</span> pq.top()[<span style="color:#666">2</span>] <span style="color:#666">&lt;</span> n <span style="color:#666">-</span> <span style="color:#666">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">auto</span> [sf, i, j] <span style="color:#666">=</span> pq.top(); pq.pop();
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">for</span> (<span style="color:#0b0;font-weight:bold">int</span> d <span style="color:#666">=</span> <span style="color:#666">0</span>; d <span style="color:#666">&lt;</span> <span style="color:#666">4</span>; <span style="color:#666">++</span>d) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> x <span style="color:#666">=</span> i <span style="color:#666">+</span> dir[d], y <span style="color:#666">=</span> j <span style="color:#666">+</span> dir[d <span style="color:#666">+</span> <span style="color:#666">1</span>];
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span> (min(x, y) <span style="color:#666">&gt;=</span> <span style="color:#666">0</span> <span style="color:#666">&amp;&amp;</span> max(x, y) <span style="color:#666">&lt;</span> n <span style="color:#666">&amp;&amp;</span> g[x][y] <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>            pq.push({min(sf, g[x][y]), x, y});
</span></span><span style="display:flex;"><span>            g[x][y] <span style="color:#666">*=</span> <span style="color:#666">-</span><span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>We process the cells in the priority queue, starting from the top-left corner. The goal is to maximize the minimum safeness factor along the path.</li>
<li>For each current cell, we examine its neighbors, updating their safeness factor by considering the minimum distance between the current cell’s safeness factor and the neighboring cell’s distance to the nearest obstacle.</li>
<li>Once a neighboring cell is processed, we mark it as visited by multiplying its value by <code>-1</code>.</li>
</ul>
</li>
<li>
<p><strong>Return the Result</strong>:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> pq.top()[<span style="color:#666">0</span>] <span style="color:#666">-</span> <span style="color:#666">1</span>;
</span></span></code></pre></div><ul>
<li>After the loop completes, the safeness factor for the bottom-right corner is stored in <code>pq.top()[0]</code>. Since we have tracked the safeness factor during the traversal, we return the final value, subtracting <code>1</code> as the last step ensures the correct output format.</li>
</ul>
</li>
</ol>
<h3 id="complexity">Complexity</h3>
<ol>
<li>
<p><strong>Time Complexity</strong>:</p>
<ul>
<li><strong>Phase 1 (BFS)</strong>: The BFS processes each cell once, and each operation involves examining up to 4 neighboring cells. Hence, the time complexity of this phase is <strong>O(n^2)</strong>, where <code>n</code> is the size of the grid.</li>
<li><strong>Phase 2 (Dijkstra-like Algorithm)</strong>: The priority queue processes each cell, and for each cell, we examine its 4 neighbors. Each insertion and extraction from the priority queue takes <strong>O(log n)</strong> time, but since we process each cell only once, the overall time complexity is <strong>O(n^2 log n)</strong>.</li>
</ul>
<p>Therefore, the overall time complexity of the algorithm is <strong>O(n^2 log n)</strong>.</p>
</li>
<li>
<p><strong>Space Complexity</strong>:</p>
<ul>
<li>The space complexity is determined by the data structures used. The queue and priority queue store up to <code>n^2</code> elements, so the space complexity is <strong>O(n^2)</strong>.</li>
</ul>
</li>
</ol>
<h3 id="conclusion">Conclusion</h3>
<p>This solution effectively solves the problem by using two key strategies:</p>
<ul>
<li>A <strong>multi-source BFS</strong> to compute the minimum distance to the nearest obstacle for every cell.</li>
<li>A <strong>Dijkstra-like algorithm</strong> to find the path that maximizes the safeness factor from the top-left to the bottom-right corner.</li>
</ul>
<p>The algorithm is efficient and handles large grids well, with a time complexity of <strong>O(n^2 log n)</strong>, which is suitable for typical input sizes. The approach ensures that we maximize the safeness factor while navigating through the grid, effectively solving the problem within the given constraints.</p>
<p><a href="https://leetcode.com/problems/find-the-safest-path-in-a-grid/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/-5mQcNiVWTs?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2271: Maximum White Tiles Covered by a Carpet | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2271: Maximum White Tiles Covered by a Carpet">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2271: Maximum White Tiles Covered by a Carpet in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2271-maximum-white-tiles-covered-by-a-carpet/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2271: Maximum White Tiles Covered by a Carpet">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2271: Maximum White Tiles Covered by a Carpet in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-03-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Binary Search">
    <meta property="article:tag" content="Greedy">
    <meta property="article:tag" content="Sorting">
    <meta property="article:tag" content="Prefix Sum">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2271: Maximum White Tiles Covered by a Carpet</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode658s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> maximumWhiteTiles(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> t, <span style="color:#0b0;font-weight:bold">int</span> len) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> t.size(), res <span style="color:#666">=</span> <span style="color:#666">0</span>,
</span></span><span style="display:flex;"><span>            cover <span style="color:#666">=</span> <span style="color:#666">0</span>, j <span style="color:#666">=</span> <span style="color:#666">0</span>, partial <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        sort(t.begin(), t.end());
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n <span style="color:#666">&amp;&amp;</span> res <span style="color:#666">&lt;</span> len ; ) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(t[j][<span style="color:#666">0</span>] <span style="color:#666">+</span> len <span style="color:#666">&gt;</span> t[i][<span style="color:#666">1</span>]) {
</span></span><span style="display:flex;"><span>                cover <span style="color:#666">+=</span> t[i][<span style="color:#666">1</span>] <span style="color:#666">-</span> t[i][<span style="color:#666">0</span>] <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>                res <span style="color:#666">=</span> max(res, cover);               
</span></span><span style="display:flex;"><span>                i<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>            } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                partial <span style="color:#666">=</span> max(<span style="color:#666">0</span>, t[j][<span style="color:#666">0</span>] <span style="color:#666">+</span> len <span style="color:#666">-</span> t[i][<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>                res <span style="color:#666">=</span> max(res, cover <span style="color:#666">+</span> partial);
</span></span><span style="display:flex;"><span>                cover <span style="color:#666">-=</span> (t[j][<span style="color:#666">1</span>] <span style="color:#666">-</span> t[j][<span style="color:#666">0</span>] <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>                j<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>            }            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>In this problem, we are given an array <code>t</code> of tiles represented by intervals, where each tile is a segment of white tiles in a linear space. The problem asks us to determine the maximum number of white tiles that can be covered by a segment of length <code>len</code>. The tiles may overlap, and we need to find the maximum number of white tiles that can be covered when sliding a window of length <code>len</code> across the tiles.</p>
<h3 id="approach">Approach</h3>
<p>The approach uses a <strong>sliding window technique</strong> with two pointers to efficiently find the maximum number of tiles that can be covered by the window of length <code>len</code>. The core idea is to:</p>
<ol>
<li>Sort the intervals of tiles by their starting position.</li>
<li>Use two pointers (<code>i</code> and <code>j</code>) to maintain a sliding window of intervals.</li>
<li>Calculate how much of the current tile is covered by the window.</li>
<li>Move the window across the tiles and keep track of the maximum coverage.</li>
</ol>
<p>The solution leverages greedy principles to maximize the number of white tiles covered at each step. Let&rsquo;s walk through the details.</p>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<h4 id="step-1-initialize-variables">Step 1: Initialize Variables</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> t.size(), res <span style="color:#666">=</span> <span style="color:#666">0</span>, cover <span style="color:#666">=</span> <span style="color:#666">0</span>, j <span style="color:#666">=</span> <span style="color:#666">0</span>, partial <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span></code></pre></div><ul>
<li><code>n</code>: The number of tiles (intervals) in the input array <code>t</code>.</li>
<li><code>res</code>: This will store the result, which is the maximum number of white tiles that can be covered by the window of length <code>len</code>.</li>
<li><code>cover</code>: This variable tracks the total number of white tiles covered by the window so far.</li>
<li><code>j</code>: This pointer tracks the left boundary of the window.</li>
<li><code>partial</code>: This stores the partial coverage of the current tile when the window doesn&rsquo;t fully cover it.</li>
</ul>
<h4 id="step-2-sort-the-tiles-by-start-position">Step 2: Sort the Tiles by Start Position</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>sort(t.begin(), t.end());
</span></span></code></pre></div><ul>
<li>Sorting the tiles by their start positions ensures that we can efficiently process them in order. This allows us to slide the window across the tiles in increasing order of their start positions.</li>
</ul>
<h4 id="step-3-sliding-window-to-calculate-maximum-coverage">Step 3: Sliding Window to Calculate Maximum Coverage</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n <span style="color:#666">&amp;&amp;</span> res <span style="color:#666">&lt;</span> len ; ) {
</span></span></code></pre></div><ul>
<li>We use a <code>for</code> loop where <code>i</code> is the right pointer of the sliding window. The loop continues until all tiles are processed or until we find a window that covers <code>len</code> white tiles (because the answer can&rsquo;t be larger than <code>len</code>).</li>
</ul>
<h4 id="step-4-check-if-the-window-fully-covers-the-current-tile">Step 4: Check if the Window Fully Covers the Current Tile</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">if</span>(t[j][<span style="color:#666">0</span>] <span style="color:#666">+</span> len <span style="color:#666">&gt;</span> t[i][<span style="color:#666">1</span>]) {
</span></span><span style="display:flex;"><span>    cover <span style="color:#666">+=</span> t[i][<span style="color:#666">1</span>] <span style="color:#666">-</span> t[i][<span style="color:#666">0</span>] <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>    res <span style="color:#666">=</span> max(res, cover);
</span></span><span style="display:flex;"><span>    i<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>If the window, starting from <code>t[j][0]</code>, can fully cover the current tile <code>t[i]</code> (i.e., <code>t[j][0] + len &gt; t[i][1]</code>), we add the full length of the current tile to <code>cover</code> and update the result <code>res</code> to the maximum of <code>res</code> and <code>cover</code>. Then, we move the right pointer <code>i</code> to the next tile.</li>
</ul>
<h4 id="step-5-handle-partially-covered-tiles">Step 5: Handle Partially Covered Tiles</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>    partial <span style="color:#666">=</span> max(<span style="color:#666">0</span>, t[j][<span style="color:#666">0</span>] <span style="color:#666">+</span> len <span style="color:#666">-</span> t[i][<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>    res <span style="color:#666">=</span> max(res, cover <span style="color:#666">+</span> partial);
</span></span><span style="display:flex;"><span>    cover <span style="color:#666">-=</span> (t[j][<span style="color:#666">1</span>] <span style="color:#666">-</span> t[j][<span style="color:#666">0</span>] <span style="color:#666">+</span> <span style="color:#666">1</span>);
</span></span><span style="display:flex;"><span>    j<span style="color:#666">++</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>If the current tile cannot be fully covered by the window, we calculate how much of the current tile can be partially covered, which is given by <code>t[j][0] + len - t[i][0]</code>.</li>
<li>We then update the result <code>res</code> to the maximum of <code>res</code> and the sum of <code>cover</code> (the coverage so far) and the <code>partial</code> coverage.</li>
<li>After processing, we move the left pointer <code>j</code> to the next tile and subtract the current tile&rsquo;s length from <code>cover</code> to ensure the window shifts correctly.</li>
</ul>
<h4 id="step-6-return-the-result">Step 6: Return the Result</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div><ul>
<li>Once the loop finishes, the result <code>res</code> contains the maximum number of white tiles covered by a window of length <code>len</code>. This value is returned as the solution.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity</h4>
<ul>
<li><strong>Sorting</strong> the tiles takes <code>O(n log n)</code> where <code>n</code> is the number of tiles (intervals).</li>
<li>The sliding window operation takes <strong>O(n)</strong> because each pointer (<code>i</code> and <code>j</code>) traverses the array at most once.</li>
<li>Therefore, the overall time complexity is dominated by the sorting step, resulting in <strong>O(n log n)</strong>.</li>
</ul>
<h4 id="space-complexity">Space Complexity</h4>
<ul>
<li><strong>O(n)</strong> for storing the tiles array <code>t</code>, where each tile is represented as a pair of integers (start and end positions).</li>
<li>Additional space complexity comes from variables like <code>cover</code>, <code>partial</code>, and <code>res</code>, which are constant and do not scale with the input size.</li>
<li>Therefore, the overall space complexity is <strong>O(n)</strong>.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>The solution provides an efficient way to calculate the maximum number of white tiles that can be covered by a window of length <code>len</code>. By using a <strong>sliding window technique</strong> with two pointers, the algorithm ensures that the problem is solved in <strong>O(n log n)</strong> time, which is optimal for scenarios involving overlapping intervals. Sorting the intervals by their starting positions allows us to process them efficiently, while the sliding window technique ensures we don&rsquo;t need to repeatedly re-evaluate the sum of covered tiles.</p>
<p>This approach works well for scenarios where we need to find coverage over a range of intervals, and it can be applied to various other problems involving range queries or sliding windows. The combination of sorting and the sliding window technique makes this solution both intuitive and efficient for large datasets, providing a scalable solution for problems involving overlapping intervals or segments.</p>
<p><a href="https://leetcode.com/problems/maximum-white-tiles-covered-by-a-carpet/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/U7fqZr_ZLd4?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

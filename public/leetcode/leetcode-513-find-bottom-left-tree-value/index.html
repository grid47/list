<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 513: Find Bottom Left Tree Value | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 513: Find Bottom Left Tree Value">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 513: Find Bottom Left Tree Value in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-513-find-bottom-left-tree-value/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 513: Find Bottom Left Tree Value">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 513: Find Bottom Left Tree Value in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-09-16T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 513: Find Bottom Left Tree Value</h1> 
            </div>
			<div class="article-post">
				<h2 id="hahahugoshortcode1171s0hbhb"><figure class="remote-image" style="text-align:center; margin: 0;">
    <div style="position: relative; width:900px; max-width:100%; padding-bottom:56.25%; overflow: hidden; border-radius:0px;">
      <img src="https://raw.githubusercontent.com/grid47/list-images/refs/heads/main/list/513.webp" 
           alt="A tree with a glowing bottom-left node, showing the value of the deepest leftmost node in the binary tree." 
           style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
    </div>
    
      <figcaption style="font-size: 0.8em; font-weight: 300; color:#555; margin-top: 4px; line-height: 1.2;">
        Solution to LeetCode 513: Find Bottom Left Tree Value Problem
      </figcaption>
    
  </figure>
  </h2>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode1171s1hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> findBottomLeftValue(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>        queue<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span><span style="display:flex;"><span>        q.push(root);
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> q.front()<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>            res <span style="color:#666">=</span> q.front()<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span> <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>                root <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>                q.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>left)  q.push(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>right) q.push(root<span style="color:#666">-&gt;</span>right);                
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The problem asks us to find the bottom-left value in a binary tree. More specifically, we need to find the leftmost node at the deepest level of the tree. The bottom-left value is the first node encountered when performing a level-order traversal (BFS) from left to right, starting from the deepest level.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we will use a <strong>Breadth-First Search (BFS)</strong> approach, which is typically used to traverse a tree level by level. The BFS approach uses a queue to explore all nodes at a given level before moving on to the next level.</p>
<p>The algorithm follows these key steps:</p>
<ol>
<li>
<p><strong>Initialize a Queue</strong>: A queue is used to store the nodes at each level of the tree. We begin by enqueueing the root node of the tree.</p>
</li>
<li>
<p><strong>Level-order Traversal</strong>: Process the tree level by level. For each level, we store the leftmost node of that level.</p>
</li>
<li>
<p><strong>Update the Result</strong>: Each time we process a new level, we update the result with the value of the leftmost node in the current level. Since the BFS explores the tree from left to right, the first node processed at each level will always be the leftmost node.</p>
</li>
<li>
<p><strong>Termination</strong>: The process continues until all levels of the tree are processed. By the end of the BFS, the result will hold the value of the leftmost node at the deepest level of the tree.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> <span style="color:#00a000">findBottomLeftValue</span>(TreeNode<span style="color:#666">*</span> root) {
</span></span><span style="display:flex;"><span>    queue<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;      <span style="color:#080;font-style:italic">// Initialize a queue to store nodes for BFS
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    q.push(root);            <span style="color:#080;font-style:italic">// Enqueue the root node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    <span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> q.front()<span style="color:#666">-&gt;</span>val; <span style="color:#080;font-style:italic">// Initialize result with the root&#39;s value
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {        <span style="color:#080;font-style:italic">// Start level-order traversal
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();     <span style="color:#080;font-style:italic">// Get the number of nodes at the current level
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        res <span style="color:#666">=</span> q.front()<span style="color:#666">-&gt;</span>val;  <span style="color:#080;font-style:italic">// The leftmost node at the current level is the first node in the queue
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span> <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {      <span style="color:#080;font-style:italic">// Process all nodes at the current level
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            root <span style="color:#666">=</span> q.front();  <span style="color:#080;font-style:italic">// Get the front node from the queue
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            q.pop();            <span style="color:#080;font-style:italic">// Dequeue the node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>left)  q.push(root<span style="color:#666">-&gt;</span>left);   <span style="color:#080;font-style:italic">// Enqueue left child, if exists
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>            <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>right) q.push(root<span style="color:#666">-&gt;</span>right);  <span style="color:#080;font-style:italic">// Enqueue right child, if exists
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">return</span> res;                 <span style="color:#080;font-style:italic">// Return the leftmost value at the deepest level
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>}
</span></span></code></pre></div><h4 id="step-1-initialize-a-queue">Step 1: Initialize a Queue</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>queue<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> q;
</span></span><span style="display:flex;"><span>q.push(root);
</span></span></code></pre></div><ul>
<li>A queue <code>q</code> is used to store nodes as they are processed in BFS. Initially, the root of the tree is added to the queue.</li>
</ul>
<h4 id="step-2-track-leftmost-node">Step 2: Track Leftmost Node</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> res <span style="color:#666">=</span> q.front()<span style="color:#666">-&gt;</span>val;
</span></span></code></pre></div><ul>
<li>The variable <code>res</code> will store the leftmost node value at the deepest level. Initially, it is set to the value of the root node.</li>
</ul>
<h4 id="step-3-process-the-tree-level-by-level">Step 3: Process the Tree Level by Level</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>    res <span style="color:#666">=</span> q.front()<span style="color:#666">-&gt;</span>val;
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span> <span style="color:#666">&gt;</span> <span style="color:#666">0</span>) {
</span></span><span style="display:flex;"><span>        root <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>        q.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>left)  q.push(root<span style="color:#666">-&gt;</span>left);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root<span style="color:#666">-&gt;</span>right) q.push(root<span style="color:#666">-&gt;</span>right);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>We use a <code>while</code> loop to process each level of the tree.</li>
<li>At the start of each level, we update <code>res</code> to store the value of the leftmost node at that level (<code>q.front()-&gt;val</code>).</li>
<li>We then process each node at the current level. If the node has a left child, it is added to the queue, followed by the right child if it exists.</li>
<li>This ensures that nodes are processed level by level, and the leftmost node at each level is always processed first.</li>
</ul>
<h4 id="step-4-return-the-bottom-left-value">Step 4: Return the Bottom-Left Value</h4>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> res;
</span></span></code></pre></div><ul>
<li>After processing all levels of the tree, the variable <code>res</code> will contain the value of the leftmost node at the deepest level of the tree, which is our desired result.</li>
</ul>
<h3 id="complexity">Complexity</h3>
<h4 id="time-complexity">Time Complexity:</h4>
<ul>
<li><strong>BFS Traversal</strong>: Each node in the tree is processed exactly once, and each operation inside the loop is constant time (O(1)). Therefore, the overall time complexity is <code>O(N)</code>, where <code>N</code> is the number of nodes in the binary tree.</li>
</ul>
<h4 id="space-complexity">Space Complexity:</h4>
<ul>
<li><strong>Queue</strong>: The space complexity is determined by the maximum number of nodes that can be stored in the queue at any given time. In the worst case, this is the number of nodes at the last level of the tree. For a complete binary tree, the maximum number of nodes in the queue will be <code>O(N / 2)</code>, which simplifies to <code>O(N)</code>.</li>
</ul>
<p>Thus, the space complexity is <code>O(N)</code> due to the space needed to store the nodes in the queue.</p>
<h3 id="conclusion">Conclusion</h3>
<p>In conclusion, the <strong>BFS approach</strong> efficiently solves the problem of finding the bottom-left value in a binary tree. By performing a level-order traversal and always tracking the leftmost node at each level, we ensure that the final result corresponds to the leftmost node at the deepest level of the tree.</p>
<p>This solution has optimal time and space complexity, both of which are linear with respect to the number of nodes in the tree (<code>O(N)</code>), making it suitable for large trees.</p>
<p>Key Points:</p>
<ul>
<li><strong>Time Complexity</strong>: <code>O(N)</code></li>
<li><strong>Space Complexity</strong>: <code>O(N)</code></li>
<li><strong>Approach</strong>: Breadth-First Search (BFS) with a queue</li>
</ul>
<p><a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/u_by_cTsNJA?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 1971: Find if Path Exists in Graph | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1971: Find if Path Exists in Graph">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1971: Find if Path Exists in Graph in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-1971-find-if-path-exists-in-graph/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1971: Find if Path Exists in Graph">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1971: Find if Path Exists in Graph in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-04-23T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Union Find">
    <meta property="article:tag" content="Graph">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 1971: Find if Path Exists in Graph</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode482s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> validPath(<span style="color:#0b0;font-weight:bold">int</span> n, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> edges, <span style="color:#0b0;font-weight:bold">int</span> start, <span style="color:#0b0;font-weight:bold">int</span> end) {
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>,vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> graph; 
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">e</span> : edges) {
</span></span><span style="display:flex;"><span>            graph[e[<span style="color:#666">0</span>]].push_back(e[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>            graph[e[<span style="color:#666">1</span>]].push_back(e[<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">bool</span><span style="color:#666">&gt;</span> visited(n,<span style="color:#666">0</span>);        
</span></span><span style="display:flex;"><span>        queue<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> q;
</span></span><span style="display:flex;"><span>        q.push(start);
</span></span><span style="display:flex;"><span>        visited[start] <span style="color:#666">=</span> <span style="color:#666">1</span>; 
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> curr <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(curr <span style="color:#666">==</span> end)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">1</span>; 
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">node</span> : graph[curr]){
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>visited[node]){
</span></span><span style="display:flex;"><span>                    visited[node] <span style="color:#666">=</span> <span style="color:#666">1</span>; 
</span></span><span style="display:flex;"><span>                    q.push(node);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The goal of this problem is to determine if there exists a valid path between two nodes in an undirected graph. The graph is represented using edges, and we need to check if a path exists from a starting node to a target node. This problem can be commonly encountered in scenarios involving network connectivity, pathfinding in mazes, or navigating social networks.</p>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we will utilize a breadth-first search (BFS) algorithm. BFS is particularly suitable for this task because it explores all neighbors at the present depth before moving on to nodes at the next depth level. This guarantees that we will find the shortest path if one exists.</p>
<p>Here’s a breakdown of the steps we will take:</p>
<ol>
<li>
<p><strong>Graph Representation</strong>: We will represent the graph using an adjacency list. Each node will have a list of its neighboring nodes.</p>
</li>
<li>
<p><strong>BFS Initialization</strong>: We will use a queue to facilitate the BFS traversal. A boolean array will keep track of visited nodes to prevent revisiting and entering into infinite loops.</p>
</li>
<li>
<p><strong>Traversal Logic</strong>: We will start the BFS from the <code>start</code> node and explore its neighbors. If we encounter the <code>end</code> node during our traversal, we return <code>true</code>. If the queue is exhausted and we haven’t found the <code>end</code> node, we return <code>false</code>.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">bool</span> validPath(<span style="color:#0b0;font-weight:bold">int</span> n, vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> edges, <span style="color:#0b0;font-weight:bold">int</span> start, <span style="color:#0b0;font-weight:bold">int</span> end) {
</span></span></code></pre></div><p>This line begins the definition of the <code>validPath</code> function, which takes the number of nodes <code>n</code>, a list of edges, and the start and end nodes as arguments.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        unordered_map<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span>,vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> graph; 
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">e</span> : edges) {
</span></span><span style="display:flex;"><span>            graph[e[<span style="color:#666">0</span>]].push_back(e[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>            graph[e[<span style="color:#666">1</span>]].push_back(e[<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>Here, we create an adjacency list representation of the graph using an unordered map. For each edge, we add the connection in both directions since the graph is undirected.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">bool</span><span style="color:#666">&gt;</span> visited(n,<span style="color:#666">0</span>);        
</span></span><span style="display:flex;"><span>        queue<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> q;
</span></span><span style="display:flex;"><span>        q.push(start);
</span></span><span style="display:flex;"><span>        visited[start] <span style="color:#666">=</span> <span style="color:#666">1</span>; 
</span></span></code></pre></div><p>We initialize a boolean vector <code>visited</code> to track which nodes have been explored. We then create a queue and enqueue the starting node, marking it as visited.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> curr <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(curr <span style="color:#666">==</span> end)
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#666">1</span>; 
</span></span></code></pre></div><p>We enter a loop that continues until there are no more nodes in the queue. We retrieve the front node and check if it matches the <code>end</code> node. If it does, we return <code>true</code>, indicating that a valid path exists.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#666">&amp;</span><span style="color:#a0a000">node</span> : graph[curr]){
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">if</span>(<span style="color:#666">!</span>visited[node]){
</span></span><span style="display:flex;"><span>                    visited[node] <span style="color:#666">=</span> <span style="color:#666">1</span>; 
</span></span><span style="display:flex;"><span>                    q.push(node);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>For each neighboring node of the current node, we check if it has already been visited. If not, we mark it as visited and add it to the queue for further exploration.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">false</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>If we exit the while loop without finding the <code>end</code> node, we return <code>false</code>, indicating that no valid path exists.</p>
<h3 id="complexity">Complexity</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: The time complexity of this algorithm is (O(V + E)), where (V) is the number of vertices (or nodes) in the graph and (E) is the number of edges. This is because, in the worst case, we might need to explore all nodes and edges.</p>
</li>
<li>
<p><strong>Space Complexity</strong>: The space complexity is also (O(V + E)) for storing the graph in the adjacency list and the visited array, as well as the queue used for BFS.</p>
</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>This BFS-based solution effectively determines whether a valid path exists between two nodes in an undirected graph. The use of an adjacency list allows for efficient storage and retrieval of neighbor information, while BFS ensures that all possible paths are explored in a systematic manner.</p>
<h3 id="key-features">Key Features</h3>
<ol>
<li>
<p><strong>Efficiency</strong>: The algorithm runs in linear time relative to the number of nodes and edges, making it suitable for large graphs.</p>
</li>
<li>
<p><strong>Simplicity</strong>: The use of an adjacency list and a queue for BFS keeps the implementation straightforward and easy to understand.</p>
</li>
<li>
<p><strong>Scalability</strong>: This approach can easily be adapted to handle various graph-related problems, such as finding all connected components or detecting cycles.</p>
</li>
</ol>
<h3 id="example-usage">Example Usage</h3>
<p>Here’s an example of how to use the <code>validPath</code> function:</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Solution sol;
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> edges <span style="color:#666">=</span> {{<span style="color:#666">0</span>, <span style="color:#666">1</span>}, {<span style="color:#666">1</span>, <span style="color:#666">2</span>}, {<span style="color:#666">2</span>, <span style="color:#666">3</span>}, {<span style="color:#666">3</span>, <span style="color:#666">4</span>}};
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> <span style="color:#666">5</span>; <span style="color:#080;font-style:italic">// Number of nodes
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span><span style="color:#0b0;font-weight:bold">int</span> start <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> end <span style="color:#666">=</span> <span style="color:#666">4</span>;
</span></span><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">bool</span> result <span style="color:#666">=</span> sol.validPath(n, edges, start, end);
</span></span><span style="display:flex;"><span>cout <span style="color:#666">&lt;&lt;</span> <span style="color:#b44">&#34;Path exists: &#34;</span> <span style="color:#666">&lt;&lt;</span> (result <span style="color:#666">?</span> <span style="color:#b44">&#34;Yes&#34;</span> <span style="color:#666">:</span> <span style="color:#b44">&#34;No&#34;</span>) <span style="color:#666">&lt;&lt;</span> endl;
</span></span></code></pre></div><p>In this example, the <code>validPath</code> function is called with a specific set of edges and nodes. The output indicates whether there is a valid path from the start node to the end node.</p>
<h3 id="potential-improvements-and-variations">Potential Improvements and Variations</h3>
<ol>
<li>
<p><strong>Bidirectional Search</strong>: For very large graphs, a bidirectional search can be more efficient. This approach simultaneously explores from both the start and end nodes.</p>
</li>
<li>
<p><strong>DFS Alternative</strong>: While BFS is used here, depth-first search (DFS) could also be implemented for pathfinding, depending on the specific requirements of the problem.</p>
</li>
<li>
<p><strong>Weighted Graphs</strong>: If the graph is weighted, we could adapt the solution to use Dijkstra’s algorithm or A* search algorithm for shortest pathfinding.</p>
</li>
</ol>
<p>This solution not only provides a method for checking connectivity in graphs but also serves as a foundation for tackling more complex graph algorithms and problems in computer science.</p>
<p><a href="https://leetcode.com/problems/find-if-path-exists-in-graph/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/knLFe7hEp3Y?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

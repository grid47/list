<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 2039: The Time When the Network Becomes Idle | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 2039: The Time When the Network Becomes Idle">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 2039: The Time When the Network Becomes Idle in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-2039-the-time-when-the-network-becomes-idle/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 2039: The Time When the Network Becomes Idle">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 2039: The Time When the Network Becomes Idle in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-04-17T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Breadth-First Search">
    <meta property="article:tag" content="Graph">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 2039: The Time When the Network Becomes Idle</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode526s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> networkBecomesIdle(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> edges, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> patience) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> patience.size();        
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> grid(n);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">e</span>: edges) {
</span></span><span style="display:flex;"><span>            grid[e[<span style="color:#666">0</span>]].push_back(e[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>            grid[e[<span style="color:#666">1</span>]].push_back(e[<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> sd(n, INT_MAX); <span style="color:#080;font-style:italic">// shortest distance(sd) to master;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        sd[<span style="color:#666">0</span>] <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        queue<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> q;
</span></span><span style="display:flex;"><span>        vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> vis(n, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        q.push(<span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>        vis[<span style="color:#666">0</span>] <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> t <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>                t<span style="color:#666">++</span>;            
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#0b0;font-weight:bold">int</span> node <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>                q.pop();
</span></span><span style="display:flex;"><span>                <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: grid[node]) {
</span></span><span style="display:flex;"><span>                    <span style="color:#a2f;font-weight:bold">if</span>(vis[it]) <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>                    vis[it] <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>                    sd[it] <span style="color:#666">=</span> t;
</span></span><span style="display:flex;"><span>                    q.push(it);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#080;font-style:italic">// for(int i = 0; i &lt; n; i++)
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#080;font-style:italic">//     cout &lt;&lt; sd[i] &lt;&lt; &#34; &#34;;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> mx <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> dist <span style="color:#666">=</span> <span style="color:#666">2</span> <span style="color:#666">*</span> sd[i];
</span></span><span style="display:flex;"><span>            <span style="color:#0b0;font-weight:bold">int</span> pat <span style="color:#666">=</span> patience[i];
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(pat <span style="color:#666">&gt;=</span> dist) {
</span></span><span style="display:flex;"><span>                mx <span style="color:#666">=</span> max(mx, dist);
</span></span><span style="display:flex;"><span>            } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                <span style="color:#0b0;font-weight:bold">int</span> mod <span style="color:#666">=</span> dist <span style="color:#666">%</span> pat <span style="color:#666">==</span> <span style="color:#666">0</span><span style="color:#666">?</span> <span style="color:#a0a000">pat</span>: dist <span style="color:#666">%</span> pat;
</span></span><span style="display:flex;"><span>                
</span></span><span style="display:flex;"><span>                mx <span style="color:#666">=</span> max(mx, dist <span style="color:#666">-</span> mod <span style="color:#666">+</span> dist);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> mx <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The task is to determine when a network will become &ldquo;idle.&rdquo; Given a network represented by nodes and edges, where one node (the master server) sends data to other nodes, we want to calculate the time it will take for all data exchanges to stop, based on the response pattern of each node. Specifically, each node has a patience level, which dictates how often it re-sends a message if it hasn’t received a reply. The goal is to find the earliest time when the network is completely idle, meaning all data exchanges have ceased.</p>
<h3 id="approach">Approach</h3>
<p>To solve this, we break down the problem into several key steps. Here’s a high-level overview of the approach:</p>
<ol>
<li><strong>Graph Representation</strong>: Represent the network as a graph, where each node is a computer, and edges represent bidirectional communication links. We use an adjacency list to model this graph.</li>
<li><strong>Shortest Distance Calculation</strong>: Since the master server (node 0) needs to send data to all other nodes, we calculate the shortest distance from the master server to each node. We perform a Breadth-First Search (BFS) starting from the master server to find the shortest path to each node.</li>
<li><strong>Calculate Message Return Times</strong>: Using the distances computed in the previous step, we determine the time it takes for messages to travel to each node and back to the master server. For each node, the round-trip time is <code>2 * distance</code>.</li>
<li><strong>Calculate Idle Time</strong>: For each node, we check if its patience is greater than or equal to the round-trip time. If it is, the node will only send one message and wait for the reply. If not, it will keep re-sending messages according to its patience level until the first message reaches the node. Using these rules, we calculate the exact time the network will become idle.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<p>Let’s walk through each part of the code in detail.</p>
<ol>
<li>
<p><strong>Class and Method Definition</strong>: We define a class named <code>Solution</code> containing our main method <code>networkBecomesIdle</code>. This method takes two parameters: <code>edges</code>, which represents the network connections, and <code>patience</code>, which contains the patience levels of each node.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> networkBecomesIdle(vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;&amp;</span> edges, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> patience) {
</span></span></code></pre></div></li>
<li>
<p><strong>Initialize Variables</strong>: We initialize <code>n</code> as the number of nodes and <code>grid</code> as an adjacency list to represent the graph.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> n <span style="color:#666">=</span> patience.size();        
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&gt;</span> grid(n);
</span></span></code></pre></div></li>
<li>
<p><strong>Build the Graph</strong>: Using the <code>edges</code> list, we construct the adjacency list for the graph.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">e</span>: edges) {
</span></span><span style="display:flex;"><span>    grid[e[<span style="color:#666">0</span>]].push_back(e[<span style="color:#666">1</span>]);
</span></span><span style="display:flex;"><span>    grid[e[<span style="color:#666">1</span>]].push_back(e[<span style="color:#666">0</span>]);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>Initialize Distance and Visited Arrays</strong>: We set up an array <code>sd</code> to store the shortest distance from the master server to each node, initializing each entry to <code>INT_MAX</code> except for the master server (distance 0). We also initialize <code>vis</code>, an array to track visited nodes, and a queue <code>q</code> for BFS.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> sd(n, INT_MAX); <span style="color:#080;font-style:italic">// shortest distance to master;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>sd[<span style="color:#666">0</span>] <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span>queue<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> q;
</span></span><span style="display:flex;"><span>vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> vis(n, <span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>q.push(<span style="color:#666">0</span>);
</span></span><span style="display:flex;"><span>vis[<span style="color:#666">0</span>] <span style="color:#666">=</span> <span style="color:#666">1</span>;
</span></span></code></pre></div></li>
<li>
<p><strong>Breadth-First Search (BFS)</strong>: Using BFS, we calculate the shortest distance from the master server to each node.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> t <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">while</span>(<span style="color:#666">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> sz <span style="color:#666">=</span> q.size();
</span></span><span style="display:flex;"><span>    t<span style="color:#666">++</span>;            
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">while</span>(sz<span style="color:#666">--</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> node <span style="color:#666">=</span> q.front();
</span></span><span style="display:flex;"><span>        q.pop();
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#a2f;font-weight:bold">auto</span> <span style="color:#a0a000">it</span>: grid[node]) {
</span></span><span style="display:flex;"><span>            <span style="color:#a2f;font-weight:bold">if</span>(vis[it]) <span style="color:#a2f;font-weight:bold">continue</span>;
</span></span><span style="display:flex;"><span>            vis[it] <span style="color:#666">=</span> <span style="color:#a2f">true</span>;
</span></span><span style="display:flex;"><span>            sd[it] <span style="color:#666">=</span> t;
</span></span><span style="display:flex;"><span>            q.push(it);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>Calculate Idle Time for Each Node</strong>: We iterate over each node and calculate the time the network becomes idle based on the node’s patience level and the round-trip time. For each node:</p>
<ul>
<li>If the patience level is greater than or equal to the round-trip time, we add this time to <code>mx</code>.</li>
<li>Otherwise, we calculate the last time the node sends a message before receiving a response, adjusting the maximum idle time (<code>mx</code>) accordingly.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#0b0;font-weight:bold">int</span> mx <span style="color:#666">=</span> <span style="color:#666">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> i <span style="color:#666">=</span> <span style="color:#666">0</span>; i <span style="color:#666">&lt;</span> n; i<span style="color:#666">++</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> dist <span style="color:#666">=</span> <span style="color:#666">2</span> <span style="color:#666">*</span> sd[i];
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> pat <span style="color:#666">=</span> patience[i];
</span></span><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">if</span>(pat <span style="color:#666">&gt;=</span> dist) {
</span></span><span style="display:flex;"><span>        mx <span style="color:#666">=</span> max(mx, dist);
</span></span><span style="display:flex;"><span>    } <span style="color:#a2f;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">int</span> mod <span style="color:#666">=</span> dist <span style="color:#666">%</span> pat <span style="color:#666">==</span> <span style="color:#666">0</span> <span style="color:#666">?</span> <span style="color:#a0a000">pat</span> : dist <span style="color:#666">%</span> pat;
</span></span><span style="display:flex;"><span>        mx <span style="color:#666">=</span> max(mx, dist <span style="color:#666">-</span> mod <span style="color:#666">+</span> dist);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
<li>
<p><strong>Return the Final Idle Time</strong>: After looping through all nodes, we return <code>mx + 1</code>, accounting for the final message sent by the master server.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">return</span> mx <span style="color:#666">+</span> <span style="color:#666">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<h3 id="complexity">Complexity</h3>
<ul>
<li><strong>Time Complexity</strong>: The time complexity is (O(n + m)), where (n) is the number of nodes and (m) is the number of edges. BFS ensures that we visit each node and edge once.</li>
<li><strong>Space Complexity</strong>: The space complexity is (O(n + m)) for the adjacency list and other auxiliary arrays.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>In summary, this solution efficiently calculates when a network becomes idle after all data exchanges cease. By using BFS to compute shortest distances and iterating over nodes to apply the patience rules, we achieve an optimal and clean solution. This approach balances careful timing and efficient graph traversal to meet the problem’s requirements. Thus, the method not only provides an accurate solution but also scales well with larger inputs, making it a powerful approach to network-related timing issues in graph-based problems.</p>
<p><a href="https://leetcode.com/problems/the-time-when-the-network-becomes-idle/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/9URBYJ62lyY?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

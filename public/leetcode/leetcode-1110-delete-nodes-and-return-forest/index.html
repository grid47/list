<!DOCTYPE html>
<html lang="en-us"><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
	<meta name="generator" content="Hugo 0.136.4">
	
	<link rel="icon" href="/images/logo.png">
	
	<title>Leetcode 1110: Delete Nodes And Return Forest | grid47</title>
	
	

	
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1110: Delete Nodes And Return Forest">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1110: Delete Nodes And Return Forest in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">

	<meta property="og:url" content="http://localhost:1313/leetcode/leetcode-1110-delete-nodes-and-return-forest/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1110: Delete Nodes And Return Forest">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1110: Delete Nodes And Return Forest in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="leetcode">
    <meta property="article:published_time" content="2024-07-19T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-06T00:00:00+00:00">
    <meta property="article:tag" content="Array">
    <meta property="article:tag" content="Hash Table">
    <meta property="article:tag" content="Tree">
    <meta property="article:tag" content="Depth-First Search">
    <meta property="article:tag" content="Binary Tree">


	<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
	<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">
	<link href="https://fonts.googleapis.com/css?family=Righteous%7CMerriweather:300,300i,400,400i,700,700i" rel="stylesheet">

	
	<link rel="stylesheet" href="http://localhost:1313/css/medium.ced6b291f6520a092efe4c87ca4fc7047e1c3174b10653f78e13ca06f0bb6abf.css" integrity="sha256-ztaykfZSCgku/kyHyk/HBH4cMXSxBlP3jhPKBvC7ar8=">

	
	<link rel="stylesheet" href="http://localhost:1313/css/additional.8819b6defcdc6d21280f9b402b00df87ca779135901de6c22e708c62e20184b9.css" integrity="sha256-iBm23vzcbSEoD5tAKwDfh8p3kTWQHebCLnCMYuIBhLk=">

	
	
	<link rel="stylesheet" href="/css/head.css" integrity="" crossorigin="anonymous" media="screen">
</head>
<body>
<nav class="navbar navbar-expand-lg navbar-light bg-white fixed-top mediumnavigation nav-down">
    <div class="container pr-0">
        
        <a class="navbar-brand" href="http://localhost:1313//">

            
            <img src="/images/logo.png" alt="logo">
            
        </a>
        

        <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarMediumish" aria-expanded="false" aria-label="Toggle navigation">
            <span class="navbar-toggler-icon"></span>
        </button>

        
        <div class="collapse navbar-collapse" id="navbarMediumish">
            
            <ul class="navbar-nav ml-auto">
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/about/">About</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/leetcode/">LeetCode</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/terms/">Terms &amp; Policy</a>
                </li>
                 
                <li class="nav-item ">
                    <a class="nav-link" href="/contact/">Contact</a>
                </li>
                
            </ul>
        </div>
        
    </div>
</nav>


        <div class="site-content">   
            <div class="container">
<div class="main-content">

<div class="container">
	<div class="row">
        <div class="col-md-1"></div>
		<div class="col-md-10">
			<div class="mainheading">
				<h1 class="posttitle">Leetcode 1110: Delete Nodes And Return Forest</h1> 
            </div>
			<div class="article-post">
				<hr>
<p><strong>Code:</strong></p>
<h2 id="hahahugoshortcode66s0hbhb"><div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#080;font-style:italic">/**
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> ans;
</span></span><span style="display:flex;"><span>    set<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> to_del;
</span></span><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> delNodes(TreeNode<span style="color:#666">*</span> root, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> to_delete) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">i</span>: to_delete) to_del.insert(i);
</span></span><span style="display:flex;"><span>        helper(root, <span style="color:#a2f">true</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> ans;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> <span style="color:#00a000">helper</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">bool</span> is_root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#0b0;font-weight:bold">bool</span> del <span style="color:#666">=</span> to_del.find(root<span style="color:#666">-&gt;</span>val) <span style="color:#666">!=</span> to_del.end();
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(is_root <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>del) ans.push_back(root);
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> helper(root<span style="color:#666">-&gt;</span>left, del);
</span></span><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> helper(root<span style="color:#666">-&gt;</span>right, del);
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">return</span> del<span style="color:#666">?</span> <span style="color:#a2f">NULL</span> <span style="color:#666">:</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div></h2>
<h3 id="problem-statement">Problem Statement</h3>
<p>The task is to delete specific nodes from a binary tree and return all the remaining trees as a list of root nodes. Given a binary tree and an array of values representing the nodes to be deleted, your goal is to:</p>
<ul>
<li>Remove the specified nodes from the tree.</li>
<li>If a node is deleted, its children should be treated as new root nodes in the resulting forest.</li>
</ul>
<p><strong>Input:</strong></p>
<ul>
<li>A pointer to the root of the binary tree.</li>
<li>A list of integers representing the values of nodes to delete.</li>
</ul>
<p><strong>Output:</strong></p>
<ul>
<li>A vector containing pointers to the root nodes of the remaining trees.</li>
</ul>
<h3 id="approach">Approach</h3>
<p>To solve this problem, we will use a recursive approach:</p>
<ol>
<li>Create a set to efficiently check which nodes need to be deleted.</li>
<li>Traverse the tree recursively. For each node:
<ul>
<li>If it is marked for deletion, recursively call the function on its children.</li>
<li>If it is not marked for deletion and is considered a root node (i.e., its parent is deleted), add it to the result list.</li>
</ul>
</li>
<li>Return <code>nullptr</code> for deleted nodes, and the original node for non-deleted nodes.</li>
<li>Utilize a helper function to facilitate the recursion and maintain clarity.</li>
</ol>
<h3 id="code-breakdown-step-by-step">Code Breakdown (Step by Step)</h3>
<ol>
<li>
<p><strong>Class and Struct Definition</strong>: The <code>TreeNode</code> structure defines the structure of each node in the binary tree.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">struct</span> <span style="color:#00f">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#0b0;font-weight:bold">int</span> val;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#666">*</span>right;
</span></span><span style="display:flex;"><span>    TreeNode() <span style="color:#666">:</span> val(<span style="color:#666">0</span>), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x) <span style="color:#666">:</span> val(x), left(<span style="color:#a2f;font-weight:bold">nullptr</span>), right(<span style="color:#a2f;font-weight:bold">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#0b0;font-weight:bold">int</span> x, TreeNode <span style="color:#666">*</span>left, TreeNode <span style="color:#666">*</span>right) <span style="color:#666">:</span> val(x), left(left), right(right) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div></li>
<li>
<p><strong>Solution Class</strong>: The <code>Solution</code> class contains the method to perform the node deletions.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#a2f;font-weight:bold">class</span> <span style="color:#00f">Solution</span> {
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> ans;
</span></span><span style="display:flex;"><span>    set<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;</span> to_del;  <span style="color:#080;font-style:italic">// Set to store values of nodes to delete
</span></span></span></code></pre></div></li>
<li>
<p><strong>Main Method</strong>: The <code>delNodes</code> method initializes the deletion process.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#a2f;font-weight:bold">public</span><span style="color:#666">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#666">&lt;</span>TreeNode<span style="color:#666">*&gt;</span> delNodes(TreeNode<span style="color:#666">*</span> root, vector<span style="color:#666">&lt;</span><span style="color:#0b0;font-weight:bold">int</span><span style="color:#666">&gt;&amp;</span> to_delete) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">for</span>(<span style="color:#0b0;font-weight:bold">int</span> <span style="color:#a0a000">i</span>: to_delete) to_del.insert(i);  <span style="color:#080;font-style:italic">// Insert to_delete values into the set
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        helper(root, <span style="color:#a2f">true</span>);  <span style="color:#080;font-style:italic">// Start the recursive helper function
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">return</span> ans;  <span style="color:#080;font-style:italic">// Return the list of remaining trees
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span></code></pre></div></li>
<li>
<p><strong>Helper Function</strong>: The <code>helper</code> method performs the recursive traversal of the tree.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    TreeNode<span style="color:#666">*</span> <span style="color:#00a000">helper</span>(TreeNode<span style="color:#666">*</span> root, <span style="color:#0b0;font-weight:bold">bool</span> is_root) {
</span></span><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(root <span style="color:#666">==</span> <span style="color:#a2f">NULL</span>) <span style="color:#a2f;font-weight:bold">return</span> <span style="color:#a2f">NULL</span>;  <span style="color:#080;font-style:italic">// Base case: if the node is null, return null
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#0b0;font-weight:bold">bool</span> del <span style="color:#666">=</span> to_del.find(root<span style="color:#666">-&gt;</span>val) <span style="color:#666">!=</span> to_del.end();  <span style="color:#080;font-style:italic">// Check if current node should be deleted
</span></span></span></code></pre></div></li>
<li>
<p><strong>Checking for Root Nodes</strong>: If the node is not marked for deletion and is a root node (i.e., <code>is_root</code> is true), it is added to the result.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#a2f;font-weight:bold">if</span>(is_root <span style="color:#666">&amp;&amp;</span> <span style="color:#666">!</span>del) ans.push_back(root);  <span style="color:#080;font-style:italic">// Add to result if it&#39;s a root and not deleted
</span></span></span></code></pre></div></li>
<li>
<p><strong>Recursive Calls</strong>: The function calls itself for the left and right children of the current node, updating the <code>is_root</code> flag based on whether the current node is deleted.</p>
<div class="highlight"><pre tabindex="0" style="background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        root<span style="color:#666">-&gt;</span>left <span style="color:#666">=</span> helper(root<span style="color:#666">-&gt;</span>left, del);  <span style="color:#080;font-style:italic">// Recursively process left child
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        root<span style="color:#666">-&gt;</span>right <span style="color:#666">=</span> helper(root<span style="color:#666">-&gt;</span>right, del);  <span style="color:#080;font-style:italic">// Recursively process right child
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>        <span style="color:#a2f;font-weight:bold">return</span> del <span style="color:#666">?</span> <span style="color:#a2f">NULL</span> <span style="color:#666">:</span> root;  <span style="color:#080;font-style:italic">// Return null if deleted, otherwise return the current node
</span></span></span><span style="display:flex;"><span><span style="color:#080;font-style:italic"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div></li>
</ol>
<h3 id="complexity-analysis">Complexity Analysis</h3>
<ul>
<li><strong>Time Complexity</strong>: The time complexity of the algorithm is (O(n)), where (n) is the number of nodes in the tree. Each node is visited once to check for deletion and to build the list of remaining trees.</li>
<li><strong>Space Complexity</strong>: The space complexity is (O(h)), where (h) is the height of the tree. This space is used by the recursion stack. The set <code>to_del</code> requires (O(k)) space, where (k) is the number of nodes to delete.</li>
</ul>
<h3 id="conclusion">Conclusion</h3>
<p>The provided C++ code effectively deletes specified nodes from a binary tree and constructs a forest of remaining trees using a recursive approach. By leveraging a set for fast lookups and a helper function to manage the traversal, the algorithm maintains clarity and efficiency.</p>
<p>This solution exemplifies a common pattern in tree-related problems, showcasing how to manipulate trees through recursion. The use of a set enhances performance, allowing for quick checks on whether nodes should be deleted.</p>
<p>Overall, this implementation serves as a valuable reference for those looking to understand tree manipulations and recursive algorithms in competitive programming or software development.</p>
<p><a href="https://leetcode.com/problems/delete-nodes-and-return-forest/description/"><code>Link to LeetCode Lab</code></a></p>
<hr>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/UhKu0q1yXHY?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/">LeetCode Solutions Library</a> / <a href="https://grid47.xyz/sheets/">DSA Sheets</a> / <a href="https://grid47.xyz/courses/">Course Catalog</a></th>
      </tr>
  </thead>
  <tbody>
  </tbody>
</table>

			</div>
		</div>
        <div class="col-md-1"></div>
	</div>
</div>

</div>


            </div>
<footer class="footer">
    <div class="container">
        <div class="row">
            <div class="col-md-6 col-sm-6 text-center text-lg-left">
                &copy; Copyright www.grid47.com - All rights reserved
            </div>
            
        </div>
    </div>
</footer>


        </div>


<script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js" integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM" crossorigin="anonymous"></script>


<script src="http://localhost:1313/js/mediumish.84218587c174fd40bce82544b98851670f0b124a7324b349c54a4065e2b32ffc.js" integrity="sha256-hCGFh8F0/UC86CVEuYhRZw8LEkpzJLNJxUpAZeKzL/w="></script>
      <script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
      <script>
        var doNotTrack = false;
        if ( false ) {
          var dnt = (navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack);
          var doNotTrack = (dnt == "1" || dnt == "yes");
        }
        if (!doNotTrack) {
          window.dataLayer = window.dataLayer || [];
          function gtag(){dataLayer.push(arguments);}
          gtag('js', new Date());
          gtag('config', 'G-1LN7R4LHR1');
        }
      </script>
    </body>
</html>

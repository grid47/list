<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Leetcode 1970: Last Day Where You Can Still Cross · grid47
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Mohammed Yasir Eramangadan">
<meta name="description" content="In-depth solution and explanation for Leetcode 1970: Last Day Where You Can Still Cross in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1970: Last Day Where You Can Still Cross">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1970: Last Day Where You Can Still Cross in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">

<meta property="og:url" content="http://localhost:1313/posts/leetcode_1970/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1970: Last Day Where You Can Still Cross">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1970: Last Day Where You Can Still Cross in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-01T00:00:00+00:00">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_10/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_100/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1000/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1001/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1002/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1003/">




<link rel="canonical" href="http://localhost:1313/posts/leetcode_1970/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">








<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953"
     crossorigin="anonymous"></script></head>




<body class="preload-transitions colorscheme-light">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      grid47
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/leetcode/">LeetCode</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/lists/">List</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/terms/">Terms</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/contact/">Contact</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/leetcode_1970/">
              Leetcode 1970: Last Day Where You Can Still Cross
            </a>
          </h1>
        </div>
        <div class="post-meta">
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/hard/">Hard</a></div>
          
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="/authors/crafted-by-me/">Crafted by Me</a></div>

          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-11-01T00:00:00Z">
                November 1, 2024
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              7-minute read
            </span>
          </div>
          
        </div>
      </header>

      <div class="post-content">
        
        <p><a href="https://leetcode.com/problems/last-day-where-you-can-still-cross/description/"  class="external-link" target="_blank" rel="noopener"><code>Problem Link</code></a></p>
<hr>
<p><strong>Code:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UF</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> parent;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> rank;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    UF(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        parent.resize(n);
</span></span><span style="display:flex;"><span>        rank.resize(n, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            parent[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (parent[x] <span style="color:#f92672">!=</span> x) {
</span></span><span style="display:flex;"><span>            parent[x] <span style="color:#f92672">=</span> find(parent[x]);  <span style="color:#75715e">// Path compression
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> parent[x];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">join</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rootX <span style="color:#f92672">=</span> find(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rootY <span style="color:#f92672">=</span> find(y);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (rootX <span style="color:#f92672">!=</span> rootY) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (rank[rootX] <span style="color:#f92672">&lt;</span> rank[rootY]) {
</span></span><span style="display:flex;"><span>                parent[rootX] <span style="color:#f92672">=</span> rootY;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (rank[rootX] <span style="color:#f92672">&gt;</span> rank[rootY]) {
</span></span><span style="display:flex;"><span>                parent[rootY] <span style="color:#f92672">=</span> rootX;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                parent[rootX] <span style="color:#f92672">=</span> rootY;
</span></span><span style="display:flex;"><span>                rank[rootY]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> latestDayToCross(<span style="color:#66d9ef">int</span> row, <span style="color:#66d9ef">int</span> col, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> cells) {
</span></span><span style="display:flex;"><span>        UF<span style="color:#f92672">*</span> uf <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> UF(row <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> top <span style="color:#f92672">=</span> row <span style="color:#f92672">*</span> col, bottom <span style="color:#f92672">=</span> row <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> col; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            uf<span style="color:#f92672">-&gt;</span>join(top, i);
</span></span><span style="display:flex;"><span>            uf<span style="color:#f92672">-&gt;</span>join(bottom, (row <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> i);            
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> grid(row, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(col, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> cells.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> dir[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(uf<span style="color:#f92672">-&gt;</span>find(top) <span style="color:#f92672">!=</span> uf<span style="color:#f92672">-&gt;</span>find(bottom) <span style="color:#f92672">&amp;&amp;</span> len <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> cell <span style="color:#f92672">=</span> cells[len<span style="color:#f92672">--</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> cell[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> cell[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            grid[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; k<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> dir[k], y <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> dir[k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> x <span style="color:#f92672">==</span> row <span style="color:#f92672">||</span> y <span style="color:#f92672">==</span> col <span style="color:#f92672">||</span> grid[x][y] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                uf<span style="color:#f92672">-&gt;</span>join(i <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> j, x <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> y);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="hahahugoshortcode1091s1hbhb">
  

  
  <div class="markdown-body">
    <h3 id="problem-statement">
  Problem Statement
  <a class="heading-link" href="#problem-statement">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The task is to determine the latest day on which a person can cross a grid that represents a lake, where certain cells become flooded over time. Given the dimensions of the grid and a list of cells that flood each day, the goal is to find the last day when there exists a valid path from the top row to the bottom row of the grid.</p>
<h3 id="approach">
  Approach
  <a class="heading-link" href="#approach">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>This problem can be efficiently solved using the Union-Find (or Disjoint Set Union, DSU) data structure. The main idea is to use the union-find structure to keep track of which cells are connected and to dynamically update connections as the cells become flooded over days.</p>
<ol>
<li>
<p><strong>Union-Find Structure</strong>: The Union-Find data structure helps in grouping cells into connected components. Each cell in the grid will be treated as a node, and we&rsquo;ll connect these nodes based on whether they are adjacent and not flooded.</p>
</li>
<li>
<p><strong>Grid Representation</strong>: The grid is represented using a one-dimensional array for union-find operations. Each cell at position <code>(i, j)</code> can be converted to a single index using the formula <code>index = i * col + j</code>.</p>
</li>
<li>
<p><strong>Flooding Simulation</strong>: Starting from the last day and moving backward, we simulate the flooding of cells. For each flooded cell, we check its four neighbors (up, down, left, right) and connect it to any of its neighbors that are not flooded.</p>
</li>
<li>
<p><strong>Top and Bottom Virtual Nodes</strong>: We use two virtual nodes, <code>top</code> and <code>bottom</code>, to represent the connections from the top row of the grid to the bottom row. If a path exists between these two virtual nodes after processing some days of flooding, then a valid crossing is possible.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">
  Code Breakdown (Step by Step)
  <a class="heading-link" href="#code-breakdown-step-by-step">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UF</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> parent;
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> rank;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    UF(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        parent.resize(n);
</span></span><span style="display:flex;"><span>        rank.resize(n, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            parent[i] <span style="color:#f92672">=</span> i; <span style="color:#75715e">// Initializing each node to point to itself
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>The <code>UF</code> class defines the Union-Find data structure. It initializes two vectors, <code>parent</code> and <code>rank</code>, to manage the components.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">find</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (parent[x] <span style="color:#f92672">!=</span> x) {
</span></span><span style="display:flex;"><span>            parent[x] <span style="color:#f92672">=</span> find(parent[x]);  <span style="color:#75715e">// Path compression
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> parent[x];
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>The <code>find</code> function implements path compression, which optimizes the structure by making nodes point directly to their root. This significantly speeds up future queries.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">join</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rootX <span style="color:#f92672">=</span> find(x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> rootY <span style="color:#f92672">=</span> find(y);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (rootX <span style="color:#f92672">!=</span> rootY) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (rank[rootX] <span style="color:#f92672">&lt;</span> rank[rootY]) {
</span></span><span style="display:flex;"><span>                parent[rootX] <span style="color:#f92672">=</span> rootY;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (rank[rootX] <span style="color:#f92672">&gt;</span> rank[rootY]) {
</span></span><span style="display:flex;"><span>                parent[rootY] <span style="color:#f92672">=</span> rootX;
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                parent[rootX] <span style="color:#f92672">=</span> rootY;
</span></span><span style="display:flex;"><span>                rank[rootY]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The <code>join</code> function connects two components. It uses union by rank to attach the smaller tree under the larger tree, maintaining a balanced structure.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> latestDayToCross(<span style="color:#66d9ef">int</span> row, <span style="color:#66d9ef">int</span> col, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> cells) {
</span></span><span style="display:flex;"><span>        UF<span style="color:#f92672">*</span> uf <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> UF(row <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> top <span style="color:#f92672">=</span> row <span style="color:#f92672">*</span> col, bottom <span style="color:#f92672">=</span> row <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
</span></span></code></pre></div><p>In the <code>Solution</code> class, the <code>latestDayToCross</code> method begins by creating a Union-Find instance that can accommodate all cells plus two virtual nodes (for the top and bottom rows).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> col; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            uf<span style="color:#f92672">-&gt;</span>join(top, i);
</span></span><span style="display:flex;"><span>            uf<span style="color:#f92672">-&gt;</span>join(bottom, (row <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> i);
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>Here, we connect each cell in the first row to the <code>top</code> node and each cell in the last row to the <code>bottom</code> node.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> grid(row, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(col, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>));
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> len <span style="color:#f92672">=</span> cells.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> dir[] <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>};
</span></span></code></pre></div><p>We create a <code>grid</code> initialized to -1 to indicate that all cells are initially not flooded. The <code>dir</code> array represents the four possible directions to check adjacent cells.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(uf<span style="color:#f92672">-&gt;</span>find(top) <span style="color:#f92672">!=</span> uf<span style="color:#f92672">-&gt;</span>find(bottom) <span style="color:#f92672">&amp;&amp;</span> len <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">auto</span> cell <span style="color:#f92672">=</span> cells[len<span style="color:#f92672">--</span>];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> cell[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>, j <span style="color:#f92672">=</span> cell[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>            grid[i][j] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// Mark the cell as flooded
</span></span></span></code></pre></div><p>The loop continues as long as there is no connection between the <code>top</code> and <code>bottom</code> nodes and we still have cells to flood. The flooded cell is marked in the grid.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; k <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">4</span>; k<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">int</span> x <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> dir[k], y <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> dir[k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>];
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> y <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">||</span> x <span style="color:#f92672">==</span> row <span style="color:#f92672">||</span> y <span style="color:#f92672">==</span> col <span style="color:#f92672">||</span> grid[x][y] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>                uf<span style="color:#f92672">-&gt;</span>join(i <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> j, x <span style="color:#f92672">*</span> col <span style="color:#f92672">+</span> y);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>After flooding a cell, we check its neighbors. If a neighbor is within bounds and not flooded, we connect it to the current cell.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> len <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Return the latest day when crossing is still possible
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Finally, when the loop ends, we return <code>len + 1</code> as the last day when crossing was possible.</p>
<h3 id="complexity">
  Complexity
  <a class="heading-link" href="#complexity">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: The overall time complexity is (O(N \log^* N)), where (N) is the number of cells (rows × columns). This accounts for the union-find operations, which are nearly constant time due to path compression.</p>
</li>
<li>
<p><strong>Space Complexity</strong>: The space complexity is (O(N)) for storing the parent and rank arrays in the Union-Find structure, plus the space for the grid.</p>
</li>
</ul>
<h3 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>This solution effectively combines the Union-Find data structure with a simulation of the flooding process to determine the last possible day to cross the grid. The use of path compression and union by rank ensures that the operations remain efficient, even as cells are progressively flooded.</p>
<h3 id="key-features">
  Key Features
  <a class="heading-link" href="#key-features">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>Dynamic Connectivity</strong>: The Union-Find structure allows for efficient updates to connectivity as the grid changes state with flooding.</p>
</li>
<li>
<p><strong>Virtual Nodes</strong>: Utilizing virtual nodes simplifies the problem of checking connections between the top and bottom of the grid.</p>
</li>
<li>
<p><strong>Robustness</strong>: The implementation can handle large grids and numerous flooding events efficiently, making it suitable for various scenarios.</p>
</li>
</ol>
<h3 id="example-usage">
  Example Usage
  <a class="heading-link" href="#example-usage">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Here’s an example of how to use the <code>latestDayToCross</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Solution sol;
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> cells <span style="color:#f92672">=</span> {{<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>}, {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">2</span>}, {<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">1</span>}, {<span style="color:#ae81ff">2</span>,<span style="color:#ae81ff">2</span>}};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> row <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>, col <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> result <span style="color:#f92672">=</span> sol.latestDayToCross(row, col, cells);
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Latest day to cross: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span></code></pre></div><p>In this example, the <code>latestDayToCross</code> function is called with a specified grid size and a list of flooding events. The output will indicate the last day a crossing is possible.</p>
<h3 id="potential-improvements-and-variations">
  Potential Improvements and Variations
  <a class="heading-link" href="#potential-improvements-and-variations">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>Iterative Union-Find Implementation</strong>: The code can be improved by implementing an iterative version of the union-find methods to avoid recursion.</p>
</li>
<li>
<p><strong>Advanced Data Structures</strong>: For very large grids or more complex conditions, alternative data structures like Segment Trees or Binary Indexed Trees could be explored.</p>
</li>
<li>
<p><strong>Adaptive Flooding</strong>: The flooding process can be adapted to consider different patterns or rates of flooding based on more complex rules.</p>
</li>
</ol>
<p>This solution demonstrates a well-rounded understanding of graph theory, data structures, and algorithmic problem-solving techniques, making it a valuable reference for anyone facing similar challenges in competitive programming or algorithm design.</p>
 
</div>
  

  <a class="heading-link" href="#hahahugoshortcode1091s1hbhb">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/IiXZ2_f6wug?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/"  class="external-link" target="_blank" rel="noopener">LeetCode Exercise Compilation</a> / Next : <a href="https://grid47.xyz/posts/leetcode_1971"  class="external-link" target="_blank" rel="noopener">LeetCode #1971: Find if Path Exists in Graph</a></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><div class="notice tip">
  <div class="notice-title">
    <i class="fa-solid fa-lightbulb" aria-hidden="true"></i>Tip
  </div>
  <div class="notice-content">Unlock the power of patterns! Mastering one problem builds a pathway to solve many more. Dive into practice, and let each problem sharpen your skills. <a href="https://www.udemy.com/course/algorithms-and-data-structures-in-cpp/"  class="external-link" target="_blank" rel="noopener">Check out my Momentum Learning course at Udemy! 🚀 </a></div>
</div>
</td>
      </tr>
  </tbody>
</table>

      </div>


      <footer>
        
        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "grid47" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2024
     Mohammed Yasir Eramangadan 
    ·
    
    
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1LN7R4LHR1');
</script>


  

  

  

  

  

  

  
</body>

</html>

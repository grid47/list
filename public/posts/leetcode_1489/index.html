<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Leetcode 1489: Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree Â· grid47
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Mohammed Yasir Eramangadan">
<meta name="description" content="In-depth solution and explanation for Leetcode 1489: Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysisâ€”more insightful than official and community solutions.">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1489: Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1489: Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysisâ€”more insightful than official and community solutions.">

<meta property="og:url" content="http://localhost:1313/posts/leetcode_1489/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1489: Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1489: Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysisâ€”more insightful than official and community solutions.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-01T00:00:00+00:00">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_10/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_100/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1000/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1001/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1002/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1003/">




<link rel="canonical" href="http://localhost:1313/posts/leetcode_1489/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">








<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953"
     crossorigin="anonymous"></script></head>




<body class="preload-transitions colorscheme-light">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      grid47
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/leetcode/">LeetCode</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/lists/">List</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/terms/">Terms</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/contact/">Contact</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/leetcode_1489/">
              Leetcode 1489: Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree
            </a>
          </h1>
        </div>
        <div class="post-meta">
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/hard/">Hard</a></div>
          
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="/authors/crafted-by-me/">Crafted by Me</a></div>

          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-11-01T00:00:00Z">
                November 1, 2024
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              7-minute read
            </span>
          </div>
          
        </div>
      </header>

      <div class="post-content">
        
        <p><a href="https://leetcode.com/problems/find-critical-and-pseudo-critical-edges-in-minimum-spanning-tree/description/"  class="external-link" target="_blank" rel="noopener"><code>Problem Link</code></a></p>
<hr>
<p><strong>Code:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UnionFind</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    UnionFind(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        rank <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(n, <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        f.resize(n);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) f[i] <span style="color:#f92672">=</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Find</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> f[x]) <span style="color:#66d9ef">return</span> x;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> f[x] <span style="color:#f92672">=</span> Find(f[x]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Union</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> fx <span style="color:#f92672">=</span> Find(x), fy <span style="color:#f92672">=</span> Find(y);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (fx <span style="color:#f92672">==</span> fy) <span style="color:#66d9ef">return</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (rank[fx] <span style="color:#f92672">&gt;</span> rank[fy]) swap(fx, fy);
</span></span><span style="display:flex;"><span>        f[fx] <span style="color:#f92672">=</span> fy;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (rank[fx] <span style="color:#f92672">==</span> rank[fy]) rank[fy]<span style="color:#f92672">++</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> f, rank;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> findCriticalAndPseudoCriticalEdges(<span style="color:#66d9ef">int</span> n, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> edges) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> edges.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            edges[i].push_back(i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        sort(edges.begin(), edges.end(), [](<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> b) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;</span> b[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> origin_mst <span style="color:#f92672">=</span> GetMST(n, edges, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> critical, non_critical;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> edges.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (origin_mst <span style="color:#f92672">&lt;</span> GetMST(n, edges, i)) {
</span></span><span style="display:flex;"><span>                critical.push_back(edges[i][<span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (origin_mst <span style="color:#f92672">==</span> GetMST(n, edges, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, i)) {
</span></span><span style="display:flex;"><span>                non_critical.push_back(edges[i][<span style="color:#ae81ff">3</span>]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> {critical, non_critical};
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> GetMST(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> edges, <span style="color:#66d9ef">int</span> blockedge, <span style="color:#66d9ef">int</span> pre_edge <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        UnionFind <span style="color:#a6e22e">uf</span>(n);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> weight <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (pre_edge <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            weight <span style="color:#f92672">+=</span> edges[pre_edge][<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>            uf.Union(edges[pre_edge][<span style="color:#ae81ff">0</span>], edges[pre_edge][<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> edges.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> blockedge) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> edge <span style="color:#f92672">=</span> edges[i];
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (uf.Find(edge[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">==</span> uf.Find(edge[<span style="color:#ae81ff">1</span>])) <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>            uf.Union(edge[<span style="color:#ae81ff">0</span>], edge[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>            weight <span style="color:#f92672">+=</span> edge[<span style="color:#ae81ff">2</span>];
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (uf.Find(i) <span style="color:#f92672">!=</span> uf.Find(<span style="color:#ae81ff">0</span>)) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1e9</span><span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> weight;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="hahahugoshortcode557s1hbhb">
  

  
  <div class="markdown-body">
    <h3 id="problem-statement">
  Problem Statement
  <a class="heading-link" href="#problem-statement">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The problem is to identify critical and pseudo-critical edges in a graph represented by a list of edges. Critical edges are those that, if removed, increase the weight of the minimum spanning tree (MST). Pseudo-critical edges are those that can be part of the MST but do not affect its total weight. The input consists of <code>n</code> vertices and a list of <code>edges</code>, each defined by two vertices and a weight. The goal is to return two lists: one containing the indices of critical edges and the other containing the indices of pseudo-critical edges.</p>
<h3 id="approach">
  Approach
  <a class="heading-link" href="#approach">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>To tackle this problem, we will utilize a union-find data structure (also known as Disjoint Set Union, DSU) to efficiently manage and find connected components of the graph. The main steps involved in the solution are:</p>
<ol>
<li>
<p><strong>Edge Preparation</strong>: Augment the list of edges to include their original indices, then sort the edges based on their weights. This will allow us to process them in the order necessary for MST calculations.</p>
</li>
<li>
<p><strong>Calculate the Original MST</strong>: Compute the weight of the MST using all edges to establish a baseline for comparison when edges are either omitted or included.</p>
</li>
<li>
<p><strong>Evaluate Each Edge</strong>: For each edge in the sorted list, we will:</p>
<ul>
<li>Check if removing the edge results in a higher MST weight, marking it as critical if true.</li>
<li>Check if including the edge maintains the same MST weight, marking it as pseudo-critical if true.</li>
</ul>
</li>
<li>
<p><strong>Return Results</strong>: Compile the results into two lists: one for critical edges and another for pseudo-critical edges.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">
  Code Breakdown (Step by Step)
  <a class="heading-link" href="#code-breakdown-step-by-step">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<h4 id="unionfind-class">
  UnionFind Class
  <a class="heading-link" href="#unionfind-class">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>This class manages the union-find operations, including the path compression technique for efficient searching and union operations.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">UnionFind</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    UnionFind(<span style="color:#66d9ef">int</span> n) {
</span></span><span style="display:flex;"><span>        rank <span style="color:#f92672">=</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span>(n, <span style="color:#ae81ff">1</span>);  <span style="color:#75715e">// Initialize rank for union by rank
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        f.resize(n);  <span style="color:#75715e">// Initialize parent vector
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) f[i] <span style="color:#f92672">=</span> i;  <span style="color:#75715e">// Each node is its own parent initially
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Find</span>(<span style="color:#66d9ef">int</span> x) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (x <span style="color:#f92672">==</span> f[x]) <span style="color:#66d9ef">return</span> x;  <span style="color:#75715e">// If x is the root, return x
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">return</span> f[x] <span style="color:#f92672">=</span> Find(f[x]);  <span style="color:#75715e">// Path compression
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Union</span>(<span style="color:#66d9ef">int</span> x, <span style="color:#66d9ef">int</span> y) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">int</span> fx <span style="color:#f92672">=</span> Find(x), fy <span style="color:#f92672">=</span> Find(y);  <span style="color:#75715e">// Find roots of x and y
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (fx <span style="color:#f92672">==</span> fy) <span style="color:#66d9ef">return</span>;  <span style="color:#75715e">// They are already in the same set
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (rank[fx] <span style="color:#f92672">&gt;</span> rank[fy]) swap(fx, fy);  <span style="color:#75715e">// Union by rank
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        f[fx] <span style="color:#f92672">=</span> fy;  <span style="color:#75715e">// Make fy the parent of fx
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (rank[fx] <span style="color:#f92672">==</span> rank[fy]) rank[fy]<span style="color:#f92672">++</span>;  <span style="color:#75715e">// Increment rank if equal
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> f, rank;  <span style="color:#75715e">// f for parent pointers, rank for union by rank
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>};
</span></span></code></pre></div><h4 id="solution-class">
  Solution Class
  <a class="heading-link" href="#solution-class">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h4>
<p>The main class that implements the logic to find critical and pseudo-critical edges.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> findCriticalAndPseudoCriticalEdges(<span style="color:#66d9ef">int</span> n, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> edges) {
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Step 1: Append the index to each edge and sort them by weight
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> edges.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            edges[i].push_back(i);  <span style="color:#75715e">// Add index to edges
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        sort(edges.begin(), edges.end(), [](<span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> a, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> b) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> a[<span style="color:#ae81ff">2</span>] <span style="color:#f92672">&lt;</span> b[<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">// Sort by weight
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        });
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Step 2: Get the original MST weight
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> origin_mst <span style="color:#f92672">=</span> GetMST(n, edges, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> critical, non_critical;  <span style="color:#75715e">// Prepare lists for edges
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Step 3: Evaluate each edge for criticality
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> edges.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (origin_mst <span style="color:#f92672">&lt;</span> GetMST(n, edges, i)) {
</span></span><span style="display:flex;"><span>                critical.push_back(edges[i][<span style="color:#ae81ff">3</span>]);  <span style="color:#75715e">// Edge is critical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            } <span style="color:#66d9ef">else</span> <span style="color:#a6e22e">if</span> (origin_mst <span style="color:#f92672">==</span> GetMST(n, edges, <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, i)) {
</span></span><span style="display:flex;"><span>                non_critical.push_back(edges[i][<span style="color:#ae81ff">3</span>]);  <span style="color:#75715e">// Edge is pseudo-critical
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> {critical, non_critical};  <span style="color:#75715e">// Return both lists
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// Helper function to calculate the MST weight with options to block an edge or include a pre-edge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">int</span> GetMST(<span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">const</span> vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> edges, <span style="color:#66d9ef">int</span> blockedge, <span style="color:#66d9ef">int</span> pre_edge <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>        UnionFind <span style="color:#a6e22e">uf</span>(n);  <span style="color:#75715e">// Create a new UnionFind structure for MST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> weight <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;  <span style="color:#75715e">// Initialize weight of MST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> (pre_edge <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>            weight <span style="color:#f92672">+=</span> edges[pre_edge][<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">// Add weight of pre-edge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            uf.Union(edges[pre_edge][<span style="color:#ae81ff">0</span>], edges[pre_edge][<span style="color:#ae81ff">1</span>]);  <span style="color:#75715e">// Union pre-edge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Iterate over edges to form the MST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> edges.size(); <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (i <span style="color:#f92672">==</span> blockedge) <span style="color:#66d9ef">continue</span>;  <span style="color:#75715e">// Skip the blocked edge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> edge <span style="color:#f92672">=</span> edges[i];  <span style="color:#75715e">// Current edge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">if</span> (uf.Find(edge[<span style="color:#ae81ff">0</span>]) <span style="color:#f92672">==</span> uf.Find(edge[<span style="color:#ae81ff">1</span>])) <span style="color:#66d9ef">continue</span>;  <span style="color:#75715e">// Skip if already connected
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            uf.Union(edge[<span style="color:#ae81ff">0</span>], edge[<span style="color:#ae81ff">1</span>]);  <span style="color:#75715e">// Union the edge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            weight <span style="color:#f92672">+=</span> edge[<span style="color:#ae81ff">2</span>];  <span style="color:#75715e">// Add weight to the MST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// Check if all vertices are connected
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; <span style="color:#f92672">++</span>i) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (uf.Find(i) <span style="color:#f92672">!=</span> uf.Find(<span style="color:#ae81ff">0</span>)) <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1e9</span><span style="color:#f92672">+</span><span style="color:#ae81ff">7</span>;  <span style="color:#75715e">// If not connected, return a large value
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> weight;  <span style="color:#75715e">// Return the total weight of the MST
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><h3 id="detailed-steps">
  Detailed Steps:
  <a class="heading-link" href="#detailed-steps">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>Edge Preparation</strong>: Each edge is extended to include its index, allowing us to identify edges later. We then sort the edges by weight using a lambda function.</p>
</li>
<li>
<p><strong>Calculate Original MST</strong>:</p>
<ul>
<li>The <code>GetMST</code> function is called with all edges included to calculate the weight of the original MST. This establishes a baseline for comparing critical and pseudo-critical edges.</li>
</ul>
</li>
<li>
<p><strong>Iterate Over Edges</strong>:</p>
<ul>
<li>For each edge, we check if it is critical by determining if removing it causes the MST weight to increase.</li>
<li>If removing the edge increases the MST weight, we classify it as a critical edge.</li>
<li>We also check if including the edge maintains the same weight for the MST, classifying it as a pseudo-critical edge.</li>
</ul>
</li>
</ol>
<h3 id="complexity">
  Complexity
  <a class="heading-link" href="#complexity">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: The time complexity of the algorithm is (O(E \log E + E \alpha(N))), where (E) is the number of edges, (N) is the number of vertices, and (\alpha(N)) is the inverse Ackermann function which is nearly constant for all practical purposes. The sorting step contributes (O(E \log E)).</p>
</li>
<li>
<p><strong>Space Complexity</strong>: The space complexity is (O(N + E)) due to the storage of the union-find structure and the edge list.</p>
</li>
</ul>
<h3 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>This solution effectively identifies critical and pseudo-critical edges in a graph using a union-find data structure to manage connected components efficiently. The approach involves sorting edges, calculating the original MST, and evaluating each edge&rsquo;s impact on the MST&rsquo;s weight.</p>
<p><strong>Key Takeaways</strong>:</p>
<ol>
<li><strong>Union-Find Optimization</strong>: The use of union-find with path compression and union by rank makes it efficient for dynamic connectivity queries.</li>
<li><strong>Graph Theory Application</strong>: The problem demonstrates practical applications in network design, reliability, and optimization problems.</li>
<li><strong>Performance Considerations</strong>: The algorithm&rsquo;s efficiency allows it to handle large graphs within reasonable time constraints, making it suitable for real-world applications.</li>
</ol>
<p>Overall, this implementation showcases strong algorithmic design principles while addressing a critical problem in graph theory, making it a valuable reference for similar challenges.</p>
 
</div>
  

  <a class="heading-link" href="#hahahugoshortcode557s1hbhb">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/83JnUxrLKJU?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/"  class="external-link" target="_blank" rel="noopener">LeetCode Exercise Compilation</a> / Next : <a href="https://grid47.xyz/posts/leetcode_1490"  class="external-link" target="_blank" rel="noopener">LeetCode #1490: Clone N-ary Tree</a></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><div class="notice tip">
  <div class="notice-title">
    <i class="fa-solid fa-lightbulb" aria-hidden="true"></i>Tip
  </div>
  <div class="notice-content">Unlock the power of patterns! Mastering one problem builds a pathway to solve many more. Dive into practice, and let each problem sharpen your skills. <a href="https://www.udemy.com/course/algorithms-and-data-structures-in-cpp/"  class="external-link" target="_blank" rel="noopener">Check out my Momentum Learning course at Udemy! ðŸš€ </a></div>
</div>
</td>
      </tr>
  </tbody>
</table>

      </div>


      <footer>
        
        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "grid47" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    Â©
    
      2019 -
    
    2024
     Mohammed Yasir Eramangadan 
    Â·
    
    
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1LN7R4LHR1');
</script>


  

  

  

  

  

  

  
</body>

</html>

<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Leetcode 1971: Find if Path Exists in Graph · grid47
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Mohammed Yasir Eramangadan">
<meta name="description" content="In-depth solution and explanation for Leetcode 1971: Find if Path Exists in Graph in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1971: Find if Path Exists in Graph">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1971: Find if Path Exists in Graph in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">

<meta property="og:url" content="http://localhost:1313/posts/leetcode_1971/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1971: Find if Path Exists in Graph">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1971: Find if Path Exists in Graph in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-01T00:00:00+00:00">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_10/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_100/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1000/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1001/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1002/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1003/">




<link rel="canonical" href="http://localhost:1313/posts/leetcode_1971/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">








<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953"
     crossorigin="anonymous"></script></head>




<body class="preload-transitions colorscheme-light">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      grid47
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/leetcode/">LeetCode</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/lists/">List</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/terms/">Terms</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/contact/">Contact</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/leetcode_1971/">
              Leetcode 1971: Find if Path Exists in Graph
            </a>
          </h1>
        </div>
        <div class="post-meta">
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/easy/">Easy</a></div>
          
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="/authors/crafted-by-me/">Crafted by Me</a></div>

          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-11-01T00:00:00Z">
                November 1, 2024
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              5-minute read
            </span>
          </div>
          
        </div>
      </header>

      <div class="post-content">
        
        <p><a href="https://leetcode.com/problems/find-if-path-exists-in-graph/description/"  class="external-link" target="_blank" rel="noopener"><code>Problem Link</code></a></p>
<hr>
<p><strong>Code:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> validPath(<span style="color:#66d9ef">int</span> n, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> edges, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end) {
</span></span><span style="display:flex;"><span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> graph; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> e : edges) {
</span></span><span style="display:flex;"><span>            graph[e[<span style="color:#ae81ff">0</span>]].push_back(e[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>            graph[e[<span style="color:#ae81ff">1</span>]].push_back(e[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> visited(n,<span style="color:#ae81ff">0</span>);        
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>        q.push(start);
</span></span><span style="display:flex;"><span>        visited[start] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> curr <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(curr <span style="color:#f92672">==</span> end)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>node : graph[curr]){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visited[node]){
</span></span><span style="display:flex;"><span>                    visited[node] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>                    q.push(node);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="hahahugoshortcode1093s1hbhb">
  

  
  <div class="markdown-body">
    <h3 id="problem-statement">
  Problem Statement
  <a class="heading-link" href="#problem-statement">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The goal of this problem is to determine if there exists a valid path between two nodes in an undirected graph. The graph is represented using edges, and we need to check if a path exists from a starting node to a target node. This problem can be commonly encountered in scenarios involving network connectivity, pathfinding in mazes, or navigating social networks.</p>
<h3 id="approach">
  Approach
  <a class="heading-link" href="#approach">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>To solve this problem, we will utilize a breadth-first search (BFS) algorithm. BFS is particularly suitable for this task because it explores all neighbors at the present depth before moving on to nodes at the next depth level. This guarantees that we will find the shortest path if one exists.</p>
<p>Here’s a breakdown of the steps we will take:</p>
<ol>
<li>
<p><strong>Graph Representation</strong>: We will represent the graph using an adjacency list. Each node will have a list of its neighboring nodes.</p>
</li>
<li>
<p><strong>BFS Initialization</strong>: We will use a queue to facilitate the BFS traversal. A boolean array will keep track of visited nodes to prevent revisiting and entering into infinite loops.</p>
</li>
<li>
<p><strong>Traversal Logic</strong>: We will start the BFS from the <code>start</code> node and explore its neighbors. If we encounter the <code>end</code> node during our traversal, we return <code>true</code>. If the queue is exhausted and we haven’t found the <code>end</code> node, we return <code>false</code>.</p>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">
  Code Breakdown (Step by Step)
  <a class="heading-link" href="#code-breakdown-step-by-step">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> validPath(<span style="color:#66d9ef">int</span> n, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> edges, <span style="color:#66d9ef">int</span> start, <span style="color:#66d9ef">int</span> end) {
</span></span></code></pre></div><p>This line begins the definition of the <code>validPath</code> function, which takes the number of nodes <code>n</code>, a list of edges, and the start and end nodes as arguments.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        unordered_map<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>,vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> graph; 
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> e : edges) {
</span></span><span style="display:flex;"><span>            graph[e[<span style="color:#ae81ff">0</span>]].push_back(e[<span style="color:#ae81ff">1</span>]);
</span></span><span style="display:flex;"><span>            graph[e[<span style="color:#ae81ff">1</span>]].push_back(e[<span style="color:#ae81ff">0</span>]);
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>Here, we create an adjacency list representation of the graph using an unordered map. For each edge, we add the connection in both directions since the graph is undirected.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span> visited(n,<span style="color:#ae81ff">0</span>);        
</span></span><span style="display:flex;"><span>        queue<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> q;
</span></span><span style="display:flex;"><span>        q.push(start);
</span></span><span style="display:flex;"><span>        visited[start] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; 
</span></span></code></pre></div><p>We initialize a boolean vector <code>visited</code> to track which nodes have been explored. We then create a queue and enqueue the starting node, marking it as visited.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#66d9ef">while</span>(<span style="color:#f92672">!</span>q.empty()) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">int</span> curr <span style="color:#f92672">=</span> q.front();
</span></span><span style="display:flex;"><span>            q.pop();
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(curr <span style="color:#f92672">==</span> end)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>; 
</span></span></code></pre></div><p>We enter a loop that continues until there are no more nodes in the queue. We retrieve the front node and check if it matches the <code>end</code> node. If it does, we return <code>true</code>, indicating that a valid path exists.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> <span style="color:#f92672">&amp;</span>node : graph[curr]){
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>visited[node]){
</span></span><span style="display:flex;"><span>                    visited[node] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; 
</span></span><span style="display:flex;"><span>                    q.push(node);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span></code></pre></div><p>For each neighboring node of the current node, we check if it has already been visited. If not, we mark it as visited and add it to the queue for further exploration.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>If we exit the while loop without finding the <code>end</code> node, we return <code>false</code>, indicating that no valid path exists.</p>
<h3 id="complexity">
  Complexity
  <a class="heading-link" href="#complexity">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: The time complexity of this algorithm is (O(V + E)), where (V) is the number of vertices (or nodes) in the graph and (E) is the number of edges. This is because, in the worst case, we might need to explore all nodes and edges.</p>
</li>
<li>
<p><strong>Space Complexity</strong>: The space complexity is also (O(V + E)) for storing the graph in the adjacency list and the visited array, as well as the queue used for BFS.</p>
</li>
</ul>
<h3 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>This BFS-based solution effectively determines whether a valid path exists between two nodes in an undirected graph. The use of an adjacency list allows for efficient storage and retrieval of neighbor information, while BFS ensures that all possible paths are explored in a systematic manner.</p>
<h3 id="key-features">
  Key Features
  <a class="heading-link" href="#key-features">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>Efficiency</strong>: The algorithm runs in linear time relative to the number of nodes and edges, making it suitable for large graphs.</p>
</li>
<li>
<p><strong>Simplicity</strong>: The use of an adjacency list and a queue for BFS keeps the implementation straightforward and easy to understand.</p>
</li>
<li>
<p><strong>Scalability</strong>: This approach can easily be adapted to handle various graph-related problems, such as finding all connected components or detecting cycles.</p>
</li>
</ol>
<h3 id="example-usage">
  Example Usage
  <a class="heading-link" href="#example-usage">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>Here’s an example of how to use the <code>validPath</code> function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>Solution sol;
</span></span><span style="display:flex;"><span>vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> edges <span style="color:#f92672">=</span> {{<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>}, {<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>}, {<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>}, {<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>}};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>; <span style="color:#75715e">// Number of nodes
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> start <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> end <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">bool</span> result <span style="color:#f92672">=</span> sol.validPath(n, edges, start, end);
</span></span><span style="display:flex;"><span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Path exists: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> (result <span style="color:#f92672">?</span> <span style="color:#e6db74">&#34;Yes&#34;</span> <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;No&#34;</span>) <span style="color:#f92672">&lt;&lt;</span> endl;
</span></span></code></pre></div><p>In this example, the <code>validPath</code> function is called with a specific set of edges and nodes. The output indicates whether there is a valid path from the start node to the end node.</p>
<h3 id="potential-improvements-and-variations">
  Potential Improvements and Variations
  <a class="heading-link" href="#potential-improvements-and-variations">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>Bidirectional Search</strong>: For very large graphs, a bidirectional search can be more efficient. This approach simultaneously explores from both the start and end nodes.</p>
</li>
<li>
<p><strong>DFS Alternative</strong>: While BFS is used here, depth-first search (DFS) could also be implemented for pathfinding, depending on the specific requirements of the problem.</p>
</li>
<li>
<p><strong>Weighted Graphs</strong>: If the graph is weighted, we could adapt the solution to use Dijkstra’s algorithm or A* search algorithm for shortest pathfinding.</p>
</li>
</ol>
<p>This solution not only provides a method for checking connectivity in graphs but also serves as a foundation for tackling more complex graph algorithms and problems in computer science.</p>
 
</div>
  

  <a class="heading-link" href="#hahahugoshortcode1093s1hbhb">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/knLFe7hEp3Y?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/"  class="external-link" target="_blank" rel="noopener">LeetCode Exercise Compilation</a> / Next : <a href="https://grid47.xyz/posts/leetcode_1972"  class="external-link" target="_blank" rel="noopener">LeetCode #1972: First and Last Call On the Same Day</a></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><div class="notice tip">
  <div class="notice-title">
    <i class="fa-solid fa-lightbulb" aria-hidden="true"></i>Tip
  </div>
  <div class="notice-content">Unlock the power of patterns! Mastering one problem builds a pathway to solve many more. Dive into practice, and let each problem sharpen your skills. <a href="https://www.udemy.com/course/algorithms-and-data-structures-in-cpp/"  class="external-link" target="_blank" rel="noopener">Check out my Momentum Learning course at Udemy! 🚀 </a></div>
</div>
</td>
      </tr>
  </tbody>
</table>

      </div>


      <footer>
        
        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "grid47" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2024
     Mohammed Yasir Eramangadan 
    ·
    
    
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1LN7R4LHR1');
</script>


  

  

  

  

  

  

  
</body>

</html>

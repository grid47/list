<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Leetcode 1203: Sort Items by Groups Respecting Dependencies · grid47
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Mohammed Yasir Eramangadan">
<meta name="description" content="In-depth solution and explanation for Leetcode 1203: Sort Items by Groups Respecting Dependencies in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1203: Sort Items by Groups Respecting Dependencies">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1203: Sort Items by Groups Respecting Dependencies in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">

<meta property="og:url" content="http://localhost:1313/posts/leetcode_1203/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1203: Sort Items by Groups Respecting Dependencies">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1203: Sort Items by Groups Respecting Dependencies in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-01T00:00:00+00:00">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_10/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_100/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1000/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1001/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1002/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1003/">




<link rel="canonical" href="http://localhost:1313/posts/leetcode_1203/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">








<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953"
     crossorigin="anonymous"></script></head>




<body class="preload-transitions colorscheme-light">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      grid47
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/leetcode/">LeetCode</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/lists/">List</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/terms/">Terms</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/contact/">Contact</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/leetcode_1203/">
              Leetcode 1203: Sort Items by Groups Respecting Dependencies
            </a>
          </h1>
        </div>
        <div class="post-meta">
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/hard/">Hard</a></div>
          
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="/authors/crafted-by-me/">Crafted by Me</a></div>

          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-11-01T00:00:00Z">
                November 1, 2024
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              6-minute read
            </span>
          </div>
          
        </div>
      </header>

      <div class="post-content">
        
        <p><a href="https://leetcode.com/problems/sort-items-by-groups-respecting-dependencies/description/"  class="external-link" target="_blank" rel="noopener"><code>Problem Link</code></a></p>
<hr>
<p><strong>Code:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> topoSort(vector<span style="color:#f92672">&lt;</span>unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;</span> al, <span style="color:#66d9ef">int</span> i, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> res, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> stat) {
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(stat[i] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> stat[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        stat[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> n : al[i])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>topoSort(al, n, res, stat))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        stat[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        res.push_back(i);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sortItems(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> group, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> beforeItems) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> res_tmp, res(n), stat(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> m);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> al(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> m);
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (group[i] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                al[n <span style="color:#f92672">+</span> group[i]].insert(i);
</span></span><span style="display:flex;"><span>                al[i].insert(n <span style="color:#f92672">+</span> m <span style="color:#f92672">+</span> group[i]);
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> j : beforeItems[i]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> ( group[i] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> group[i] <span style="color:#f92672">==</span> group[j]) al[j].insert(i);
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">auto</span> ig <span style="color:#f92672">=</span> group[i] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> i : n     <span style="color:#f92672">+</span> group[i];
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">auto</span> jg <span style="color:#f92672">=</span> group[j] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> j : n <span style="color:#f92672">+</span> m <span style="color:#f92672">+</span> group[j];
</span></span><span style="display:flex;"><span>                    al[jg].insert(ig);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> al.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; n <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; n<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>topoSort(al, n, res_tmp, stat))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> {};
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        reverse(begin(res_tmp), end(res_tmp));
</span></span><span style="display:flex;"><span>        copy_if(begin(res_tmp), end(res_tmp), res.begin(), [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span> i) { <span style="color:#66d9ef">return</span> i <span style="color:#f92672">&lt;</span> n; });
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="hahahugoshortcode251s1hbhb">
  

  
  <div class="markdown-body">
    <h3 id="problem-statement">
  Problem Statement
  <a class="heading-link" href="#problem-statement">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The problem at hand involves organizing items based on their dependencies while considering group constraints. Given <code>n</code> items and <code>m</code> groups, each item belongs to a group (or none), and there are dependencies between items defined by <code>beforeItems</code>, where an item must come before another. The goal is to return a valid ordering of the items such that all dependencies are satisfied, and if items belong to the same group, they are sorted accordingly. If it&rsquo;s impossible to complete the sorting, the function should return an empty list.</p>
<h3 id="approach">
  Approach
  <a class="heading-link" href="#approach">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>To solve this problem, we will use a combination of graph theory and topological sorting. The approach can be broken down into the following steps:</p>
<ol>
<li>
<p><strong>Graph Construction</strong>:</p>
<ul>
<li>Create a directed graph to represent items and their dependencies. Each item is a node, and directed edges represent the &ldquo;must come before&rdquo; relationship.</li>
</ul>
</li>
<li>
<p><strong>Group Handling</strong>:</p>
<ul>
<li>Handle items belonging to groups by introducing &ldquo;super nodes&rdquo; for each group. These super nodes will represent the groups and have edges to/from items within those groups.</li>
</ul>
</li>
<li>
<p><strong>Topological Sort</strong>:</p>
<ul>
<li>Apply a depth-first search (DFS) based topological sort to determine a valid order of processing items while respecting the dependencies. If a cycle is detected, return an empty list.</li>
</ul>
</li>
<li>
<p><strong>Returning the Result</strong>:</p>
<ul>
<li>Return the sorted items while ensuring that items in the same group are contiguous in the result.</li>
</ul>
</li>
</ol>
<h3 id="code-breakdown-step-by-step">
  Code Breakdown (Step by Step)
  <a class="heading-link" href="#code-breakdown-step-by-step">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">bool</span> topoSort(vector<span style="color:#f92672">&lt;</span>unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">&amp;</span> al, <span style="color:#66d9ef">int</span> i, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> res, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> stat) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(stat[i] <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span> stat[i] <span style="color:#f92672">==</span> <span style="color:#ae81ff">2</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        stat[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; <span style="color:#75715e">// Mark as visiting
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> n : al[i])
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>topoSort(al, n, res, stat))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> false;
</span></span><span style="display:flex;"><span>        stat[i] <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; <span style="color:#75715e">// Mark as visited
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        res.push_back(i); <span style="color:#75715e">// Add to result after visiting all children
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> true;
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><ul>
<li><strong>Lines 1-16</strong>: This segment defines a private method <code>topoSort</code> which performs a depth-first search to execute the topological sorting. It uses a <code>stat</code> vector to track the visitation state of each node (0 for unvisited, 1 for visiting, 2 for visited). If a node is revisited while in the visiting state, a cycle is detected.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> sortItems(<span style="color:#66d9ef">int</span> n, <span style="color:#66d9ef">int</span> m, vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&amp;</span> group, vector<span style="color:#f92672">&lt;</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;&amp;</span> beforeItems) {
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> res_tmp, res(n), stat(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> m);
</span></span><span style="display:flex;"><span>        vector<span style="color:#f92672">&lt;</span>unordered_set<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;&gt;</span> al(n <span style="color:#f92672">+</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> m);
</span></span></code></pre></div><ul>
<li><strong>Lines 17-23</strong>: The main method <code>sortItems</code> initializes necessary data structures:
<ul>
<li><code>res_tmp</code> to temporarily hold the sorted items,</li>
<li><code>res</code> to store the final sorted result,</li>
<li><code>stat</code> to track the visitation state of nodes, extended to account for group nodes,</li>
<li><code>al</code> to represent the adjacency list of the graph.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> n; i<span style="color:#f92672">++</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> (group[i] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>                al[n <span style="color:#f92672">+</span> group[i]].insert(i); <span style="color:#75715e">// Connect group node to item
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                al[i].insert(n <span style="color:#f92672">+</span> m <span style="color:#f92672">+</span> group[i]); <span style="color:#75715e">// Connect item to its group
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            }
</span></span></code></pre></div><ul>
<li><strong>Lines 24-31</strong>: In this loop, we populate the graph:
<ul>
<li>If an item belongs to a group, we connect the corresponding super node (group node) to the item.</li>
<li>Also, we create a directed edge from the item back to its group super node to establish a connection for topological sorting.</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">auto</span> j : beforeItems[i]) {
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> ( group[i] <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">&amp;&amp;</span> group[i] <span style="color:#f92672">==</span> group[j]) 
</span></span><span style="display:flex;"><span>                    al[j].insert(i); <span style="color:#75715e">// Same group dependency
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#66d9ef">auto</span> ig <span style="color:#f92672">=</span> group[i] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> i : n <span style="color:#f92672">+</span> group[i]; <span style="color:#75715e">// Determine item/group node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    <span style="color:#66d9ef">auto</span> jg <span style="color:#f92672">=</span> group[j] <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">?</span> j : n <span style="color:#f92672">+</span> m <span style="color:#f92672">+</span> group[j]; <span style="color:#75715e">// Determine item/group node
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                    al[jg].insert(ig); <span style="color:#75715e">// Add directed edge
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>                }
</span></span><span style="display:flex;"><span>            }
</span></span></code></pre></div><ul>
<li><strong>Lines 32-43</strong>: This inner loop processes dependencies:
<ul>
<li>If both items belong to the same group, an edge is created in the item graph.</li>
<li>For items in different groups, edges are created from the group node of item <code>j</code> to item <code>i</code> (or vice versa).</li>
</ul>
</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span>(<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> al.size() <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; n <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>; n<span style="color:#f92672">--</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>topoSort(al, n, res_tmp, stat))
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> {};
</span></span></code></pre></div><ul>
<li><strong>Lines 44-47</strong>: The outer loop executes the topological sort on all nodes. If any call to <code>topoSort</code> returns false, it indicates a cycle, and an empty vector is returned.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        reverse(begin(res_tmp), end(res_tmp));
</span></span><span style="display:flex;"><span>        copy_if(begin(res_tmp), end(res_tmp), res.begin(), [<span style="color:#f92672">&amp;</span>](<span style="color:#66d9ef">int</span> i) { <span style="color:#66d9ef">return</span> i <span style="color:#f92672">&lt;</span> n; });
</span></span></code></pre></div><ul>
<li><strong>Lines 48-51</strong>: The temporary result is reversed to maintain the correct topological order, and only valid items (those with indices less than <code>n</code>) are copied into the result vector <code>res</code>.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> res;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><ul>
<li><strong>Line 52</strong>: Finally, the sorted result <code>res</code> is returned.</li>
</ul>
<h3 id="complexity">
  Complexity
  <a class="heading-link" href="#complexity">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>Time Complexity</strong>:</p>
<ul>
<li>The time complexity of this approach is (O(N + M + P)), where (N) is the number of items, (M) is the number of groups, and (P) is the total number of dependencies (edges in the graph). Each item and dependency is processed a limited number of times.</li>
</ul>
</li>
<li>
<p><strong>Space Complexity</strong>:</p>
<ul>
<li>The space complexity is (O(N + M)) for the adjacency list representation and visitation state array, ensuring we have enough space to store the information for both items and groups.</li>
</ul>
</li>
</ol>
<h3 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The <code>sortItems</code> function effectively uses graph theory principles to sort items based on their dependencies while respecting group boundaries. By implementing a topological sort via a depth-first search approach, this solution ensures that all constraints are met while maintaining the correct order of items. The efficient handling of groups with super nodes allows for a streamlined approach to managing dependencies, making this a robust solution for the problem. This algorithm highlights the power of combining graph-based methods with careful data structure design to tackle complex sorting and dependency resolution challenges in programming.</p>
 
</div>
  

  <a class="heading-link" href="#hahahugoshortcode251s1hbhb">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>


    
    <div style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden;">
      <iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" loading="eager" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/I4Vwkq7e2xE?autoplay=0&controls=1&end=0&loop=0&mute=0&start=0" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border:0;" title="YouTube video"
      ></iframe>
    </div>

<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/"  class="external-link" target="_blank" rel="noopener">LeetCode Exercise Compilation</a> / Next : <a href="https://grid47.xyz/posts/leetcode_1204"  class="external-link" target="_blank" rel="noopener">LeetCode #1204: Last Person to Fit in the Bus</a></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><div class="notice tip">
  <div class="notice-title">
    <i class="fa-solid fa-lightbulb" aria-hidden="true"></i>Tip
  </div>
  <div class="notice-content">Unlock the power of patterns! Mastering one problem builds a pathway to solve many more. Dive into practice, and let each problem sharpen your skills. <a href="https://www.udemy.com/course/algorithms-and-data-structures-in-cpp/"  class="external-link" target="_blank" rel="noopener">Check out my Momentum Learning course at Udemy! 🚀 </a></div>
</div>
</td>
      </tr>
  </tbody>
</table>

      </div>


      <footer>
        
        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "grid47" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2024
     Mohammed Yasir Eramangadan 
    ·
    
    
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1LN7R4LHR1');
</script>


  

  

  

  

  

  

  
</body>

</html>

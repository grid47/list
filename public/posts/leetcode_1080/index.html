<!DOCTYPE html>
<html lang="en">

<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  <title>
  Leetcode 1080: Insufficient Nodes in Root to Leaf Paths · grid47
</title>
  <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="color-scheme" content="light dark">




<meta name="author" content="Mohammed Yasir Eramangadan">
<meta name="description" content="In-depth solution and explanation for Leetcode 1080: Insufficient Nodes in Root to Leaf Paths in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">
<meta name="keywords" content="blog,developer,personal">



  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Leetcode 1080: Insufficient Nodes in Root to Leaf Paths">
  <meta name="twitter:description" content="In-depth solution and explanation for Leetcode 1080: Insufficient Nodes in Root to Leaf Paths in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">

<meta property="og:url" content="http://localhost:1313/posts/leetcode_1080/">
  <meta property="og:site_name" content="grid47">
  <meta property="og:title" content="Leetcode 1080: Insufficient Nodes in Root to Leaf Paths">
  <meta property="og:description" content="In-depth solution and explanation for Leetcode 1080: Insufficient Nodes in Root to Leaf Paths in C&#43;&#43;. Includes clear intuition, step-by-step example walkthrough, and detailed complexity analysis—more insightful than official and community solutions.">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-11-01T00:00:00+00:00">
    <meta property="article:modified_time" content="2024-11-01T00:00:00+00:00">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_10/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_100/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1000/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1001/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1002/">
      <meta property="og:see_also" content="http://localhost:1313/posts/leetcode_1003/">




<link rel="canonical" href="http://localhost:1313/posts/leetcode_1080/">


<link rel="preload" href="/fonts/fa-brands-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-regular-400.woff2" as="font" type="font/woff2" crossorigin>
<link rel="preload" href="/fonts/fa-solid-900.woff2" as="font" type="font/woff2" crossorigin>


  
  
  <link rel="stylesheet" href="/css/coder.css" media="screen">








 




<link rel="icon" type="image/svg+xml" href="/images/favicon.svg" sizes="any">
<link rel="icon" type="image/png" href="/images/favicon-32x32.png" sizes="32x32">
<link rel="icon" type="image/png" href="/images/favicon-16x16.png" sizes="16x16">

<link rel="apple-touch-icon" href="/images/apple-touch-icon.png">
<link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png">

<link rel="manifest" href="/site.webmanifest">
<link rel="mask-icon" href="/images/safari-pinned-tab.svg" color="#5bbad5">








<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6219690368643953"
     crossorigin="anonymous"></script></head>




<body class="preload-transitions colorscheme-light">
  

  <main class="wrapper">
    <nav class="navigation">
  <section class="container">
    
    <a class="navigation-title" href="http://localhost:1313/">
      grid47
    </a>
    
    
      <input type="checkbox" id="menu-toggle" />
      <label class="menu-button float-right" for="menu-toggle">
        <i class="fa-solid fa-bars fa-fw" aria-hidden="true"></i>
      </label>
      <ul class="navigation-list">
        
          
            <li class="navigation-item">
              <a class="navigation-link " href="/about/">About</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/leetcode/">LeetCode</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/lists/">List</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/terms/">Terms</a>
            </li>
          
            <li class="navigation-item">
              <a class="navigation-link " href="/contact/">Contact</a>
            </li>
          
        
        
      </ul>
    
  </section>
</nav>


    <div class="content">
      
  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">
            <a class="title-link" href="http://localhost:1313/posts/leetcode_1080/">
              Leetcode 1080: Insufficient Nodes in Root to Leaf Paths
            </a>
          </h1>
        </div>
        <div class="post-meta">
          
          <div class="categories">
  <i class="fa-solid fa-folder" aria-hidden="true"></i>
    <a href="/categories/medium/">Medium</a></div>
          
          <div class="authors">
  <i class="fa-solid fa-user" aria-hidden="true"></i>
    <a href="/authors/crafted-by-me/">Crafted by Me</a></div>

          <div class="date">
            <span class="posted-on">
              <i class="fa-solid fa-calendar" aria-hidden="true"></i>
              <time datetime="2024-11-01T00:00:00Z">
                November 1, 2024
              </time>
            </span>
            <span class="reading-time">
              <i class="fa-solid fa-clock" aria-hidden="true"></i>
              5-minute read
            </span>
          </div>
          
        </div>
      </header>

      <div class="post-content">
        
        <p><a href="https://leetcode.com/problems/insufficient-nodes-in-root-to-leaf-paths/description/"  class="external-link" target="_blank" rel="noopener"><code>Problem Link</code></a></p>
<hr>
<p><strong>Code:</strong></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#75715e">/**
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Definition for a binary tree node.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * struct TreeNode {
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     int val;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *left;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode *right;
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * };
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span><span style="display:flex;"><span>    TreeNode<span style="color:#f92672">*</span> sufficientSubset(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> limit) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> NULL;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span>(root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> limit <span style="color:#f92672">?</span> NULL <span style="color:#f92672">:</span> root;
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> sufficientSubset(root<span style="color:#f92672">-&gt;</span>left, limit <span style="color:#f92672">-</span> root<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        root<span style="color:#f92672">-&gt;</span>right<span style="color:#f92672">=</span> sufficientSubset(root<span style="color:#f92672">-&gt;</span>right, limit <span style="color:#f92672">-</span> root<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> NULL <span style="color:#f92672">:</span> root;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>};</span></span></code></pre></div>
<h2 id="hahahugoshortcode100s1hbhb">
  

  
  <div class="markdown-body">
    <h3 id="problem-statement">
  Problem Statement
  <a class="heading-link" href="#problem-statement">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The problem involves modifying a binary tree by removing all leaf nodes whose path sum from the root to the leaf is less than a specified limit. The aim is to retain only those nodes in the tree that contribute to a path whose total value meets or exceeds the given limit. For instance, given a binary tree and a limit of 15, if a path from the root to a leaf sums up to less than 15, that leaf node should be removed from the tree.</p>
<h3 id="approach">
  Approach
  <a class="heading-link" href="#approach">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The approach to solve this problem employs a recursive depth-first search (DFS) technique. The idea is to traverse the tree from the root down to the leaves while maintaining a running sum of values. If a leaf node is found where the sum is less than the limit, it is removed. The recursive function returns <code>NULL</code> for nodes that need to be removed, effectively pruning the tree as the recursion unwinds.</p>
<h3 id="code-breakdown-step-by-step">
  Code Breakdown (Step by Step)
  <a class="heading-link" href="#code-breakdown-step-by-step">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ol>
<li>
<p><strong>Struct Definition</strong>:
The <code>TreeNode</code> structure is defined to represent nodes in the binary tree. Each node contains an integer value and pointers to its left and right children.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">TreeNode</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> val;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#f92672">*</span>left;
</span></span><span style="display:flex;"><span>    TreeNode <span style="color:#f92672">*</span>right;
</span></span><span style="display:flex;"><span>    TreeNode() <span style="color:#f92672">:</span> val(<span style="color:#ae81ff">0</span>), left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#66d9ef">int</span> x) <span style="color:#f92672">:</span> val(x), left(<span style="color:#66d9ef">nullptr</span>), right(<span style="color:#66d9ef">nullptr</span>) {}
</span></span><span style="display:flex;"><span>    TreeNode(<span style="color:#66d9ef">int</span> x, TreeNode <span style="color:#f92672">*</span>left, TreeNode <span style="color:#f92672">*</span>right) <span style="color:#f92672">:</span> val(x), left(left), right(right) {}
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div></li>
<li>
<p><strong>Class Definition</strong>:
The <code>Solution</code> class contains the method <code>sufficientSubset</code> that will perform the main logic of the problem.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Solution</span> {
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
</span></span></code></pre></div></li>
<li>
<p><strong>Recursive Function Implementation</strong>:
The method <code>sufficientSubset</code> takes a pointer to the root of the binary tree and an integer <code>limit</code> as arguments. It returns a pointer to the root of the modified tree.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>TreeNode<span style="color:#f92672">*</span> <span style="color:#a6e22e">sufficientSubset</span>(TreeNode<span style="color:#f92672">*</span> root, <span style="color:#66d9ef">int</span> limit) {
</span></span></code></pre></div></li>
<li>
<p><strong>Base Case for Null Nodes</strong>:
The first check is for a null node. If the current node is <code>NULL</code>, the function simply returns <code>NULL</code>, indicating that there is no node to process.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(<span style="color:#f92672">!</span>root) <span style="color:#66d9ef">return</span> NULL;
</span></span></code></pre></div></li>
<li>
<p><strong>Base Case for Leaf Nodes</strong>:
The next check identifies leaf nodes, which are nodes without children. If the current node is a leaf, it checks if its value is less than the <code>limit</code>. If the value is less than <code>limit</code>, it returns <code>NULL</code>, indicating that this leaf should be removed; otherwise, it returns the current leaf.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span>(root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> NULL <span style="color:#f92672">&amp;&amp;</span> root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">==</span> NULL)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> root<span style="color:#f92672">-&gt;</span>val <span style="color:#f92672">&lt;</span> limit <span style="color:#f92672">?</span> NULL <span style="color:#f92672">:</span> root;
</span></span></code></pre></div></li>
<li>
<p><strong>Recursive Calls</strong>:
The function then recursively calls itself for the left and right children of the current node. It subtracts the current node&rsquo;s value from the limit to adjust the threshold for the child nodes.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> sufficientSubset(root<span style="color:#f92672">-&gt;</span>left, limit <span style="color:#f92672">-</span> root<span style="color:#f92672">-&gt;</span>val);
</span></span><span style="display:flex;"><span>    root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> sufficientSubset(root<span style="color:#f92672">-&gt;</span>right, limit <span style="color:#f92672">-</span> root<span style="color:#f92672">-&gt;</span>val);
</span></span></code></pre></div></li>
<li>
<p><strong>Pruning the Tree</strong>:
After the recursive calls, the function checks if both the left and right children are <code>NULL</code>. If they are, it means both children have been removed (i.e., the current node is a leaf node that does not satisfy the limit). In this case, the current node itself should also be removed by returning <code>NULL</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-cpp" data-lang="cpp"><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">==</span> root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">?</span> NULL <span style="color:#f92672">:</span> root;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div></li>
</ol>
<h3 id="complexity-analysis">
  Complexity Analysis
  <a class="heading-link" href="#complexity-analysis">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<ul>
<li>
<p><strong>Time Complexity</strong>: The time complexity of this algorithm is (O(N)), where (N) is the number of nodes in the binary tree. This is because we traverse each node once during the recursive calls.</p>
</li>
<li>
<p><strong>Space Complexity</strong>: The space complexity is (O(H)), where (H) is the height of the binary tree. This space is used by the recursion stack. In the worst case (for example, a skewed tree), the height could be equal to (N), leading to a space complexity of (O(N)).</p>
</li>
</ul>
<h3 id="conclusion">
  Conclusion
  <a class="heading-link" href="#conclusion">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h3>
<p>The provided C++ code offers an efficient solution to the problem of pruning a binary tree based on path sums. By employing a depth-first search approach, the algorithm effectively identifies and removes leaf nodes whose path sums fall below a specified limit. The recursive nature of the function allows it to handle the tree in a clean and straightforward manner, ensuring that only the necessary nodes are retained.</p>
<p>This solution is not only optimal in terms of time complexity but also elegantly handles tree traversal using recursion. It showcases the power of recursion in solving problems involving hierarchical data structures like trees. The algorithm can be utilized in various applications where pruning or modifying tree structures based on specific conditions is required, making it a valuable addition to the toolkit of algorithms for tree manipulations.</p>
<p>In summary, the <code>sufficientSubset</code> method efficiently prunes a binary tree while maintaining its structural integrity for paths that meet the specified criteria, demonstrating a robust approach to tree modification challenges.</p>
 
</div>
  

  <a class="heading-link" href="#hahahugoshortcode100s1hbhb">
    <i class="fa-solid fa-link" aria-hidden="true" title="Link to heading"></i>
    <span class="sr-only">Link to heading</span>
  </a>
</h2>
<table>
  <thead>
      <tr>
          <th><a href="https://grid47.xyz/leetcode/"  class="external-link" target="_blank" rel="noopener">LeetCode Exercise Compilation</a> / Next : <a href="https://grid47.xyz/posts/leetcode_1081"  class="external-link" target="_blank" rel="noopener">LeetCode #1081: Smallest Subsequence of Distinct Characters</a></th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><div class="notice tip">
  <div class="notice-title">
    <i class="fa-solid fa-lightbulb" aria-hidden="true"></i>Tip
  </div>
  <div class="notice-content">Unlock the power of patterns! Mastering one problem builds a pathway to solve many more. Dive into practice, and let each problem sharpen your skills. <a href="https://www.udemy.com/course/algorithms-and-data-structures-in-cpp/"  class="external-link" target="_blank" rel="noopener">Check out my Momentum Learning course at Udemy! 🚀 </a></div>
</div>
</td>
      </tr>
  </tbody>
</table>

      </div>


      <footer>
        
        <div id="disqus_thread"></div>
<script>
  window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "grid47" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
    
    document.addEventListener('themeChanged', function (e) { 
        if (document.readyState == 'complete') {
          DISQUS.reset({ reload: true, config: disqus_config });
        }
    });
</script>
        
        
        
        
        
        
      </footer>
    </article>

    
  </section>

    </div>

    <footer class="footer">
  <section class="container">
    ©
    
      2019 -
    
    2024
     Mohammed Yasir Eramangadan 
    ·
    
    
    
  </section>
</footer>

  </main>

  

  
  
  <script src="/js/coder.js"></script>
  

  

  


  

  

  

  

  

  

  

  

  
<script async src="https://www.googletagmanager.com/gtag/js?id=G-1LN7R4LHR1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-1LN7R4LHR1');
</script>


  

  

  

  

  

  

  
</body>

</html>
